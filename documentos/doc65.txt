    Uso de      Constraint Solvers    na Gera√ß√£o de

Dados de Teste: Um Mapeamento Sistem√°tico

                          da Literatura




              Trabalho de Conclus√£o de Curso
                Engenharia da Computa√ß√£o




Bruno Fonseca Lins de Oliveira
Orientador: Gustavo Carvalho
           Bruno Fonseca Lins de Oliveira




  Uso de Constraint Solvers na Gera√ß√£o de
Dados de Teste: Um Mapeamento Sistem√°tico
                 da Literatura


                         Monograa apresentada como requisito par-
                         cial para obten√ß√£o do diploma de Bacharel
                         em Engenharia de Computa√ß√£o pela Escola
                         Polit√©cnica de Pernambuco - Universidade de
                         Pernambuco




                       Orientador:

                  Gustavo Carvalho



              Universidade de Pernambuco
           Escola Polit√©cnica de Pernambuco
        Gradua√ß√£o em Engenharia de Computa√ß√£o




                   Recife - PE, Brasil

                   23 de mar√ßo de 2012
Declaro que revisei o Trabalho de Conclus√£o de Curso sob o t√≠tulo Uso de Constraint

Solvers na Gera√ß√£o de Dados de Teste: Um Mapeamento Sistem√°tico da Literatura , de

autoria de Bruno Fonseca Lins de Oliveira, e que estou de acordo com a entrega do mesmo.




Recife, ____   /   ______________         /   ____




                                   Gustavo Carvalho
                                      Orientador
                          Agradecimentos

   A todos os professores pelo conhecimento transmitido, principalmente ao meu orien-

tador, Gustavo Carvalho, pela oportunidade, paci√™ncia, aten√ß√£o e pelo apoio dado.


   A fam√≠lia e amigos, que estiveram do meu lado durante todo o tempo, torcendo por

mim, me apoiando e n√£o me deixando desistir mesmo nos momentos de diculdade.


   A todos os meus colegas de gradua√ß√£o, com certeza sem o apoio deles ao longo desses

5 anos eu n√£o ter√≠a chegado at√© aqui.
                       Resumo

Nos √∫ltimos tempos ferramentas comerciais utilizando Cons-
traint Solvers t√™m sido adotadas por empresas para gera√ß√£o
autom√°tica de dados de testes.     Este trabalho tem como ob
jetivo principal, sumarizar evid√™ncias existentes a m de pro-
ver um melhor entendimento sobre os detalhes de como dados
de teste s√£o gerados automaticamente a partir do uso de Con-
traint Solvers.   Mais especicamente, este trabalho tamb√©m
tem os seguintes objetivos


   ‚Ä¢   Mapear as t√©cnicas mais utilizadas;


   ‚Ä¢   Identicar qual o tipo de Solver mais utilizado;


   ‚Ä¢   Analisar a escalabilidade para problemas reais;


   ‚Ä¢   Apontar benef√≠cios e limita√ß√µes.


Palavras-chave:      Constraint Solvers, Constraint Language
Programming, Test Data, Test Vector.
                       Abstract

In recent times commercial tools using Constraint Solvers have
been adopted by companies for automatic generation of test
data.    This work has as main objective summarize existing
evidence in order to provide a better understanding of the de-
tails of how test data are generated from the use of Constraint
Solvers.   More speciacally, this work also has the following
objectives:


   ‚Ä¢    Map the most widely used techniques;


   ‚Ä¢    Identify the most widely used type of solver;


   ‚Ä¢    Analyze the scalability to real problems;


   ‚Ä¢    Point out the benets and limitations.


Keywords:       Constraint Solvers, Constraint Language Pro-
gramming,Test Data, Test Vector
                                   Sum√°rio


Lista de Figuras                                                                          p. ix



Lista de Tabelas                                                                           p. x



Lista de Abreviaturas e Siglas                                                            p. xi



1 Introdu√ß√£o                                                                              p. 12


  1.1   Qualica√ß√£o do Problema       . . . . . . . . . . . . . . . . . . . . . . . . .   p. 13


  1.2   Objetivos   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   p. 13


        1.2.1   Objetivos Espec√≠cos . . . . . . . . . . . . . . . . . . . . . . . .      p. 13


  1.3   Resultados e Impactos Esperados       . . . . . . . . . . . . . . . . . . . . .   p. 13


  1.4   Estrutura da Monograa . . . . . . . . . . . . . . . . . . . . . . . . . .        p. 14



2 Constraint Programming                                                                  p. 15


  2.1   Constraint Satisfation Problems . . . . . . . . . . . . . . . . . . . . . .       p. 15


        2.1.1   Exemplo de CSP: Colora√ß√£o de Mapa . . . . . . . . . . . . . . .           p. 16


        2.1.2   Exemplo de CSP: Planejamento de Tarefas . . . . . . . . . . . .           p. 18


        2.1.3   Varia√ß√µes da Modelagem CSP . . . . . . . . . . . . . . . . . . .          p. 20


  2.2   Constraint Solvers    . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   p. 22


        2.2.1   SAT e SMT Solvers . . . . . . . . . . . . . . . . . . . . . . . . .       p. 22


  2.3   Teste de Software . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     p. 23



3 M√©todo de Pesquisa                                                                      p. 24


  3.1   Qualica√ß√£o do M√©todo de Pesquisa . . . . . . . . . . . . . . . . . . . .         p. 24
  3.2   Etapas do M√©todo de Pesquisa . . . . . . . . . . . . . . . . . . . . . . .        p. 24


  3.3   Quest√µes de Pesquisa . . . . . . . . . . . . . . . . . . . . . . . . . . . .      p. 25


  3.4   Estrat√©gia de Busca . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     p. 26


  3.5   Termos Chaves da Pesquisa       . . . . . . . . . . . . . . . . . . . . . . . .   p. 26


  3.6   Termos e Predicado de Busca       . . . . . . . . . . . . . . . . . . . . . . .   p. 26


  3.7   Fontes de Busca . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     p. 26


  3.8   Sele√ß√£o dos Estudos . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     p. 28


  3.9   Crit√©rios de Inclus√£o   . . . . . . . . . . . . . . . . . . . . . . . . . . . .   p. 28


  3.10 Crit√©rios de Exclus√£o . . . . . . . . . . . . . . . . . . . . . . . . . . . .      p. 29


  3.11 Processo de Sele√ß√£o dos Estudos Prim√°rios . . . . . . . . . . . . . . . .          p. 29


  3.12 Leitura dos Trabalhos Selecionados       . . . . . . . . . . . . . . . . . . . .   p. 31


  3.13 Avalia√ß√£o da Qualidade dos Estudos . . . . . . . . . . . . . . . . . . . .         p. 31


        3.13.1 Crit√©rios de Avalia√ß√£o     . . . . . . . . . . . . . . . . . . . . . . .   p. 35


  3.14 Estrat√©gia de Extra√ß√£o Dos Dados . . . . . . . . . . . . . . . . . . . . .         p. 37


  3.15 S√≠ntese dos Dados Coletados . . . . . . . . . . . . . . . . . . . . . . . .        p. 38


  3.16 Documenta√ß√£o e Apresenta√ß√£o dos Resultados . . . . . . . . . . . . . .             p. 38



4 Resultados                                                                              p. 39


  4.1   An√°lise Quantitativa    . . . . . . . . . . . . . . . . . . . . . . . . . . . .   p. 39


  4.2   An√°lise Qualitativa das Evid√™ncias      . . . . . . . . . . . . . . . . . . . .   p. 44


        4.2.1   Principais T√©cnicas Utilizadas . . . . . . . . . . . . . . . . . . .      p. 44


        4.2.2   Escalabilidade para Problemas Reais       . . . . . . . . . . . . . . .   p. 45


        4.2.3   Benef√≠cios Da Utiliza√ß√£o de Constraint Solvers . . . . . . . . . .        p. 47


        4.2.4   Limita√ß√µes Da Utiliza√ß√£o de Constraint Solvers        . . . . . . . . .   p. 47


        4.2.5   Tipos de Solvers    . . . . . . . . . . . . . . . . . . . . . . . . . .   p. 49



5 Considera√ß√µes Finais                                                                    p. 50
  5.1   Conclus√µes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    p. 50


  5.2   Limita√ß√µes e Trabalhos Futuros      . . . . . . . . . . . . . . . . . . . . . .   p. 51



Refer√™ncias                                                                               p. 53



Ap√™ndice A -- Trabalhos Inclu√≠dos                                                         p. 55



Ap√™ndice B -- Trabalhos Relevantes                                                        p. 58
                     Lista de Figuras

1   Grafo de restri√ß√£o   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   p. 17


2   Distribui√ß√£o dos estudos prim√°rios ao longo dos anos       . . . . . . . . . .   p. 40


3   Distribui√ß√£o dos estudos prim√°rios por local de publica√ß√£o       . . . . . . .   p. 41


4   Distribui√ß√£o dos estudos prim√°rios por tipo de estudo.       . . . . . . . . .   p. 42


5   Distribui√ß√£o dos estudos prim√°rios por local dos autores.      . . . . . . . .   p. 43


6   Distribui√ß√£o por tipo de solver utilizado.   . . . . . . . . . . . . . . . . .   p. 44


7   Distribui√ß√£o por linguagem de programa√ß√£o.         . . . . . . . . . . . . . .   p. 48


8   Distribui√ß√£o por tipo de solver utilizado.   . . . . . . . . . . . . . . . . .   p. 49
                       Lista de Tabelas

1    Trabalhos inclu√≠dos. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     p. 30


2    Trabalhos exclu√≠dos.     . . . . . . . . . . . . . . . . . . . . . . . . . . . .   p. 30


3    Coeciente Kappa.      . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   p. 31


4    Informa√ß√µes gerais.    . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   p. 32


5    Caracteriza√ß√£o da contribui√ß√£o.      . . . . . . . . . . . . . . . . . . . . . .   p. 33


6    Caracteriza√ß√£o das estapas.      . . . . . . . . . . . . . . . . . . . . . . . .   p. 33


7    Caracteriza√ß√£o do apoio ferramental.       . . . . . . . . . . . . . . . . . . .   p. 34


8    Caracteriza√ß√£o da avalia√ß√£o. . . . . . . . . . . . . . . . . . . . . . . . .       p. 34


9    N√≠veis de qualidade. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     p. 37


10   Quantidade de estudos prim√°rios por evento. . . . . . . . . . . . . . . .          p. 42


11   Qualidade dos estudos prim√°rios.       . . . . . . . . . . . . . . . . . . . . .   p. 43
        Lista de Abreviaturas e Siglas

CSP     Constraint Satiscation Problem
COP     Constraint optimization problems
ISSTA   International Symposium on Software Testing and Analysis
SAT     Satisability
SMT     Satisability Modulo Theories
SUT     System Under Test
                                                                                                  12




1       Introdu√ß√£o


    O processo de teste exerce um importante papel na garantia da qualidade de software.

Durante o processo de desenvolvimento de software, diversos erros e falhas podem apa-

recer e o objetivo dos testes √© capturar a maior quantidade de defeitos poss√≠vel atrav√©s

da aplica√ß√£o de um conjunto de atividades apuradas e bem planejadas. Essas atividades

t√™m como objetivo vericar se todos os requisitos do sistema foram corretamente imple-

mentados, assegurar a qualidade e corretude do software produzido e reduzir custos de

manuten√ß√£o corretiva (MYERS, 1979).


    Testar, por√©m, custa tempo e dinheiro.                O tempo √© um inimigo di√°rio nas grandes

empresas.   O desao de desenvolver software com qualidade se depara constantemente

com o fator tempo.            Nesse sentido, as empresas buscam alternativas de automa√ß√£o de

testes com o intuito de assegurar a qualidade de seus produtos, mas ao mesmo tempo

consumindo menos recursos na atividade de testes.


    Mais especicamente, atualmente, empresas empregam uma grande quantidade de

esfor√ßo e recursos durante a gera√ß√£o de dados de teste, pois estes s√£o geralmente escritos

manualmente, levando a erros, falhas e redund√¢ncias. A gera√ß√£o autom√°tica de dados de

teste surge como abordagem promissora para minimizar o esfor√ßo na cria√ß√£o de casos de

teste, resultando em um maior controle da qualidade e na redu√ß√£o de custos inerentes ao

processo.


    Nos √∫ltimos tempos, ferramentas comerciais, utilizando Constraint Solvers, como:
            1             2                   3
RT-Tester       , T-Vec       , SCR Toolset       , entre outras, t√™m sido adotadas por empresas para

gera√ß√£o autom√°tica de dados de teste. A ideia por tr√°s da utiliza√ß√£o de Constraint Solvers

√© resolver problemas, simplesmente armando restri√ß√µes (constraints ) as quais devem ser

satisfeitas por uma solu√ß√£o do problema.

  1 http://www.veried.de/en/products/rt-tester
  2 http://www.t-vec.com/
  3 https://www.nrl.navy.mil/chacs/5546/scr_toolset/index.php
1.1 Qualica√ß√£o do Problema                                                            13


1.1 Qualica√ß√£o do Problema
   Como visto anteriormente, nos √∫ltimos tempos ferramentas comerciais utilizando

Constraint Solvers t√™m sido adotadas por empresas para gera√ß√£o autom√°tica de dados

de testes. Logo, √© importante, saber quais os benef√≠cios e limita√ß√µes dessa t√©cnica, o que

j√° foi feito, e o que pode ou precisa ser melhorado.


   Portanto, esse trabalho tem como problema de pesquisa: como Constraint Solvers

t√™m sido utilizados para gerar automaticamente dados de teste?       Para responder este

questionamento e obter um melhor entendimento da √°rea, prop√µe-se a realiza√ß√£o de um

mapeamento sistem√°tico da literatura.




1.2 Objetivos
   Este trabalho tem como principal objetivo sumarizar evid√™ncias a m de prover um

melhor entendimento sobre os detalhes de como dados de teste s√£o gerados automatica-

mente a partir do uso de Contraint Solvers.




1.2.1 Objetivos Espec√≠cos
   Mais especicamente, este trabalho tamb√©m tem os seguintes objetivos:




   ‚Ä¢   Mapear as t√©cnicas mais utilizadas;


   ‚Ä¢   Identicar qual o tipo de Constraint Solver mais utilizado;


   ‚Ä¢   Analisar a escalabilidade para problemas reais;


   ‚Ä¢   Apontar benef√≠cios e limita√ß√µes da t√©cnica.




1.3 Resultados e Impactos Esperados
   Este trabalho ter√° como principal resultado um mapeamento de Constraint Solvers

utilizados na gera√ß√£o autom√°tica de dados de testes para os dom√≠nios nos quais essa

abordagem tem sido utilizada.


   Este mapeamento fornecer√° um arcabou√ßo para posicionar novas pesquisas, al√©m de

apoiar a gera√ß√£o de novas hip√≥teses de pesquisa. Em particular, ser√° poss√≠vel posicionar
1.4 Estrutura da Monograa                                                             14


novas pesquisas em rala√ß√£o as limita√ß√µes e desaos existentes atualmente no emprego

desta t√©cnica de testes de software e sistemas.




1.4 Estrutura da Monograa
   Este trabalho est√° dividido em cinco cap√≠tulos, incluindo este cap√≠tulo introdut√≥rio.

A seguir tem-se uma breve descri√ßao do conte√∫do de cada um destes:




   ‚Ä¢   O Cap√≠tulo 2 apresenta o referencial te√≥rico, e os principais conceitos que s√£o ne-

       cess√°rios para a compreens√£o deste trabalho.


   ‚Ä¢   O Cap√≠tulo 3 descreve a metodologia utilizada para realiza√ß√£o do estudo, as princi-

       pais etapas da pesquisa e o processo para a realiza√ß√£o do mapeamento sistem√°tico

       da literatura, a partir da deni√ß√£o de um protocolo. Para nalizar, √© descrito como

       √© feita a an√°lise dos dados extra√≠dos e sintetize num mapeamento.


   ‚Ä¢   No Cap√≠tulo 4 apresentam-se os resultados, sendo analisados inicialmente os da-

       dos quantitativos do mapeamento como principais fontes, quantidade de estudos

       retornados, avalia√ß√£o da qualidade dos mesmos.    Em seguida, √© feita uma an√°lise

       qualitativa das evid√™ncias com o objetivo de responder a quest√£o de pesquisa.


   ‚Ä¢   No Cap√≠tulo 5 √© apresentada a conclus√£o do trabalho atrav√©s dos dados obtidos a

       partir do mapeamento sistem√°tico sobre o tema da pesquisa.
                                                                                            15




2         Constraint Programming


    Constraint programming (ou Propaga√ß√£o por Restri√ß√µes) √© um poderoso paradigma

para resolver problemas de busca combinat√≥ria, que se baseia em uma ampla gama de

t√©cnicas de intelig√™ncia articial, ci√™ncia da computa√ß√£o, linguagens de programa√ß√£o e

pesquisa operacional (ROSSI;   BEEK; WALSH, 2006).         Constraint programmin g atualmente √©

aplicada em muitos dom√≠nios, como an√°lise de circuitos el√©tricos, planejamento nanceiro,

gera√ß√£o de dados de teste, etc.


    √â um paradigma de programa√ß√£o em que as rela√ß√µes entre as vari√°veis pode ser

expressa na forma de restri√ß√µes. Restri√ß√µes diferem das primitivas comuns de outras lin-

guagens de programa√ß√£o na medida em que n√£o especicam um passo ou a sequ√™ncia de

passos para executar, mas sim as propriedades de uma solu√ß√£o a ser encontrada. Cons-

traint programming pode ser utilizada pra resolver uma grande variedade de problemas

de forma mais eciente.


    De acordo com Russell et al. (1996), utilizando um conjunto de vari√°veis, onde cada

uma das quais tem um valor, um problema √© solucionado quando cada vari√°vel possuir

um valor que satisfaz todas as restri√ß√µes impostas sobre a mesma. Um problema descrito

desta maneira √© chamado de Constraint Satiscation Problem, ou CSP.




2.1 Constraint Satisfation Problems
    De acordo com Russell et al. (1996), um Constraint Satiaction Problem (CSP) con-

siste em tr√™s componentes, X, D e C, onde:




    ‚Ä¢   X √© um conjunto de vari√°veis,   {Xi , ..., Xn };

    ‚Ä¢   D √© um conjunto de dom√≠nios,    {Di , ..., Dn },   um para cada vari√°vel;


    ‚Ä¢   C √© um conjunto de restri√ß√µes que especica poss√≠veis combina√ß√µes de valores.
2.1 Constraint Satisfation Problems                                                                   16


    Cada dom√≠nio         Di ,   consiste em um conjunto de poss√≠veis valores    {V1 , ..., Vk }   para a

vari√°vel   Xi .   Cada restri√ß√£o    Ci   consiste no par (escopo, rel), onde escopo √© uma tupla de

valores que participam na restri√ß√£o e rel √© a rela√ß√£o que dene os valores que essas vari√°veis

podem assumir. A rela√ß√£o pode ser representada como uma lista de todas as tuplas de

valores que satisfazem a restri√ß√£o, ou como uma rela√ß√£o abstrata que suporta opera√ß√µes:

testando se uma tupla √© membro da rela√ß√£o e enumerando os membros da rela√ß√£o. Por

exemplo, se       X1 e X2 ambos t√™m o dom√≠nio {A,B}, ent√£o, a restri√ß√£o que diz que essas duas
vari√°veis devem ter valores diferentes pode ser escrita como           ((X1 , X2 ), {(A, B), (B, A)})
ou como    ((X1 , X2 ), X1 6= X2 ).

    Para resolver um CSP, precisa-se denir um estado-espa√ßo. Cada estado em um CSP

√© denido por uma atribui√ß√£o de valores a algumas ou todas as vari√°veis. Uma atribui√ß√£o

que n√£o viola nenhuma restri√ß√£o √© chamada de atribui√ß√£o consistente. Uma atribui√ß√£o

parcial √© aquela que atribui valores apenas a algumas vari√°veis. J√° uma atribui√ß√£o com-

pleta √© uma atribui√ß√£o onde cada vari√°vel √© atribu√≠da e nalmente, uma solu√ß√£o para um

CSP √© uma atribui√ß√£o completa e consistente.




2.1.1 Exemplo de CSP: Colora√ß√£o de Mapa
    Um exemplo bastante difundido em CSP √© o problema da colora√ß√£o de mapas, que

consiste em colorir as regi√µes de um determinado mapa de modo que duas regi√µes vizinhas

n√£o possuam a mesma cor. Neste problema, as regi√µes do mapa s√£o as vari√°veis, o dom√≠nio

√© o conjunto das poss√≠veis cores para as regi√µes, e a restri√ß√£o √©: duas regi√µes vizinhas n√£o

podem possuir a mesma cor.


    Neste tipo de problema a constru√ß√£o de um constraint graph ou gr√°co de restri√ß√£o,

como mostrado na Figura 1 pode ser √∫til para a visualiza√ß√£o do problema. Os n√≥s do gr√°fo

correspondem as vari√°veis do problema, e uma aresta conecta quaisquer duas vari√°veis

que participem de uma restri√ß√£o


    Tomando como exemplo o grafo da Figura 1, para formular esse exemplo como um

CSP, denem-se as vari√°veis como sendo as regi√µes do mapa.




                                         X = {A, B, C, D, E, F, G} .


    O dom√≠nio de cada vari√°vel √© o conjunto           Di = {vermelho, verde, azul}.    As restri√ß√µes

requerem que duas regi√µes vizinhas tenham cores distintas. O grafo de restri√ß√µes possui
2.1 Constraint Satisfation Problems                                                             17




                             Figura 1: Grafo de restri√ß√£o


nove arestas, ou seja, nove regi√µes de fronteira. A partir dessa observa√ß√£o, nove restri√ß√µes

s√£o obtidas:



      C = {F 6= A, F 6= B, F 6= C, F 6= D, F 6= E, A 6= B, B 6= C, C 6= D, D 6= E} .


    F 6= A   √© uma abrevia√ß√£o para    ((F, A), F 6= A),   onde    F 6= A   pode ser enumerado por

sua vez como:


    {(vermelho, verde), (vermelho, azul), (verde, vermelho), (verde, azul),
(azul, vermelho), (azul, verde)}

    Existem v√°rias poss√≠veis solu√ß√µes para este problema, como:


    {A = vermelho, B = verde, C = vermelho, D = verde, E = vermelho, F = azul,
G = vermelho}

    Uma das raz√µes de se modelar um problema como um CSP √© que os modeols CSPs s√£o

uma representa√ß√£o natural para uma grande variedade de problemas. Se j√° possuirmos

um sistema de resolu√ß√£o de CSP (CSP-solving system ), √© mais f√°cil resolver problemas

utilizando esse sistema do que construir uma solu√ß√£o personalizada utilizando outras

t√©cnicas de busca para cada problema (RUSSELL          et al.,   1996).    Al√©m disso, CSP-solvers

podem ser mais r√°pidos do que algoritmos de busca de estado-espa√ßo porque os CSP-

solvers podem eliminar rapidamente grandes amostras do espa√ßo de busca. Por exemplo,

uma vez que atribu√≠mos    {F = Azul}     no problema anterior, pode-se concluir que nenhum

das cinco regi√µes vizinhas pode assumir a cor azul.             Sem tirar vantagem da constraint

propagation (propaga√ß√£o de restri√ß√µes) (RUSSELL       et al.,   1996) , um procedimento de busca

teria que considerar   35 = 243   atribui√ß√µes para as cinco vari√°veis vizinhas √† vari√°vel F; j√°
2.1 Constraint Satisfation Problems                                                                      18


com a Constraint Propagation n√£o se precisa considerar azul como um valor, logo, se

tem apenas      25 = 32   atribui√ß√µes poss√≠veis. Uma redu√ß√£o de 87%.


    Com modelos CSPs, uma vez descoberto que uma atribui√ß√£o parcial n√£o √© uma solu-

√ß√£o, podemos imediatamente descartar futuros renamentos sobre essa atribui√ß√£o. Al√©m

disso, podemos observar quais vari√°veis infringem a restri√ß√£o, e ent√£o concentrar a aten-

√ß√£o sobre as vari√°veis que s√£o importantes. Como resultado, muitos problemas que s√£o

intrat√°veis utilizando busca em estado-espa√ßo podem ser resolvidos rapidamente quando

formulados como um CSP (RUSSELL             et al.,   1996).




2.1.2 Exemplo de CSP: Planejamento de Tarefas
    Outro exemplo de problema que pode ser descrito como um CSP √© o problema de

planejar um dia de trabalho em uma f√°brica, o qual est√° sujeito a varias restri√ß√µes. Na

pratica, muitos desses problemas s√£o resolvidos com t√©cnicas de CSP (RUSSELL                         et al.,
1996).    Considere o problema de planejamento de uma montadora de carro.                          Todo o

trabalho √© composto de tarefas e cada tarefa pode ser modelada como uma vari√°vel, onde

o valor de cada vari√°vel √© o momento em que a tarefa √© iniciada, expresso como um

numero inteiro de minutos. Restri√ß√µes podem armar que uma tarefa deve ocorrer antes

de outra, por exemplo, a roda do carro deve ser xada antes que a calota seja colocada,

e que apenas um n√∫mero determinado de tarefas pode ser executado por vez.


    Para ilustrar considerarmos apenas uma pequena parte da montagem do carro, con-

sistindo de 15 tarefas: montar eixos (dianteiro e traseiro), xar as quatro rodas, apertar

as porcas de cada roda, xar as calotas e inspecionar toda a montagem. As tarefas podem

ser representadas por 15 vari√°veis:




     {X = Eixod , Eixot , Rodade , Rodadd , Rodate , Rodatd , P orcade , P orcadd , P orcate ,

                             P orctd , Calde , Caldd , Calte , Caldd , Inspec}

    O valor de cada vari√°vel √© o tempo em que a tarefa √© iniciada. O pr√≥ximo passo √©

representar as restri√ß√µes de preced√™ncia entre duas vari√°veis individuais. Sempre que uma

tarefa   T1   precise ocorrer antes que a tarefa      T2 , e a tarefa T1   dure   D1   para ser completada,

√© adicionada uma restri√ß√£o aritm√©tica da forma              T1 + d1 ‚â§ T2 .

    Neste exemplo os eixos devem ser colocados antes que as rodas, e a xa√ß√£o dos eixos

demora 10 minutos para ser completada, assim:
2.1 Constraint Satisfation Problems                                                               19




                          Eixod + 10 ‚â§ Rodade ; Eixod + 10 ‚â§ Rodadd ;

                             Eixot + 10 ‚â§ Rodate ; Eixot + 10 ‚â§ Rodatd .

Para cada roda, √© preciso colocar a roda (1 minuto), depois apertar as roscas (2 minutos)

e depois colocar a calota (1 minuto).




                          Rodade + 1 ‚â§ P orcade ; P orcade + 2 ‚â§ Calde ;

                          Rodadd + 1 ‚â§ P orcadd ; P orcadd + 2 ‚â§ Caldd ;

                             Rodate + 1 ‚â§ P orcate ; P orcate + 2 ‚â§ Calte ;

                          Rodatd + 1 ‚â§ P orcatd ; P orcatd + 2 ‚â§ Caltd .

Suponha que exista quatro trabalhadores para instalar as rodas, mas eles compartilham

uma ferramenta que ajuda a colocar o eixo no lugar. √â necess√°rio uma restri√ß√£o disjuntiva

para dizer que   Eixod   e   Eixot   n√£o deve sobrepor-se no tempo:




                         (Eixod + 10 6= Eixot )ou(Eixot + 10 6= Eixod ).



Esta restri√ß√£o parece ser mais complicada, combinando aritm√©tica e l√≥gica.                 Mas ainda

reduz-se a um conjunto de pares de valores que          Eixod     e   Eixoe   podem assumir.


    Tamb√©m √© necess√°rio armar que a inspe√ß√£o vem por ultimo e demora 3 minutos.

Para cada vari√°vel exceto Inspec √© adicionada a restri√ß√£o da forma                 X + dx 6= Inspec.
Finalmente, supondo que h√° uma exig√™ncia para que toda a montagem seja feita em 30

minutos. Pode-se conseguir isso limitando o dom√≠nio de todas as vari√°veis:




                                         Di = {1, 2, 3, ...27}.


    Apesar da resolu√ß√£o desse problema em particular, ser trivial, CSPs tem sido aplicados

a problemas de planejamento como esse com milhares de vari√°veis. Em alguns casos, h√°

restri√ß√µes complicadas que s√£o dif√≠ceis de especicar utilizando a modelagem CSP.
2.1 Constraint Satisfation Problems                                                                         20


2.1.3 Varia√ß√µes da Modelagem CSP
     O tipo mais simples de CSP envolve vari√°veis que possuem dom√≠nio nito e discreto,

problemas como os de colora√ß√£o de mapa e planejamento de tarefas s√£o desse tipo.


     Entretanto, um dom√≠nio discreto pode ser innito, como o conjunto dos inteiros ou

strings (cadeias de caracteres).        Com dom√≠nios innitos, n√£o √© mais poss√≠vel descrever

restri√ß√µes enumerando todos as combina√ß√µes de valores poss√≠veis. Ao inv√©s disso, deve ser

usada uma linguagem de restri√ß√µes (constraint language ) (ROSSI;                BEEK; WALSH,            2006),

que entenda diretamente restri√ß√µes como               (T1 + d1 ‚â§ T2 ),   sem enumerar o conjunto de

pares dos poss√≠veis valores para        (T1 , T2 ).   Existem algoritmos especiais para solu√ß√£o de

restri√ß√µes lineares sobre vari√°veis inteiras, onde cada vari√°vel aparece apenas na forma

linear (RUSSELL      et al.,   1996).


     J√° os Constraint satisfaction problems com dom√≠nios cont√≠nuos s√£o comum em pro-

blemas reais e s√£o amplamente estudados no campo de pesquisas operacionais (RUSSELL

et al.,   1996).   Por exemplo, o planejamento dos experimentos com o telesc√≥pio espacial

Hubble, exige um tempo muito preciso de observa√ß√µes; o inicio e o m de cada observa-

√ß√£o e manobra s√£o vari√°veis de valores cont√≠nuos que devem obedecer uma variedade de

restri√ß√µes astron√¥micas, de preced√™ncia e de energia (RUSSELL              et al.,   1996).


     A categoria mais conhecida de CSPs com dom√≠nio continuo √© a de problemas de

programa√ß√£o linear (Linear Programming Problems ), onde as restri√ß√µes devem ser igual-

dades ou desigualdades lineares. Linear Programming Problems podem ser solucionados

em tempo polinomial de acordo com o n√∫mero das vari√°veis. Problemas com diferentes

tipos de restri√ß√µes e fun√ß√µes objetivo tamb√©m tem sido estudados (RUSSELL                     et al.,   1996).


     Al√©m disso, para examinar os tipos de vari√°veis que podem aparecer em modelos CSP,

√© vantajoso observar os tipos de restri√ß√µes. O tipo mais simples √© a restri√ß√£o un√°ria (unary

constraint ), que restringe o valor de uma √∫nica vari√°vel. Por exemplo, no problema da

colora√ß√£o de mapa visto na se√ß√£o anterior, poderia ser o caso em que a regi√£o A n√£o

tolerasse a cor verde, isso pode ser expresso com a restri√ß√£o un√°ria             (A 6= verde).

     Uma restri√ß√£o bin√°ria (binary constraint ) relaciona duas vari√°veis, por exemplo,

A 6= B     √© uma restri√ß√£o bin√°ria. Um CSP bin√°rio √© um problema apenas com restri√ß√µes

bin√°rias e pode ser representado como um grafo de restri√ß√£o, como na Figura 1.


     Tamb√©m podem ser descritas restri√ß√µes de ordem superior, tais como assegurar que

o valor de Y est√° entre X e Z, como a restri√ß√£o tern√°ria Between (X,Y,Z). Uma restri√ß√£o

envolvendo um n√∫mero arbitr√°rio de vari√°veis √© chamada de restri√ß√£o global (global cons-
2.1 Constraint Satisfation Problems                                                                         21


traint ). Apesar do nome, uma restri√ß√£o global n√£o precisa envolver todas as vari√°veis de

um problema. Uma das restri√ß√µes globais mais comuns √© Alldi, que arma que todas as

vari√°veis envolvidas na restri√ß√£o devem ter valores diferentes. Por exemplo, a restri√ß√£o

Alldi (A,B,C,D) quer dizer que as vari√°veis A, B, C e D devem ter valores diferentes

entre si.


       √â importante destacar que toda restri√ß√£o de dom√≠nio nito pode ser reduzida a um

conjunto de restri√ß√µes bin√°rias, se forem introduzidas vari√°veis auxiliares (RUSSELL                         et
al.,   1996). Desse modo, qualquer CSP pode ser transformado em um CSP apenas com

restri√ß√µes bin√°rias.   Por exemplo, a restri√ß√£o global Alldi (A,B,C,D) pode ser descrita

por um conjunto de restri√ß√µes bin√°rias;        {A 6= B, A 6= C, A 6= D, B 6= C, B 6= D, C 6= D}.
Isso torna os algoritmos de constraint solving mais simples.


       Uma forma simples de detectar inconsistencia para restri√ß√µes Alldi                       funciona da

seguinte maneira: se    m   vari√°veis est√£o envolvidas na restri√ß√£o, e se existem                 n   poss√≠veis

valores distintos no total, e   m>n     , ent√£o a restri√ß√£o n√£o pode ser satisfeita. Isso leva

ao simples algoritmo:     primeiro, remove-se qualquer vari√°vel na restri√ß√£o que tem um

dom√≠nio singleton (isto √©, com apenas um valor), e exclui-se o valor desta vari√°vel dos

dom√≠nios das vari√°veis restantes. Repete-se enquanto houver vari√°veis singleton. Se em

algum momento um dom√≠nio vazio √© produzido ou h√° mais vari√°veis do que os valores

restantes do dom√≠nio, ent√£o uma inconsist√™ncia foi detectada.


       Outra maneira de converter qualquer CSP em um CSP com restri√ß√µes bin√°rias √©

a dual grapfh transformation (RUSSELL           et al.,   1996):   criar um novo grafo onde haver√°

uma vari√°vel para cada restri√ß√£o do grafo original, e uma restri√ß√£o bin√°ria para cada

par de restri√ß√µes no grafo original que compartilhem vari√°veis. Por exemplo, se o grafo

original tiver as vari√°veis X, Y, Z e as restri√ß√µes          ((X, Y, Z), C1 )    e   ((X, Y ), C2 ),   ent√£o o

dual graph tem duas vari√°veis      C1 , C2   com a restri√ß√£o bin√°ria           ((X, Y ), R1 ),   onde (X,Y)

s√£o as vari√°veis compartilhadas e     R1     √© uma nova rela√ß√£o que dene a restri√ß√£o entre as

vari√°veis compartilhadas, como especicado pelo original             C1 eC2 .

       No entanto, existem duas raz√µes pelas quais deve se preferir restri√ß√µes globais como

Alldi ao inv√©s de um conjunto de restri√ß√µes bin√°rias. Primeiro, √© mais f√°cil e menos

suscet√≠vel a erros escrever a descri√ß√£o do problema usando restri√ß√µes globais. Segundo, √©

poss√≠vel projetar algoritmos de infer√™ncia para restri√ß√µes globais que n√£o s√£o dispon√≠veis

para um conjunto de restri√ß√µes mais primitivas (RUSSELL              et al.,   1996).


       As restri√ß√µes descritas at√© agora, s√£o todas restri√ß√µes absolutas, isto √©, a viola√ß√£o

dessas restri√ß√µes exclui poss√≠veis solu√ß√µes. Muitos problemas do mudo real incluem res-
2.2 Constraint Solvers                                                                       22


tri√ß√µes preferenciais (preference constraints ), indicando quais solu√ß√µes s√£o preferidas. Por

exemplo, numa universidade, o problema de aloca√ß√£o de aulas possui restri√ß√µes absolutas,

onde, nenhum professor pode estar em duas aulas ao mesmo tempo. Mas tamb√©m podem

existir restri√ß√µes preferenciais: Professor X pode preferir ensinar no per√≠odo da manh√£,

enquanto que Professor Z prefere ensinar no per√≠odo da tarde. Restri√ß√µes preferenciais

podem muitas vezes ser codicadas como custos sobre atribui√ß√µes de vari√°veis individuais,

por exemplo, atribuir uma vaga da tarde para o Professor X custa 2 pontos na fun√ß√£o ob-

jetivo global, enquanto uma vaga da manha custa 1. Com essa formula√ß√£o, modelos CSP

com preferencias podem ser resolvidos com m√©todos de busca otimizados. Esse tipo de

problema √© chamado de constraint optimization problems ou COP (RUSSELL          et al.,   1996).

Linear programming problems fazem esse tipo de otimiza√ß√£o.




2.2 Constraint Solvers
    A ideia de constraint programming √© resolver problemas simplesmente declarando

restri√ß√µes (condi√ß√µes, propriedades) e devem ser satisfeitas por uma solu√ß√£o do problema.

(FRUHWIRTH;    ABDENNADHER,      2005)


    Quando executado, um constraint program gera sucetivamente restri√ß√µes.          Um pro-

grama especial, o constraint solver, armazena, combina e simplica as restri√ß√µes at√© uma

solu√ß√£o ser encontrada. O solver re√∫ne as restri√ß√µes que chegam de forma incremental a

partir de um ou mais programas em execu√ß√£o e armazena essas restri√ß√µes em uma cons-

traint store, uma estrutura de dados para as restri√ß√µes. Ent√£o o solver simplica e, se

poss√≠vel, encontra uma solu√ß√£o para o problema (FRUHWIRTH;        ABDENNADHER,      2005).




2.2.1 SAT e SMT Solvers
    Na ultima d√©cada houveram importantes avan√ßos nas t√©cnicas e ferramentas baseadas

em l√≥gica. Avan√ßos signicativos ocorreram no campo da propositional satisability (SAT)

a tal ponto que, atualmente, SAT solvers s√£o capazes de resolver problemas do mundo

real modelados utilizando l√≥gica de primeira ordem, como o problema de colora√ß√£o de

mapas.


    As t√©cnicas de SAT tem sido adaptadas para l√≥gicas mais expressivas. Por exemplo,

o caso da SAT Modulo Theories (SMT). Uma instancia de SMT √© uma generaliza√ß√£o

de uma instancia de SAT em que algumas vari√°veis proposicionais s√£o substitu√≠das por

predicados de teorias subjacentes, e pode conter formulas como:
2.3 Teste de Software                                                                23




                  f (f (x) ‚àí f (y)) 6= f (z) ‚àß x + z ‚â§ y ‚àß y ‚â§ x ‚áí z < 0,


fornecendo uma linguagem de modelagem muito mais rica que simples formulas proposi-

cionais (FRUHWIRTH;     ABDENNADHER,    2005).


   A principal √°rea de aplica√ß√£o de SMT √© a verica√ß√£o de hardware e software (FRUHWIRTH;

ABDENNADHER,     2005). Entretanto, as teorias dispon√≠veis n√£o restringem o uso de SMT

a problemas de verica√ß√£o, e, de fato, permite codicar v√°rios problemas fora da √°rea de

verica√ß√£o de uma maneira natural.




2.3 Teste de Software
   Durante o desenvolvimento de um software, o processo de testes exerce um importante

papel para garantir a qualidade do software.     O orocesso de testes √© um conjunto de

atividades apuradas e bem planejadas. Essas atividades t√™m como objetivo vericar se

todos os requisitos do sistema foram implementados corretamente e assegurar a qualidade

e corretude do software produzido (MYERS, 1979).


   Um ponto importante no processo de testes √© a gera√ß√£o dos dados que ser√£o utilziados

nessas atividades. Atualmente, empresas empregam uma grande quantidade de esfor√ßo

e recursos durante a gera√ß√£o dos dados de teste, pois esse dados geralmente s√£o escritos

manualmente, levando a erros, falhas e redund√¢ncias.


   A gera√ß√£o autom√°tica de dados de teste surge como uma abordagem promissora para

minimizar o esfor√ßo na gera√ß√£o de dados de teste, resultando em um maior controle de

qualidade e na redu√ß√£o dos custos inerentes ao processo.
                                                                                           24




3         M√©todo de Pesquisa


    Este Cap√≠tulo apresenta a metodologia aplicada neste trabalho, sua qualica√ß√£o, es-

tapas, crit√©rios de inclus√£o e exclus√£o, processo de sele√ß√£o, estrat√©gia de estra√ß√£o e sintese

dos dados e apresenta√ß√£o dos resultados.




3.1 Qualica√ß√£o do M√©todo de Pesquisa
    Este trabalho optou pela utiliza√ß√£o do m√©todo de mapeamento sistem√°tico da lite-

ratura. Os mapeamentos sistem√°ticos t√™m por objetivo apresentar uma avalia√ß√£o justa

de um t√≥pico de investiga√ß√£o, usando uma con√°vel, rigorosa e veric√°vel metodologia

(KITCHENHAM, 2007).




3.2 Etapas do M√©todo de Pesquisa
    Um mapeamento sistem√°tico come√ßa com a deni√ß√£o do protocolo que especica as

quest√µes de investiga√ß√£o e os m√©todos que ser√£o utilizados para conduzir o mapeamento.

De acordo com Kitchenham (2007), al√©m das raz√µes e objetivos da pesquisa devem fazer

parte do protocolo:




    ‚Ä¢   As quest√µes de investiga√ß√£o que a pesquisa pretende responder. A estrat√©gia que

        ser√° usada para procurar os estudos prim√°rios, incluindo os termos de pesquisa e

        recursos necess√°rios.


    ‚Ä¢   Crit√©rios de sele√ß√£o do estudo que ser√£o usados para determinar quais estudos ser√£o

        inclu√≠dos ou exclu√≠dos do mapeamento sistem√°tico.


    ‚Ä¢   Uma descri√ß√£o de como os crit√©rios de sele√ß√£o ser√£o aplicados, por exemplo, como

        avaliar cada estudo prim√°rio, e como diverg√™ncias entre os avaliadores ser√£o resol-

        vidas.
3.3 Quest√µes de Pesquisa                                                               25


   ‚Ä¢   O protocolo tamb√©m deve conter listas de verica√ß√£o da qualidade e procedimentos

       de avalia√ß√£o desta.


   ‚Ä¢   Uma estrat√©gia de extra√ß√£o de dados que dene como e quais informa√ß√µes ser√£o

       extra√≠das de cada estudo prim√°rio. Se os dados exigem manipula√ß√£o ou suposi√ß√µes

       e infer√™ncias a serem feitas, o protocolo deve especicar um processo de valida√ß√£o

       adequado.


   ‚Ä¢   Uma estrat√©gia de s√≠ntese dos dados. Esta informa√ß√£o deve esclarecer se uma meta-

       an√°lise formal se aplica e caso armativo, quais t√©cnicas ser√£o usadas.


   ‚Ä¢   Por m, uma estrat√©gia de divulga√ß√£o.     Esta dene como as conclus√µes oriundas

       da pesquisa ser√£o apresentadas e divulgadas para terceiros interessados no mesmo

       tema.




3.3 Quest√µes de Pesquisa
   A partir do que est√° apresentado anteriormente, a principal quest√£o de pesquisa deste

       Como Constraint
estudo √©:                       Solvers t√™m sido utilizados para gerar automatica-
mente dados de teste?
   Para um mapeamento sistem√°tico mais preciso, foram elaboradas as se seguintes sub-

quest√µes:




   ‚Ä¢   Qual a escalabilidade para problemas reais da utiliza√ß√£o de Constraint Solvers para

       gera√ß√£o autom√°tica de dados de teste?


   ‚Ä¢   Quais os benef√≠cios da utiliza√ß√£o de Constraint Solvers para gera√ß√£o autom√°tica de

       dados de teste?


   ‚Ä¢   Quais as limita√ß√µes da utiliza√ß√£o de Constraint Solvers para gera√ß√£o autom√°tica de

       dados de teste?


   ‚Ä¢   Quais as t√©cnicas mais utilizadas para gerar dados de teste utilizando Constraint

       Solvers ?


   ‚Ä¢   Qual o tipo de Constraint Solver mais utilizado?
3.4 Estrat√©gia de Busca                                                              26


3.4 Estrat√©gia de Busca
   Segundo Kitchenham (2007), uma estrat√©gia de busca deve ser usada para a pesquisa

dos estudos prim√°rios. Devem ser denidas palavras chaves, termos de busca e decididas

em que bibliotecas digitais, jornais e confer√™ncias, os termos ser√£o submetidos. Devido

√† limita√ß√£o de tempo dispon√≠vel.   A estrat√©gia usada nessa pesquisa √© apresentada nas

pr√≥ximas subse√ß√µes.




3.5 Termos Chaves da Pesquisa
   A partir da quest√£o de investiga√ß√£o, os principais termos podem ser identicados.

Ap√≥s a identica√ß√£o, √© realizada a tradu√ß√£o desses termos para a l√≠ngua inglesa, por ser

a l√≠ngua utilizada nas bases de dados eletr√¥nicas pesquisadas e nos principais jornais e

conferencias dos t√≥picos de investiga√ß√£o.


   Os termos e sin√¥nimos identicados s√£o apresentados abaixo:



   ‚Ä¢ Dados de Teste:      Test Data, Test Vector.


   ‚Ä¢ Constraint Solver:     Constraint Solver, Constraint Solving, SAT, SMT, CLP.




3.6 Termos e Predicado de Busca
   Segundo Kitchenham (2007), os termos s√£o constru√≠dos a partir das estruturas das

quest√µes de pesquisa e podem sofrer adapta√ß√µes de acordo com as necessidades especicas

de cada base da dados. Assim, a busca √© realizada a partir da combina√ß√£o dos termos

chave e sin√¥nimos usando OR (ou) e AND (e), e poss√≠veis particularidades das bibliotecas

digitais. Nesta pesquisa apenas uma express√£o de busca ser√° utilizada.


 ((test data OR test vector )) AND (constraint solving OR constraint solver OR

                                SAT OR SMT OR CLP)




3.7 Fontes de Busca
   Os crit√©rios de sele√ß√£o das fontes de busca s√£o:



   ‚Ä¢   Disponibilidade de consulta dos artigos na web.
3.7 Fontes de Busca                                                                            27


   ‚Ä¢   Presen√ßa de mecanismos de busca utilizando palavras-chave.


   ‚Ä¢   Import√¢ncia e relev√¢ncia das fontes.




   Assim, com a express√£o de busca denida, as fontes de pesquisa utilizadas para a

busca dos estudos prim√°rios s√£o listadas abaixo:




   ‚Ä¢   ACM Digital Library (portal.acm.org/dl.cfm)


            Seguindo o seguinte procedimento:        (i) entrar no site Portal ACM       (http :
             //dl.acm.org/);    (ii) clicar em Search ; (iii) considerando a base  The ACM

             Guide to Computing Literatur e. clicar em  Advanced Search e (iv) digitar a

             string de busca acima no campo localizado abaixo do texto  Edit the query

             directly, or use the form below .


   ‚Ä¢   IEEE Xplore (ieeexplore.ieee.org/Xplore/dynhome.jsp)


            Seguindo o seguinte procedimento: (i) entrar no site do IEEE XPlore          (http :
             //ieeexplore.ieee.org/); (ii) clicar em  Advanced Search ; (iii) clicar em  Switch
             to Command Search ; (iv) escolher a op√ß√£o  Full Text & Metadata e (v) digitar

             a string de busca acima no campo principal.


   ‚Ä¢   SpringerLink (www.springer.com)


            Seguindo o seguinte procedimento: (i) entrar no site do Springer Link         (http :
             //www.springerlink.com/)       e (ii) digitar a string de busca acima no campo

             principal ( Search For ).


   ‚Ä¢   Science Direct (www.sciencedirect.com)


            Seguindo o seguinte procedimento: (i) entrar no site do Science Direct        (http :
             //www.sciencedirect.com/)      e (ii) digitar a string de busca acima no campo

             principal ( All Fields ).




   Para conferir uma maior conabilidade √† pesquisa, evitando a n√£o considera√ß√£o de

artigos relevantes n√£o retornados pela busca, idealmente, deveria ser feita uma pesquisa

em segundo n√≠vel utilizando o processo snow-balling (GREENHALGH;              PEACOCK,     2005),

ou seja, para todos os artigos selecionados, as suas refer√™ncias seriam analisadas para

identicar trabalhos relevantes n√£o capturados pela express√£o de busca.
3.8 Sele√ß√£o dos Estudos                                                                 28


    Esse processo e a express√£o de busca foram validados a partir de sete trabalhos j√°

conhecidos e considerados relevantes, estes trabalhos est√£o listados no Ap√™ndice B . A

lista nal com os trabalhos selecionados deve ser avaliada por um pesquisador mais ex-

periente, de forma que este possa valid√°-la e porventura incluir trabalhos relevantes n√£o

selecionados. Essa avalia√ß√£o est√° sujeita a disponibilidade de tempo, e a disponibilidade

do pesquisador escolhido.




3.8 Sele√ß√£o dos Estudos
    Os estudos que fazem parte desta pesquisa s√£o:




   ‚Ä¢   Artigos em revistas, confer√™ncias e congressos;


   ‚Ä¢   Relat√≥rios t√©cnicos;


   ‚Ä¢   Disserta√ß√µes e teses.




    Uma vez obtidos os estudos prim√°rios, os mesmos passar√£o por uma an√°lise para

comprovar sua relev√¢ncia para a pesquisa, e para que estudos n√£o relevantes sejam des-

cartados. Segundo Travassos (2007), crit√©rios de inclus√£o e exclus√£o devem ser baseados

nas quest√µes de pesquisa.      Portanto, os crit√©rios de inclus√£o e exclus√£o foram baseados

nos trabalhos de Travassos (2007) e Kitchenham (2007) e ser√£o apresentados a seguir.




3.9 Crit√©rios de Inclus√£o
    Para um trabalho ser considerado relevante para esta pesquisa s√£o executadas duas

etapas. Estas etapas se aplicam tanto aos artigos retornados pela aplica√ß√£o da express√£o

de busca nas bases de dados antes citados, como tamb√©m na pesquisa em segundo n√≠vel,

antes explicada.


    Na primeira etapa s√£o analisados o t√≠tulo e as palavras-chave e o resumo de cada

artigo, vericando se os mesmos est√£o de acordo com o tema deste estudo. Na segunda

etapa, atrav√©s da leitura da introdu√ß√£o e conclus√£o, √© vericado se o trabalho obedece aos

crit√©rios listados abaixo:




   ‚Ä¢   Os documentos devem estar inteiramente dispon√≠veis na internet
3.10 Crit√©rios de Exclus√£o                                                              29


   ‚Ä¢   Os textos devem apresentar informa√ß√µes sobre gera√ß√£o autom√°tica de dados de teste

       utilizando Constraint Solvers.




3.10 Crit√©rios de Exclus√£o
   Ser√£o descartados trabalhos que se enquadrem em algum dos crit√©rios abaixo:



   ‚Ä¢   Estudos que n√£o sejam dispon√≠veis livremente na web;


   ‚Ä¢   Estudos irrelevantes para a pesquisa, de acordo com a quest√£o de pesquisa;


   ‚Ä¢   Estudos repetidos: se determinado estudo estiver dispon√≠vel em diferentes fontes de

       busca, a primeira pesquisa ser√° considerada;


   ‚Ä¢   Estudos duplicados: caso dois trabalhos apresentam estudos semelhantes, apenas o

       mais recente e/ou mais completos ser√° considerado, a menos que tenham informa√ß√£o

       complementar;


   ‚Ä¢   Estudos que apresentem texto, conte√∫do e resultados incompletos, ou seja, normal-

       mente, trabalhos com menos de 2 p√°ginas.




3.11 Processo de Sele√ß√£o dos Estudos Prim√°rios
   Ap√≥s a deni√ß√£o das quest√µes de pesquisa, da estrat√©gia de busca e dos crit√©rios de

inclus√£o e exclus√£o, as etapas do processo de sele√ß√£o dos estudos prim√°rios s√£o descritas

abaixo:



  1. Em uma data xa, a express√£o de busca ser√° aplicada nas bases de dados selecio-

       nadas, e a lista com todos os resultados ser√° armazenada. Desta forma, ser√° criado

       uma fotograa em cima do qual a sele√ß√£o dos artigos ocorrer√°.


  2. De forma paralela e independente, o autor deste trabalho e o seu orientador ir√£o

       analisar o documento pdf antes mencionado e criar tr√™s listas: uma lista com os

       artigos que devem ser inclu√≠dos, uma lista com os artigos que devem ser exclu√≠dos

       e outra lista de indecisos com artigos para os quais n√£o foi poss√≠vel identicar se

       o mesmo se enquadra no tema desta pesquisa.      Isto ser√° feito a partir da leitura

       do t√≠tulo, palavras-chave e resumo.   Em seguida, estas listas ser√£o unicadas da

       seguinte maneira:
3.11 Processo de Sele√ß√£o dos Estudos Prim√°rios                                            30


        ‚Ä¢   Se o artigo consta na lista de inclu√≠dos, ou na lista de indecisos, de pelo menos

            um dos pesquisadores, o mesmo ser√° inclu√≠do.


        ‚Ä¢   Se o artigo consta na lista de exclu√≠do dos dois autores, o mesmo ser√° exclu√≠do.


     De acordo com Kitchenham (2007), as buscas iniciais retornam uma grande quanti-

     dade de estudos que n√£o s√£o relevantes, n√£o respondendo √†s quest√µes ou mesmo n√£o

     tendo rela√ß√£o com o t√≥pico em quest√£o. Portanto, √© prov√°vel que a quantidade de

     artigos inclu√≠dos represente um pequeno percentual do total de artigos retornados.


  3. Ap√≥s este primeiro ltro (etapa 2), os dois pesquisadores, mais uma vez de forma

     paralela e independente, ir√£o repetir o processo descrito anteriormente, contudo com

     a seguinte diferen√ßa: ap√≥s a leitura da introdu√ß√£o e da conclus√£o de cada trabalho.


  4. Os artigos na nova lista de inclu√≠dos ser√£o lidos por completo. Caso o volume de

     trabalhos n√£o seja compat√≠vel com o tempo dispon√≠vel pela pesquisa, um corte tem-

     poral deve ser analisado. Por exemplo, considerar apenas os trabalhos dos √∫ltimos

     5 anos. Para este trabalho ser√£o lidos em torno de 25 trabalhos.


  5. Ap√≥s a leitura dos artigos, as etapas 2 e 3 s√£o aplicadas de forma an√°loga, contudo,

     considerando agora as refer√™ncias citadas pelos artigos lidos. Como dito anterior-

     mente, o que constitui o segundo n√≠vel do mapeamento.




   Os estudos inclu√≠dos s√£o documentados atrav√©s das Tabela 1. Enquanto que todos os

trabalhos exclu√≠dos e o crit√©rio que deniu sua exclus√£o ser√£o documentados na Tabela 2.




                            Tabela 1: Trabalhos inclu√≠dos.
                                  [Fonte: elabora√ß√£o pr√≥pria]
                              Fonte T√≠tulo 1o Autor Ano




                            Tabela 2: Trabalhos exclu√≠dos.
                                  [Fonte: elabora√ß√£o pr√≥pria]
                  Fonte T√≠tulo 1o Autor Ano Crit√©rio de Exclus√£o
3.12 Leitura dos Trabalhos Selecionados                                                        31


     √â realizada uma an√°lise de conabilidade para avaliar a concord√¢ncia entre os in-

vestigadores. Para esta an√°lise √© utilizado o coeciente kappa (k), o coeci√™nte kappa √©
                                                  Po ‚àíPe
calculado a partir da seguinte f√≥rmula:     k =   1‚àíPe
                                                         , onde    Po   √© a concord√¢ncia obtida e

Pe   a concord√¢ncia esperada (COHEN, 1960). Para interpretar a magnitude do coeciente

kappa obtido, ser√£o utilizadas diretrizes propostas por (LANDIS;         KOCH,   1977), como pode

ser visto na Tabela 3.   Para este trabalho ser√° admitido o coeciente kappa maior que

0.60, ou seja, n√≠vel de concord√¢ncia subst√¢ncial.




                             Tabela 3: Coeciente Kappa.
                                   [Fonte: elabora√ß√£o pr√≥pria]
                         Coeciente Kappa N√≠vel de Concord√¢ncia
                               <0.00                     Pobre
                             0.00 - 0.20                  Leve
                             0.21 - 0.4                 Razo√°vel
                             0.41 - 0.6                Moderado
                             0.61 - 0.80              Substancial
                             0.81 - 1.00             Quase perfeito




3.12 Leitura dos Trabalhos Selecionados
     Cada artigo √© lido por somente um pesquisador, no caso, o autor deste trabalho.

Durante a leitura dos artigos, √© coletada a maior quantidade poss√≠vel de informa√ß√µes

relevantes para responder a quest√£o de pesquisa deste mapeamento. As Tabelas 4, 5, 6, 7

e 8, apresentam um chamento que dene quais informa√ß√µes s√£o coletadas e como elas

s√£o organizadas.




3.13 Avalia√ß√£o da Qualidade dos Estudos
     Al√©m das informa√ß√µes coletadas a partir da Tabela 4, √© importante considerar tamb√©m

a qualidade dos estudos selecionados. Apesar de n√£o existir uma deni√ß√£o universal do que

seja qualidade de estudo, a maioria dos checklists incluem quest√µes que objetivam avaliar

a extens√£o em que o vi√©s √© minimizado e a valida√ß√£o interna e externa s√£o maximizadas

(KITCHENHAM, 2007). De acordo com Kitchenham (2004), esta an√°lise traz os seguintes

benef√≠cios:
3.13 Avalia√ß√£o da Qualidade dos Estudos                              32




                                 Tabela 4: Informa√ß√µes gerais.
                                       [Fonte: elabora√ß√£o pr√≥pria]
  Informa√ß√µes gerais
  T√≠tulo do Trabalho:
  No :
  Autores:
  Fonte de Pesquisa:
  Local de Publica√ß√£o:
  Ano:
  Tipo de Estudo:
         ‚Ä¢ Experimento
         ‚Ä¢ Te√≥rico
         ‚Ä¢ Revis√£o Sistem√°tica
         ‚Ä¢ Relato de Experi√™ncia Industrial


  Tipo de Publica√ß√£o:
         ‚Ä¢ Artigo
         ‚Ä¢ Peri√≥dico
         ‚Ä¢ Disserta√ß√£o
         ‚Ä¢ Tese
         ‚Ä¢ Relat√≥rio T√©cnico
         ‚Ä¢ Cap√≠tulo de Livro
         ‚Ä¢ Livro


  Principal contribui√ß√£o do artigo (Resumo em 2 frases)
3.13 Avalia√ß√£o da Qualidade dos Estudos                                 33




                       Tabela 5: Caracteriza√ß√£o da contribui√ß√£o.
                                      [Fonte: elabora√ß√£o pr√≥pria]
  Caracteriza√ß√£o da contribui√ß√£o.
  O que espera de entrada, o que gera de sa√≠da?


  Em qual formalistmo a entrada e a sa√≠da est√£o representadas?


  Diferencial em rela√ß√£o as outras estrat√©gias.


  Limita√ß√µes.


  Propriedades (Cobertura, corretude, etc.).


      Apresenta prova formal ou argumenta√ß√£o intuitiva?


      Rela√ß√£o de conformidade
           Implicita x Explicita?
           Verica√ß√£o autom√°tica?
           Composicional?




                          Tabela 6: Caracteriza√ß√£o das estapas.
                                     [Fonte: elabora√ß√£o pr√≥pria]
  Caracteriza√ß√£o das estapas existentes na aplica√ß√£o da contribui√ß√£o.
  Demais formalismos utilizados internamente.


  T√©cnicas utilizadas internamente.


  As etapas s√£o autom√°ticas ou h√° interven√ß√£o manual?
3.13 Avalia√ß√£o da Qualidade dos Estudos                                     34



                   Tabela 7: Caracteriza√ß√£o do apoio ferramental.
                                    [Fonte: elabora√ß√£o pr√≥pria]
  Caracteriza√ß√£o do apoio ferramental (se aplic√°vel)
  Existe apoio ferramental?


  Faz uso de que tipo de solver (SAT, SMT, outros)?


  A ferramenta √© paga ou gratuita?


  Se gratuita, onde baixar/requisitar?


  Tem uso pr√°tico por parte de empresas? Quais?




                          Tabela 8: Caracteriza√ß√£o da avalia√ß√£o.
                                    [Fonte: elabora√ß√£o pr√≥pria]
  Caracteriza√ß√£o da avalia√ß√£o da contribui√ß√£o.
  A avalia√ß√£o seguiu um planejamento bem estruturado?


  Os instrumentos utilizados na avalia√ß√£o est√£o dispon√≠veis publicamente.


  Se sim, onde baixa-los?


  Detalhes da aplica√ß√£o considerada:
      Dom√≠nio (ex: avia√ß√£o, automobilismo, etc.).


      Tamanho (LOC, quantidade de vari√°veis, restri√ß√µes, etc.).


  Resumo dos resultados
      Congura√ß√£o do computador (se aplic√°vel).


      Detalhes do projeto experimental (se aplic√°vel)


  An√°lise de escalabilidade para problemas reais?


  Trabalhos futuros propostos
3.13 Avalia√ß√£o da Qualidade dos Estudos                                                 35


   ‚Ä¢   Investigar se as diferen√ßas de qualidade fornecem uma explica√ß√£o para as diferen√ßas

       dos resultados;


   ‚Ä¢   Meio de pondera√ß√£o da import√¢ncia dos estudos individuais, quando os resultados

       est√£o sendo sintetizados;


   ‚Ä¢   Orientar a interpreta√ß√£o dos resultados e determinar a for√ßa das infer√™ncias;


   ‚Ä¢   Guia de recomenda√ß√£o para futuras pesquisas.




3.13.1 Crit√©rios de Avalia√ß√£o
   Para avaliar a qualidade dos estudos para esta pesquisa, s√£o levados em conta onze

crit√©rios baseados nos crit√©rios propostos pelo Critical Appraisal Skills Programme e nos

princ√≠pios de boas praticas para a realiza√ß√£o de estudos emp√≠ricos em engenharia de soft-

ware (DYB√Ö;   DINGS√òYR,    2008).


   De acordo com Dyb√• e Dings√∏yr (2008), estes onze crit√©rios abrangem tr√™s quest√µes

principais relativas √† qualidade, que precisam ser consideradas ao avaliar os estudos iden-

ticados:




   ‚Ä¢   Rigor: tem sido aplicada uma abordagem completa e apropriada aos m√©todos de

       investiga√ß√£o fundamentais no estudo?


   ‚Ä¢   Credibilidade: os resultados s√£o signicativos e bem apresentados?


   ‚Ä¢   Relev√¢ncia: qu√£o uteis os resultados s√£o para a ind√∫stria de software e a comunidade

       acad√™mica?




   Dentre os onze crit√©rios, tr√™s crit√©rios est√£o relacionados com a qualidade dos resul-

tados, objetivos e contexto do estudo. Assim, para cada estudo ser√° avaliado se:




  1. O estudo relatou uma pesquisa emp√≠rica ou foi apenas um relato de li√ß√µes aprendi-

       das baseadas na opini√£o de um especialista.


  2. As metas e objetivos foram claramente relatados (incluindo uma raz√£o do por qu√™

       o estudo foi realizado).


  3. Houve uma descri√ß√£o adequada do contexto em qual a pesquisa foi realizada.
3.13 Avalia√ß√£o da Qualidade dos Estudos                                                     36


       Cinco crit√©rios est√£o relacionados ao rigor dos m√©todos de pesquisa empregados para

estabelecer a validade das ferramentas de coleta de dados e dos m√©todos de an√°lise, e, por-

tanto a conabilidade dos resultados. Consequentemente para cada estudo ser√° avaliado

se:



      4. O projeto de pesquisa foi apropriado para alcan√ßar os objetivos da pesquisa.


      5. Houve uma descri√ß√£o adequada da amostra usada e dos m√©todos usados para iden-

        ticar e recrutar essa amostra.


      6. Algum grupo de controle foi usado para comparar os tratamentos.


      7. Foram descritos e utilizados m√©todos de coleta de dados apropriados.


      8. Houve uma descri√ß√£o adequada dos m√©todos utilizados para analisar os dados, e

        se foram utilizados m√©todos apropriados para garantir que a analise dos dados foi

        fundamentada nos dados.



       Al√©m disso, dois outros crit√©rios est√£o relacionados com a credibilidade dos m√©todos

utilizados pelo estudo, para assegurar que os resultados s√£o v√°lidos e signicativos. Em

rela√ß√£o a isso, ser√° vericado se:



      9. A rela√ß√£o entre o pesquisador e os participantes foi considerada com adequada.


 10. O estudo forneceu claramente resultados con√°veis e conclus√µes fundamentadas.



       O crit√©rio nal est√° relacionado com a relev√¢ncia do estudo para a ind√∫stria de software

em geral e a comunidade acad√™mica. Assim, ser√° vericado se:



 11. O estudo forneceu valor para a pesquisa ou pratica.



       Para a avalia√ß√£o da qualidade dos estudos √© utilizada a escala Likert-5, que permite

o pesquisador responder as quest√µes dos crit√©rios de qualidade com respostas gradativas.

O pesquisador pode usar os seguintes n√≠veis de concord√¢ncia ou discord√¢ncia: (concordo

totalmente, concordo parcialmente, neutro, discordo parcialmente e discordo totalmente).

Para a avalia√ß√£o, devem ser consideradas as seguintes observa√ß√µes:



      ‚Ä¢ Concordo totalmente (4):        deve ser concedido no caso em que o trabalho atenda

        totalmente aos crit√©rios da quest√£o;
3.14 Estrat√©gia de Extra√ß√£o Dos Dados                                                        37


   ‚Ä¢ Concordo parcialmente (3):              deve ser concedido no caso em que o trabalho atenda

     parcialmente aos crit√©rios da quest√£o;


   ‚Ä¢ Neutro (2):      deve ser concedido no caso em que o trabalho n√£o deixe claro se atende

     ou n√£o a quest√£o;


   ‚Ä¢ Discordo parcialmente(1):            dever ser concedido no caso em que o trabalho n√£o

     atenda aos crit√©rios contidos na quest√£o;


   ‚Ä¢ Discordo totalmente (0):            deve ser concedido no caso em que o trabalho n√£o

     atenda de forma alguma os crit√©rios de avalia√ß√£o, isto √©, n√£o existe nada no trabalho

     que atenda aos crit√©rios da quest√£o.




    Os estudos prim√°rios avaliados podem ent√£o se enquadrar em 5 n√≠veis de qualidade,

conforme classica√ß√£o de Beecham et al. (2007), a partir dos valores nais da avalia√ß√£o

de cada estudo, conforme mostra a Tabela 9




                               Tabela 9: N√≠veis de qualidade.
                                      [Fonte: elabora√ß√£o pr√≥pria]
                                     Faixa de Notas Avalia√ß√£o
                                         >86%           Excelente
                                       66% - 85%        Muito Boa
                                       46% - 65%           Boa
                                       26% - 45%          M√©dia
                                         <26%             Baixa




3.14 Estrat√©gia de Extra√ß√£o Dos Dados
    Para Kitchenham (2007), o objetivo desta etapa √© criar formas de extra√ß√£o dos dados

para registrar com precis√£o as informa√ß√µes obtidas a partir dos estudos prim√°rios. Esta

deve ser projetada para coletar as informa√ß√µes necess√°rias as quest√µes.          Um formul√°rio

eletr√¥nico √© sugerido por v√°rios trabalhos, pois segundo especialistas, o uso pode facilitar

a an√°lise posterior. Logo, para apoiar a extra√ß√£o e registro dos dados e posterior an√°lise,
                                         1
ser√° utilizada a ferramenta JabRef           , um gerenciador de referencias c√≥digo aberto que

permite a customiza√ß√£o e facilidades na importa√ß√£o/exporta√ß√£o e dados (KITCHENHAM,

2007) (TRAVASSOS, 2007).

  1 http://jabref.sourceforge.net/
3.15 S√≠ntese dos Dados Coletados                                                       38


3.15 S√≠ntese dos Dados Coletados
   Ap√≥s a coleta dos dados, as informa√ß√µes dever ser tabuladas de acordo com as quest√µes

de pesquisa, as tabelas devem ser estruturadas de forma a destacar as semelhan√ßas e

diferen√ßas entre os resultados do estudo (KITCHENHAM, 2007).


   De acordo com Kitchenham (2007), a s√≠ntese dos dados pode ser qualitativa e/ou

quantitativa, sendo que a primeira necessariamente seria tratada como uma meta an√°lise.

Para esta pesquisa ser√£o realizadas s√≠nteses qualitativas e quantitativas.




3.16 Documenta√ß√£o e Apresenta√ß√£o dos Resultados
   A fase nal de uma revis√£o sistem√°tica envolve a reda√ß√£o dos resultados de an√°lise e

divulga√ß√£o dos resultados aos potenciais interessados. Alguns estudos indicam alguns t√≥-

picos necess√°rios para a apresenta√ß√£o de uma revis√£o sistem√°tica: T√≠tulo ( de acordo com

as quest√µes de pesquisa); Autores; Resumo do trabalho (contexto, objetivos, m√©todo, re-

sultados e conclus√µes); Background (justicativa da necessidade da revis√£o); Quest√µes de

pesquisa; M√©todo de revis√£o (estrat√©gia de busca, sele√ß√£o dos estudos, avalia√ß√£o da quali-

dade, extra√ß√£o e s√≠ntese dos dados); Estudos inclu√≠dos e exclu√≠dos; Resultados; Discuss√£o,

e Conclus√µes (KITCHENHAM, 2007).


   A partir da s√≠ntese dos dados, s√£o sumarizadas evidencias existentes a m de prover

um melhor entendimento sobre os detalhes de como constraint solvers t√™m sido utilizados

para gerar dados de teste.
                                                                                        39




4       Resultados


    Neste cap√≠tulo s√£o apresentados os resultados do estudo e a an√°lise dos mesmos. Para

melhor compreens√£o dos resultados obtidos, os mesmos s√£o apresentados em duas se√ß√µes:



    ‚Ä¢ 4.1 An√°lise quantitativa do mapeamento sistem√°tico - apresenta dados gerais
      da revis√£o, como:   processo de sele√ß√£o com o n√∫mero nal de estudos prim√°rios,

      distribui√ß√£o ao longo dos anos, locais de publica√ß√£o, tipos de estudos e avalia√ß√£o da

      qualidade.


    ‚Ä¢ 4.2 An√°lise qualitativa das evidencias      - apresenta√ß√£o das evidencias identica-

      das pelo mapeamento sistem√°tico, com o intuito de responder a quest√£o de pesquisa.




4.1 An√°lise Quantitativa
    A revis√£o sistem√°tica foi executada de acordo com o que foi denido no protocolo que

se encontra no cap√≠tulo anterior. A partir da express√£o de busca e fontes denidas, as bus-

cas prim√°rias retornaram um total de 8.844 trabalhos, dos quais, 2.960 foram identicados

no IEEE, 1.775 na ACM, 2.414 no ScienceDirect, e 1.695 no SpringerLink.


    Devido a grande quantidade de trabalhos prim√°rios retornados pelo processo de busca

e o limite de tempo dispon√≠vel para a realiza√ß√£o desta pesquisa, foram considerados ape-

nas os trabalhos identicados na base da ACM, por ter sido a fonte que mais retornou

trabalhos entre os sete trabalhos j√° conhecidos e considerados relevantes.


    Tamb√©m em consequ√™ncia da indisponibilidade de tempo, n√£o foi poss√≠vel a realiza√ß√£o

de uma pesquisa em segundo n√≠vel utilizando o processo snow-balling, onde, para todos

os artigos selecionados, as suas refer√™ncias seriam analisadas para identicar trabalhos

relevantes n√£o capturados pela express√£o de busca.


    Atrav√©s do processo de sele√ß√£o e exclus√£o, o numero de trabalhos foi bastante reduzido.

A partir da primeira sele√ß√£o por t√≠tulo e palavra-chave, dos 1.775 trabalhos identicados
4.1 An√°lise Quantitativa                                                                  40


na ACM, apenas 95 foram identicados como estudos potencialmente relevantes para a

pesquisa.


    Com a leitura do resumo e conclus√£o dos estudos potencialmente relevantes, e utilizando-

se os crit√©rios de inclus√£o e exclus√£o, chegou-se a 42 estudos prim√°rios. Assim, 53 trabalhos

considerados potencialmente relevantes na primeira sele√ß√£o foram exclu√≠dos, e o principal

motivo para a exclus√£o foi que os estudos foram considerados irrelevantes de acordo com

a quest√£o de pesquisa.


    Como foi mencionado no processo de sele√ß√£o do Cap√≠tulo 3, s√≥ seriam lidos em torno

de vinte e cinco trabalhos, se mais de 30 trabalhos fossem selecionados, seria necess√°rio

um corte temporal que retornasse uma quantidade de trabalhos compat√≠vel com o tempo

dispon√≠vel.   Desse modo, como foram selecionados 42 estudos prim√°rios, foram selecio-

nados os trabalhos que foram publicados nos √∫ltimos 5 anos, ou seja, a partir de 2007.

Foram identicados, ent√£o, 24 trabalhos publicados nos √∫ltimos 5 anos.




       Figura 2: Distribui√ß√£o dos estudos prim√°rios ao longo dos anos


    A Figura 2 ilustra a distribui√ß√£o dos estudos prim√°rios ao longo dos anos. Pode-se

perceber que a utiliza√ß√£o de constraint solvers para gera√ß√£o de dados de teste tem sido

tema recorrente de pesquisas nos √∫ltimos 12 anos.


    A Figura 3 apresenta a distribui√ß√£o dos trabalhos por local de publica√ß√£o. Atrav√©s

dela podemos vericar que a grande maioria dos estudos prim√°rios ( 96% ) foi publicada

em anais de eventos (Confer√™ncias, Workshops e Simp√≥sios). Apenas 1 trabalho (4%) foi
4.1 An√°lise Quantitativa                                                              41




    Figura 3: Distribui√ß√£o dos estudos prim√°rios por local de publica√ß√£o


publicado em peri√≥dicos.


   A Tabela 10 apresenta a quantidade de estudos prim√°rios retornados por evento.

Pode-se perceber que o International Symposium on Software Testing and Analysis (IS-

STA) se destaca entre os demais eventos como sendo o evento onde ocorreram mais publi-

ca√ß√µes sobre a utiliza√ß√£o de constarint solvers na gera√ß√£o de dados de teste. Dos estudos

prim√°rios selecionados, 16,6% foram publicados nesse evento. Apenas um estudo prim√°rio

foi publicado em um peri√≥dico (Journal Information and Software Technology ).


   Dos 24 estudos prim√°rios avaliados, 88% se caracterizam como estudos experimentais

(estudos baseados em evidencias ou experimentos, Empirical Studies, em ingl√™s), 8% como

te√≥ricos (estudos conceituais baseados em um entendimento de uma √°rea, referenciando

outros trabalhos relacionados), e apenas 4%, ou seja, apenas 1 estudo prim√°rio foi carac-

terizado com revis√£o sistem√°tica da literatura. Nenhum estudo prim√°rio foi caracterizado

como relato de experi√™ncia industrial.


   A Figura 4 mostra a distribui√ß√£o dos trabalhos por tipo de estudo. Dentro os estudos

classicados como experimento, todos foram classicados como experimento controlado

de acordo com a classica√ß√£o de Easterbrook et al. (2007).


   A Figura 5 apresenta a distribui√ß√£o dos estudos por local dos autores, desse modo

ser√° poss√≠vel identicar quais pa√≠ses e ou centros de pesquisa s√£o mais atuantes na √°rea

de pesquisa. Ainda nesta Figura, pode ser observado que os Estados Unidos aparecem

como principal pa√≠s, com 10 trabalhos ( 42% ) entre os trabalhos selecionados. Dentre

os 10 trabalhos publicados por autores americanos, 5 trabalhos ( 50% ) foram publicados

pela Universidade do Texas. A Fran√ßa tamb√©m se destaca, com 5 trabalhos ( 2% ) entre
4.1 An√°lise Quantitativa                                                              42




            Tabela 10: Quantidade de estudos prim√°rios por evento.
                                    [Fonte: elabora√ß√£o pr√≥pria]
       Evento                                                       Quantidade   de
                                                                    Trabalhos
       International Symposium on Software Testing and Analysis     4
       Foundations of Software Engineering                          3
       International Conference on Software Engineering             3
       Automated Software Engineering                               2
       European Conference on Object-Oriented Programming           2
       Genetic and Evolutionary Computation Conference              2
       ACM SIGPLAN workshop on Partial evaluation and program ma-   1
       nipulation
       ACM Symposium On Applied Computing                           1
       Design, Automation, and Test in Europe                       1
       GLSVLSI Great Lakes Symposium on VLSI                        1
       Library-Centric Software Design                              1
       NASA Formal Methods Symposium                                1
       Principles and Practice of Declarative Programming           1




      Figura 4: Distribui√ß√£o dos estudos prim√°rios por tipo de estudo.
4.1 An√°lise Quantitativa                                                              43




     Figura 5: Distribui√ß√£o dos estudos prim√°rios por local dos autores.


os selecionados.


   Os resultados da avalia√ß√£o de qualidade s√£o apresentados pela Tabela 11 e na Figura 6.

O valor m√°ximo que um estudo pode alcan√ßar, com base nos crit√©rios de avalia√ß√£o descritos

no capitulo 3, seria de 44 pontos. Com base na nota alcan√ßada pelo estudo, o mesmo ser√°

analisado conforme a Tabela 9, baseada em Beecham et al. (2007), indicando a classica√ß√£o

do estudo: Excelente, Muito Boa, Boa, M√©dia e Baixa.


   Como pode ser observado, apenas 1 estudo encontra-se na faixa Baixa e 1 estudo na

M√©dia. Enquanto 5 estudos ( 21% ) est√£o na faixa boa, 12 estudos ( 50% ) est√£o na faixa

muito boa, e 5 estudos ( 21% ) est√£o na faixa Excelente. Portanto a maioria dos trabalhos

analisados apresentam qualidade acima da m√©dia de acordo com os crit√©rios utilizados.




                   Tabela 11: Qualidade dos estudos prim√°rios.
                                   [Fonte: elabora√ß√£o pr√≥pria]
                                             Classica√ß√£o do estudo
                           Baixa    M√©dia    Boa    Muito Boa    Excelente   Total
              Quantidade   1        1        5      12           5           24


   √â importante destacar que quanto melhor avaliado for um trabalho, maior deve ser

a import√¢ncia dada √†s evid√™ncias fornecidas por ele. A qualidade atribu√≠da ao estudo √©

levada em considera√ß√£o na an√°lise das evid√™ncias.
4.2 An√°lise Qualitativa das Evid√™ncias                                                   44




               Figura 6: Distribui√ß√£o por qualidade dos estudos.


4.2 An√°lise Qualitativa das Evid√™ncias
    Nessa se√ß√£o, s√£o apresentadas as evid√™ncias que ajudam a responder a quest√£o de

pesquisa deste estudo. Todas as evid√™ncias s√£o referenciadas pelos 24 estudos prim√°rios,

e os n√∫meros de identica√ß√£o s√£o precedidos por EP (Estudo Prim√°rio) que se encontram

dispon√≠veis no ap√™ndice X.




4.2.1 Principais T√©cnicas Utilizadas
    Na tentativa de responder a quest√£o de pesquisa, nesta se√ß√£o ser√£o apresentadas as

principais t√©cnicas mais utilizadas pelas abordagens propostas pelos estudos prim√°rios.


    A t√©cnica mais citada pelos trabalhos foi a t√©cnica de execu√ß√£o simb√≥lica (symbolic

execution em ingl√™s), sendo citada por 7 dos 21 trabalhos classicados como experimento.

A principal da symbolic execution √© utilizar valores simb√≥licos como entrada do programa,

ao inv√©s de valores reais, e utilizar express√µes simb√≥licas para representar as vari√°veis do

programa. Como resultado, os valores de sa√≠da computados pelo programa s√£o expres-

sos como uma fun√ß√£o dos valores de entrada simb√≥licos (LAKHOTIA;       HARMAN; MCMINN,
2008).


    Algumas limita√ß√µes da symbolic execution foram identicadas pelos estudos prim√°rios.

As principais limita√ß√µes encontradas foram: o problema da explos√£o de caminho (The
4.2 An√°lise Qualitativa das Evid√™ncias                                                 45


Path Explosion Problem ) e a capacidade limitada de raciocinar sobre determinadas

constru√ß√µes do c√≥digo, como objetos do sistema, chamadas a fun√ß√µes externas, etc.




   ‚Ä¢   EP_09 - Symbolic execution suers from scalability issues since the number of

       symbolic paths that need to be explored is very large (or even innite)...


   ‚Ä¢   EP_12 - while in hardware we can perform symbolic simulation easily, in software

       a symbolic simulation will miss some of the aspects of a program.



    Para compensar essas limita√ß√µes, alguns dos trabalhos lidos zeram uso da t√©cnica

concolic testing (LAKHOTIA;    HARMAN; MCMINN,      2008). Concolic testing √© uma t√©cnica

que combina a execu√ß√£o concreta de um programa com a execu√ß√£o simb√≥lica do mesmo.




   ‚Ä¢   EP_16 - One of the principle strenghts of concolic testing is the way in which

       concrete values are used to overcome many of the problems associated with symbolic

       execution.


   ‚Ä¢   EP_21 - Simultaneously, the concrete execution helps to retain precision in the

       symbolic computations by allowing dynamics values to be used in the symbolic exe-

       cutor.



    O principal benecio das abordagens que utilizaram as t√©cnicas citadas anteriormente,

juntamente com t√©cnicas de constraint solving, foi alcan√ßar o crit√©rio de cobertura utili-

zando um numero m√≠nimo de casos de teste. Crit√©rios de cobertura s√£o heur√≠sticas que

tentam estimar o qu√£o bem o programa √© exercitado por um conjunto de testes. Exemplos

de crit√©rios de cobertura s√£o: statement coverage, onde requer que cada linha do c√≥digo

seja executada; path coverage, onde requer que todos os caminhos poss√≠veis de todas as

fun√ß√µes sejam executados, etc.




   ‚Ä¢   EP_19 - The full branch and code coverage is not a surprese since symbolic exe-

       cution generates tests for all reachable branches and all the branches in the event

       handlers...



4.2.2 Escalabilidade para Problemas Reais
    Escalabilidade √© uma caracter√≠stica desej√°vel em todo o sistema, em uma rede ou em

um processo, que indica sua habilidade de manipular uma por√ß√£o crescente de trabalho
4.2 An√°lise Qualitativa das Evid√™ncias                                                      46


de forma uniforme, ou estar preparado para crescer (BONDI, 2000).             Nesta se√ß√£o ser√°

apresentada uma an√°lise de escalabilidade para problemas reais sobre os estudos prim√°rios

selecionados.


    Dentre os 21 estudos prim√°rios classicados como experimento, 5 (EP_01, EP_02,

EP_04, EP_18, EP_20) apresentaram resultados para sistemas do mundo real. A ava-

lia√ß√£o feita pelo EP_01 foi realizada utilizando 5 modelos do mundo real para testes

de sistema de controle de fun√ß√µes automotivas.          Os modelos utilizados s√£o propriedade

intelectual da Daimler (http://www.daimler.com/).

                                                                       1
    O EP_02 avaliou sua abordagem utilizando 14 projetos Ruby              do mundo real.


    O EP_04 avaliou sua abordagem realizando testes em uma aplica√ß√£o industrial de

tempo real utilizada por um fabricante de ve√≠culos e autom√≥veis. A aplica√ß√£o fornecida

pela Geensoft (http://www.geensoft.com/) √© um controlador que controla v√°rias fun√ß√µes

relacionadas com as luzes de um carro. Uma completa descri√ß√£o , junto com seu c√≥digo
                        2
est√° dispon√≠vel na web .


    A aplica√ß√£o do mundo real utilizada pelo EP_18 foi um gerador de treino utilizado

pelo Sports Clubs Apolon. A aplica√ß√£o possui 649 linhas de c√≥digo e recebe como entrada

caracter√≠sticas pessoais do usu√°rio, como altura, peso, idade, metabolismo e n√≠vel de

experi√™ncia, e com base nesses dados de entrada, a aplica√ß√£o gera um programa de treino

adequado.


    O EP_20 n√£o utiliza nenhuma aplica√ß√£o do mundo real para avaliar sua abordagem,

mas o autor arma que a ferramenta est√° sendo avaliada em aplica√ß√µes reais e os resultados

preliminares sugerem que a abordagem √© escal√°vel.




   ‚Ä¢   EP_21 - The tool is under evaluation on realistic applications and the preliminar

       results suggest that the approach is scalable.



    Estes resultados mostram que apesar do grande n√∫mero de experimentos realizados

na √°rea (21 dos 24 estudos prim√°rios selecionados foram classicados como experimento),

apenas 5 (23%) deles apresentaram resultados que sugerem que suas abordagens s√£o

escal√°veis para problemas do mundo real.

  1 http://www.ruby-lang.org/pt/
  2 http://users.polytech.unice.fr/~rueher/Benchs/FM/
4.2 An√°lise Qualitativa das Evid√™ncias                                                   47


4.2.3 Benef√≠cios Da Utiliza√ß√£o de Constraint                     Solvers
    Dentre os principais benef√≠cios apontados pelos estudos prim√°rios analisados, est√£o

a maior velocidade das abordagens que utilizam t√©cnicas constraint solving em rela√ß√£o a

outras t√©cnicas, uma vez que os solvers podem eliminar rapidamente grandes amostras

do espa√ßo de busca.



   ‚Ä¢   EP_24 - in practice current state-of-the-art SAT solvers can often determine the

       satisability of boolean formulas with tens of thousands of variables in a reasonable

       amount of time



    Abordagens que utilizam t√©cnicas de constraint solving tamb√©m demonstraram ge-

rar casos de teste com melhor qualidade que outras abordagens. Os estudos analisados

mostraram que essas abordagens encontraram melhores n√≠veis de cobertura do que outras

abordagens.



   ‚Ä¢   EP_02 - Experiments on 14 cases taken from real-world Ruby projects show that

       RuTeG achieves full or higher statement coverage on more cases and does so faster

       than randomly generated test cases. ... RuTeG could achieve full code coverage in

       11 of 14 cases, while the random test case generator only succeeded on 4 occasions.

       In 10 of 14 cases RuTeG found test cases that showed a signicantly higher code

       coverage than random generation.


   ‚Ä¢   EP_19 - Experimental results using our prototype show that it provides signicantly

       better performance compared to random input generation, in terms of line and branch

       coverage.



4.2.4 Limita√ß√µes Da Utiliza√ß√£o de                 Constraint Solvers
    Algumas limita√ß√µes foram identicadas durante a leitura dos estudos prim√°rios.        A

grande maioria dessas limita√ß√µes ocorrem nas abordagens que esperam como entrada o

c√≥digo fonte do SUT (System Under Test ).


    Essas limita√ß√µes n√£o foram encontradas em abordagens que esperam de entrada mo-

delos do SUT especicados em linguagens de modelagem (Modeling Language, em ingl√™s),

j√° que a maioria dessas limita√ß√µes s√£o intr√≠nsecas a linguagens de programa√ß√£o. As lin-

guagens de programa√ß√£o mais utilizadas nas abordagens foram as linguagens Java e C. A

Figura 7 apresenta a distribui√ß√£o dos experimentos por linguagem.
4.2 An√°lise Qualitativa das Evid√™ncias                                                   48




             Figura 7: Distribui√ß√£o por linguagem de programa√ß√£o.


    Muitas dessas limita√ß√µes podem ser observadas nas transcri√ß√µes abaixo:



   ‚Ä¢   EP_02 -This approach was tested on a small number of test programs, which showed

       its applicability. However, this approach is limited to simple dynamic data structu-

       res, such as binary trees.


   ‚Ä¢   EP_04 - ... input data are restricted to Booleans, integers and arrays of Booleans

       and integers. Pointers are not handled and only runtime error-free programs are

       treated (i.e. errors like dividing by zero or exceptions are not handled).


   ‚Ä¢   EP_05 - Additional challenges are associated with the need to adequately model

       class hierarchies and inheritance, dynamic arrays, data types including arbitrary-

       precision integers, strings and pointers.


   ‚Ä¢   EP_06 - Code involving linked data structures with rich invariants (such as circular

       lists, red-black trees, AVL trees or binomial heaps) is hard to analyze using these

       techniques.


   ‚Ä¢   EP_16 - ..the limitations of many constraint solvers, especially in the presence of

       oating point arithmetic..


   ‚Ä¢   EP_21 - ...such test input generation techniques run into certain problems when de-

       aling with database-driven programs. Technical problems remain to handle properly

       function pointers (second-order programming) and recursive calls.


   ‚Ä¢   EP_24 - Our current implementation does not support checking the exceptional

       behavior of programs or generating inputs with multi-dimensional-array-based com-
4.2 An√°lise Qualitativa das Evid√™ncias                                                 49


      ponents. ...inheritance is fundamental in object-oriented programming. So far, we

      have not addressed how to utilize class hierarchies in test generation



    Essas limita√ß√µes podem ser as respons√°veis pelo baixo n√∫mero de experimentos (dentre

os estudos prim√°rios selecionados) escal√°veis para problemas reais, j√° que muitas dessas

situa√ß√µes como utiliza√ß√£o de ponteiros, heran√ßa, chamadas a banco de dados, chamadas

recursivas, etc., s√£o comumente encontradas em sistemas reais.




4.2.5 Tipos de Solvers




               Figura 8: Distribui√ß√£o por tipo de solver utilizado.


    A Figura 8 apresenta a distribui√ß√£o do tipo de solver utilizado nos estudos que s√£o

experimentos. Entre os 21 trabalhos classicados como experimento, 8 deles n√£o deixam

claro que tipo de solver foi utilizado no experimento.    Entre os 13 trabalhos restantes,

11 estudos ( 85% ) utilizaram SAT-solvers, 2 estudos utilizaram SMT-solvers. Portanto,

atrav√©s da Figura 8 percebe-se a predomin√¢ncia dos SAT-solvers entre os solvers mais

utilizados.
                                                                                        50




5        Considera√ß√µes Finais


     Este cap√≠tulo apresenta as considera√ß√µes acera do uso de Constraint Solvers na gera√ß√£o

de dados de teste.




5.1 Conclus√µes
     Os resultados desta pesquisa mostram que a utiliza√ß√£o de constraint solvers na gera√ß√£o

de dados de teste tem sido um tema de pesquisa recorrente, com 24 trabalhos publicados

nesta √°rea nos √∫ltimos 5 anos.


     Apesar de 88% dos estudos prim√°rios analisados nessa pesquisa serem classicados

como experimento, apenas 19% deles apresentaram ser escal√°veis para problemas reais.

Isso mostra que apesar do grande n√∫mero de experimentos realizados na √°rea, apenas

alguns encontram-se maduros o suciente para serem adotadas no mundo real.


     A partir dos resultados obtidos, foi observado que apesar de suas limita√ß√µes, a utili-

za√ß√£o de constraint solvers na gera√ß√£o de dados de teste √© uma abordagem promissora,

j√° que apresentou melhores resultados em rela√ß√£o √† desempenho e qualidade dos testes,

atingindo melhores n√≠veis de cobertura do que outras abordagens.


     Al√©m de sumarizar evid√™ncias existentes a m de prover um melhor entendimento

sobre os detalhes de como dados de teste s√£o gerados automaticamente a partir da utili-

za√ß√£o de constraint solvers, este trabalho buscou contribuir com a Engenharia de Software

baseada em evid√™ncias (KITCHENHAM, 2007). O trabalho apresentou um processo deta-

lhado para a realiza√ß√£o de um mapeamento sistem√°tico da literatura, processo que pode

ser seguido por outros trabalhos.


     Para servir de apoio para trabalhos futuros, s√£o listadas abaixo algumas li√ß√µes apren-

didas durante este trabalho:




    1. Os termos de busca devem ser denidos antes de iniciar o protocolo, j√° que os
5.2 Limita√ß√µes e Trabalhos Futuros                                                        51


       mesmos guiar√£o o trabalho;


  2. Os termos de busca precisam ser adequados de acordo com as particularidades de

       cada base da dados que ser√° utilizada na pesquisa. Na maioria das bases de dados

       √© necess√°ria uma licen√ßa especial para vizualiza√ß√£o dos trabalhos;


  3. As buscas retornam muitos trabalhos irrelevantes para o escopo da pesquisa.          Os

       crit√©rios de inclus√£o e exclus√£o devem garantir a imparcialidade na sele√ß√£o;


  4. √â importante evitar que o processo se torne muito complexo e assim engessar o

       trabalho. Al√©m disso, o processo pode n√£o garantir que trabalhos dentro do escopo

       da pesquisa sejam selecionados;


  5. O protocolo de pesquisa precisa ser claro e objetivo, n√£o deixando margem para

       ambiguidade. Depois da deni√ß√£o dos principais pontos, o mapeamento pode ser

       iniciado, e o protocolo evoluir paralelamente;


  6. A deni√ß√£o dos crit√©rios de qualidade √© um dos maiores desaos na deni√ß√£o do

       protocolo e √© deixado de lado em muitos trabalhos. Essa quest√£o merece um cuidado

       especial, j√° que a avalia√ß√£o pode dar uma maior relev√¢ncia a estudos de maior

       qualidade;




5.2 Limita√ß√µes e Trabalhos Futuros
   Apesar da preocupa√ß√£o em utilizar um m√©todo rigoroso, esta pesquisa apresentou

algumas limita√ß√µes:




   ‚Ä¢   Devido a restri√ß√£o de tempo, a pesquisa apenas considerou o portal ACM como base

       de pesquisa, n√£o levando em considera√ß√£o bases de dados sugeridas por Kitchenham

       (2007), como SpringerLink, IEEE e Science Direct.


   ‚Ä¢   Tamb√©m devido a restri√ß√£o de tempo e a grande quantidade de estudos prim√°rios

       retornados pelo processo de sele√ß√£o, foi necess√°rio a realiza√ß√£o de um corte temporal,

       selecionando apenas trabalhos publicados nos √∫ltimos 5 anos.


   ‚Ä¢   Apenas o processo de busca foi revisado por mais de um pesquisador, como √© sugerido

       pelos guias atuais. A maior parte da extra√ß√£o dos dados foi realizada apenas pela

       autor deste trabalho.
5.2 Limita√ß√µes e Trabalhos Futuros                                                       52


   As limita√ß√µes encontradas oferecem caminhos claros para novas pesquisas, como:




   ‚Ä¢   Este estudo pode ser renado, expandido para outras bases de dados sugeridas

       por Kitchenham (2007), aumentando o n√∫mero de estudos prim√°rios analisados no

       mapeamento sistem√°tico.


   ‚Ä¢   O mapeamento sistem√°tico pode ser extendido, levando em considera√ß√£o tamb√©m

       trabalhos publicados a mais de 5 anos, aumentando tamb√©m o n√∫mero de estudos

       prim√°rios analisados.


   ‚Ä¢   Para conferir uma maior conabilidade √† pesquisa, pode ser realizada uma pes-

       quisa em segundo n√≠vel utilizando o processo snow-balling (GREENHALGH;          PEA-
       COCK,    2005), ou seja, para todos os trabalhos selecionados, analisar suas refer√™n-

       cias, na tentativa de identicar trabalhos relevantes n√£o capturados pelos termos de

       busca.


   ‚Ä¢   Outros pesquisadores podem participar do processo de extra√ß√£o e s√≠ntese dos dados,

       como sugere Kitchenham (2007), garantindo maior conabilidade aos resultados

       obtidos pelo mapeamento sistem√°tico.
                                                                                                                        53




                                              Refer√™ncias

BEECHAM,              S.   et   al.    Motivation      in     software      engineering:          A   systematic    litera-
     ture review. Inf. Softw. Technol., Butterworth-Heinemann, Newton, MA, USA,
     v.    50,        n.    9-10,      p.   860878,     ago.       2007.      ISSN    0950-5849.         Dispon√≠vel   em:
     <http://dx.doi.org/10.1016/j.infsof.2007.09.004>.

BONDI, A. B. Characteristics of scalability and their impact on performance. In: Proce-
     edings of the 2nd international workshop on Software and performance. New York,
     NY, USA: ACM, 2000. (WOSP '00), p. 195203. ISBN 1-58113-195-X. Dispon√≠vel
     em:   <http://doi.acm.org/10.1145/350391.350432>.

COHEN, J. A coecient of agreement for nominal scales. Educational and Psycho-
     logical Measurement,                   Durham,      v.   20,    n.   1,     p.   3746,   1960.      Dispon√≠vel   em:
     <http://epm.sagepub.com/cgi/doi/10.1177/001316446002000104>.

DYB√Ö, T.; DINGS√òYR, T. Empirical studies of agile software development: A systematic
     review. Inf. Softw. Technol., Butterworth-Heinemann, Newton, MA, USA, v. 50,
     n. 9-10, p. 833859, ago. 2008. ISSN 0950-5849.


EASTERBROOK, S. et al. Selecting Empirical Methods for Software Engineering Rese-
     arch. 2007.

FRUHWIRTH, T.; ABDENNADHER, S. Principles of Constraint Systems and Cons-
     traint Solvers. 2005.

GREENHALGH, T.; PEACOCK, R. Eectiveness and eciency of search methods in
     systematic reviews of complex evidence: audit of primary sources. BMJ (Clinical re-
     search ed.), v. 331, n. 7524, p. 10641065, Nov 5 2005. LR: 20060518; PUBM: Print-
     Electronic; DEP: 20051017; JID: 8900488; CIN: Evid Based Dent. 2006;7(1):19.
     PMID: 16557254; RF: 4; 2005/10/17 [aheadofprint]; ppublish.


KITCHENHAM, B. Procedures for performing systematic reviews. Keele UK Keele Uni-
     versity, Citeseer, v. 33, n. TR/SE-0401, p. 28, 2004.

KITCHENHAM, B. Guidelines for performing systematic literature reviews in software
     engineering. Engineering, ACM Press, v. 2, n. EBSE 2007-001, p. 1051, 2007.


LAKHOTIA,             K.;       HARMAN,          M.;     MCMINN,            P.   Handling         dynamic    data   struc-
     tures       in    search         based   testing.      In:     Proceedings        of   the    10th    annual   confe-
     rence on Genetic and evolutionary computation. New York, NY, USA: ACM,
     2008.       (GECCO             '08),   p.   17591766.       ISBN       978-1-60558-130-9.           Dispon√≠vel   em:
     <http://doi.acm.org/10.1145/1389095.1389435>.
Refer√™ncias                                                                        54


LANDIS, J. R.; KOCH, G. G. The measurement of observer agreement for categorical
     data. Biometrics, International Biometric Society, v. 33, n. 1, p. 159174, 1977.
     Dispon√≠vel em:   <http://www.ncbi.nlm.nih.gov/pubmed/843571>.

MYERS, G. J. Art of Software Testing. New York, NY, USA: John Wiley & Sons, Inc.,
     1979. ISBN 0471043281.


ROSSI, F.; BEEK, P. v.; WALSH, T. Handbook of Constraint Programming (Foundations
     of Articial Intelligence). New York, NY, USA: Elsevier Science Inc., 2006. ISBN
     0444527265.


RUSSELL, S. J. et al. Articial intelligence: a modern approach. Upper Saddle River,
     NJ, USA: Prentice-Hall, Inc., 1996. ISBN 0-13-103805-2.


TRAVASSOS, G. Revis√µes sistem√°ticas aplicadas a engenharia de software. XXI SBES -
     Brazilian Symposium on Software Engeneering, 2007., v. 1, 2007.
                                                                                55




AP√äNDICE A -- Trabalhos Inclu√≠dos




    Id    Fonte T√≠tulo                             1o Autor              Ano
  EP_01   ACM   Automated     test   case   ge-    Jan Peleska           2011
                neration with SMT-solving
                and abstract interpretation

  EP_02   ACM   Search-based software tes-         Stefan Mairhofer      2011
                ting and test data genera-
                tion for a dynamic program-
                ming language

  EP_03   ACM   A comparative evaluation of        Hazlifah Mohd Rusli   2011
                state-of-the-art web service
                composition testing approa-
                ches

  EP_04   ACM   A dynamic constraint-based         Thierry Gueguen       2011
                BMC strategy for genera-
                ting counterexamples

  EP_05   ACM   The       challenges          of   Vitaly Lagoon         2011
                constraint-based            test
                generation

  EP_06   ACM    Analysis of invariants for        Juan P. Galeotti      2010
                ecient   bounded     verica-
                tion

  EP_07   ACM   Abstract path testing with         Nicky Williams        2010
                PathCrawler

  EP_08   ACM   AIana: an AI planning sys-         Stefan J. Galler      2010
                tem for test data generation

  EP_09   ACM   Parallel symbolic execution        Matt Staats           2010
                for structural test genera-
                tion
Ap√™ndice A -- Trabalhos Inclu√≠dos                                                         56




       EP_10     ACM     PET: a partial evaluation-           German Puebla        2010
                         based test case generation
                         tool for Java bytecode

       EP_11     ACM     Representation dependence            G. Ramalingam        2010
                         testing using program inver-
                         sion

       EP_12     ACM     A MILP-based approach to             Jos√© C. Monteiro     2009
                         path sensitization of embed-
                         ded software

       EP_13     ACM     MYGEN:        automata-based         Zeljko Zilic         2009
                         on-line    test    generator   for
                         assertion-based verication

       EP_14     ACM     Using formal specications           Jonathan P. Bowen    2009
                         to support testing

       EP_15     ACM     Ecient solving of structu-          Bassem Elkarablieh   2008
                         ral constraints

       EP_16     ACM     Handling      dynamic       data     Phil McMinn          2008
                         structures in search based
                         testing

       EP_17     ACM     Query-Aware         Test   Gene-     Sarfraz Khurshid     2008
                         ration     Using   a   Relational
                         Constraint Solver

       EP_18     ACM     Test generation for graphi-          Dewayne E Perry      2008
                         cal user interfaces based on
                         symbolic execution

       EP_19     ACM     A   specication-based         ap-   Don Batory           2007
                         proach to testing software
                         product lines
Ap√™ndice A -- Trabalhos Inclu√≠dos                                                           57




       EP_20     ACM     Automatic         generation     of   Ioannis Parissis      2007
                         test data generators for syn-
                         chronous programs: Lutess
                         V2

       EP_21     ACM     Dynamic test input genera-            Ioannis Parissis      2007
                         tion for database applicati-
                         ons

       EP_22     ACM     Goal-oriented test data ge-           Arnaud Gotlieb        2007
                         neration    for    pointer     pro-
                         grams

       EP_23     ACM     Scalable     automatic         test   Ranjith Subramanian   2007
                         data       generation        from
                         modeling diagrams

       EP_24     ACM     Whispec: white-box testing            Danhua Shao           2007
                         of libraries using declarative
                         specications
                                                                              58




AP√äNDICE B -- Trabalhos Relevantes




T√≠tulo                                                  1o Autor            Ano
A clp framework for computing structural test data      Arnaud Gotlieb      2000

A Dynamic Constraint-Based BMC Strategy For Gene-       H√©l√®ne Collavizza   2011
rating Counterexamples

A Real-World Benchmark Model for Testing Concurrent     Jan Peleska         2011
Real-Time Systems in the Automotive Domain

Automated Test Case Generation with SMT-Solving         Jan Peleska         2011
and Abstract Interpretation

Automatic test data generation using constraint logic   Christophe Meudec   2001
programming and symbolic execution

Automatic Test Data Generation using Constraint Sol-    Arnaud Gotlieb      1998
ving Techniques

Test Data Generation of Bytecode by CLP Partial Eva-    Elvira Albert       2009
luation




  ...
