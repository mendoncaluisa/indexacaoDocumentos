Uma Visao Geral da Arquitetura Ëœ Cell
Wellington Mariusso (010086)
Instituto de ComputacÂ¸ Ëœao
UNICAMP
wellington.mariusso@ic.unicamp.br
RESUMO
A arquitetura Cell foi desenvolvida a partir de uma proposta
das empresas Sony e Toshiba feita `a IBM para a criaÂ¸cËœao de
uma tecnologia que permitisse alto desempenho de processamento sem o Ë†onus do alto consumo de energia e preÂ¸cos
elevados. O resultado disso foi o desenvolvimento conjunto
do Cell, ou CBEA (Cell Broadband Engine Architecture),
uma arquitetura multicore heterogË†enea, otimizada para demandas como entretenimento, criptografia e computaÂ¸cËœao cientÂ´Ä±fica.
Este texto tem por objetivo apresentar as principais caracterÂ´Ä±sticas da arquitetura, proporcionando uma visËœao geral
dos pontos em que ela difere das arquiteturas convencionais.
Palavras Chave
arquitetura de computadores, Cell, multicore
1. INTRODUCÂ¸ AOËœ
A arquitetura Cell, conhecida formalmente como CBEA (Cell
Broadband Engine Architecture) [2], foi desenvolvida em conjunto pela IBM, Sony e Toshiba com o objetivo inicial de
usar chips deste tipo como a base para o novo console de entretenimento da Sony, o Playstation 3 [4]. AplicaÂ¸cËœoes deste
tipo demandam alto poder de processamento, mas nËœao podem ter custo elevado, o que diminuiria muito o possÂ´Ä±vel
mercado consumidor.
Para poder suprir estas duas necessidades, associada `a necessidade de evitar consumo de energia muito elevado, a alternativa foi criar uma arquitetura multicore heterogË†enea [1].
O fato de o chip ser multicore, permite que um alto desempenho seja alcanÂ¸cado atravÂ´es do uso de paralelismo, sem a necessidade de custear vÂ´arias vezes o encapsulamento do chip
â€“ o que teria de ser feito no caso de se usar uma arquitetura
paralela usando processadores completamente independentes. Um chip Cell tÂ´Ä±pico, como os que serËœao usados pela
Sony em seu console, possui nove processadores capazes de
atuar em paralelo, o que permite um bom desempenho.
Para diminuir as necessidades de consumo de energia e tambÂ´em
de custo, optou-se por uma arquitetura paralela, porÂ´em contendo processadores com caracterÂ´Ä±sticas diferentes para realizar tarefas diferenciadas. A arquitetura define que todo
chip Cell deve ter dois tipos de processadores diferentes: os
PPEs (PowerPC Processor Element), que Â´e um processador
de propÂ´osito geral e os SPUs (Synergistic Processor Unit),
que sËœao processadores mais especializados, mas nËœao define
exatamente quantos processadores de cada tipo devem estar
presentes â€“ exige apenas que pelo menos um de cada tipo
esteja no chip [2] . Os SPUs tambÂ´em sËœao chamados de SPEs
(SPU Element). Em um chip tÂ´Ä±pico, hÂ´a apenas um PPE e
oito SPEs. Na verdade, nËœao hÂ´a a necessidade de que todos
os componentes estejam fisicamente no mesmo chip, mas em
geral essa Â´e uma caracterÂ´Ä±sticas importante para a garantia
de baixo custo e de performance.
O PPE Â´e um processador PowerPC de 64 bits, de propÂ´osito
geral. Isso garante que um Cell seja capaz de executar
aplicaÂ¸cËœoes genÂ´ericas, sem compilaÂ¸cËœao especial, desde que tenham sido desenvolvidas para PowerPC.
O SPU Â´e um processador mais especializado, menor, com um
conjunto de instruÂ¸cËœoes diferente do conjunto de instruÂ¸cËœoes
do PowerPC. Este processador permite instruÂ¸cËœoes do tipo
SIMD (Single Instruction, Multiple Data) e opera com valores de atÂ´e 128 bits. Este processadores tË†em por objetivo
trabalhar com aplicaÂ¸cËœoes que dependam fortemente de manipulaÂ¸cËœao numÂ´erica, como criptografia, computaÂ¸cËœao cientÂ´Ä±fica
e aplicaÂ¸cËœoes de mÂ´Ä±dia (Â´audio, vÂ´Ä±deo, etc.).
Dessa forma, os SPUs atuam como co-processadores para
os PPEs, que distribuem as tarefas computacionalmente pesadas. Esta decisËœao permite um melhor aproveitamento da
Â´area ocupada pelo chip, dado que os SPUs sËœao menores e
mais simples.
AlÂ´em disso, a arquitetura define a existË†encia de um mecanismo rÂ´apido de acesso `a memÂ´oria e uma interface rÂ´apida
para a realizaÂ¸cËœao de entrada e saÂ´Ä±da de dados.
Interconectando os componentes do Cell, hÂ´a um barramento
chamado EIB (Element Interconnect BUS), que transmite
atÂ´e 96 bytes por ciclo.
EIB
PXU L1
L2 MIC BIC
SXU
LS
SPE
SXU
LS
SPE
SXU
LS
SPE
SXU
LS
SPE
SXU
LS
SPE
SXU
LS
SPE
SXU
LS
SPE
SXU
LS
SPE
PPE
Memoria
Principal
Canais
de I/O
Figura 1: VisËœao Geral do Cell
As caracterÂ´Ä±sticas de cada um destes componentes serËœao discutidas com mais detalhes posteriormente.
2. PRINCIPAIS COMPONENTES
Nesta seÂ¸cËœao, sËœao apresentados os principais componentes de
arquitetura Cell e suas caracterÂ´Ä±sticas mais importantes.
2.1 PowerPC Processor Element (PPE)
A arquitetura CBEA define que todo sistema compatÂ´Ä±vel
com Cell deve ter, pelo menos, um processador do tipo PPE.
Este processador deve ser um processador de 64 bits, compatÂ´Ä±vel com a famÂ´Ä±lia PowerPC, mas deve ter algumas caracterÂ´Ä±sticas diferenciadas. E necessÂ´ario, por exemplo, que o Â´
processador tenha um conjunto de instruÂ¸cËœoes relativo `as extensËœoes multimÂ´Ä±dia, permitindo que ele tambÂ´em seja usado
para execuÂ¸cËœao de programas fortemente dependente de processamento de dados. Portanto, o PPE tambÂ´em possui um
pequeno conjunto de instruÂ¸cËœoes SIMD.
O PPE ainda pode ser dividido em duas partes: o cache L2
e a PXU (PowerPC eXecution Unit).
AlÂ´em disso, o PPE presente no Cell deve ter uma implementaÂ¸cËœao que permita a operaÂ¸cËœao em freqÂ¨uË†encias altas, alÂ´em
de ter caracterÂ´Ä±sticas de baixo consumo de energia, mesmo
que para isso algumas funcionalidades dos PowerPCs mais
novos nËœao estejam presentes. Boa parte das caracterÂ´Ä±sticas
do PPE nËœao sËœao parte da especificaÂ¸cËœao CBEA, sendo dependentes de implementaÂ¸cËœao.
No caso do Cell tÂ´Ä±pico, que serÂ´a usado pela Sony nos consoles
de entretenimento, muitas destas caracterÂ´Ä±sticas podem ser
observadas e sËœao interessantes para exemplificar o potencial
desta unidade. As caracterÂ´Ä±sticas do PPE que seguem sËœao
referentes a esta implementaÂ¸cËœao especÂ´Ä±fica.
O cache L2, por exemplo, foi reduzido em relaÂ¸cËœao ao que
existe nos processadores PowerPC recentes. O cache L2
possui apenas 512KB, jÂ´a que Â´e comum o cache ocupar uma
Â´area muito grande do chip. Dessa forma, pode-se poupar
Â´area para que pudessem ser colocados outros processadores
no mesmo chip. Essa decisËœao foi de certa forma contrabalanceada pelo uso de memÂ´orias externas rÂ´apidas, do tipo
XDR da RAMBUS. O cache Â´e L1 Â´e de 32KB, e Â´e dividido
em um cache para dados e outro cache para instruÂ¸cËœoes.
A PXU desta implementaÂ¸cËœao Â´e capaz de executar instruÂ¸cËœoes
de duas threads simultaneamente, mas nËœao reordena instruÂ¸cËœoes â€“ uma involuÂ¸cËœao se compararmos aos PowerPCs
mais novos, que jÂ´a possuem esta caracterÂ´Ä±stica. A PXU
pode ser subdivida em trË†es componentes ainda menores, mas
ainda com funcionalidade bem definida. A IU ( Instruction
Unit), a XU (Fixed Point Execution Unit) e a VSU (Vector
Scalar Unit).
A IU Â´e responsÂ´avel pelo controle do PPE e cuida de tarefas
como fetch de instruÂ¸cËœoes, decodificaÂ¸cËœao e branch prediction.
A cada ciclo, 4 instruÂ¸cËœoes sofrem fetch e duas delas sËœao processadas pela IU. A tabela usada para branch prediction
possui 4 KB de tamanho e possui um pipeline de 23 estÂ´agios.
A XU Â´e responsÂ´avel pela execuÂ¸cËœao das instruÂ¸cËœoes que envolvem nÂ´umeros inteiros e de instruÂ¸cËœoes do tipo Load e Store. A
XU possui, para cada thread, 32 registradores de propÂ´osito
geral de 64 bits e a unidade de Load e Store, da qual o cache
L1 de dados faz parte, tem caracterÂ´Ä±sticas nËœao bloqueantes.
Isso significa que, enquanto o cache estÂ´a processando uma
requisiÂ¸cËœao `a memÂ´oria por conta de um cache miss, pode receber outras requisiÂ¸cËœoes. Na prÂ´atica Â´e possÂ´Ä±vel, portanto,
observar um cache hit ao mesmo tempo que hÂ´a o processamento do cache miss.
A VSU Â´e responsÂ´avel pela execuÂ¸cËœao de instruÂ¸cËœoes SIMD e
tambÂ´em atua como unidade de ponto flutuante. A unidade
de ponto flutuante da VSU tambÂ´em possui um banco de
32 registradores de 64 bits por thread, tem um pipeline interno de 10 estÂ´agios e Â´e compatÂ´Ä±vel com as especificaÂ¸cËœoes da
IEEE. A unidade vetorial da VSU processa vetores de 32
entradas de 128 bits por thread e todas as instruÂ¸cËœoes para
esta unidade sËœao instruÂ¸cËœoes do tipo SIMD de 128 bits.
2.2 Synergistic Processing Element (SPE)
Os processadores do tipo SPE sËœao bem diferentes dos processadores do tipo PPE. O objetivo principal de tais processadores Â´e garantir alto desempenho para aplicaÂ¸cËœoes que
processam dados de maneira intensiva, tais como operaÂ¸cËœoes
para tratamento de Â´audio, vÂ´Ä±deo, criptografia e cÂ´alculos para
simulaÂ¸cËœao de fenË†omenos.
2.2.1 Local Store
Um das maiores barreiras para alcanÂ¸car altos nÂ´Ä±veis de performance Â´e o gargalo de acesso `a memÂ´oria. O custo de fazer
acessos constantes `a memÂ´oria Â´e muito grande e deve ser evitado sempre que possÂ´Ä±vel[5].
Para tentar minimizar tais problemas, os SPEs tË†em memÂ´oria
prÂ´opria e nËœao tË†em acesso direto `a memÂ´oria principal do sistema. Essa memÂ´oria Â´e uma memÂ´oria rÂ´apida (tËœao rÂ´apida
quanto memÂ´oria usada em sistemas de cache) e Â´e usada para
guardar tanto instruÂ¸cËœoes quanto dados. A implementaÂ¸cËœao
dessas memÂ´oria tenta minimizar o nÂ´umero de transistores
necessÂ´arios para guardar os dados, para melhorar o aproveitamento da Â´area do chip.
A comunicaÂ¸cËœao com a memÂ´oria principal Â´e feita por DMA
e Â´e responsabilidade de uma unidade interna de gerË†encia
de memÂ´oria, chamada MFC (Memory Flow Controller). As
transferË†encia de dados com a memÂ´oria principal podem ser
iniciadas tanto pelos PPEs quanto pelos SPEs e Â´e possÂ´Ä±vel,
atravÂ´es de um esquema de filas, executar simultaneamente
mÂ´ultiplos comandos de DMA.
Dessa forma, os dados necessÂ´arios para executar uma tarefa em um SPE em geral estËœao sempre presentes no Local
Store e foram prÂ´e carregados pelo PPE antes de entregar a
tarefa. Isso minimiza bastante os acessos (principalmente
os acessos aleatÂ´orios) `a memÂ´oria principal, garantindo uma
performance muito boa em relaÂ¸cËœao `as arquiteturas convencionais.
Em uma implementaÂ¸cËœao tÂ´Ä±pica do Cell, o Local Store ocupa
de 85% a 90% da Â´area total do SPE, o que equivale a 256KB
de memÂ´oria rÂ´apida e local.
O Local Store provË†e dois canais de acesso: um canal mais
largo, de 128 bytes, Â´e usada para interface com o sistema
de DMA. Um canal mais enxuto, de 128 bits, Â´e usado para
interfacear com a unidade de execuÂ¸cËœao do SPE.
Como o Local Store Â´e uma unidade rÂ´apida de memÂ´oria, nËœao
hÂ´a a necessidade de memÂ´oria cache para os SPEs. Mesmo
assim, a arquitetura permita que haja um cache entre o Local
Store e o MFC, para evitar chamadas `a memÂ´oria principal
desnecessÂ´arias.
2.2.2 A unidade de execucÂ¸ao â€“ SXU Ëœ
A unidade de execuÂ¸cËœao de instruÂ¸cËœoes do SPE Â´e chamada de
SXU (SPE eXecution Unit) e Â´e otimizada para trabalhar
com dados em unidades de 128 bits. Apenas uma Â´unica
thread Â´e executada por vez, mas Â´e possÂ´Ä±vel executar mais
de umas instruÂ¸cËœao por ciclo, dependendo dos tipos de instruÂ¸cËœao. Caso seja uma instruÂ¸cËœao de acesso a memÂ´oria e
uma instruÂ¸cËœao de operaÂ¸cËœao com dados, Â´e possÂ´Ä±vel que ambas sejam executadas simultaneamente. A SXU nËœao realiza reordenaÂ¸cËœao de instruÂ¸cËœoes, deixando esta tarefa para o
compilador e o conjunto de instruÂ¸cËœoes Â´e novo, desenhado especificamente para o Cell, para permitir o aproveitamento
mÂ´aximo das funcionalidades implementadas.
A SXU tem um banco de 128 registradores de 128 bits cada,
o que permite que o compilador tenha muitas opÂ¸cËœoes para
reorganizar as instruÂ¸cËœoes de forma a minimizar possÂ´Ä±veis perdas com latË†encia. InstruÂ¸cËœoes com inteiros sËœao executadas em
dois ciclos e instruÂ¸cËœoes do tipo Load e de ponto flutuante de
precisËœao simples sËœao executadas em apenas 6 ciclos.
Essa performance para execuÂ¸cËœao de operaÂ¸cËœoes com ponto
flutuante Â´e alcanÂ¸cada facilmente porque a unidade de ponto
flutuante nËœao Â´e compatÂ´Ä±vel com o padrËœao IEEE, e portanto
algumas simplificaÂ¸cËœoes foram feitas. Isso permitiu que uma
unidade menor, mais simples e mais rÂ´apida fosse criada.
Os projetistas do Cell argumentam que este nËœao Â´e um problema sÂ´erio [1], visto que para a maioria das aplicaÂ¸cËœoes a
que a arquitetura estÂ´a destinada, uma pequena falha de
arredondamento provocada por problemas na normalizaÂ¸cËœao
nËœao implicaria em perdas considerÂ´aveis. Em um vÂ´Ä±deo, por
exemplo, nËœao seria tËœao problemÂ´atico sem um pixel parece
ligeiramente mais claro ou mais escuro. Quando um personagem em um jogo realiza um salto, nËœao teria problema se o
do cÂ´alculo da fÂ´Ä±sica envolvida provocasse um deslocamento
aquÂ´em do possÂ´Ä±vel para o personagem, em dadas situaÂ¸cËœoes.
Caso haja a necessidade de tratar com mais seriedade os
dados de ponto flutuante, deve-se avaliar se nËœao seria melhor usar precisËœao dupla (que Â´e tratada com mais cuidado
pela SXU) ou entËœao usar o prÂ´oprio PPE para realizar tais
cÂ´alculos.
O conjunto de instruÂ¸cËœoes da SXU Â´e SIMD [3]â€“ o que significa
que uma Â´unica instruÂ¸cËœao Â´e capaz de processar muitos dados
simultaneamente. As instruÂ¸cËœoes podem tratar os dados de
vÂ´arias formas diferentes, contato que no total tenham sido
processados 128 bits. E possÂ´Ä±vel, com uma Â´unica instruÂ¸cËœao Â´
SIMD, realizar operaÂ¸cËœoes com:
â€¢ 16 inteiros de 8 bits
â€¢ 8 inteiros de 16 bits
â€¢ 4 inteiros de 32 bits
â€¢ 4 valores de ponto flutuante com precisËœao simples
â€¢ 2 valores de ponto flutuante com precisËœao dupla
E importante observar que, diferentemente do PPE, o SPE Â´
nËœao possui caracterÂ´Ä±sticas de branch prediction, pois uma
unidade deste tipo traria uma complexidade adicional que
nËœao Â´e desejada para este elemento. Por outro lado, Â´e possÂ´Ä±vel
que o programador (ou compilador) possa indicar, atravÂ´es
de instruÂ¸cËœoes especiais, qual Â´e o destino mais provÂ´avel de um
branch. Dessa forma, quando a SXU detecta que um branch
se aproxima, realiza o prÂ´e-fetch das instruÂ¸cËœoes que estËœao no
suposto endereÂ¸co de destino do branch.
2.2.3 RestricÂ¸oes Ëœ
O SPE nËœao Â´e um processador de propÂ´osito geral como o SPE
e portanto possui algumas restriÂ¸cËœoes. A principal delas Â´e o
fato de nËœao ter acesso direto `a memÂ´oria principal â€“ todos os
acessos `a memÂ´oria principal tË†em de ser feitos atravÂ´es do controlador de memÂ´oria, por comandos DMA. O SPE tambÂ´em
nËœao sabe distinguir entre diferentes modos do processador,
como modo usuÂ´ario e modo privilegiado. E impossÂ´Ä±vel ao Â´
SPE acessar recursos de controle do sistema, como tabelas
de pÂ´agina por exemplo.
Por conta destas restriÂ¸cËœoes, grande parte das tarefas realizadas pelo sistema operacional devem ser executadas pelos
PPEs.
3. SOFTWARE
Como a arquitetura Cell Â´e razoavelmente diferente do que
vem sendo trabalhado com as arquiteturas convencionais, Â´e
importante que os softwares tenham que ser desenvolvidos
com caracterÂ´Ä±sticas especiais.
Embora qualquer aplicaÂ¸cËœao compatÂ´Ä±vel com PowerPC possa
ser executada no Cell sem a necessidade de alteraÂ¸cËœoes, Â´e de
suma importË†ancia que software tenha que ser desenvolvido
especificamente para a arquitetura Cell para que todo o potencial seja aproveitado.
Essa iniciativa deve comeÂ¸car pela criaÂ¸cËœao de novos compiladores. Paralelamente ao desenvolvimento do Cell, uma
equipe da IBM trabalhou na criaÂ¸cËœao de compiladores otimizados, mas ainda hÂ´a muito o que caminhar neste sentido.
Como vimos, tanto os SPEs quanto os PPEs foram projetados imaginando que boa parte das tarefas de otimizaÂ¸cËœao
fossem realizadas pelo processador. Por exemplo: nËœao hÂ´a reordenaÂ¸cËœao de instruÂ¸cËœoes em nenhum dos processadores. No
caso do PPE, nËœao hÂ´a nem ao menos branch prediction.
AlÂ´em disso, Â´e necessÂ´ario que os programas para essa nova
arquitetura sejam criados levando em consideraÂ¸cËœao suas caracterÂ´Ä±sticas. Os programas devem ser feitos de forma que
possam ser divididos em tarefas menores e independentes,
que podem ser divididas entres os vÂ´arios SPEs. Deve-se
tambÂ´em programar imaginando que existe um conjunto de
instruÂ¸cËœoes SIMD que deve ser usado para maximizar performance. Por outro lado, Â´e necessÂ´ario desenvolver software
capaz de escalonar de maneira eficientes tais tarefas para os
SPEs corretos, bem como garantir que os dados necessÂ´arios
estejam presentes no Local Store do SPE.
FreqÂ¨uË†encia de clock 4+ GHz
Pico de performance (precisËœao simples) 256 GFlops
Pico de performance (precisËœao dupla) 26 GFlops
Cache L2 512 KB
Local Store (total) 4 MB
Area Â´ 221 mm2
Transistores 240 milhËœoes
Tabela 1: EstatÂ´Ä±sticas relacionadas ao Cell
4. PERFORMANCE E ESTATÂ´ISTICAS
Para termos uma idÂ´eia do que um chip Cell Â´e capaz de fazer, Â´e interessante apresentarmos alguns dados. Os dados
que estËœao sendo apresentados na Tabela 1 sËœao referentes `a
implementaÂ¸cËœao tÂ´Ä±pica do Cell, que serÂ´a usada no Sony Playstation 3.
5. CONCLUSAOËœ
A arquitetura Cell, desenvolvida em conjunto pela Sony,
Toshiba e IBM Â´e uma arquitetura multicore de alto desempenho, que tenta minimizar custo e gasto com energia.
Atualmente a arquitetura jÂ´a tem um mercado potencial gigantesco, que sËœao os consumidores de console Playstation
da Sony, mas o potencial do Cell permite que ele ainda seja
introduzido em vÂ´arias Â´areas diferentes.
Para garantir o sucesso da plataforma, porÂ´em, Â´e imprescindÂ´Ä±vel que seja desenvolvido software para maximizar o
uso da arquitetura.
6. REFERÃŠNCIAS
[1] E. Altman, P. Capek, et al. The cell architecture â€“
innovation matters. IBM, Sony, Toshiba, ISSCC, 2005.
[2] IBM. Cell Broadband Engine Architecture â€“ Version
1.0. IBM, Sony, Toshiba, 2005.
[3] IBM. Synergistic Processor Unit Instruction Set
Architecture â€“ Version 1.0. IBM, Sony, Toshiba, 2005.
[4] J. A. Kahle, M. N. Day, H. P. Hofstee, et al.
Introduction to the cell processor. IBM J. Res & Dev.,
49(4/5):589â€“604, July/September 2005.
[5] W. Wulf and S. McKee. Hitting the memory wall:
Implications of the obvious. ACM Computer
Architecture News, 23(1):20â€“24, 1995.