Fixed-Parameter Tractability and Completeness II:
 On Completeness for W[1]
 Rod G. Downey
 Mathematics Department
 Victoria University
 Wellington, New Zealand
 Michael R. Fellows
 Computer Science Department
 University of Victoria
 Victoria, B.C. Canada
 Abstract
 For many xed-parameter problems that are trivially solvable in polynomial-time, such as k
DOMINATINGSET,essentially no better algorithm is presently known than the one which tries all
 possible solutions. Other problems, such as FEEDBACK VERTEX SET, exhibit xed-parameter
 tractability: for each xed k the problem is solvable in time bounded by a polynomial of degree c,
 where c is a constant independent of k. In a previous paper, the W Hierarchy of parameterized
 problems was dened, and complete problems were identied for the classes W[t] for t ≥ 2. Our
 main result shows that INDEPENDENT SET is complete for W[1].
 1. Introduction
 Many natural computational problems have input that consists of a pair of items. For
 practical applications, it is often the case that only a small range of parameter values are
 signicant.
 We now have encouraging xed-parameter tractability results for many problems. For
 example, for each xed parameter value k, it can be determined whether a graph G on n
 vertices has k disjoint cycles in time O(n) [Bo,DF1]. MINOR TESTING and the GRAPH
 GENUS problem can be solved in O(n3) time for each xed parameter value by the deep
 results of Robertson and Seymour [RS1,RS2].
 There are many other parameterized problems, such as DOMINATING SET, for which
 essentially no better algorithm is presently known than the trivial brute-force algorithm that
 checks all sets of k vertices.
 The following denitions provide a framework for the study of xed-parameter complex
ity.
 1
Denition. A parameterized problem is a set L ⊆ Σ∗ ×Σ∗ where Σ is a xed alphabet.
 Denition. A parameterized problem L is (uniformly) xed-parameter tractable if there
 exists a constant α and an algorithm to determine if (x,y) is in L in time f(y)·xα, where
 f : N →N is an arbitrary function. We will denote the class of xed-parameter tractable
 problems by FPT.
 In a previous paper we dened a hierarchy of parameterized problem classes
 FPT ⊆W[1]⊆W[2] ⊆W[3] ⊆··· ⊆ W[SAT] ⊆W[P]
 and exhibited problems complete for W[t] for t ≥ 2. For example, DOMINATING SET is
 complete for W[2]. Our main result in the present paper shows that several natural problems
 (including INDEPENDENT SET) are complete or hard for W[1]. We remark that W[1] is
 currently the most important of the parameterized classes that we beleive to be intractable.
 This is because it is our current minimally intractable class in the sense that we believe
 it to be intractable and if we wish to prove a problem to be xed parameter intractable we
 will establish this by showing hardness for W[1]. The reasons that we believe that W[1] is
 xed parameter intractable are that many problems have been shown to be W[1] complete
 here and elsewhere (e.g. [CCDF]) and the following generic problem is W[1] complete (in
 [CCDF]):
 SHORT TURING MACHINE COMPUTATION
 Input: A Nondeterministic Turing Machine M and a string x.
 Parameter: k
 Question: Does M have a computation path that accepts x in at most k steps?
 We believe that the W[1] completeness of this problem establishes a miniaturized Cook
Levin theorem and provides very strong evidence that W[1] really is xed parameter in
tractable.
 For a parameterized problem L and y ∈ Σ∗ we write Ly to denote the associated xed
parameter problem (y is the parameter) Ly = x(x,y) ∈ L.
 Denition. A (uniform) reduction of a parameterized problem L to a parameterized problem
 L′ is an oracle algorithm A that on input (x,y) determines whether x ∈ Ly and satises
 (1) There is an arbitrary function f : N → N and a polynomial q such that the running
 time of A is bounded by f(y)q(x).
 (2) For each y ∈ Σ∗ there is a nite subset Jy ⊆ Σ∗ such that A consults oracles only for
 xed-parameter decision problems L′
 w where w ∈ Jy.
 If, additionally the functions f and y → Jy are both recursive we say that the reduction
 is strongly uniform. (All of the reductions in this paper are strongly uniform.)
 2
A motivating example for the above denition is the reduction of the Graph Genus
 problem to the problem of MINOR TESTING.Bythedeepresults of Robertson and Seymour
 [RS1,RS2] the GRAPH GENUS problem for each xed parameter value k reduces to nitely
 many minor tests; the reduction can be made uniform by the techniques of [FL1,FL2]. The
 following is easily veried.
 Lemma 1.1 If the parameterized problem L reduces to the parameterized problem L′, and
 if L′ is f.p. tractable, then L is f.p. tractable.
 2
 In the Section 2 we review the denition of the W hierarchy. In Section 3 we prove
 our main result, that INDEPENDENT SET is complete for W[1]. In Section 4 we discuss
 a number of natural problems that are hard for W[1], including a parameterized variant of
 SUBSET SUM. Section 5 concludes with a discussion of open problems. We remark that
 the results of this paper have been used in many W[1] hardness proofs, as well as applied
 to Computational Learning Theory([DEF]). Moreover, as we montioned earlier, since the
 writing of the present paper, many other W[1] hardness and completeness results have been
 found. We make some further remarks towards this in an Addendum in §6.
 2. The W Hierarchy of Parameterized Problems
 The complexity classes W[t] of parameterized problems intuitively reect the diculty
 of checking a solution. We rst dene circuits in which some gates have bounded fan-in and
 some have unrestricted fan-in. It is assumed that fan-out is never restricted.
 Denition. A Boolean circuit is of mixed type if it consists of circuits having gates of the
 following kinds.
 (1) Small gates: not gates, and gates and or gates with bounded fan-in. We will usually
 assume that the bound on fan-in is 2 for and gates and or gates, and 1 for not gates.
 (3) Large gates: And gates and Or gates with unrestricted fan-in.
 We will use lower case to denote small gates (or gates and and gates), and upper case
 to denote large gates (Or gates and And gates).
 Denition. The depth of a circuit C is dened to be the maximum number of gates (small
 or large), not counting not gates, on an input-output path in C. The weft of a circuit C is
 the maximum number of large gates on an input-output path in C.
 Denition. We say that a family of circuits F has bounded depth if there is a constant h such
 that every circuit in the family F has depth at most h. We say that F has bounded weft if
 there is constant t such that every circuit in the family F has weft at most t. F is a decision
 circuit family if each circuit has a single output. A decision circuit C accepts an input vector
 x if the single output gate has value 1 on input x. The weight of a boolean vector x is the
 3
number of 1s in the vector.
 Denition. Let F be a family of decision circuits. We allow that F may have many dierent
 circuits with a given number of inputs. To F we associate the parameterized circuit problem
 LF =(C,k) : C ∈ F and C accepts an input vector of weight k.
 Denition. A parameterized problem L belongs to W[t] (monotone W[t]) if L uniformly
 reduces to the parameterized circuit problem LF(t,h) for the family F(t,h) of mixed type
 (monotone) decision circuits of weft at most t, and depth at most h, for some constant h.
 Thus we have the containments
 FPT ⊆W[1]⊆W[2] ⊆
 and we conjecture that each of these containments is proper. We term the union of these
 classes the W hierarchy. If we place no bound on the depth or weft of the circuits we similarly
 get the class W.
 Bydenition, a parameterized problem L ∈ W[1] reduces to LF(1,h) for the family F(1,h)
 of weft 1 circuits of depth bounded by h, for some h. The following argument shows that we
 may assume the circuits in F to have depth 2 and a particularly simple form, consisting of a
 single output And gate which receives arguments from or gates having fan-in bounded by a
 constant h′. Thus each such circuit is isomorphically represented by a boolean expression in
 conjunctive normal form having clauses with at most h′ literals. We will say that a family of
 circuits having this form is normalized. With this in mind we have the following denition.
 Denition. The family of parameterized problems W[1,s] is dened to be those parameter
ized problems in W[1] reducible to LF(s) for the family F(s) of depth 2, weft 1 normalized
 circuits, with the or gates on level 1 having fan-in bounded by s.
 Lemma 2.1. Let F be a family of weft 1 circuits of depth bounded by a constant h. Then
 LF is reducible to LF(s) for s = 2h + 1, and hence LF ∈ W[1,s].
 Proof. Let C ∈ F and let k be a positive integer. We describe how to produce a circuit
 C′ ∈ F(s) and an integer k′ such that C accepts a weight k input if and only if C′ accepts
 an input of weight k′.
 Step 1. The reduction to tree circuits.
 The rst step is to transform C into an equivalent weft 1 tree circuit C′ of depth at
 most h. In a tree circuit every logic gate has fan-out one, and thus the circuit can be viewed
 as equivalent to a Boolean formula. The transformation can be accomplished by replicating
 the portion of the circuit above a gate as many times as the fan-out of the gate, beginning
 with the top level of logic gates, and proceeding downward level by level. The creation of C′
 from C may require time O(CO(h)) and involve a similar blow-up in the size of the circuit.
 4
This is permitted since h is a xed constant independent of k and C.
 Step 2. Moving the not gates to the top of the circuit.
 Let C denote the circuit we receive from the previous step (we will use this notational
 convention throughout the proof). Transform C into an equivalent circuit C′ by commuting
 the not gates to the top, using DeMorgans laws. This may increase the size of the circuit
 by at most a constant factor. The tree circuit C′ thus consists (from the top) of the input
 nodes, with not gates on some of the lines fanning out from the inputs. In counting levels
 we consider all of this as level 0.
 Step 3. A preliminary depth 4 normalization.
 The goal of this step is to produce a tree circuit C′ of depth 4 that corresponds to a
 Boolean expression E in the following form. (For convenience we use product notation to
 denote logical  and sum notation to denote logical .)
 m
 ∏
 E =
 where:
 (1) m is bounded by a function of h
 i=1
 (2) for all i, mi is bounded by a function of h
 (3) for all i,j, Eij is either:
 mij
 ∏
 mi
 ∑
 j=1
 mijk
 ∑
 Eij =
 Eij
 x[i, j, k, l]
 k=1
 or
 mij
 ∑
 Eij =
 k=1
 l=1
 mijk
 ∏
 l=1
 x[i, j, k, l]
 where the x[i,j,k,l] are literals (i.e., input Boolean variables or their negations) and for all
 i, j, k, mijk is bounded by a function of h. The family of circuits corresponding to these
 expressions has weft 1, with the large gates corresponding to the Eij. (In particular, the mij
 are not bounded by a function of h.)
 To achieve this form, let g denote a large gate in C. An input to g is computed by a
 subcircuit of depth bounded by h consisting only of small gates, and so is a function of at
 most 2h literals. This subcircuit can thus be replaced, at constant cost, by either a product
of-sums expression (if g is a large  gate), or a sum-of-products expression (if g is a large
  gate). In the rst case, the product of these replacements over all inputs to g yields the
 subexpression Eij corresponding to g. In the second case, the sum of these replacements
 yields the corresponding Eij.
 5
The output of C is a function of the outputs of at most 2h large gates. This function
 can be expressed as a product-of-sums expression of size at most 22h. At the cost of possibly
 duplicating some of the large gate subcircuits at most 22h times, we can achieve the desired
 normal form with the bounds: m ≤ 22h, mi ≤ 2h and mijk ≤ 2h.
 Step 4. Employing additional nondeterminism.
 Let C denote the normalized depth 4 circuit received from Step 3 and corresponding
 to the Boolean expression E described above. For convenience, assume that the Eij for
 j = 1,,m′
 i are sums-of-products and the Eij for j = m′
 i + 1,,mi are products-of-sums.
 Let V0 = x1,,xn denote the variables of E.
 In this step we produce an expression E′ in product-of-sums form with the size of the
 sums bounded by 2h +1 that has a satisfying truth assignment of weight
 m
 k′ = 2k +k(1+2h)22h +m+
 ∑
 i=1
 m′
 i
 if and only if C has a satisfying truth assignment of weight k. The main idea is to use
 additional (bounded weight) nondeterminism to guess both: (1) a weight k input x for C,
 and (2) additional information that will allow us to check that C(x) = 1 with a W[1,s]
 circuit, s = 2h + 1.
 The set V of variables of E′ is V = V0 V1 V2 V3 where
 V1 = x[i,j] : 1 ≤ i ≤ n, 0 ≤ j ≤ (1+2h)22h
 V2 = u[i,j] : 1 ≤ i ≤ m, 1 ≤ j ≤ mi
 V3 = w[i,j,k] : 1 ≤ i ≤ m, 1 ≤ j ≤ m′
 i, 0 ≤ k ≤ mij
 The expression E′ is a product of subexpressions E′ = E1  ···  E8 described:
 n
 ∏
 E1 =
 n
 ∏
 E2 =
 22h+1
 ∏
 i=1
 (¬xi +x[i,0])(¬x[i,0] + xi)
 (¬x[i, j] + x[i,j + 1 (mod r)]) r = 1+(1+2h)22h
 i=1
 j=0
 E4 =
 m
 ∏
 E3 =
 m
 ∏
 i=1
 mi−1
 ∏
 j=1
 i=1
 mi
 ∏
 mi
 ∑
 j=1
 u[i, j]
 (¬u[i, j] + ¬u[i,j′])
 j′=j+1
 6
E5=m ∏
 i=1
 m′
 i ∏
 j=1
 mij−1 ∏
 k=0
 mij ∏
 k′=k+1
 (¬w[i,j,k]+¬w[i,j,k′])
 E6=m ∏
 i=1
 m′
 i ∏
 j=1
 (¬u[i,j]+¬w[i,j,0])
 E7=m ∏
 i=1
 m′
 i ∏
 j=1
 mij ∏
 k=1
 mijk ∏
 l=1
 (¬w[i,j,k]+x[i,j,k,l])
 E8=m ∏
 i=1
 mi ∏
 j=m′
 i+1
 mij ∏
 k=1
 (
 ¬u[i,j]+
 mijk ∑
 l=1
 x[i,j,k,l]
 )
 ToseethatStep4workscorrectly,supposeτ isaweightktruthassignmenttoV0 that
 satisesE.Wedescribehowtoextendτ toweightk′ truthassignmentτ′ tothevariables
 V thatsatisesE′ asfollows:
 (1)Foreachisuchthatτ(xi)=1andforj=0,,(1+2h)22h setτ′(x[i,j])=1.
 (2)For eachi=1,,mchoosechoosean indexji suchthatEi,ji
 evaluates to1(this is
 possible, sinceτ satisesE)andsetτ′(u[i,ji])=1.
 (3)If in(2)Ei,ji
 isasum-of-products, thenchooseanindexki suchthat
 mi,j,ki ∏
 l=1
 x[i,j,k,l]
 evaluatesto1,andcorrespondinglysetτ′(w[i,j,ki])=1.
 (4)Fori=1,,mandj=1,,m′
 i suchthatj=ji, setτ′(w[i,j,0])=1.
 It is straightforwardtocheckthat theabovedescribedweightk′ extensionτ′ satises
 E′.
 Conversely,supposeυ′ isaweightk′ truthassignmenttothevariablesofV thatsatises
 E′.Wearguethattherestrictionυofυ′ toV0 isaweightktruthassignmentthatsatises
 E.
 Claim1. υsetsatmostkvariablesofV0 to1.
 If thiswerenot so, thentheclauses inE1 andE2wouldtogether forceat least (k+
 1)(2+(1+2h)22h)variablestobe1inorder forυ′ tosatisfyE′,acontradictionasthis is
 morethank′.
 Claim2. υsetsat leastkvariablesofV0 to1.
 TheclausesofE4 insurethatυ′ setsatmostmvariablesofV2 to1.TheclausesofE5
 insurethatυ′ setsatmostm
 i=1m′
 i variablesofV3 to1. IfClaim2werefalsethenforυ′ to
 7
have weight k′ there must be more than k indices j for which some variable x[i,j] of V1 has
 the value 1, a contradiction in consideration of E1 and E2.
 The clauses of E3 and the arguments above show that υ′ necessarily has the following
 restricited form:
 (1) Exactly k variables of V0 are set to 1.
 (2) For each of the k in (1) the corresponding (1+2h)22h +1 variables of V1 are set to 1. (3)
 For each i = 1,,m there is exactly one ji for which u[i,ji] ∈ V2 is set to 1.
 (4) For each i = 1,,m and j = 1,,m′
 i there is exactly one ki for which w[i,j,ki] ∈ V3 is
 set to 1.
 To argue that υ satises E it suces to argue that υ satises every Ei,ji 
for i = 1,,m.
 The clauses of E6 insure that if υ′(u[i,j]) = 1 then ki= 0. This being the case, the
 clauses of E7 force the literals in a subexpression of Ei,ji 
to evaluate in a way that shows
 Ei,ji 
to evaluate to 1. The clauses of E8 enforce that Ei,ji 
evaluates to 1 for ji > m′
 i.
 2
 Thus we have the following stratication of W[1] that will be useful to our arguments.
 ∞
 ⋃
 W[1] =
 s=1
 W[1,s]
 Our main result shows that W[1] collapses to W[1,2].
 3. Antimonotonicity
 A family of circuits F is termed monotone if the circuits in F do not have any not
 gates. Equivalently, the circuits in F correspond to boolean expressions having only positive
 literals. If we restrict the denition of W[t] and W[1,s] to monotone circuit families we
 obtain the family of parameterized problems monotone W[t] (monotone W[1,s]).
 We say that a family of circuits F is antimonotone if the boolean expressions corre
sponding to the circuits in F have only negative literals. In an antimonotone circuit each
 fan-out line from an input node goes to a not gate (and in the remainder of the circuit there
 are no other not gates). The restriction to antimonotone circuit families yields the classes of
 parameterized problems antimonotone W[t] (antimonotone W[1,s]).
 Theorem 3.1 of [DF2] employed as a change-of-variables as in the proof of theorem 4.1
 of that paper shows the following relationship.
 Proposition 3.1. W[t] = monotone W[t] for t even and t ≥ 2.
 We prove the following complementary result.
 Proposition 3.2. W[t] = antimonotone W[t] for t odd, t ≥ 1.
 8
 2
We rst prove the following lemma.
 Lemma 3.1 W[1,s] = antimonotone W[1,s] for all s ≥ 2.
 Proof. The plan of our argument is to identify a problem (RED/BLUE NONBLOCKER)
 that belongs to antimonotone W[1,s], and then show that the problem is hard for W[1,s].
 RED/BLUE NONBLOCKER is the parameterized problem which takes as input a graph
 G = (V,E) where V is partitioned into two color classes V = Vred  Vblue, and a positive
 integer k. The problem is to determine if there is a set of red vertices V ′ ⊆ Vred of cardinality
 k such that every blue vertex has at least one neighbor that does not belong to V ′.
 The closed neighborhood of a vertex u ∈ V is the set of vertices N[u] = x : x ∈
 V and x=u or xu∈E.
 It is easy to see that the restriction of RED/BLUE NONBLOCKER to graphs G of
 maximum degree s belongs to antimonotone W[1,s] since the product-of-sums boolean ex
pression
 ∏
 u∈Vblue
 ∑
 xi∈N[u]∩Vred
 ¬xi
 has a weight k truth assignment if and only if G has size k nonblocking set. By the weight of
 a truth assignment to a set of boolean variables, we mean the number of variables assigned
 the value true.
 Such an expression corresponds directly to a circuit meeting the dening conditions for
 antimonotone W[1,s]. We will refer to the restriction of RED/BLUE NONBLOCKER to
 graphs of maximum degree bounded by s as s-RED/BLUE NONBLOCKER. We next argue
 that s-RED/BLUE NONBLOCKER is complete for W[1,s].
 Let X be a boolean expression in conjunctive normal form with clauses of size bounded
 by s. Suppose X consists of m clauses C1,,Cm over the set of n variables x0,,xn−1. We
 show how to produce in polynomial-time by local replacement, a graph G = (Vred,Vblue,E)
 that has a nonblocking set of size 2k if and only if X is satised by a truth assignment of
 weight k.
 Before we give any details, we give a brief overview of the construction, whose component
 design is outlined in Diagram 1. There are 2k red components arranged in a circle. These
 are alternatively gouped as blocks from V1 and then V2 sets to be precisely described below.
 The idea is that V1 blocks should represent a positive choice (corresponding to a literal
 being true) and the V2 blocks corresponding to the gap until the next positive choice. We
 will ensure that for each pair in a block there will be a blue vertex connected to the pair
 and nowhere else (these are the sets V3 and V5). This device ensures that at most one red
 vertex from each block can be chosen and since we must choose 2k this ensures that we
 choose exactly one red vertex from each block. The reader should think of the V2 blocks
 9
as arranged in k columns. Now if i is chosen fron a V1 block we will ensure that column i
 gets to select the next gap. To ensure this we connect a blue degree 2 vertex to i and each
 vertex not in the i-th column of the next V2 block. Of course this means that if i is chosen
 since these blue vertices must have an unchosen red neighbour, we must choose from the
 i-th column. The nal part of the component design is to enforce consistency in the next
 V1 block. That is if we choose i and have a gap choice in the next V2 block, column i, of
 j then the next chosen variable should be i + j + 1 (here we work mod n). Again we can
 enforce this by using many degree 2 blue vertices to block any other choice (These are the
 V6 vertices.) The last part of the construction is to force consistency with the clauses. We
 do this as follows. For each way a nonblocking set can correspond to making a clause false,
 we make a blue vertex and join it up to the s relevant vertices. This ensures that thay cant
 all be chosen. (This is the point of the V7 vertices.) We now turn to the formal details.
 The red vertex set Vred of G is the union of the following sets of vertices:
 V1 = a[r1,r2] : 0 ≤ r1 ≤ k −1,0 ≤ r2 ≤ n−1
 V2 = b[r1,r2,r3] : 0 ≤ r1 ≤ k −1,0 ≤ r2 ≤ n−1,1 ≤ r3 ≤ n−k+1
 The blue vertex set Vblue of G is the union of the following sets of vertices:
 V3 = c[r1,r2,r′
 2] : 0 ≤ r1 ≤ k − 1,0 ≤ r2 < r′
 2 ≤ n−1
 V4 = d[r1,r2,r′
 2,r3,r′
 3] : 0 ≤ r1 ≤ k−1,0 ≤ r2,r′
 2 ≤ n−1,0 ≤ r3,r′
 3 ≤ n−1 and either r2=
 r′
 2 or r3= r′
 3
 V5 = e[r1,r2,r′
 2,r3] : 0 ≤ r1 ≤ k − 1,0 ≤ r2,r′
 2 ≤ n −1,r2= r′
 2,1 ≤ r3 ≤ n−k +1
 V6 = f[r1,r′
 1,r2,r3] : 0 ≤ r1,r′
 1 ≤ k−1,0 ≤ r2 ≤ n−1,1 ≤ r3 ≤ n−k+1,r′
 1= r2+r3 mod n
 V7 = g[j,j′] : 1 ≤ j ≤ m,1 ≤ j′ ≤ mj
 In the desription of V7, the integers mj are bounded by a polynomial in n and k of
 degree a function of s which will be described below. Note that since s is a xed constant
 independent of k, this is allowed by our denition of reduction for parameterized problems.
 For convenience we distinguish the following sets of vertices.
 A(r1) = a[r1,r2] : 0 ≤ r2 ≤ n−1
 B(r1) = b[r1,r2,r3] : 0 ≤ r2 ≤ n −1,1 ≤ r3 ≤ n−k +1
 B(r1,r2) = b[r1,r2,r3] : 1 ≤ r3 ≤ n − k +1
 The edge set E of G is the union of the following sets of edges. In these descriptions we
 implicitly quantify over all possible indices for the vertex sets V1,,V7.
 E1 =a[r1,q]c[r1,r2,r′
 2] : q = r2 or q = r′
 2
 E2 =b[r1,q2,q3]d[r1,r2,r′
 2,r3,r′
 3] : either (q2 = r2 and q3 = r3) or (q2 = r′
 2 and q3 = r′
 3)
 E3 =a[r1,r2]e[r1,r2,q,q′]
 E4 =b[r1,q,q′]e[r1,r2,q,q′]
 E5 =b[r1,r2,r3]f[r1,r′
 1,r2,r3]
 E6 =a[r1 +1 mod n,r′
 1]f[r1,r′
 1,r2,r3]
 10
We say that a red vertex a[r1,r2] represents the possibility that the boolean variable
 xr2 
may evaluate to true (corresponding to the possibility that a[r1,r2] may belong to a 2k
element nonblocking set V ′ in G). Similarly, we say that a red vertex b[r1,r2,r3] represents
 the possibility that the boolean variables xr2+1,,xr2+r3−1 (with indices reduced mod n) may
 evaluate to false.
 Suppose C is a clause of X having s literals. There are O(n2s) distinct ways of choosing,
 for each literal l ∈ C, a single vertex representative of the possibility that l = xi may evaluate
 to false, in the case that l is a positive literal, or in the case that l is a negative literal l = ¬xi,
 a representative of the possibility that xi may evaluate to true. For each clause Cj of X,
 j =1,,m, let R(j,1),R(j,2),,R(j,mj) be an enumeration of the distinct possibilities for
 such a set of representatives. We have the additional sets of edges for the clause components
 of G:
 E7 =a[r1,r2]g[j,j′] : a[r1,r2] ∈ R(j,j′)
 E8 =b[r1,r2,r3]g[j,j′] : b[r1,r2,r3] ∈ R(j,j′)
 Suppose X has a satisfying truth assigment τ of weight k, with variables xi0
 ,xi1
 ,,xik−1
 assigned the value true. Suppose i0 < i2 <  < ik−1. Let dr = ir+1(modk) − ir (mod n) for
 r =0,,k − 1. It is straightforward to verify that the set of 2k vertices
 N =a[r,ir] : 0 ≤ r ≤ k−1b[r,ir,dr] : 0 ≤ r ≤ k −1
 is a nonblocking set in G.
 Conversely, suppose N is a 2k-element nonblocking set in G. It is straightforward to
 check that a truth assignment for X of weight k is described by setting those variables true
 for which a vertex representative of this possibility belongs to N, and by setting all other
 variables to false.
 Note that the edges of the sets E1 (E2) which connect pairs of distinct vertices of A(r1)
 (B(r1)) to blue vertices of degree two, enforce that any 2k-element nonblocking set must
 contain exactly one vertex from each of the sets A(0),B(0),A(1),B(1),,A(k−1),B(k−1).
 The edges of E3 and E4 enforce (again by connections to blue vertices of degree two) that
 if a representative of the possibility that xi evaluates to true is selected for a nonblocking
 set from A(r1), then a vertex in the ith row of B(r1) must be selected as well, representing
 (consistently) the interval of variables set false (by increasing index modn) until the next
 variable selected to be true. The edges of E5 and E6 insure consistency between the selection
 in A(r1) and the selection in A(r1 + 1 mod n). The edges of E7 and E8 insure that a
 consistent selection can be nonblocking if and only if it does not happen that there is a set
 of representatives for a clause witnessing that every literal in the clause evaluates to false.
 (There is a blue vertex for every such possible set of representatives.)
 2
 Proof of Prop. 3.2. Let C be a circuit of weft t for t odd, t ≥ 3. By Theorem 4.1 of [DF2]
 we may assume that C is represented by a boolean expression E0 that is in (alternating)
 11
product-of-sums-of-products... form (for t alternations). The rst level of the circuit below
 the inputs consists of And gates (since t is odd).
 Suppose the inputs to C are x1,,xn. Let X1 be the boolean expression with single
literal clauses X1 = (x1)(x2)···(xn) and let G be the graph constructed from X1 by the
 reduction in the lemma above. Let y1,,yz be new variables, one for each red vertex in G.
 Let E1 be the boolean expression
 E1 = ∏
 u∈(Vblue−V7)
 and let C1 be a circuit realizing E1.
 We modify C in the following ways:
 ∑
 yi∈N[u]
 ¬yi
 (1) Each positive fan-out from an input xi to C is replaced by an And gate receiving negated
 inputs from all of the new input variables yj for which the corresponding red vertices of G
 represent the possibility that xi evaluates to false.
 (2) Each negated fan-out from an input xi to C is replaced by an And gate receiving negated
 inputs from all of the new input variables yj for which the corresponding red vertices of G
 represent the possibility that xi evaluates to true.
 (3) The circuit C1 is conjunctively combined with C at the bottommost (output) And gate.
 The circuit C′ obtained in this way accepts a weight 2k input vector if and only if C
 accepts a weight k input vector. The argument for correctness is essentially the same as for
 Lemma 3.1. The circuit C′ has weft t after the And gates replacing the former inputs are
 coalesced with the And gates of the topmost large gate level (this is feasible, since t is odd).
 All of the input fan-out lines of C′ are negated.
 2
 Lemma 3.1 provides the starting point for demonstrating the following collapse of the
 W[1] stratication.
 Proposition 3.3. W[1] = W[1,2]
 Proof. It suces to argue that for all s ≥ 2, antimonotone W[1,s] = W[1,2]. The ar
gument here consists of another change of variables. Let C be an antimonotone W[1,s]
 circuit for which we wish to determine whether a weight k input vector is accepted. We
 show how to produce a circuit C′ corresponding to an expression in conjunctive normal form
 with clause size two, that accepts an input vector of weight
 s
 k′ = k2k +
 ∑
 i=2
 (
 )
 k
 i
 if and only if C accepts an input vector of weight k. (The circuit C′ will in general not
 be antimonotone, but this is immaterial by Lemma 3.1. Actually in [DEF] we use another
 reduction that only needs k′ = ks+1 + s
 i=2
 k
 i
  
and is hence polynomial in k for a xed s.)
 12
Let x[j] for j = 1,n be the input variables to C. The idea is to create new variables
 representing all possible sets of at most s and at least 2 of the variables x[j]. Let A1,,Ap
 be an enumeration of all such subsets of the input variables x[j] to C. The inputs to each
 or gate g in C (all negated, since C is antimonotone) are precisely the elements of some Ai.
 The new input corresponding to Ai represents that all of the variables whose negations are
 inputs to the gate g have the value true. Thus in the construction of C′, the or gate g is
 replaced by the negation of the corresponding new collective input variable.
 We introduce new input variables of the following kinds:
 (1) One new input variable v[i] for each set Ai for i = 1,,p, to be used as above.
 (2) For each x[j] we introduce 2k copies x[j,0],x[j,1],x[j,2],,x[j,2k − 1].
 In addition to replacing the or gates of C as described above, we add to the circuit
 additional or gates of fan-in 2 that provide an enforcement mechanism for the change of
 variables. The necessary requirements can be easily expressed in conjunctive normal form
 with clause size two, and thus can be incorporated into a W[1,2] circuit.
 We require the following implications concerning the new variables:
 (1) The n·2k implications, for j = 1,,n and r = 0,,2k − 1,
 x[j, r] ⇒ x[j,r + 1 (mod 2k)]
 (2) For each containment Ai ⊆ Ai′, the implication
 v[i′] ⇒ v[i]
 (3) For each membership x[j] ∈ Ai, the implication
 v[i] ⇒ x[j,0]
 It may be seen that this transformation may increase the size of the circuit by a lin
ear factor exponential in k. We make the following argument for the correctness of the
 transformation.
 If C accepts a weight k input vector, then setting the corresponding copies x[i,j] among
 the new input variables accordingly, together with appropriate settings for the the new
 collective variables v[i] yields a vector of weight k′ that is accepted by C′.
 For the other direction, suppose C′ accepts a vector of weight k′. Because of the impli
cations in (1) above, exactly k sets of copies of inputs to C must have value 1 in the accepted
 input vector (since there are 2k copies in each set). Because of the implications described in
 (2) and (3) above, the variables v[i] must have values in the accepted input vector compatible
 with the values of the sets of copies. By the construction of C′, this implies there is a weight
 k input vector accepted by C.
 13
 2
We have now done most of the work required to show that the following well- known
 problems are complete for W[1].
 INDEPENDENT SET
 Instance: A graph G = (V,E) and a positive integer k.
 Question: Is there a set V ′ ⊆ V of cardinality k, such that ∀u,v ∈ V′, uv  ∈ E?
 CLIQUE
 Instance: A graph G = (V,E) and a positive integer k.
 Question: Is there a set of k vertices V ′ ⊆ V that forms a complete subgraph of G (that is,
 a clique of size k)?
 Theorem 3.1. INDEPENDENT SET is complete for W[1].
 Proof. It is easy to observe that INDEPENDENT SET belongs to W[1]. By Lemma 3.1
 and Theorem 3.1 it is enough to argue that INDEPENDENT SET is hard for antimonotone
 W[1,2]. Given a boolean expression X in conjuctive normal form (product of sums) with
 clause size two and all literals negated, we may form a graph GX with one vertex for each
 variable of X, and having an edge between each pair of vertices corresponding to variables
 in a clause. The graph GX has an independent set of size k if and only if X has a weight k
 truth assignment.
 Corollary 3.2 CLIQUE is complete for W[1].
 2
 Proof. This follows immediately by considering the complement of a given graph. The
 complement has an independent set of size k if and only if the graph has a clique of size k.
 2
 4. Problems Hard for W[1]
 In this section we show that the following problems are hard for W[1]. None of them
 is presently known to belong to W[1]. We conjecture that the rst two problems, which are
 shown to be equivalent with respect to uniform reductions, and to belong to W[2], are of
 diculty intermediate between W[1] and W[2].
 PERFECT CODE
 Instance: A graph G = (V,E) and a positive integer k.
 Question: Does G have a k-element perfect code? A perfect code is a set of vertices V ′ ⊆ V
 with the property that for each vertex v ∈ V there is precisely one vertex in N[v]  V ′.
 WEIGHTED EXACT CNF SATISFIABILITY
 Instance: A boolean expression E in conjuctive normal form, and a positive integer k.
 Question: Is there a truth assignment of weight k to the variables of E that makes exactly
 14
one literal in each clause of E true?
 SIZED SUBSET SUM
 Instance: A list of positive integers L = (x1,x2,,xn), a positive integer S and a positive
 integer k.
 Question: Is there a sublist of L of size k that sums to S?
 Lemma 4.1. PERFECT CODE ∈ W[2].
 Proof. Let G = (V,E) be a graph for which we wish to determine whether G has a k
element perfect code. It suces to show how to eciently construct a boolean expression
 EG in product-of-sums form that has a weight k truth assignment if and only if the graph
 G has a k-element perfect code. Let EG be the expression E = E0E1E2 where the variables
 of EG are in one-to-one correspondence with vertices of G and
 E0 = ∏
 u∈V
 E1 = ∏
 ∑
 x∈N[u]
 (¬u +¬v)
 uv∈E
 E2 = ∏
 uv,vw∈E
 (¬u +¬w)
 If G has a k-element perfect code V ′ ⊆ V, then the truth assignment which sets the variables
 corresponding to the vertices of V ′ true and all others false satises EG, since V ′ is an
 independent set (so that E1 is satised), and V ′ contains no vertices at a distance 2 from
 each other in G (so that E2 is satised), and yet V ′ is dominating set (so that E2 is satised).
 Conversely, any satisfying truth assignment for EG of weight k must satisfy each of of these
 subproducts, and therefore the vertices corresponding to the variables set to true must be a
 perfect code in G.
 2
 Lemma 4.2. PERFECT CODE reduces to WEIGHTED EXACT CNF SATISFIABILITY.
 Proof. A graph G has a k-element perfect code if and only if the expression E0 constructed
 as in Lemma 5.1 has a weight k truth assignment that makes exactly one literal in each
 clause true.
 2
 Lemma 4.3. WEIGHTED EXACT CNF SATISFIABILITY reduces to PERFECT CODE.
 Proof. The reduction can be demonstrated using the transformation used in the proof of The
orem 3.1 of [DF1] (which is there used to reduce Weighted Satisability to DOMINATING
 SET).
 2
 Lemma 4.4. PERFECT CODE reduces to SIZED SUBSET SUM.
 15
Proof. Let G = (V,E) be a graph for which we wish to determine whether G has a perfect
 code of size k. Suppose for convenience that the vertex set of the graph V = 0,,n − 1.
 We can easily compute the list of positive integers L = (x[i,j] : 1 ≤ i ≤ k, 0 ≤ j ≤ n − 1)
 and the positive integer M, where
 x[i, j] = (k + 1)n+k−i + ∑
 u∈N[j]
 n+k−1
 ∑
 M =
 t=0
 (k +1)t
 (k +1)u
 such that L has a sublist of size k summing to M if and only if G has a k-element perfect
 code. The correctness of this transformation is easily observed if the numbers of L are
 represented in base k +1, and it is noted that there can be no carries in a sum of k integers
 from L expressed in this way.
 2
 Theorem 4.1. PERFECT CODE is hard for W[1].
 Proof. We reduce from INDEPENDENT SET. Let G = (V,E) be a graph. We show
 how to produce a graph H = (V′,E′) that has a perfect code of size k′ =
 
 
 k
 2
 +k+1 if and
 only if G has a k-element independent set. The vertex set V ′ of H is the union of the sets
 of vertices:
 V1 = a[s] : 0 ≤ s ≤ 2
 V2 = b[i] : 1 ≤ i ≤ k
 V3 = c[i] : 1 ≤ i ≤ k
 V4 = d[i,u] : 1 ≤ i ≤ k,u ∈ V
 V5 = e[i,j,u] : 1 ≤ i < j ≤ k,u ∈ V
 V6 = f[i,j,u,v] : 1 ≤ i < j ≤ k, u,v ∈ V
 The edge set E′ of H is the union of the sets of edges:
 E1 =a[0]a[i] : i = 1,2
 E2 =a[0]b[i] : 1 ≤ i ≤ k
 E3 =b[i]c[i] : 1 ≤ i ≤ k
 E4 =c[i]d[i,u] : 1 ≤ i ≤ k,u ∈ V
 E5 =d[i,u]d[i,v] : 1 ≤ i ≤ k, u,v ∈ V
 E6 =d[i,u]e[i,j,u] : 1 ≤ i < j ≤ k,u ∈ V
 E7 =d[j,v]e[i,j,u] : 1 ≤ i < j ≤ k,v ∈ N[u]
 E8 =e[i,j,x]f[i,j,u,v] : 1 ≤ i < j ≤ k,x= u,x  ∈ N[v]
 E9 =f[i,j,u,v]f[i,j,x,y] : 1 ≤ i < j ≤ k,u= x or v= y
 An overview of this construction is given in Diagram 2 and a (partial) example is given
 in Diagram 3. Suppose C is a perfect code of size k′ in H. Since a[1] and a[2] are pendant
 vertices attached to a[0], neither vertex belongs to C because both cannot belong to C, and
 if only one belongs to C, then C fails to be a dominating set. It follows that a[0] ∈ C. This
 16
implies that none of the vertices in V2 and V3 belong to C (V3 would kill V2), and it implies
 also that exactly one vertex in each of the cliques formed by the edges of E5 belongs to C
 (to cover V3). Note that each of these k cliques has n vertices indexed by V , the vertex set
 of G (this is the selection gadget). Let I be the set of vertices of G corresponding to the
 elements of C in these cliques. We argue that I is an independent set of order k in G.
 Suppose u,v ∈ I and that uv ∈ E. Then there are indices i < j between 1 and k such
 that (without losss of generality) d[i,u] ∈ C and d[j,v] ∈ C. By the denition of E6 and E7
 each of these vertices is adjacent to e[i,j,u], which contradicts that C is a perfect code in
 H. Thus I is an independent set in G.
 Conversely, we argue that if J = u1,,uk is a k-element independent set in G, then
 H has a perfect code CJ of size k′. We may take CJ to be the following set of vertices:
 CJ =a[0] d[i,ui] : 1 ≤ i ≤ kf[i,j,ui,uj] : 1 ≤ i,j ≤ k
 That CJ is a perfect code can be veried directly from the denition of H.
 2
 By Lemmas 4.2, 4.4 and the above theorem we have the following hardness results as
 well.
 Theorem 4.2 WEIGHTED EXACT CNF SATISFIABILITY is hard for W[1].
 Theorem 4.3 SIZED SUBSET SUM is hard for W[1].
 2
 2
 One problem that we are quite interested in is the natural analogue of Travelling Sales
person:
 SHORT CHEAP TOUR
 Instance: A weighted graph and positive integers S and k.
 Question: Is there a tour through at least k vertices of cost at most S?
 The precise diculty of this problem is at present open but a variation is hard for W[1].
 Let SHORT EXACT TOUR be the same as SHORT CHEAP TOUR except that we ask
 that the tour costs exactly S.
 Theorem 4.4 SHORT EXACT TOUR is hard for W[1].
 Proof. Let (L,S,k) be an instance of sized subset sum,with L = x1,,xn. Construct a
 graph G as follows: For each xi we have two vertices yi and zi . Join yi to zi with an edge of
 weight xi. Let d exceed x1 +  + xn. For i not equal to j join yi to zj. Give all such edges
 weight d. Now ask if G has a 2k vertex tour of weight S +kd?
 2
 The reader should note that the natural analogue of HAMILTON CIRCUIT which asks
 17
if there is a cycle through k or more vertices is strongly uniformly xed parameter tractable
 (Bodlaender), but it is unknown if the problem of determining if there is a cycle of size
 exactly k is also tractable. (See [JvL,section 2.4.3]).
 As a nal example, we remark that the reduction of [DF2] can be used to show that the
 following problem is also hard for W[1].
 WEIGHTED EXACT BINARY INTEGER PROGRAMMING
 Instance: A binary vector b, a binary matrix A and an integer k.
 Question: Is there a binary vector x of weight k such that Ax equals b?
 5. Open Problems
 The study of xed-parameter tractability and completeness can be viewed as addressing
 aspects of the the general subject of computational infeasibility inside of P. For related
 work examining limited ammounts of nondeterminism see [BG]. Many familiar issues in
 complexity theory have unexplored analogues in the xed-parameter setting (such as parallel
 and randomized complexity, one-way functions, and approximation). A number of basic
 structural questions concerning the W hierarchy have yet to be resolved. For example,
 while it is known a collapse of the W hierarchy implies a collapse involving more familiar
 unparameterized complexity classes ([ADF2]), the exact relationship is unknown.
 A wide variety of natural parameterized problems may well be complete for various
 levels of the W hierarchy. Well-known natural problems for which neither xed-parameter
 tractability nor W[t] hardness is presently known include: DIRECTED FEEDBACK VER
TEXSET, GRAPHTOPLOGICALCONTAINMENTandIMMERSIONORDERING(the
 parameters in the last two problems being a xed Graph.) (for the denitions, see [GJ]).
 6. Addendum 7 Feb 1994
 Since the original writing of this paper, there has benn quite a bit of activity regarding
 W[1] and it is clear that this is probably the most important class one can use to establish
 xed parameter intractability along the lines of establishing intractability via NP com
pleteness. Particularly strong evidence for the intractability of W[1] is given in Cai, Chen,
 Downey, and Fellows [CCDF] where it is established that the following very generic problem
 is W[1] complete:
 SHORT TURING MACHINE COMPUTATION
 Input: A Nondeterministic Turing Machine M and a string x.
 Parameter: k.
 Question: Does M have a length k computation path accepting x?
 This problem is particularly signigant as it proves a sort of Cooks theorem in a pa
18
rameterized setting. Many other problems have been shown to be W[1] complete. We quote
 a couple. In [CCDF] it is also proven that the following are W[1] complete:
 SHORT DERIVATION (for unrestricted grammars)
 Input: A phrase-structure grammar G and a word x.
 Parameter: k
 Question: Is there a G derivation of x of length k?
 SHORT POST CORRESPONDENCE
 Input: A Post Correspondence System Π.
 Parameter: k
 Question: Is there a length k solution for Π?
 Downey, Fellows, Kapron, Hallett, and Wareham [DFKHW] proved that the following
 problem is W[1] complete:
 SHORT CSL DERIVATION
 Input: A context sensitive grammar G and a word x ∈ Σ∗.
 Parameter: k
 Question: Is there a G derivation of x of length at most k?
 Downey and Fellows proved that some parameterized versions of embedding questions
 turn out to be W[1] complete. For instance from [DF7] we have the following being W[1]
 complete.
 SEMIGROUP EMBEDDING
 Input: A semigroup G.
 Parameter: A semigroup H.
 Question: Is H embeddable into G?
 SEMILATTICE EMBEDDING
 Input: A semialttice S.
 Parameter: A semialttice L.
 Question: Is L embeddable into S?
 BIPARTITE GRAPH EMBEDDING
 Input: A bipartite graph G.
 Parameter: A bipatrite graph H.
 Question: Is H embeddable into G?
 Another area that has found W[1] complete problems is that of Computational Learning
 Theory. Consider the following problem which is the most important parameter in learning
 theory.
 19
VAPNIK CHERVONENKIS DIMENSION
 Input: A family F of subsets of a base set X.
 Parameter: k.
 Question: Is the VC-dimension of F at least k?
 In [DEF], the authors together with P. Evans proved that VAPNIK-CHERVONENKIS
 DIMENSIONishardfor W[1], and hence combined with membership of W[1] which is proven
 in Downey-Fellows [DF5], we see that this problem is W[1] complete. We remark that this
 is very interesting since the unparameterized version is highly unlikely to be NP-complete
 unless NP is very small. See, Papadimitriou and Yannakakis [PY].
 Finally we mention some problems that are W[1] complete arizing from molecular biol
ogy, which is a particularly fertile area of applications for this theory in view of the fact that
 many problems have small parameters (such as the number of strands of DNA) yet large
 problem size.
 LONGEST COMMON SUBSEQUENCE
 Input: A set of k strings X1,,Xk over Σ∗.
 Parameter[1]: k.
 Parameter[2]: m.
 Parameter[3]: m, k.
 Question: Is there a string X ∈ Σ∗ that has at least m symbols that is a subsequence of
 X1,, Xk?
 In Bodlaender, Downey, Fellows, and Wareham [BDFW] it is shown that all of the vari
ations LCS[i] (with the obvious meanings) are W[1] hard, and that LCS[3] is W[1] complete.
 We conclude by remarking that there have beeen very many other problems which have
 been proven to be W[1] hard and even complete for other levels of the W-hierarchy. Partial
 lists can be found in [DF2] and [DF4].
 20
References
 [ADF1] K. A. Abrahamson, R.G. Downey andM.F.Fellows, Fixed-Parameter Intractability
 II, In STACS93 (1993) Springer-Verlag Lecture Notes in Computer Science, 374-385.
 [ADF2] K. A. Abrahamson, R. G. Downey, and M. R. Fellows, Fixed-Parameter Tractability
 and Completeness IV: On Completeness for W[P] and PSPACE Analogues, to appear,
 Annals of Pure and Applied Logic.
 [BG] J. F. Buss and J. Goldsmith, Nondeterminism Within P, SIAM J of Comput. 22
 (1993) 560-572.
 [Bo] H. L. Bodlaender, On Disjoint Cycles, Technical Report RUU-CS-90-29, Dept. of
 Computer Science, Utrecht University, Utrecht, The Netherlands, August 1990.
 [BDFW] H. L. Bodlaender, R. G. Downey, M. R. Fellows, and H. Todd Wareham,The
 Parameterized Complexity of Sequence Alignment and Concensus, In Proceedings Combi
natorial Pattern Matching, Asilomar, 1994, to appear.
 [CCDF] L. Cai, J. Chen, R. G. Downey and M. F. Fellows,The Parameterized Complexity
 of Short Computation and Factorization, submitted.
 [DEF] R. G. Downey, P. Evans, and M. F. Fellows,Parameterized Learning Complexity,in
 COLT93 (6 th Annual Conference on Learning Theory, 1993) IEEE publ. 51-57.
 [DF1] R. G. Downey and M. R. Fellows, Fixed-Parameter Tractability and Completeness,
 Cong. Numer. 87 (1992) 161-187.
 [DF2] R. G. Downey and M. R. Fellows, Fixed-Parameter Tractability and Completeness
 I: Basic Results, to appear SIAM J. of Comput.
 [DF3] R. G. Downey and M. R. Fellows, Fixed-Parameter Tractability and Completeness
 III: Some Structural Aspects of the W-Hierarchy, in Complexity Theory, (ed. K. Ambos
Spies, S. Homer, and U. Sch/oing), Cambridge University Press, (1993) 166-191.
 [DF4] R. G. Downey and M. F. Fellows,Fixed-Parameter Intractability, Proceedings 7th
 Annual Structure in Complexity (1992) 36-49.
 [DF5] R. G. Downey and M. F. Fellows,Parameterized Computational Feasibility,in Fea
sible Mathematics II, (ed. P. Clote and J. Remmel) Birkhauser, Boston, to appear.
 [DF6] R. G. Downey and M.F.Fellows,Parameterized Complexity Monograph in preparation.
 [DF7] R. G. Downey and M. F. Fellows,Fixed-Parameter Tractability and Intractability-a
 21
Survey, in preparation.
 [FL1] M. R. Fellows and M. A. Langston, On Search, Decision and the Eciency of
 Polynomial-Time Algorithms. In Proc. Symp. on Theory of Computing (STOC) (1989),
 501-512.
 [FL2] M. R. Fellows and M. A. Langston, An Analogue of the Myhill-Nerode Theorem
 and Its Use in Computing Finite Basis Characterizations. In Proc. Symp. Foundations of
 Comp. Sci. (FOCS) (1989), 520-525.
 [GJ] M. R. Garey and D. S. Johnson, Computers and Intractability: A Guide to the Theory
 of NP-Completeness (Freeman, San Francisco, 1979).
 [PY] C. Papadimitriou and M. Yannakakis,On limited Nondeterminism and the Complexity
 of the VC-Dimension,in Proceedings 8th Annual Structure in Complexity Conference, IEEE
 Publ. (1993) 12-18.
 [RS1] N. Robertson and P. D. Seymour, Graph Minors XIII. The Disjoint Paths Problem,
 to appear.
 [RS2] N. Robertson and P. D. Seymour, Graph Minors XV. Wagners Conjecture, to
 appear.
 [JvL] J. van Leeuwen, Graph Algorithms. in Handbook of Theoretical Computer Science,
 Volume A (ed J. van Leeuwen) Elsevier Science Publishers B.V.,The Netherlands (1990),
 525-632.
 2