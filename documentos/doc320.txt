UNIVERSIDADE DE SÃO PAULO 
Instituto de Física de São Carlos 
Estêvão Vilas Boas de Oliveira 
Computação Quântica com o IBM Q Experience 
Trabalho de conclusão de curso apresentado ao Programa de Graduação em Física do Instituto de Física de São Carlos da Universidade de São Paulo, para obtenção do título de Bacharel em Física 
Orientador: Prof. Dr. Frederico Borges de Brito 
São Carlos 
2019
Resumo 
Este projeto teve como objetivo inicial um estudo dos elementos fundamentais da computação quântica, bem como a familiarização com a implementação de circuitos quânticos simples utilizando a plataforma de acesso público da IBM, a IBM Q Experience1. Assim, propomos aqui a elaboração de algoritimo quântico, que caracteriza-se de uma calculadora simples para a realização do procedi mento de soma entre dois números de 1 qbit, cuja aplicação, tanto em um dispositivo quântico real quanto em um simulador clássico que implementa um computador quântico ideal, serviu para uma análise mais geral de certos aspectos da computação quântica. A partir desta análise constatou-se a origem de erros quânticos intrínsecos à implementação física do problema em questão. Ainda, está incluído neste trabalho uma apresentação sucinta do Algoritimo de Shor como forma de estabelecer um comparativo entre ele e o código aqui proposto, no que diz respeito à exploração efetivamente vantajosa das propriedades da mecânica quântica para a computação. 
1 Introdução Teórica 
Nesta seção serão apresentados, de maneira sucinta, apenas alguns conceitos essenciais para o entendimento deste projeto, tendo como base os postulados e fundamentos da mecânica quântica. 
1.1 Introdução à mecânica quântica 
O primeiro conceito a ser introduzido é o conceito de vetor de estado, pertencente à um espaço de estados contido no espaço de Hilbert, como representação de um sistema físico. Aqui o sistema físico de interesse, o qbit, apresenta um espaço de estados bidimensional com base ortonormal {|0�, |1�}. Qualquer vetor estado |Ψ� nesse espaço de estados pode ser representado como um estado de super posição entre os vetores da base da forma 
|Ψ� = a |0� + b |1�, (1) 
com a2 + b2 = 1 sendo a condição de normalização, e 
|0� = 
� 
1 
0 
� 
, e |1� = 
� 
0 
1 
� 
(2) 
na notação matricial. Ainda, podemos gerar estados compostos de dois ou mais qbits, da forma |Ψt� = |Ψ0� ⊗ |Ψ1� ⊗ ... ⊗ |Ψn�, (3) 
com o espaço de estados 2n-dimensional. 
1
A evolução temporal de |Ψ� é dada por uma operação unitária U tal que 
|Ψ(t2)� = U(t1, t2)|Ψ(t1)�, (4) 
e a unitariedade de U preserva a norma de |Ψ� uma vez que 
�Ψ|Ψ� = �Ψ(t)|Ψ(t)� = �Ψ| U† · U |Ψ� = 1 =⇒ U† · U = Id, (5) 
em que Id é o operador identidade, definido como sendo a matriz identidade de dimensão nxn, em que n é a dimensão do espaço vetorial. Para um sistema de 1 qbit temos 
Id = 
� 
1 0 
0 1
� 
. (6) 
A operação unitária U é obtida a partir da equação de Schrödinger 
i� ∂∂t|Ψ� = H |Ψ�, (7) 
e se o operador Hamiltoniano H do sistema não depende explicitamente do tempo temos2;3 
U(t1, t2) = exp
�−iH(t2 − t1) � 
� 
(8) 
Em computação quântica a base ortonormal do espaço de estados apresentada é definida como sendo a base computacional 2 ou base z, uma vez que os vetores de estado da base são auto-vetores da 
matriz de Pauli Z, definida como 
Z = 
� 
1 0 
0 −1 
� 
. (9) 
Introduziremos, agora, uma apresentação alternativa à descrição de um sistema físico em termos dos vetores de estado: a matriz densidade, ou operador densidade ρ, definido como 
ρ = � i 
pi |Ψi��Ψi| , (10) 
em que pi é a probabilidade de o sistema estar no estado |Ψi�. Esta formulação é útil para descrever um ensemble de estados quântico, pois sua formulação evidencia o caráter estatístico do problema físico já que os elementos de matriz da diagonal principal representam as probabilidades clássicas dos resultados de medidas feitas no estado |Ψ�. Uma consequência disso é o traço de ρ ser igual à 
2
unidade. Para o estado puro dado segundo a equação 1 temos � 
ρ = a2 |0��0| + ab |0��1| + ab |1��0| + b2 |1��1| = 
a2 ab ab b2 
� 
, (11) 
e ainda, os termos fora da diagonal principal estão relacionados à coerência do estado quântico3. Analogamente ao vetor de estado |Ψ�, a evolução temporal da matriz densidade ρ é dada, também, através da operação unitária U da forma 
ρ(t) = |Ψ(t)��Ψ(t)| = U |Ψ��Ψ| U† = UρU† (12) 
1.2 Introdução à computação quântica 
A computação quântica, em analogia à computação clássica, é construída a partir de um circuito quântico composto por objetos que carregam e manipulam a informação quântica. Munidos dos conceitos introduzidos anteriormente, podemos, então, definir aqui os instrumentos responsáveis por manipular a informação quântica no processo computacional. Esses objetos são as portas lógicas quânticas e são definidos como sendo quaisquer operações unitárias agindo no vetor de estado do sistema. 
Serão introduzidas as principais portas lógicas quânticas utilizadas na composição dos algoritimos quânticos deste trabalho. Além das operações Id e Z definidas nas equações (6) e (9), definimos as seguintes portas lógicas de 1 qbit: 
Matriz de Pauli X dada por 
X = 1√2 
� 
0 1 
1 0
� 
=⇒ 
�|0� → |1� 
|1� → |0�, (13) 
cuja operação é inverter o vetor de estado; A porta Hadamard 
� 
� 
=⇒ H |i� = |0� + (−1)i |1� 
H = 1√2 
1 1 1 −1 
√2 , (14) 
cuja atuação cria um estado de superposição entre os vetores de estado da base com igual amplitude de probabilidade; 
E a operação Ry(θ) 
� 
Ry(θ) = 
cos θ2 sin θ2 sin θ2 cos θ2 
� 
, (15) 
que representa um rotação de θ do vetor de estado ao redor do eixo y. 3
Defindo as operações de 2 qbits temos a porta lógica CNOT, ou "não controlado" UCNc→t , em que c representa o qbit de controle e t o qbit alvo. Sua atuação varia o estado do qbit alvo dependendo do valor do qbit de controle 
UCNc→t = 
 
1 0 0 0 
0 1 0 0 0 0 0 1 0 0 1 0 
 
 =⇒ 
  
|00� → |00� |01� → |01� |10� → |11� |11� → |10� 
; (16) 
A porta lógica de troca ou swap Sw 
Sw = 
que opera trocando os estados dos dois qbits. 
 
1 0 0 0 
0 0 1 0 0 1 0 0 0 0 0 1 
 
, (17) 
Por fim, definimos a porta lógica Toffoli UTc,c→t de 3 qbits, sendo dois deles qbits de controle e o último sendo o alvo, da forma 
UTc,c→t = 
 
1 0 0 0 0 0 0 0 
0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 
 
, (18) 
que de maneira análoga à porta CNOT, atua mudando o estado do qbit alvo dependo do valor dos qbits de controle. 
2 Materiais e métodos 
Nesta seção será apresentado um breve resumo sobre a plataforma online da IBM para computa ção quântica, a IBM-Q Experience 1, utilizada para o processamento dos algoritimos quânticos aqui propostos, bem como, para a aquisição de todos os dados. A plataforma é aberta e exige apenas um cadastro inicial e verificação de conta para sua utilização e oferece uma interface gráfica para a cria ção de circuitos quânticos, mostrada na figura 1, bem como a possibilidade processá-los, através de uma submissão online, em computadores quânticos reais dos laboratórios de pesquisa da IBM. 
4
  

Figura 1 – Interface gráfica utilizada para a criação de circuitos quânticos. 
Fonte: IBM Q1 
Da figura 1 vemos que as 3 primeiras linhas (q[0] à q[2]) correspondem cada uma a um regis tro quântico configurado com um estado inicial default de entrada |0�. A última linha (c3 no caso da gravura acima) corresponde à um registro clássico das medições dos qbits, sendo cada registro quântico relacionado à 1 bit no registro clássico. Cada ícone na figura corresponde à alguma porta lógica quântica ou à alguma operação. A montagem do circuito é feita clicando-se nos ícones, cor respondentes às portas lógicas ou operações que se deseja implementar, e arrastando-os até a posição desejada nos registros quânticos, de modo que a sua ordem, da esquerda para a direita, representam linhas de comando. Em todos os algoritimos criados aqui utilizaremos as portas lógicas quânticas, já introduzidas na seção 1.2, e operações ilustradas na figura 2 
  
  
  
  

  
  
  
  
  
  
  
  

(a) Identidade (b) Pauli X (c) Hadamard (d) Rotação y 
(e) CNOT (f) Troca (g) Toffoli (h) Medidor clássico 
Figura 2 – Ícones e representações referentes às portas lógicas quânticas de um, dois e três qbits utilizadas e à operação de medição na base computacional Z quânticos 
Fonte: IBM Q1 
A operação de medição, ilustrada na figura 2(h), é definida como sendo a medição dos qbits na base computacional, ou seja, a base Z. A operação de medição converte o valor obtido para os estados quânticos dos qbits em bits, e armazena no registro clássico, em que o primeiro qbit (referente ao 
5
registro q[0]) é o primeiro dígito (menor base de 2) do número binário no registro clássico, e assim por diante, de modo que o resultado da medição do estado |110� seria o número binário 011, por exemplo. 
A submissão online dos códigos pode ser feita clicando-se no ícone "Run", mostrado na figura 1, e em seguida, ajustando-se as condições do experimento, de acordo com a figura 3 
  

	



Figura 3 – Tela de ajuste das opções do experimento, sendo elas a escolha do computador quântico à processar o código, e o número de vezes que esse código será processado 
Fonte: IBM Q1 
A primeira opção consiste na escolha de qual dispositivo da IBM deseja-se processar o circuito quântico. Dentre estes, estão alguns computadores quânticos e também um simulador clássico sendo este último um dispositivo que implementa um computador quântico ideal, ou seja, aquele constituído de um sistema quântico perfeitamente isolado, não apresentando, portanto, erros quânticos relacio nados à processos de dissipação e descoerência. Diferentemente, os dispositivos quânticos reais são susceptíveis à tais erros e uma discussão mais detalhada das implicações disto será dada mais adiante, na seção 3. 
A segunda opção consiste na escolha do número de vezes que o código será executado, sendo, num contexto ideal, cada execução equivalente à uma idêntica* preparação, manipulação e medição de n sistemas quânticos com as mesmas características, podendo, n ser 1, 1024, 4096 ou 8196, segundo as opções da plataforma, e neste trabalho a utilização dos termos, "número de medições" , "quantidades de medidas tomadas", ou sinônimos, se referirão à esse aspecto. Destaca-se ainda que a opção permite uma melhora na precisão estatística dos resultados das aferições do circuito quântico proposto, e uma explicação mais detalhada disto será dada, também, na seção 3. 
Ao final os resultados dos experimentos são dados na forma de um histograma das possíveis respostas de uma medição dos qbits do circuito elaborado. Entretanto, por uma questão de clareza os resultados serão apresentados em histogramas personalizados elaborados utilizando o software Mathematica 11.34. 
* É importante ressaltar que em um contexto não ideal existe uma limitação experimental associada à essa condição de construção de sistemas idênticos, o que também levará à erros. 
6
Foram utilizados para executar os códigos, além do simulador clássico, os dispositivos quânticos ibmq_5_yorktown-ibmqx2 (v2.0.0) e ibmq_ourense (v1.0.1) com as características definidas se gundo a figura 4, em que as setas ligando os qbits representam a conectividade entre eles, ou seja, como eles interagem entre si. A escala de cores representa o erro associado a cada operação básica realizada, relativa à cada qbit. Ambos apresentam como operações básicas as portas lógicas U1, U2, U3, que atuam como operações de rotações, Cx, que é a operação CNOT, e Id a operação identidade. 
  
(a) ibmq_5_yorktown-ibmqx2 (v2.0.0) (b) ibmq_ourense (v1.0.1) 
Figura 4 – Set-ups dos dispositivos quânticos utilizados no processamento dos circuitos quânticos. As setas representam a conectividade dentre os qbitis e a escala de cores representam os erros de cada qbit com relação às operações dadas 
Fonte: IBM Q1 
A predileção por tais dispositivos se deu, primeiro, pelo fato de que os códigos criados aqui são de no máximo três qbits, e portanto um dispositivo que apresente uma conectividade maior entre esses qbits utilizados seria mais interessante, e , segundo, por uma questão de praticidade visto que a execução de algoritimos respeita uma fila de submissão, sendo tais dispositivos os que apresentavam uma concorrência menor. 
3 Resultados e discussão 
3.1 Algoritimo para a geração de dois qbits emaranhados 
Inicialmente será pautada a construção de um sistema físico mais simples com o intuito de se analisar suas principais características no contexto da mecânica quântica e da computação quântica. Tal construção foi dada pela montagem do seguinte circuito, ilustrado na figura 5 O estado inicial e a atuação das portas Hadamard e CNOT, respectivamente, são dadas por 
|Ψ� = UCNq[0]→q[1] (H ⊗ Id)|Ψ0� = UCNq[0]→q[1] (H ⊗ Id)|00� = |00� + |11� √2 (19) 
7

Figura 5 – Representação do circuito quântico de um sistema de 2 qbits emaranhados Fonte: IBM Q1 
Vemos que o resultado de uma medida no primeiro qbit inevitavelmente revela qual será o resul tado de uma medida no segundo qbit, antes mesmo que essa medida seja realizada. Assim, fazendo-se uma medição do primeiro e segundo qbit respectivamente, os dois únicos possíveis resultados são 00 e 11, ambos com 50% de probabilidade. O código foi processado tanto no simulador clássico quanto num computador quântico, e os resultados para diferentes quantidades de medidas em sistemas iden ticamente preparados são mostrados na figura 6. 
Aqui é interessante notar dois fatores. O primeiro deles está relacionado ao caráter probabilístico da mecânica quântica, se repararmos apenas nas medidas realizadas no simulador, onde vemos que a estatística do problema se torna mais apurada a medida que o espaço amostral (número de medições realizadas em 1, 1024, 4096 ou 8192 sistemas identicamente preparados) aumenta. 
O segundo fator notório são as probabilidades não nulas para os resultados 01 e 10 em uma me dida, presentes nos histogramas referentes ao computador quântico. A ressalva de que, devido à definição do estado |Ψ� na equação (19), seria, num sistema físico ideal impossível obter-se resulta dos de medições diferentes de 00 e 11, nos leva a indagar de onde surgem os erros ligados à essas probabilidades não nulas. 
Conforme mencionado na seção 2 anterior, o simulador implementa um computador quântico ideal, ou seja, um sistema quântico perfeitamente isolado de qualquer meio interagente, e, portanto, não suscetível a processos de dissipação e descoerência, e como podemos constatar os histogramas da primeira coluna não apresenta erros relacionados à tais processos. 
De fato, conforme5 vemos que o ambiente nas vizinhanças de um sistema quântico desempenha um papel crucial nestes processos. Ainda, em6 um modelo quantizado da interação de um sistema quântico com sua vizinhança mostra que até mesmo flutuações do vácuo contribuem com a descoe rência, sendo, então, impossível construir-se um sistema quântico perfeitamente isolado. 
Portanto, diferentemente do simulador, um computador quântico real sempre apresentará erros associados aos processos de dissipação e descoerência, por mais minimizados que sejam. Ainda que presentes, esses erros não impossibilitam o refinamento da estatística do problema (até o limite imposto pelo erro), à medida que espaço amostral aumenta, de maneira similar ao que foi discutido anteriormente, e pode ser visto nos histogramas da segunda coluna na figura 6. 
8

Figura 6 – Histogramas de probabilidades para medidas no sistema de 2qbits emaranhados utilizando tanto um simulador clássico quanto uma máquina real (computador quântico) Fonte: Elaborada pelo autor. 
3.2 Calculadora de soma de 2 registros de 1 qbit 
Aqui propõe-se a implementação de algoritimos quânticos que realizem a operação de soma entre qbits. Os algoritimos aqui propostos são formulados com base em aritmética modular e soma de números binários. Assim, ressalta-se que todos os passos realizados pelos algoritimos quânticos implementados nesta seção poderiam ser realizados, também, em um computador clássico utilizando as portas lógicas clássicas devidas. Sendo assim, a motivação desta proposta é apenas a exploração de algumas propriedades quânticas dos sistemas apresentados, com um viés didático de estudo do tema "computação quântica". 
Nesta implementação configurou-se o algoritimo da seguinte maneira: 
Entrada: Dois registros de 1 qbit, representando os números à serem somados Saída: Um número, de até 2 bits, resultado da soma entre os números da entrada Para isso necessitou-se de 3 registros quânticos iniciais e 2 medidores clássicos, ao final do código. 
9
Cada um dos dois primeiros registros (q[0] e q[1]) é composto de 1 qbit, e o terceiro composto por um estado de ancila. A figura 7 ilustra a montagem do sistema. 

Figura 7 – Representação do circuito quântico de soma de dois registros de 1 qbit Fonte: IBM Q1 
A função do estado de ancila é armazenar o qbit excedente da soma módulo 2. O algoritimo pode ser dividido em 3 partes, ilustradas na figura 7 pelas linhas verticais pontilhadas: 
Primeira parte: Entrada do usuário nos registros q[0] e q[1] dos números que se deseja somar, de modo que o estado inicial é |Ψ� = (U1 |0�) ⊗ (U2 |0�) ⊗ |0�, em que U1 e U2 são quaisquer portas lógicas de 1 qbit; 
Segunda parte: algoritimo de soma representado pelo operador unitário US, dado por US = (Id ⊗ SWq[1]↔q[2]) (UCNq[1]→q[0] ⊗ Id) UTq[0],q[1]→q[2]. Tal algoritimo realiza a operação de soma clássica entre os números representados pelos dois primeiros qbits; 
Terceira parte: Medidores clássicos nos registros q[0] e q[1], nessa ordem. 
Introduziremos agora quatro casos diferentes de entradas no algoritimo quântico, que abrangem todas as possibilidades de soma binária clássica de dois números de 1 bit (0 + 0, 0 + 1, 1 + 0 e 1 + 1). Os circuitos que representam esses casos são dados na figura 8. 
Aqui, a matriz de Pauli X foi usada pra inverter o estado de um dos registros (ou dos dois primeiros registros na figura 8(d)) do estado default |0� para o estado |1�. A resposta obtida na saída de cada circuito dado será dada pela medida dos dois primeiros qbits no estado resultante da atuação do operador US em cada um estados iniciais dados. 
|000� US −−−→ |000� medição −−−−−−→ 00 
|010� US −−−→ |100� medição −−−−−−→ 01 |100� US −−−→ |100� medição −−−−−−→ 01 |110� US −−−→ |011� medição −−−−−−→ 10 
(20) 
Os histogramas resultante de um conjunto de várias medições, por conta do erro experimental, de sistemas igualmente preparados conforme os circuitos ilustrados na figura 8 são mostrados nos gráficos na figura 9. 
10
(a) 0+0 (b) 0+1 
(c) 1+0 (d) 1+1 
Figura 8 – Circuitos (a), (b), (c) e (d) que mostram as diferentes entradas usadas para representar a soma clássica binária de dois números de 1bit, 0 + 0, 0 + 1, 1 + 0 e 1 + 1 respectivamente Fonte: IBM Q1 
Analisando os histogramas dos resultados das medidas utilizando o simulador, para cada um dos casos, vemos que os resultados esperados numa medida, ou seja, o resultado da soma binária clássica para cada um dos casos, aparecem com 100% de probabilidade, seguindo a espectativa. 
Aqui, novamente vemos, no processamento do algoritimo no CQ real, probabilidades não nulas para certos resultados, não esperados em um sistema quântico ideal. Ainda sobre esse aspecto, po demos ver que, diferente do algoritimo para a geração de dois qbits emaranhados, que utiliza apenas duas portas lógicas, a utilização de um número maior de operações no algoritimo de soma (tanto as do próprio operador US em si, quanto àquelas introduzidas pelo usuário) promove um aumento dos erros associados aos processos de decoerência e dissipação, seja pelo número maior de passos ou pelo aumento no tempo de processamento do algoritimo. 
Ainda assim, observamos que as probabilidades de se obter os resultados esperados numa medida, em cada um dos casos, são expressamente majoritárias, tornando satisfatória a implementação do algoritimo, mas ainda longe do limite de uma computação robusta à erro. 
Até agora vemos que o algoritimo implementado, no que diz respeito à inserção da entrada e ob tenção dos resultado, não apresenta, ainda, diferenças com relação à um algoritimo clássico com a mesma função. Assim, exploraremos algumas propriedades quânticas do sistema introduzindo entra das constituídas por estados de superposição. Iniciando o código com |q[0]� e |q[1]� estados arbitrários temos 
|q[0]� = a |0� + b |1�, 
|q[1]� = c |0� + d |1�, (21) 
11

Figura 9 – Histogramas resultantes de um conjunto de 8192 medições para cada um dos circuitos da figura 8. As medidas foram tomadas tanto em um computador quântico (CQ) quanto no simulador clássico. 
Fonte: Elaborada pelo autor. 
com a2 + b2 = c2 + d2 = 1. Portanto, o estado |Ψ� inicial de entrada do algoritimo pode ser representado por |Ψ� = |q[0]� ⊗|q[1]� ⊗|q[2]�, e atribuindo a arbitrariedade dos estados |q[0]� e |q[1]� (entrada do usuário), e mantendo o estado de ancila, temos 
|Ψ� = (a |0� + b |1�) ⊗ (c |0� + d |1�) ⊗ |0� 
= ac |000� + ad |010� + bc |100� + bd |110� (22) 
Aqui será conveniente representar |Ψ� e US na notação matricial. Da definição de US na seção 3.2 e da equação (22), na base computacional, obtemos 
 
, (23) 
US = 
e, 
 
1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 
|Ψ� = 
� 
ac 0 ad 0 bc 0 bd 0 12
�T. (24) 
Para a análise do problema e de sua evolução, ou seja, a atuação do operador US no estado inicial |Ψ� (processamento do algoritimo) será útil a introdução do operador densidade evoluído ρ�, segundo a equação (12) 
ρ� = |Ψ(t)� �Ψ(t)| = US |Ψ� �Ψ| U†S (25) 
ρ� = 
 
a2c2 0 0 abcd abc2 a2cd 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 abcd 0 0 b2d2 b2cd abd2 0 0 abc2 0 0 b2cd b2c2 abcd 0 0 a2cd 0 0 abd2 abcd a2d2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
 
(26) 
Assim, o operador densidade na equação (26) contém toda a informação do processamento de uma estado arbitrário no algoritimo de soma. Como ao final do código os medidores clássicos fazem medições correspondentes apenas aos registros quânticos q[0] e q[1], a informação útil ao nosso problema se restringe às informações relativas aos dois primeiros qbits. Logo, tomando o traço parcial do operador ρ� com relaçao ao terceiro qbit temos 
Tr3 ρ� = ρ�12 = 
 
a2c2 0 abc2 0 
0 b2d2 abd2 0 abc2 abd2 b2c2 + a2d2 0 0 0 0 0 
 
(27) 
Desse modo estendemos a análise dos resultados da soma de dois números de 1 bit, aos possíveis resultados de uma medida no sistema de qbits dado. 
A análise probabilística dos possíveis resultados das medidas realizadas pelos registradores clás sicos pode ser dada em termos da matriz densidade reduzida (27) de modo que 
P(00) = �00| ρ�12 |00� = a2c2 
P(01) = �10| ρ�12 |10� = b2c2 + a2d2 P(10) = �01| ρ�12 |01� = b2d2 P(11) = �11| ρ�12 |11� = 0 
(28) 
Agora, serão testadas duas entradas inicias com diferentes coeficientes a, b, c e d, ambas mostradas na figuras 10. 
Da figura 10(a) temos 
13
(a) Estados de superposição aplicando portas Hadamard (b) Estados de superposição aplicando portas Ry 
Figura 10 – Circuitos (a) e (b) que mostram diferentes entradas de estados de superposição Fonte: IBM Q1 
|Ψ� = (|0� + |1�) 
√2⊗ (|0� + |1�) 
√2⊗ |0� =⇒ a = b = c = d = 1√2 (29) 
e, segundo a equação (28) obtemos 


P(00) = 0, 25 
	



P(01) = 0, 50 
	



P(10) = 0, 25 
	



P(11) = 0 
	



; ; ; (30) 
Da figura 10(b), e da definição da operação Ry na equação (15), temos 
 
|Ψ� = Ryπ/4|0� ⊗ Ryπ/8 |0� ⊗ |0� 
= (cos π8 |0� + sinπ8 |1�) ⊗ (cos π16 |0� + sinπ16 |1�) ⊗ |0� =⇒  
e, novamente, segundo a equação (28) obtemos 
a = cosπ8 b = sinπ8 c = cosπ16 d = sinπ16 
(31) 


P(00) = 0, 82107 
	



P(01) = 0, 17336 
	



P(10) = 0, 00557 
	



P(11) = 0 
	



; ; ; (32) 
Os histogramas resultantes de um conjunto de várias medições de sistemas igualmente preparados conforme os circuitos ilustrados na figura 10 são mostrados nos gráficos na figura 11. Analisando os histogramas e as equações (30) e (32), em ambos os casos, notamos novamente a presença de probabilidades não nulas para o resultado 11 devido aos erros relacionados à implemen tação física do computador quântico, discutidos anteriormente. 
Outra vez, a fidelidade nas probabilidades dos resultados das medições realizadas no simulador dependem exclusivamente da formulação estatística do problema no que diz respeito à quantidade de medições efetuadas num certo número de sistemas identicamente preparados. Constata-se que o 
14

Figura 11 – Histogramas resultantes de um conjunto de 8192 medições para cada um dos circuitos da figura 10. As medidas foram tomadas tanto em um computador quântico (CQ) quanto em um simulador. 
Fonte: Elaborada pelo autor. 
simulador sempre dá P(11) = 0, diferentemente do que ocorre para as probabilidades resultantes do computador quântico. Além disso, observa-se que este último apresenta uma perda de fidelidade para probabilidades esperadas com valor pequeno, já que nestes casos os erros se tornam mais expressivos, como na probabilidade esperada para o resultado 10 no segundo histograma. 
É importante salientar que a principal motivação para a introdução de entradas constituídas de estados de superposição no algoritimo de soma é sua circunstancial vantagem com relação aos algo ritimos clássicos usuais já que aqui foi possível a realização de todas as possíveis operações de soma de dois números de 1bit em apenas uma execução do algoritimo. Assim, ao final do código temos um estado final que é a superposição de todas as possíveis respostas esperadas classicamente. 
Entretanto, o caráter probabilístico da mecânica quântica nos deixa refém do ato da medição no sentido de que embora tenhamos em mão um "oráculo" ciente de todas as respostas somos obrigados aceitar o fato de que a cada pergunta apenas uma das respostas será fornecida e todas as outras serão perdidas. Assim, é necessário realizar esse procedimento por diversas vezes até que se obtenha uma distribuição estatística fiel de todos os possíveis resultados. 
Desse modo, realizar todas as operações de possíveis soma entre dois números de 1bit de uma só vez, mas ser obrigado a executar esse processo várias vezes, ao invés de realizar todas as possíveis operações de soma entre dois números de 1 bit, individualmente, aparenta não ser uma troca tão vantajosa assim, conforme foi enunciado. 
De fato esta última observação está correta já que aqui a introdução dos estados de superposição no algoritimo de soma teve um caráter puramente didático e de investigação das propriedades quânticas do sistema implementado, apesar de, na prática, tal implementação não ser tão engenhosa assim, no que diz respeito à exploração destas propriedades. Todavia essa apresentação abriu um interessante precedente para a formulação de um comparativo entre o sistema proposto e um sistema que, de maneira extremante sagaz, efetivamente beneficia-se do caráter quântico do problema. Esse breve comparativo será introduzido na seção a seguir com a exposição do algoritimo de Shor. 
15
3.3 O algoritimo de Shor 
O algoritimo de Shor é um algoritimo quântico de fatoração de números inteiros em fatores primos criado em 1994 pelo matemático Peter Shor7. A importância do algoritimo de Shor no contexto da computação quântica é creditada justamente à sua eficiência frente aos algoritimos clássicos de fatoração. 
Em ciência da computação uma das características que definem um algoritimo eficiente é o seu processamento ser dado em "tempo polinomial", ou seja, o número de passos crescer como um po linômio do input inicial. Assim, dado um número N ∈ Z, sua fatoração via Shor em números primos requer O(n2 log n log (log n)) operações, em que n é o número de bits da entrada inicial N, enquanto 
� 
o análogo clássico requer exp
O(n2/3 log2/3 n)�operações.2 
Ainda assim o algoritimo pode ser entendido como sendo composto de duas partes: uma parte clássica, que diz respeito a todos os passos que poderiam reproduzidos exatamente em algoritimos clássicos de fatoração usuais, e têm base na teoria dos números e aritmética modular, e uma parte quântica, que explora, de maneira extremamente engenhosa, as propriedades da mecânica quântica de superposição de estados e interferência quântica para a obtenção da resposta, sendo esta última a principal motivação desta seção. 
Para dar mais clareza à maneira como o algoritimo de Shor opera e o que é responsável por sua maior eficiência será necessário introduzir um tópico sobre a transformada de Fourier quântica. 
3.3.1 Transformada de Fourier quântica (QFT) 
A transformada de Fourier é uma transformação matemática que mapeia uma função em um novo espaço de funções, denominado espaço recíproco. Em física, sua principal aplicação é o mapeamento de funções de domínio temporal para o domínio das frequências. No algoritimo de Shor, a aplicação da QFT parte da mesma premissa: explorar a periodicidade de uma função. Assim sendo, podemos definir a QFT. Dado uma base ortonormal {|0�, |1�, ..., |N − 1�}, a transformada de Fourier quântica (QFT) pode ser definida como sendo a operação linear que age nos estados da base de modo que 
|j� −→ 1√NN�−1 k=0 
e2πi 
N jk |k�, (33) 
sendo |j� um dos quaisquer estados. Deste modo podemos definir um operador linear UQF T tal que 
UQF T |j� ≡ 1√NN�−1 k=0 
e2πi 
N jk |k� (34) 
É importante ressaltar que a QFT é uma operação unitária, ou seja, U† · U = I, sendo, então, possível a construção de um circuito quântico que compute tal transformação. Assim, para sua imple mentação, em termos das portas lógicas quânticas usuais, é conveniente introduzir a representação 
16
produto da QFT, representando os estados da base ortonormal em termos da base computacional (base binária). 
Se tomarmos N = 2n para algum n ∈ Z, temos que os estados da base ficam: |0�, |1�, ..., |2n − 1�. Então, para um estado |j� qualquer, temos que j em base binária fica j1j2...jn com j = 0, 1, ou seja, j = 2n−1j1 + 2n−2j2 + ... + 21jn−1 + 20jn. 
Da equação (33) 
|j� −→ 12n/2�1 k1=0 
= 12n/2�1 
�1 
k2=0 �1 
... �1 kn=0 
... �1 
e2πij (2n−1k1+2n−2k2+...+21kn−1+20kn) 
2n |k1k2...kn� 
e2πij �nl=1 kl 2−l|k1k2...kn� 
k1=0 
= 12n/2�1 k1=0 
k2=0 �1 
k2=0 
kn=0 
... �1 kn=0 
��n l=1 
� 
e2πijkl 2−l|kl� 
(35) 
= 12n/2�n l=1 
��1 kl=0 
� 
e2πijkl 2−l|kl� 
= 12n/2�n l=1 
� 
|0� + e2πij 2−l|1�� 
�|0� + e2πij/2 |1�� �|0� + e2πij/22|1��... �|0� + e2πij/2n|1�� = 
2n/2 
Ainda, podemos escrever o termo j2l em termos de frações binárias, sendo 
jn2−n+l−1 (36) 
Assim 
0.jljl+1...jm = �m n=l 


UQF T |j� = (|0� + e2πi0.jn |1�) (|0� + e2πi0.jn−1jn |1�)...(|0� + e2πi0.j1j2...jn |1�) 2n/2 
	



(37) 
Aqui, vê-se que a representação produto coloca a QFT em termos da base computacional, facili tando a busca de um circuito quântico que compute a transformação. Tal circuito é representado na figura 12, em que a operação Rk é dada por 
Rk = 
�1 0 0 e2πi 
2k 
� 
. (38) 
O número de portas lógicas utilizadas para n qbits é então, para o primeiro qbit: uma Hadamard e (n − 1) Rk, sendo n no total; para o segundo qbit: uma Hadamard e (n − 2), sendo (n − 1); e assim sucessivamente, de modo que o número total de portas lógicas Hadamard e Rk é dada pela progressão aritmética 
17
n + (n − 1) + (n − 2) + ... + 2 + 1 =n(n + 1) 
2 . (39) 

Figura 12 – Representação da QFT em um circuito quântico , omitindo-se os fatores de normalização e as portas swap para inverter a ordem dos qbits, conforme vemos na representação produto 
Fonte: NIELSEN, M. A.; CHUANG, I.2 
Ainda, utiliza-se uma porta Swap para cada par de qbits, de modo totalizar n/2 portas, no máximo. Aqui vemos que o número de portas lógicas utilizadas é da ordem de O(n2), em contra partida à implementação clássica da transformada de Fourier, que requer exponencialmente mais portas lógicas. 
3.3.2 Fatoração em números primos 
Dado {N|N ∈ Z , N > 1} a partir do teorema fundamental da aritmética2, sempre é possível escrever N da forma N = p1a1 p2a2 ...pnan , em que pi é um número primo e ai é um inteiro positivo. Para x e N inteiros positivos e co-primos, ou seja, o máximo divisor entre eles é 1, a ordem de x módulo N é o inteiro positivo r tal que xr = 1 mod N. 
Mais genericamente, dado um inteiro positivo N, escolhendo arbitrariamente x �= 1, co-primo e menor que N temos que xr − 1 é um múltiplo de N, assim 
xr − 1 = mN =⇒ �xr/2 + 1� �xr/2 − 1�= mN, (40) 
com m um inteiro qualquer. 
Vemos aqui que a partir da busca da ordem r é possível obter-se a fatoração de N em fatores não triviais (xr/2±1) m . Mesmo m sendo desconhecido, pode-se executar algoritimos clássicos, como o algoritimo de Euclides2, para se computar o máximo divisor comum (m.d.c) entre �xr/2 ± 1�e N. 
Assim, o problema da fatoração de N em números primos se resume ao problema de busca da ordem r. Partindo desse princípio definimos a função f(k) tal que 
f(k) = xk mod N, (41) 
para k ∈ Z. 
18
Da estrutura da f(k) podemos verificar que ela é r-periódica, sendo r a ordem definida acima, f(k + r) = xk+r mod N = xkxr mod N = xk(1 mod N) = xk mod N = f(k) (42) 
Assim, podemos iniciar o algoritimo com o estado de dois registros |0�|0�. 
Aplicamos t transformações de Hadamard no primeiro registro (note que a representação do es tado quântico em termos da base decimal é mais ilustrativo para o propósito deste trabalho): 
(Ht ⊗ I)|0�|0� = (Ht |0�)|0� = 12t/22�t−1 k=0 
|k�|0� (43) 
Ainda, calculamos f(k) para cada k e armazenamos no segundo registro: 
2�t−1 
|k���xk mod N�, (44) 
1 
2t/2 
k=0 
e assim teremos: 
�|0�|0� + |1�|1� + ... + |kj �|f(kj )� + |kj+1�|f(kj+1)� + ... + ��2t−1� ��f(2t−1)�� (45) 
1 
2t/2 
Aqui, realizando uma medição no segundo registro, obteríamos um certo estado |f(kn)� de modo que a função de onda total colapsaria num estado emaranhado de todos os |kn� cuja f(k) = f(kn). Mas explorando a periodicidade da função f(k) obtemos o seguinte estado: 
C [|kn�|f(kn)� + |kn + r�|f(kn)� + |kn + 2r�|f(kn)� + ...] , (46) 
em que C é a constante de normalização. 
Por fim, a aplicação da QFT no primeiro registro, a partir de uma série de padrões de interferên cias construtivas e destrutivas, leva-o à um estado de superposição �l αl |l�, em que αl é zero para qualquer l não múltiplo de r, de modo que em uma única medida de |l� é possível se obter a ordem r com uma certa precisão. 
4 Conclusões e considerações finais 
A partir da implementação dos algoritimos propostos nas seções 3.1 e 3.2, tanto no simulador clássico quanto num dispositivo quântico, foi possível constatar certos aspectos de extrema relevância no contexto da computação quântica. O primeiro deles está relacionado às fontes de erros gerados por processos de descoerência e dissipação nos resultados das implementações físicas de sistemas quânticos. A inexistência desses erros é observada no simulador clássico que implementa um sistema perfeitamente isoladado. 
19
O segundo aspecto está relacionado ao caráter probabilístico da mecânica quântica, em que a descrição dos possíveis resultados das medidas dos sistemas propostos apresentaram um aumento na precisão estatística com o aumento do espaço amostral, ou seja, número de execução dos códigos. Esse resultado foi observado tanto para o simulador clássico quanto para o computador quântico, com a ressalva de que neste último a acurácia estatística era limitada pelos erros associados aos processos de dissipação e descoerência mencionados acima. 
Ainda, a implementação da calculadora de soma partindo-se de estados iniciais constituídos de estados de superposição, apesar de promover o processamento em paralelo de todos os possíveis cálculos de soma de dois números de 1bit, mostrou-se pouco inventiva com relação à exploração da propriedades da mecânica quântica em prol da obtenção eficiente das respostas do problema proposto. Diferente desta, vimos na seção 3.3 que o Algoritimo de Shor, a partir da implementação da transfor mada de Fourier quântica, promove uma serie de padrões de interferência construtiva e destrutiva de modo a resultar num estado final formado pela superposição apenas dos estados que correspondem à resposta esperada para o problema. Assim, em uma única medida é possível obter-se, com certa precisão, os fatores primos de um número inteiro N, no caso da apresentação feita aqui. 
Referências 
1 IBM Corporation 1994-2019. IBM Q Experience. Disponível em: https:// quantum-computing.i bm.com/. Acesso em: 20 out. 2019. 
2 NIELSEN, M. A.; CHUANG, I.. Quantum computation and quantum information: 10th anni versary edition. Cambridge: Cambridge University Press, 2011. 
3 COHEN-TANNOUDJI, C.; DIU, B.; LALOE,F. Quantum mechanics. New York: John Wiley & Sons,1991.v.1. 
4 WOLFRAM RESEARCH. Mathematica for students for sites - versão 11.3.0.0. Distribuição de Software CCE - USP, out 2019. Disponível em: https://atendimentosti.usp.br/otrs/public.pl?Action=P ublicFAQZoom;ItemID=287. Acesso em: 25 nov. 2020. 
5 ZUREK, W. H. Environment-induced decoherence and the transition from quantum to classical. Vistas in Astronomy, v.37 p.185–196, 1993. 
6 PALMA, G. M.; SUOMINEN, K.; EKERT,A. Quantum computers and dissipation. Proceedings Mathematical Physical and Engineering Sciences, v.452, p.567–584, 1996. doi:10.1098/rspa.1996. 0029. 
7 SHOR, P. W. Algorithms for quantum computation: discrete logarithms and factoring. In: AN NUAL SYMPOSIUM ON FOUNDATIONS OF COMPUTER SCIENCE, 35th, Santa Fe, NM, USA. Proceedings 35th Annual Symposium on Foundations of Computer Science, Santa Fe: 1994. p. 124–134. 
20