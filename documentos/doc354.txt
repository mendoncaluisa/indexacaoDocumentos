IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999 63
Brief Papers
A Multistage Evolutionary Algorithm for the Timetable Problem
E. K. Burke and J. P. Newall
Abstract— It is well known that timetabling problems can be
very difficult to solve, especially when dealing with particularly
large instances. Finding near-optimal results can prove to be
extremely difficult, even when using advanced search methods
such as evolutionary algorithms (EA’s). This paper presents a
method of decomposing larger problems into smaller components,
each of which is of a size that the EA can effectively handle.
Various experimental results using this method show that not
only can the execution time be considerably reduced but also
that the presented method can actually improve the quality of
the solutions.
Index Terms—Evolutionary algorithms, timetable problems.
I. I NTRODUCTION
A. The Timetable Problem
THE timetabling problem consists of allocating a number
of events to a finite number of time slots (or periods)
such that the necessary constraints are satisfied. In general, the
nature of the constraints varies between different instances of
the timetable problem, but most problems share the following
conditions.
• No individual entity (e.g., person) should be required to
attend two events simultaneously.
• For each period there should be sufficient resources (e.g.,
rooms) to service the events scheduled within that period.
These constraints are fundamental to any timetabling prob-
lem and generally form the basis for a feasible timetable but,
as mentioned above, a number of other constraints may be
introduced depending on the particular flavor of the timetable
problem being considered. Often, these varying constraints can
be at odds with each other. For instance, when scheduling
university examinations it is often considered undesirable
for students to have to sit for exams in adjacent periods.
Alternatively, when scheduling university lectures it is often
actually preferred for students to have two or three lectures
in a row. Putting aside these differences for our experiments,
we will be concentrating on an instance of the examination
problem. While there are many possible side constraints for
this problem, the most difficult task to carry out (aside from
producing a feasible timetable at all) is often to minimize
the number of conflicts between adjacent periods to allow
Manuscript received December 30, 1997; revised June 4, 1998 and Novem-
ber 10, 1998.
The authors are with the Automated Scheduling and Planning Group,
Department of Computer Science, University of Nottingham, Nottingham,
NG7 2RD U.K.
Publisher Item Identifier S 1089-778X(99)02081-0.
students time to recover between exams. If a large number of
periods are allocated, it would most likely be the case that this
would not cause any problems. Unfortunately limits on time
and rooms often mean that finding any feasible solution is a
considerable task in itself and that no zero penalty solution
will exist.
The timetable problem is known in general to be NP-
complete [15], [21]. Of the many approaches that have been
applied to the problem, the earliest methods are those that uti-
lize heuristics. A good example of this is heuristic sequencing
[13], which involves using a heuristic to estimate how difficult
each event will be to schedule. If the events that are regarded
as the most difficult are then scheduled before the other events
we should produce a substantially better timetable than by
merely using a random ordering. A useful addition to this
process is backtracking, such as that used in [8]. This treats
situations where there is no valid period available to schedule
an event because of placements already made. It does this by
unscheduling the conflicting events from a chosen period to
allow the current event to be scheduled in that period. The
unscheduled events are then placed back in the ordering for
later scheduling.
In addition to these heuristic techniques, a number of
general search methods have also been applied to the timetable
problem. Such approaches include simulated annealing [19],
Tabu search [14], and variants on genetic algorithms [2], [4],
[10], [17]. While most of these have shown worth, it is notable
that many of the more successful methods employ some kind
of “trick” in the algorithm to improve results for timetable
problems. It follows that specialized timetabling algorithms
may function substantially better than those based on more
general optimization techniques.
For the interested reader, more information on the exam-
ination timetabling problem and the methods that have been
applied can be found in two excellent surveys [6], [7] which
go into considerable depth. For further information about the
problem itself, see [1] which presents and discusses the results
of a questionnaire on examination timetabling that was sent to
universities throughout the United Kingdom.
B. Memetic Timetabling
In [4], an approach was proposed for timetabling problems
based on memetic algorithms. In essence, memetic algorithms
are evolutionary algorithms that utilize local search to some
extent. The concept of memetics originates from Dawkins
[12] who describes the meme as an idea or concept that is
passed around society. Individuals can then adapt ideas to suit
1089–778X/99$10.00  1999 IEEE
64 IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999
their own environment, in contrast with biological evolution
where genes are passed down and cannot be altered by the
recipient. In the same way that memes were related to genes by
Dawkins, memetic algorithms were proposed as an alternative
to genetic algorithms [11] by Moscato and Norman [16]. The
main motivation of this approach is that by applying a hill-
climbing operator after each of the genetic operators, we can
then treat the process as a search through local optima, rather
than the entire search space. Applying a local search operator
like this will clearly cause each generation to take considerably
longer but this can be justified if sufficiently more is achieved
per generation than if local search were not used.
The memetic algorithm proposed in [4] uses a combination
of mutation and local search to effectively explore the solution
space. Mutation actually consists of two separate operators,
light and heavy mutation. The light mutation operator merely
shuffles a few individual events to other valid periods, the
purpose of this being to “nudge” solutions away from local
optima to find a new solution. The heavy mutation operator,
on the other hand, functions by targeting periods where large
amounts of penalty are arising. The algorithm then randomly
reschedules the events in these periods to produce a new solu-
tion that retains some of the (hopefully better) characteristics
of the original solution. Neither of these operators on their own
achieves any substantial improvements in solution quality but
when followed by an application of a simple hill-climber the
process becomes much more effective [4].
II. P ROBLEM DEFINITION
The technique presented here was tested on an instance of
the examination timetabling problem. Instances of this problem
usually involve hard and soft constraints. Hard constraints are
those that must be satisfied (at all costs). Soft constraints, on
the other hand, are regarded as desirable but it is not absolutely
essential to satisfy all of them.
In this problem there are exams that must be scheduled in
periods with examination seats available for each period
(where and are nonnegative integers). There are three
periods in a day. Any two of the exams may conflict with
each other. This means that they have a number of students
enrolled for both exams. When scheduling the exams we can
encounter two types of conflicts.
• First-Order Conflicts: This term is used to describe sit-
uations where conflicting exams are scheduled in the
same period. This is highly undesirable as it involves
quarantining some students after one exam so they may
sit for the other exam after the main sitting. In all but
the most difficult of situations, this is regarded as a basic
hard constraint.
• Second-Order Conflicts: These conflicts, on the other
hand, are less important and represent situations where
two conflicting exams are not scheduled in the period,
but are scheduled in periods too near to each other. For
instance we might not want students to have to sit for
two exams in consecutive periods or to sit for two exams
in the same day. To totally satisfy all of these constraints
is often not practical. They are usually treated as soft
constraints.
In addition to avoiding these conflicts, it is also very
important to adhere to the limitations on available seating for
each period. The problem can be formally specified by first
defining the following:
one if exam is scheduled in period zero otherwise;
the number of students taking both exams and ;
three if period is on the same day as period one
if they are on adjacent days, and zero otherwise. This
provides a higher weight for same day conflicts because
it is more important to satisfy them;
the number of students taking exam .
To take into account that the construction of a feasible
timetable might not actually be possible, we need an extra
period, the th period, into which any exams can be
placed that are not yet scheduled in a valid period. There are
no constraints to prevent scheduling in this period, but it will
need to be heavily penalized. Now we need to minimize (1)
subject to (2)–(4) (all presented below). Equation (1) sums
up occurrences where students must attend two exams in
consecutive periods and weights the number of unscheduled
exams by 5000 to strongly discourage incomplete timetables. If
two consecutive periods are on the same day then any adjacent
conflicts are weighted by three. If there is a single night
between them the conflicts are weighted by one, otherwise
any conflicts are ignored (for example when periods are split
by a weekend). Equation (2) states that every event should
scheduled once, and only once in the timetable. Equation (3)
specifies that no conflicting events should be scheduled within
the same period and (4) enforces the condition that the total
number of seats required for any period is not greater than
the number of seats available. The problem can be presented
formally as follows.
Minimize
(1)
subject to
(2)
and
(3)
and
(4)
III. A M ULTISTAGE MEMETIC ALGORITHM
A. Basic Framework
While memetic algorithms show promise for timetabling
problems [4], [17] the time involved in optimizing large
IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999 65
Fig. 1. The problem is divided into three subsets which are scheduled one
at a time.
problems (of say greater than 500 events) is much longer
than would be ideal. The memetic algorithm would be a more
desirable approach if it could produce a schedule in a matter
of minutes rather than hours. It might achieve this goal by
first considering a subset of events. After fixing those events,
the algorithm could consider another subset and add those to
the previously created schedule. The process of decomposition
has been studied by Carter [5], who proposed a heuristic
method of recursively splitting a large problem into smaller
problems until each subproblem is small enough to be solved
by conventional methods such as linear integer programming.
The idea has also been studied by Weare [20] who applied
such a technique to random data on flexible length timetables.
The results indicated that as the number of events considered at
one time is decreased, the time taken to produce solutions also
decreases, but unfortunately so did the quality of solutions. A
contributing factor to the lower quality could have been the
use of the flexible-length timetable model and a preference for
shorter timetables. This may have caused shorter timetables to
be produced in the earlier phases (at the expense of second-
order conflicts) when the final timetable may be much longer
regardless. Therefore for the purposes of our experiments we
use a fixed-length timetable model to avoid these problems.
We also experiment with modifications and enhancements for
this method. Fig. 1 shows how a set of events could be split
into three subsets and then scheduled in three different phases,
where the darker portions of the graph represent how early on
in the process that portion was fixed in the timetable.
This should substantially reduce the complexity of the
problem but there will of course be the obvious pitfall that by
fixing events in periods in this fashion it may be impossible
to schedule events later on in the process. Fortunately, there
are a number of methods that can be employed to reduce the
chances of this happening. First, it is possible to borrow an idea
from heuristic sequencing methods and allow the algorithm
to choose subsets according to some heuristic ordering. This
should help improve the quality of produced timetables by
optimizing first those events that are likely to cause most
problems. Second, the algorithm could look ahead in the
process by optimizing two subsets at a time but only fixing
the first of these subsets at the end of every stage. This will
Fig. 2. Using a look-ahead approach, two subsets are now considered at one
time but only the first is fixed at the end of a phase.
inevitably lead to the process taking longer than if a single
subset of the same size was considered, as the algorithm
is considering most of the events twice, but this could be
justified if it leads to substantial improvements in quality.
Fig. 2 illustrates how the earlier three-phase example would
be handled using a look-ahead approach.
Having this look-ahead approach will help, but it is probably
more important to choose a good heuristic to order the
events. If the algorithm concentrates on scheduling those more
difficult events earlier on in the process and reducing the
penalty caused by these events with respect to each other, we
should find that fewer problems are encountered later on in the
process, regardless of whether or not a look-ahead approach is
used. For these experiments we will use three heuristics that
are generally accepted to be suitable for the exam timetabling
problem [9].
• Largest Degree: The first events to be chosen for sched-
uling are those with the greatest number of conflicts with
other events. These would generally be considered to be
more difficult.
• Color Degree: This is similar to largest degree except that
the events that are scheduled first are those that have the
greatest number of conflicts with other events that have
already been scheduled. It is expected that events with
conflicting events already scheduled will be more difficult
to place than events with a large amount of conflicts, but
little or none of these events already scheduled.
• Saturation Degree: The first events to be scheduled here
are those events with fewer valid periods remaining in
the timetable. The expectation here is that if these events
were not to be scheduled earlier on in the process then
there may no valid periods at all remaining to schedule
these events later on.
We can use the formal definition of the problem to define
the above terms unambiguously. The degree of an exam is
defined in (5), where # gives the cardinality of a set. As the
degree of an exam is constant this need only be calculated
once in any run of an algorithm
degree (5)
Similarly the colorDegree of an exam is defined in (6).
Unlike the degree, the color degree of an exam changes
every time one of its conflicting exams is moved from the
unscheduled list to a valid period
colorDegree
(6)
66 IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999
Finally the saturation degree of an exam is defined in (7).
This will need to be recalculated every time an event is moved
to a period, either from the unscheduled list or another valid
period
(7)
The multistage process when scheduling exams at a time
can be described by the following pseudocode.
•
• REPEAT
IF THEN
ELSE
FOR each unscheduled exam
Calculate the desired degree of that exam
Pick the exams with the largest/least degrees
Apply the memetic algorithm to schedule those
exams, keeping the previously scheduled exams
fixed in their current position.
• UNTIL
The point at which to exit the memetic algorithm presents a
choice. Normally the memetic algorithm would exit when the
population has fully converged but this is inappropriate with
our mutation-driven memetic algorithm. Two other options
would be to either run the algorithm for a fixed number of
generations, or alternatively to stop the algorithm after a set
number of generations have passed without finding a new
“best so far” solution. In these experiments the algorithm
was halted after five generations without a new “best so far”
solution. While five generations may seem a little low, note
that a generation usually achieves considerably more (while
also consuming considerably more CPU cycles) than a typical
evolutionary algorithm due to the use of the hill-climbing
operator.
While the decomposition method is in itself independent
of the particular technique used to solve each subproblem,
the memetic algorithm presented in [4] has been shown to
be effective at solving all but the very largest timetabling
problems.
B. The Memetic Timetabling Algorithm
The memetic approach employs a simple evolutionary
model with a population of solutions (of size 50 for all
experiments described here). The algorithm applies mutation
operators (one of the light or heavy forms, decided by a
50/50 probability), followed by a hill-climbing operator, to
produce an oversize population (which is twice the normal
population size). Solutions are then selected from this oversize
set to form the new population for the next generation.
Previous experiments [3] with recombination operators for
this algorithm have proved unfruitful and as such were not
used here.
1) Quality and Evaluation: A simple linear weighted
penalty function is used to assess the quality (and hence
the fitness, or rather unfitness) of solutions. This function is
identical to that shown in (1).
2) Initial Population Generation: The initial population is
generated by taking events in a random order and scheduling
in the first valid period. The hill-climbing operator is then
applied to each member of this population.
3) Light Mutation: As mentioned in Section I-B this oper-
ator selects a number of events (30 in this case) at random
and tries to place each in an alternative period, also picked at
random. Moves that violate hard constraints are not allowed,
and in this case another period is tried.
4) Heavy Mutation: This operator is one of the more com-
plicated operators in the algorithm, and we describe it in
some detail. It targets periods that appear to be causing
“large” amounts of penalty for “disruptions.” We use the term
“disruption” to mean that all events contained within a period
are temporarily unscheduled. All events from disrupted periods
can then be randomly rescheduled in the timetable. The penalty
for a period is based on the evaluation function and is defined
in
penalty (8)
What actually constitutes a “large” amount of penalty is
clearly relative so the algorithm also needs something with
which to compare. For this it can calculate the average penalty
per period of the best solution in our population as in
average Fitness best
Number of periods (9)
Having calculated these, the algorithm can now calculate a
probability of being disrupted for each period. Equation (10)
shows how the probability of being disrupted is calculated,
with bias being a definable value (0.1 here) to vary the
probability of periods being disrupted. Periods causing greater
than average penalty are automatically disrupted
Probability (Disrupt period
if penalty average
penalty bias
average if average. (10)
The penalty arising from a particular period is dependant on
the events scheduled in the next period so the algorithm must
have special cases for disrupting two periods in a row. For
instance, say the operator preserved period because it had a
low number of conflicts with period ; it does not make
sense to then disrupt period The operator, however, may
well want to disrupt the next period. If the operator were to
pick out period for disruption, it would instead disrupt
period automatically. In this case period would then
be the next period to be considered.
IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999 67
This can be summarized formally as follows.
• FOR each period (where in the timetable in turn
decide if is to be disrupted based on the probability
given by (10)
IF decision is to disrupt but previous period was not
disrupted THEN
do not actually disrupt this period, instead disrupt
the next period
ELSE IF disrupt THEN
disrupt this period
ELSE
do not disrupt this period
It can be seen from the pseudocode that heavy mutation
will not disrupt the first period. This period, however, is not
immune to changes made by either the light mutation operator
or the hill-climbing operator and will normally change quite
considerably over the course of the evolution.
5) The Hill-Climbing Operator: A simple efficient hill-
climbing operator is applied after each mutation operator to
restore solutions to local optima. This utilizes delta evaluation
[18] to avoid the time-consuming process of performing a
full evaluation at every step. Where (1) provides our fitness
function, our delta evaluation function when moving event
from a period to a period is defined in
fitness
(11)
The actual process used by the hill-climber is as follows.
• REPEAT
FOR each period (in some random order)
FOR each event scheduled in period
Schedule event in the valid period causing
least penalty (this includes the original period)
Try and schedule any unscheduled events
• UNTIL no improvement can be made
While the hill-climbing routing does occasionally check
if it can schedule events that are currently unscheduled,
its main aim is to improve the quality of already feasible
solutions, rather than produce low quality feasible solutions
from infeasible solutions. A more complicated local search
procedure might achieve this, but would inevitably increase
the total time spent by the algorithm.
6) Selection: Selection is achieved by using a simple rank-
based selection method, with each candidate being given a
probability of being selected in order of quality. The process
takes candidate solutions in order of fitness. The fittest solution
(that with the lowest penalty) has a probability of being
selected. If it does not get selected then the second fittest
solution is offered the same chance. This continues until either
a solution does get selected or the final solution is reached. The
probability in these experiments was set to be 0.08, which
appeared to give balanced results given the population size
of 50.
7) Using the Memetic Algorithm Within the Multistage
Framework: The operation of this algorithm varies very little
when used within the proposed multistage framework. There
are basically three differences at any particular phase of
execution.
1) Any events fixed at the end of an earlier phase cannot
be moved by any operator in the memetic algorithm,
though they are still used for calculating conflicts, seat
usage, etc.
2) The algorithm ignores all events that will be added to
the problem in a later phase.
3) When generating the initial population for a particular
phase the set of events for this phase is added in the
same random order over the fixed events from previous
phases.
Notice that the memetic algorithm does not perform any
degree measures (see Section III-A). These are performed at
the higher (multistage) level. The three points presented here
apply to the memetic algorithm described in Section III-B. It
is important not to confuse the memetic approach with the de-
composition of the problem presented in the previous section.
As mentioned earlier, the decomposition (Section III-A) is
essentially independent of the memetic approach (Section III-
B).
C. Implementation Details
1) The Memetic Algorithm:
Conflict checking: Due to the number of times conflicts
between exams need to be checked, it is impractical to obtain
the number of conflicts each time by comparing the lists of
enrolled students for those exams. Fortunately as we are more
interested in the number of students involved in the conflict,
rather than the actual students involved in the conflict the
comparisons need only be performed once. Having calculated
the conflicts we can then create a conflict matrix This
matrix will have dimensions by the definition
from Section II-B being the th element of the matrix.
Storing this matrix within the algorithm enables rapid conflict
checking and also eliminates the number of students as a factor
in the complexity of the problem. For example, assume that
four students must attend both exams and In this case the
th element of the matrix will have the value four.
Data structures: Due to the hill-climbing operator being
responsible for a large part of the operation of the memetic
algorithm, the encoding of solution timetables is designed to
reduce the time taken to evaluate and make small steps. Fig. 3
illustrates the link list style encoding used. Each period, plus
the unscheduled list, has an associated object in the solution
that knows the first event scheduled in that period. Similarly
each event also has an associated object that knows the next
event scheduled in that period or has a null pointer as it is
the last event. By representing a timetable in this way we can
easily move through the events in a period to check conflicts,
etc. It also facilitates rapid movement of single events from
one period to another, making it highly suitable for the hill-
climbing operator. Aside from this, however, we may also
need to quickly establish which period an event is scheduled
68 IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999
Fig. 3. The encoding used for a solution timetable. A linked list style approach is used that allows easy movement of events from one period to the other.
in. To address this, the event objects keep knowledge of
which period its associated event has been scheduled in. By
then storing all the event objects in an ordered array, it is
possible to quickly access the information about any one event.
Altogether, this structure provides for efficient manipulation
and stable memory usage.
2) The Multistage Decomposition Method: There are some
practical considerations when implementing this method; oth-
erwise we could find that using it produces results little or no
faster than the traditional single phase approach. The authors
found that the main reason that this happens was the time taken
to perform evaluations (and delta evaluations) at each stage
of the algorithm. For instance, consider a problem with 400
events and suppose we have decided to schedule in subsets
of 100 events with no look ahead. Now suppose that the
algorithm is in the third phase. Two hundred events have
already been fixed in the previous phase, and it is trying to
schedule the next 100 events. Even though it is only placing
those 100 events it must also consider the 200 events already
scheduled when checking for first– and second-order conflicts,
or other constraints. Similarly, in the final phase, it must still
consider the 300 events that will have been fixed by then. In
an algorithm such as ours where the majority of the execution
time is spent either evaluating solutions, portions of solutions,
or possible moves, it becomes clear that the time taken for
each phase will increase substantially later on in the process
when, ideally, each phase that considers an equal number of
events should require an equal amount of time.
In the implementation used for the experiments here, the
events that had already been fixed were merged into a number
of virtual “super” events, one of these for each period in the
timetable. These super events could be considered to be what
would happen if all the students from all the events scheduled
in a period so far were taken and were all registered on a
new single event instead. It is then possible to forget about
those initial events and remove them from the timetable, letting
the new super events be used for evaluation purposes. This
has obvious complexity advantages as the number of events
involved in evaluations is now the subset size we have chosen
plus the number of periods in the timetable, regardless of
the phase that the algorithm is currently in (with the obvious
exception of the first phase, where there is no need for any of
these “super events”). Due to the way records of conflicts are
handled (outlined in Section III-C1), there is no more overhead
for checking conflicts with a “super” event than there is for
a single event.
Fig. 4 illustrates how the timetable might build up phase by
phase using this approach. The actual process of building a
“super event” is basically a case of summing up the conflict
matrices of the component events and the size of each event.
For instance, if a new super event is to be created from a
number of events scheduled in period , then the
event would have the properties shown in (12). Note that
as there must be a super event for each period the number of
real events would now be given by
(12)
IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999 69
Fig. 4. Merging fixed events to improve performance. All merged events in a period can then be treated as a single “super event.”
TABLE I
THE R EAL D ATA S ETS U SED FOR T ESTING
The combined super event is treated as having its size equal
to the sum of its component events. The process, however,
is a little more complicated when room allocation is a part
of the problem. Unfortunately only one of the data sets
used for testing (the University of Nottingham data) includes
information on rooms. In this case the super event preserves
the room allocation of its component events, which cannot
then be altered.
IV. RESULTS
A. Experimental Data
To evaluate the effectiveness of this approach, several real
enrollment data sets were used for testing. Table I lists the
data used together with the characteristics of each data set
such as the total number of exams and the total number of
student exam enrollments. The density of the conflict matrix
is calculated as the average number of other exams that each
exam conflicts with divided by the total number of exams. For
example, a conflict density of 0.5 indicates that each exam
conflicts with half of the other exams on average. As most of
this data does not include data on rooms available, a simple
upper limit on the number of seats available each period is
used instead. The problems range from the smaller but more
densely conflicting kfu and carf92 problems to the fairly large
but relatively sparsely conflicting nott data set and the huge
pur data set.1
For all of the problems, a typical timetable layout was used
that was comprised of three periods per day from Monday to
Friday and one period on Saturday morning. There were no
1 All of these data sets can be obtained over the Internet:
ftp://ftp.cs.nott.ac.uk/ttp/Data and ftp://ie.utoronto.ca/mwc/testprob
periods on Sunday. This layout was repeated until the given
number of periods for the problem was reached.
The primary task of the algorithm was scheduling all events
within the given number of periods, and the secondary task
was minimizing the number of back-to-back conflicts with
adjacent periods, with adjacent conflicts on the same day
being penalized more than those occurring overnight. For the
purposes of solution evaluation and quality the function as
shown in (1) was used.
B. Results
The method was tested on all the above data sets with subset
sizes of 50, 100, 250, and 500 events both with and without a
look-ahead approach. Each of these configurations was tested
with all of the given heuristics five times each, and the average
result given. This small sample size is sufficient here to
offer some reasonable observations regarding the algorithm’s
performance.
Tables II–IV show the results achieved when using the
relevant heuristics. The value given in the time column is the
execution time in CPU seconds on a DEC Alpha computer
for that particular run. Where the number of exams implies
that the last subset of a run is incomplete the final phase of
the process is run with a reduced subset size. The breakdown
of results for the best of the five runs is given as the
number of unscheduled exams and the violations of the second
order conflicts. The results are also shown graphically in
Figs. 5–12.
Looking at the results when using largest degree, shown
in Table II, we see quite a mixed picture. On the carf92
problem the best result is obtained with a subset size of 50
and a look-ahead approach, taking less than one tenth of the
70 IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999
TABLE II
R ESULTS OF A PPLYING THE M ULTISTAGE M ETHOD W HEN U SING L ARGEST D EGREE TO S EPARATE THE P ROBLEMS
Fig. 5. Results when run on the carf92 problem without a look ahead. Fig. 6. Results when run on the carf92 problem with a look ahead.
IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999 71
TABLE III
R ESULTS OF A PPLYING THE M ULTISTAGE M ETHOD W HEN U SING C OLOR D EGREE TO S EPARATE THE P ROBLEMS
Fig. 7. Results when run on the kfu problem without a look ahead. Fig. 8. Results when run on the kfu problem with a look ahead.
72 IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999
TABLE IV
RESULTS OF A PPLYING THE M ULTISTAGE M ETHOD W HEN U SING S ATURATION D EGREE TO S EPARATE THE P ROBLEMS
Fig. 9. Results when run on the nott problem without a look ahead. Fig. 10. Results when run on the nott problem with a look ahead.
IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999 73
Fig. 11. Results when run on the pur problem without a look ahead.
Fig. 12. Results when run on the pur problem with a look ahead.
amount of time to execute, with the larger subset sizes failing
to find feasible solutions. Similarly for the kfu problem the
best result is also found with the subset size of 50 and a
look-ahead approach, but the difference with the higher subset
sizes is not quite as great. The situation with the nott data is
quite different. In this case, only the larger subset sizes are
able to consistently find good quality timetables. This is most
probably due to high room utilization (nearly 100%) and the
low density of the problem, making it more of a bin-packing
problem than a graph coloring one and therefore lessening the
effects of the heuristic. When considering the results for the
pur problem we must take into account the fact that “two in
one [first order] conflicts are unavoidable” [9]. This means
that some conflicting exams will have to be scheduled in the
same period. This situation (in practice) involves quarantining
students until they can sit for an exam after the main sitting.
So the aim is, therefore, to reduce the amount of infeasibility
in the timetable rather than to find fully feasible timetables.
Bearing this in mind it is clear that a larger subset size of
100 with a look-ahead approach finds the best solution. We
might have expected this subset size to be larger given the
huge number of events but this does of course depend on the
structure of the problem.
Considering the results when using color degree we see little
difference in the individual results when compared to largest
degree apart from a few minor variations in solution quality. If
we instead compare with saturation degree, however, we can
discern a notable improvement. While there is no substantial
variation for the kfu and carf92 problem, it is clear that the
approach works completely differently on the nott data set
where the employment of saturation degree results in the
algorithm consistently finding feasible solutions even with
very small subset sizes. A probable reason for this is that
the nott data set has variable length exams and periods
resulting in fewer available time-slots for longer exams. This is
something that neither color degree or largest degree consider
but saturation degree does. For this problem, subset sizes of 50
and 100, both with look-ahead approaches, produce the best
quality solutions. While the general trend for the pur problem
remains roughly the same, there is a noticeable increase in
quality for smaller subset sizes, indicating that saturation
degree is also a much better heuristic for this problem.
Taking all the results into account it would seem that
least saturation degree first is the most reliable heuristic to
use for this method. Though other choices of heuristic may
be more suitable for other problems it is notable that least
saturation degree first outperforms the other heuristics on
the nott problem, which is more constrained in terms of
seats and less dense in terms of its conflict matrix, while
still achieving equivalent performance on the more densely
conflicting problems. In terms of which subset size to use,
a size of 50 seems to be appropriate for smaller problems
and a size of 100 for larger problems. In both cases a look-
ahead approach should be used. Using these sizes and given a
suitable heuristic, it is possible to produce substantially better
results in a fraction of the time than if the memetic algorithm
were applied.
For the purposes of comparison with a more established
method, Table V shows the results when using a heuristic
backtracking method similar to that described by Carter [9]
which is well established and has been implemented at several
universities. These results represent the lowest penalty found
for these data sets by a published algorithm. The heuristic
used here was least saturation degree first, which was found
to be the most effective heuristic in [9]. This also provides
the best comparison as saturation degree certainly appears to
be the most effective heuristic for our method. This method
requires very little run time. Even the very large pur problem
requires no longer than a few minutes. Comparing the results
in Table V with our results when using saturation degree we
see a quite uniform reduction in penalty of roughly 40%.
V. CONCLUSIONS
The application of an algorithm to a problem in phases
can drastically reduce the amount of time taken to find that
solution (relative to the time taken to apply an algorithm to
the entire problem) and also considerably improve the quality
of that solution. In essence the method offered is a hybrid of
heuristic sequencing and evolutionary methods, which (as we
74 IEEE TRANSACTIONS ON EVOLUTIONARY COMPUTATION, VOL. 3, NO. 1, APRIL 1999
TABLE V
RESULTS OF A PPLYING H EURISTIC B ACKTRACKING
B ASED ON S ATURATION D EGREE TO THE S AME D ATA
have shown) can outperform either method on its own. This
hybrid improves on its components by utilizing knowledge of
the problem to order events according to expected difficulty
but instead of taking the single most difficult event and perhaps
placing it in the best available period, it takes a number of the
most difficult events and applies the evolutionary algorithm
EA to find the best placements with respect to each other, as
well as with those events already scheduled.
In attempting to determine the best subset size to use
with this method, there appears to be an optimal size that
is perhaps related to the number of events in the problem,
though there may be other considerations. For instance when
using saturation degree the smaller kfu and carf92 problems
seem to work best with the smaller subset size of 50 with a
look-ahead approach, the larger nott data set produces roughly
equivalent results at sizes of 50 and 100, both with look-ahead
approaches, while a subset size of 100 with a look-ahead
approach produces the best results on the pur data set. As
mentioned earlier we might have expected the optimal subset
size for the pur data set to be higher due to the huge nature of
the problem. This could be due to the evolutionary algorithm
perhaps having an upper limit on the amount of data it can
efficiently handle (which could perhaps be overcome with
larger population sizes, though this would inevitably lead to
even higher run times) or maybe because of the low density
of the conflict matrix. Throughout the trials, however, the use
of a look-ahead approach shows obvious benefits. Although
there is substantial extra time involved in doing this, it is not
quite so important when we use subset sizes that are relatively
small such as those which seem to produce the best results.
Even with a good choice of heuristic, and an optimal subset
size with a look ahead, it is possible that on some more difficult
problems placements made earlier in the process could well
prevent some events being scheduled later in a valid period.
To prevent this from happening we could borrow another idea
from heuristic sequencing methods and allow a backtracking
operator to be applied at the end of a phase if there are any
events still unscheduled. Such an operator would have to be
allowed to move events that have previously been fixed to
be effective. This would inevitably degrade the quality of the
timetable to some degree but should mean that the process
will have as much chance of finding a feasible timetable as
any other method.
This approach could possibly be adapted to other schedul-
ing problems, especially those where some sort of heuristic
sequencing approach exists. Early work is being carried out
in the Automated Scheduling and Planning group at the
University of Nottingham into employing a similar approach
for power maintenance scheduling problems.
REFERENCES
[1] E. K. Burke, D. G. Elliman, P. H. Ford, and R. F. Weare, “Examination
timetabling in british universities a survey,” in The Practice and Theory
of Automated Timetabling: Selected Papers from the 1st International
Conference (Lecture Notes in Computer Science 1153), E. Burke and
P. Ross, Eds. Berlin, Germany: Springer-Verlag, 1996, pp. 76–90.
[2] E. K. Burke, D. G. Elliman, and R. F. Weare, “A hybrid genetic
algorithm for highly constrained timetabling problems,” in Genetic
Algorithms: Proceedings of the 6th International Conference, L. J.
Eshelman, Ed. San Francisco, CA: Morgan Kaufmann, 1995, pp.
605–610.
[3] E. K. Burke and J. P. Newall, “Investigating the benefits of utilising
problem specific heuristics within a memetic timetabling algorithm,”
Dept. Comput. Sci., Univ. Nottingham, UK, Working Paper NOTTCS-
TR-97-6, 1997.
[4] E. K. Burke, J. P. Newall, and R. F. Weare, “A memetic algorithm for
university exam timetabling,” in The Practice and Theory of Automated
Timetabling: Selected Papers from the 1st International Conference
(Lecture Notes in Computer Science 1153), E. Burke and P. Ross, Eds.
Berlin, Germany: Springer-Verlag, 1996, pp. 241–250.
[5] M. W. Carter, “A decomposition algorithm for practical timetabling
problems,” Dept. Industrial Eng., Univ. Toronto, Working Paper 83-
06,Apr. 1983.
[6] , “A survey of practical applications of examination timetabling,”
Oper. Res., vol. 34, pp. 193–202, 1986.
[7] M. W. Carter and G. Laporte, “Recent developments in practical
examination timetabling,” in The Practice and Theory of Automated
Timetabling: Selected Papers from the 1st International Conference
(Lecture Notes in Computer Science 1153), E. Burke and P. Ross, Eds.
Berlin, Germany: Springer-Verlag, 1996, pp. 3–21.
[8] M. W. Carter, G. Laporte, and J. W. Chinneck, “A general examination
scheduling system,” Interfaces, vol. 11, pp. 109–120, 1994.
[9] M. W. Carter, G. Laporte, and S. Y. Lee, “Examination timetabling:
Algorithmic strategies and applications,” Dept. Industrial Eng., Univ.
Toronto, Working Paper 94-03, Jan. 1995..
[10] D. Corne, P. Ross, and H. Fang, “Fast practical evolutionary
timetabling,” in Lecture Notes in Computer Science 865 (AISB Workshop
on Evolutionary Computing), T. C. Fogarty, Ed.. Berlin: Springer-
Verlag, 1994, pp. 250–263.
[11] L. Davis, Ed., Handbook of Genetic Algorithms. New York: Van
Nostrand Reinhold, 1991.
[12] R. Dawkins, The Selfish Gene. London, U.K.: Oxford Univ. Press,
1976.
[13] E. Foxley and K. Lockyer, “The construction of examination timetables
by computer,” Comput. J., vol. 11, pp. 264–268, 1968.
[14] A. Hertz, “Tabu search for large scale timetabling problems,” Eur. J.
Oper. Res., vol. 54, pp. 39–47, 1991.
[15] R. M. Karp, “Reducibility among combinatorial problems,” in Complex-
ity of Computer Computations, R. E. Miller and J. W. Thatcher, Eds.
New York: Plenum, 1972, pp. 85–103.
[16] P. Moscato and M. G. Norman, “A ‘memetic’ approach for the trav-
elling salesman problem implementation of computational ecology for
combinatorial optimization on message-passing systems,” in Proc. Int.
Conf. Parallel Computing and Transputer Applications. Amsterdam:
IOS Press, 1991.
[17] B. Paechter, A. Cumming, and H. Luchian, “The use of local search sug-
gestion lists for improving the solution of timetable problems with evo-
lutionary algorithms,” in Lecture Notes in Computer Science 993 (AISB
Workshop on Evolutionary Computing), T. C. Fogarty, Ed. Berlin:
Springer-Verlag, 1995, pp. 86–93.
[18] P. Ross, D. Corne, and H.-L. Fang, “Improving evolutionary timetabling
with delta evaluation and directed mutation,” in Parallel Problem
Solving in Nature, vol. III, Y. Davidor, H-P. Schwefel, and R. Manner,
Eds. Berlin: Springer-Verlag, 1994.
[19] J. M. Thompson and K. A. Dowsland, “General cooling schedules
for a simulated annealing based timetabling system,” in The Practice
and Theory of Automated Timetabling: Selected Papers from the 1st
International Conference ( Lecture Notes in Computer Science 1153), P.
Ross and E. Burke, Eds. Berlin: Springer-Verlag, 1996, pp. 345–364.
[20] R. F. Weare, “Automated examination timetabling,” Ph.D. dissertation,
Univ. Nottingham, Dept. Comput. Sci., 1995.
[21] D. J. A. Welsh and M. B. Powell, “An upper bound for the chromatic
number of a graph and its application to timetable problems,” Comput.
J., vol. 10, pp. 85–86, 1967.