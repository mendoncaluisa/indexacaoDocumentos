Nelson Glauber de Vasconcelos Leal

Novatec



Copyright © 2015, 2019 Novatec Editora Ltda.



Todos os direitos reservados e protegidos pela Lei 9.610 de 19/02/1998. É proibida a reprodução desta
obra, mesmo parcial, por qualquer processo, sem prévia autorização, por escrito, do autor e da Editora.
Editor: Rubens Prates
Assistente editorial: Priscila A. Yoshimatsu
Revisão gramatical: Smirna Cavalheiro
Editoração eletrônica: Carolina Kuwabata
Capa: Leo Macedo



ISBN: 978-85-7522-727-5
Histórico de edições impressas:
Março/2019 Terceira edição
Novembro/2016 Segunda reimpressão
Março/2016 Primeira reimpressão
Novembro/2015 Segunda edição
Março/2015 Primeira reimpressão
Janeiro/2015 Primeira edição (ISBN: 978-85-7522-412-0)



Novatec Editora Ltda.
Rua Luís Antônio dos Santos 110
02460-000 – São Paulo, SP – Brasil
Tel.: +55 11 2959-6529
Email: novatec@novatec.com.br
Site: www.novatec.com.br
Twitter: twitter.com/novateceditora
Facebook: facebook.com/novatec
LinkedIn: linkedin.com/in/novatec
NG20190228



Dedico este livro primeiramente a Deus, que me abençoa todos os
dias com suas graças, as quais nunca terei tempo suficiente para

agradecer.
Aos alicerces da minha vida, meu pai, Neves, e minha mãe,

Eronilda, que me deram amor, educação e me ensinaram a trilhar
o caminho do bem.

A Marcia, minha esposa e o grande amor da minha vida. Se não
fosse pelo seu amor, seu companheirismo, sua paciência, seu apoio

e sua compreensão, este livro não existiria.
Ao meu irmão, Nevinho, meu segundo pai, grande amigo e

conselheiro. À minha irmã, Martinha, que me deu o exemplo de
onde o conhecimento poderia me levar.



Sumário

Agradecimentos
Sobre o autor
Prefácio
Introdução
Capítulo 1 ■ Conceitos básicos
Iniciando um novo projeto com Android Studio

Android Jetpack
Estrutura de um projeto Android
AndroidManifest.xml
Arquivos de recursos
MainActivity.kt
Arquivo de layout

Configuração do aparelho
Android Virtual Device
Emulador Genymotion
Executando a aplicação
Processo de compilação
Alocação dinâmica de recursos

Idioma
DIP – Density Independent Pixel
Orientação e resolução de tela

Android Device Tools
findViewById e evento de clique
Kotlin Android Extensions
Debug no Android Studio
Tratando erros na aplicação
Capítulo 2 ■ Layouts
Gerenciadores de layout



Editor visual de layout do Android Studio
Largura e altura
Padding e Margin
FrameLayout
RelativeLayout
LinearLayout
TableLayout
GridLayout
ConstraintLayout

Posicionamento
Tamanho
Bias (Inclinação)
Chains
GuideLines

CardView
ScrollView
Capítulo 3 ■ Activity e Intents
Activity
Passando parâmetros para uma Activity
Passando objetos em Intents
Biblioteca: Parceler
Parcelize
Ciclo de vida da Activity
Tratando mudança de orientação

Opção 1: Forçar uma orientação
Opção 2: Tratar mudança de orientação manualmente
Opção 3: Salvar o estado da Activity

Orientação e o estado da Activity
Obtendo dados de outra activity
Intents implícitas
Display cutout
Capítulo 4 ■ Componentes – Parte I
TextView

AutoLink
Ellipsize + MaxLines



Espaçamento
Alterando a fonte
Autosize
Usando HTML
Pondo em prática
CharSequence e Spanned

EditText
Hint
Input Type e Ime Options
Digits
Pondo em prática
Máscara no EditText

A biblioteca de componentes do Material Design
TextInputLayout
Mais componentes
Capítulo 5 ■ Componentes – Parte II
ListView e Adapter customizados

Detectando o clique em um item da ListView
Cabeçalho e rodapé
Empty View
Invertendo os itens da ListView

AutoCompleteTextView
RecyclerView
Capítulo 6 ■ Componentes – Parte III
Utilizando o Material Design
Formato 9-Patch
Utilização de estilos
Selectors

Selector para um Button
Selector para texto
Selector para RadioButton

WebView
Chrome Custom Tabs
Views customizadas
Salvando o estado da view



Atributos personalizados
Capítulo 7 ■ MVP (Model View Presenter)
Model
View
Presenter
Comunicação entre as camadas
Variações na implementação do padrão MVP
Capítulo 8 ■ Fragments
Fragment
Projeto de hotéis com MVP
Listagem de hotéis
Tela de detalhes do hotel
Definindo layout para tablets
Action Bar

Adicionando a action bar ao projeto
AlertDialog e DialogFragment

Adicionando novos hotéis
Tratando o retorno do dialog

Usando o botão Up
Seleção múltipla com action bar
Retendo a instância do Fragment
Desfazendo a exclusão com a SnackBar
Floating Action Button
Coordinator Layout
Ação de compartilhamento
Capítulo 9 ■ Modos de navegação
Tipos de navegação

Toolbar
DrawerLayout e NavigationView
Fragments do primeiro nível

Abas usando TabLayout
Bottom Navigation
ViewPager
Empilhando Fragments



Navigation API
BottomSheet

BottomSheetDialog
Capítulo 10 ■ Persistência de dados
Shared Preferences
Lendo e escrevendo arquivos
Arquivos na memória interna
Arquivos no cartão de memória
Permissões no Android 6.0 Marshmallow
Dica de biblioteca: Permission Dispatcher
Telas de preferências com PreferenceFragment
Banco de dados SQLite

Utilizando o SQLite na aplicação de hotéis
Definindo o banco de dados da aplicação

Injeção de dependência com Koin
Editando hotéis cadastrados
Criando um Adapter para a tela de listagem
Content Provider
Autobackup dos dados
Capítulo 11 ■ Android Architecture Components
Lifecycle
ViewModel
LiveData
Room
Refatorando o projeto de hotéis para Architecture Components

Room
View Models

Capítulo 12 ■ Acesso à web – Parte I
Conectando à rede
Cada um na sua thread
Tarefas assíncronas
Estabelecendo a conexão
JSON
Lendo um JSON assincronamente via HTTP



Dica de biblioteca: Carregando imagens da web
Dica de biblioteca: OkHttp
Dica de Biblioteca: GSON

OkHttp + GSON
Lendo arquivos XML
Coroutines
Capítulo 13 ■ Broadcast receiver
Capturando eventos
Declarando um broadcast receiver
Disparando um broadcast receiver implícito
Broadcast receivers locais
Tratando eventos do sistema
Declarando com permissões
Detectando a presença de conectividade
Capítulo 14 ■ Acesso à web – Parte II
Padrão REST
Web service REST com PHP
Preparando a aplicação para a web
Dica de biblioteca: Retrofit
Acessando um web service
Upload de arquivos
Capítulo 15 ■ Services
Quando utilizar um serviço?
Limitações no uso de serviços
Service versus IntentService
Utilizando a classe JobIntentService
Conectando-se a um serviço
Capítulo 16 ■ Agendamento de tarefas
Handler
Agendamento de tarefas em background
WorkManager
WorkManager no projeto de hotéis
Doze Mode
Detectando aplicação em background



Capítulo 17 ■ Notificações
Atributos de uma notificação
Desabilitando notificações
Canais de notificação
Criando notificações
Notificação simples
Ação de clicar na Notificação
Notificação com texto longo

Notificações com botões de ação
Notificações com digitação de texto
Notificações agrupadas
Detectando a exclusão da Notificação
Visibilidade das Notificações
Notificações Heads-up
Notificações customizadas
Capítulo 18 ■ APIs do Google
Google Sign-In

Gerando a chave de acesso
Integrando o Google Sign-In no app de hotéis
Fazendo o logout e desautorizando o aplicativo
Boas práticas na integração do Google Sign-In uma aplicação servidora
Desautorizando um aplicativo

Firebase Cloud Messaging
Visão geral da arquitetura
Adicionando o projeto no Firebase Console
Adicionando o FCM ao projeto de hotéis
Aplicação Cliente
Enviando mensagens pelo Firebase Console
Aplicação servidora
Simulando o envio de mensagem FCM pelo servidor

YouTube Android Player API
Pondo em prática

Propaganda com AdMob
Adicionando um banner



Capítulo 19 ■ Mapa e localização
Google Maps

Gerando a chave de acesso
Trabalhando com mapas

Mapas e coordenadas
Localização
Obtendo a localização atual do aparelho
Verificando se o GPS está habilitado
Buscando um endereço
Traçando rotas
Monitorando a localização do usuário
Trabalhando com áreas demarcadas (Geofence)
Capítulo 20 ■ Data Binding
Projeto: cadastro de livros
Binding de objetos em arquivos de layout
Binding adapters para conversão de textos
Binding adapters para carregamento de imagens
Two way data binding
Inverse Binding Adapters
Data Binding em listas
BaseObservable, Observable e Observable fields

Ouvindo mudanças nas propriedades
Data binding expression language (EL)
Capítulo 21 ■ Firebase
Configurando o projeto de livros
Authentication
Cloud Firestore

Configurando o Firestore
Inserindo e atualizando livros
Listando os livros
Ajustes de UI
Removendo registros

Cloud Storage
Configurando o Storage



Fazendo o upload da capa do livro
Excluindo a capa do livro

Crashlytics
Capítulo 22 ■ Contatos e SMS
Content Provider de contatos
Inserindo contatos
Recebendo e enviando mensagens SMS

SMS API a partir do Kit Kat (4.4)
Capítulo 23 ■ Bluetooth
Bluetooth API

Permissões
Ativando o Bluetooth

Processo de conexão
Servidor
Cliente

Enviando e recebendo mensagens
Capítulo 24 ■ AppWidgets
Widget API
AppWidgetProviderInfo
Layout de um widget
AppWidgetProvider
Tratando eventos de clique em Widgets
Widgets de listagem
Capítulo 25 ■ Multimídia
Câmera
Tirando fotos
Alterando o papel de parede do aparelho
Gravando vídeos
Criando uma activity de câmera

Camera1, Camera2 e bibliotecas
Mobile Vision API
Gravando áudio
Reconhecimento de voz via intent
Reconhecimento de voz com SpeechRecognizer



Capítulo 26 ■ Animações
View Animations
clipChildren e clipToPadding
ObjectAnimator e ViewPropertyAnimator

ViewPropertyAnimator
ObjectAnimator
TypeEvaluator

Animação quadro a quadro
Animando alterações no layout
Transition API
Animações circulares
Transições entre Activities

Transição de activities com ActivityOptions
Animações entre fragments
Animação no ViewPager

Considerações sobre animações
Capítulo 27 ■ Gestos e toque na tela
Detectando toques na tela
Detectando gestos

Gesto de escala
Drag and Drop
Capítulo 28 ■ Sensores
Trabalhando com sensores
Listando os sensores do aparelho
Utilizando o acelerômetro
Capítulo 29 ■ Gradle
Visão geral
Projeto e módulos
Dependências
Trabalhando com módulos
Source sets
Arquivos do Gradle

settings.gradle
build.gradle



gradle.properties
local.properties
gradle-wrapper

Build Types, Flavors e Build Variants
Assinatura do aplicativo
ProGuard

Proguard e bibliotecas
Proguard D8 e R8

Multidex
Otimizando o processo de build
Capítulo 30 ■ Material Design e bibliotecas Android
Aplicativo de discos
Definindo as cores e o tema da aplicação
Lendo informações do web com GSON e OkHttp
Listagem de álbuns da web
Elevação da View
CardView
CoordinatorLayout

CoordinatorLayout e AppBar
CoordinatorLayout e CollapsingToolbarLayout

Transições de tela
Transição com itens compartilhados
Biblioteca Palette
Persistindo os álbuns favoritos
TabLayout e a tela de favoritos
Vector Drawable

FloatingActionButton da tela de favoritos
AnimatorVectorDrawable

Animated Vector Drawable com Shape Shifter
Capítulo 31 ■ Ferramentas de teste
Introdução

Estrutura do projeto de testes
Testes unitários com JUnit
Testes instrumentados com AndroidJUnitRunner

Validando os eventos de uma activity



Espresso
Configurando o Espresso
Criando um teste simples
Trabalhando com listas
Actions e Matchers customizados
Espresso e RecyclerView

Teste de estresse com o Monkey
Mais ferramentas

Capítulo 32 ■ Google Play
Preparação do código-fonte

AndroidManifest.xml
build.gradle

Geração do APK
APK Analyzer

Registro de desenvolvedor na Google Play
Publicação do aplicativo

Versões de apps
Detalhes do app
Conteúdo e classificação
Preço e distribuição
Finalizando a publicação



Agradecimentos

Eu não imaginava quão grande era o trabalho de escrever uma obra como esta
e, para torná-la realidade, várias pessoas e instituições contribuíram direta ou
indiretamente.

Meus sinceros agradecimentos ao Google, por ter mudado minha vida
profissional ao me nomear para o programa de GDE (Google Developer
Experts). Isso me deu a oportunidade de conhecer comunidades de
desenvolvedores do Brasil e do mundo, além de me proporcionar um contato
mais próximo com os times responsáveis pelas APIs e ferramentas do
Android.

À comunidade de desenvolvedores Android Dev BR, na qual todos
compartilham conhecimento por meio de posts, vídeos, palestras, eventos ou
simplesmente tirando dúvidas rápidas.

Um agradecimento especial ao Marcelo Quinta e ao Ubiratan Soares, que
me ajudaram respectivamente com os capítulos sobre Google Play e
ferramentas de testes. Sem sombra de dúvida, esses capítulos ficaram muito
melhores com a contribuição deles.

Não posso deixar de agradecer a todas as pessoas que leram as primeiras
edições do “Dominando o Android”. Cada comentário, avaliação, crítica, foi
essencial e me impulsionou a escrever este novo livro revisado, ampliado e
atualizado.

Muitíssimo obrigado a todos!



Sobre o autor

Nelson Glauber é mestre em Engenharia de Software e trabalha com
desenvolvimento de software desde 2002. Atua como engenheiro de software
especializado em projetos mobile desde 2006, e com Android desde 2009.
Em 2014, foi nomeado pelo Google como primeiro Developer Expert de
Android da América Latina. Também é professor de tecnologias móveis em
cursos de extensão e pós-graduação. Escreve sobre desenvolvimento mobile
no seu blog pessoal (www.nglauber.com.br). Pode ser contatado pelo email
nglaubervasc@gmail.com.



Prefácio

A computação é, sem dúvida, uma das áreas que vem evoluindo mais
rapidamente nas últimas décadas, principalmente se compararmos com os
primeiros computadores que ocupavam diversos andares e eram usados
basicamente para fazer cálculos de maneira absurdamente rápida para aquela
época. Exemplo desse uso dos computadores pode ser visto no filme
“Estrelas Além do Tempo”, que as “computadoras” humanas recebem o
“reforço” do IBM 7090 para a realização dos cálculos que acabariam por
levar o homem à Lua.

Depois disso vem a história que conhecemos, com a evolução dos
mainframes e a criação dos Centros de Processamento de Dados, CPD, em
diversas empresas que passavam a automatizar suas rotinas, geralmente
começando por financeiro, RH, e, por fim, relatórios e mais análises que
fossem possíveis.

Com a evolução da microeletrônica, os circuitos, processadores e todos os
componentes foram cada vez mais reduzindo em tamanho, melhorando em
desempenho e se tornando mais acessíveis. Unindo a essa miniaturização e
popularização, a chegada da internet às empresas e residências na década de
1990 provocou uma popularização ainda mais intensa dos computadores
pessoais, fazendo com que aos poucos se tornasse um equipamento
indispensável em casa ou no escritório.

E com o passar do tempo as pessoas foram se acostumando a ficar “online”,
trocar emails, buscar informações na internet etc. Assim, os telefones
celulares, que também já vinham se popularizando, passaram a incorporar
cada vez mais funcionalidades de conectividade e multimídia, a ponto de
fabricantes como a Nokia e SonyEricsson lançarem telefones com GPS,
câmeras de alta resolução e players de vídeo e música para tentarem atrair um
público cada vez mais sedento por conectividade e inovação.

Porém, parecia que ainda faltava algo. Apesar de já permitir certa
possibilidade para desenvolvedores, todo o processo ainda era um pouco
complicado, principalmente para se distribuir aplicativos para os usuários



finais. É então que chega o ano de 2007, o ano-chave para a computação
móvel, pois nesse ano são anunciados o iPhone e o Android que, pelas
demonstrações, prometiam ser inovações incríveis, principalmente pelo
modelo de negócio que permitiria aos desenvolvedores criarem e oferecerem
seus aplicativos para todo o mundo.

Desde então, a plataforma Android evoluiu de forma constante, com novas
APIs a cada versão, novas formas de organizar seu aplicativo, e conforme os
aplicativos aumentam a complexidade, novas técnicas de programação e
padrões de projeto foram sendo incorporados ao processo de
desenvolvimento de aplicativos Android.

Dominar essas técnicas e as APIs da plataforma é importante para aqueles
que querem se tornar, e se manter, como bons desenvolvedores. Isso requer
conhecer desde aspectos básicos da plataforma, como o que são Intents,
layouts, activities e os componentes visuais da plataforma. E também
assuntos relacionados à navegação e componentização, como os modos de
navegação e fragments.

O livro do Nelson traz isso de uma forma clara e direta, dando os
fundamentos para que o leitor possa seguir de forma confiante na leitura e
também aprender com exemplos práticos e uma leitura prazerosa.

Além dos tópicos fundamentais técnicos, é interessante que o livro também
cobre aspectos de padrão de projeto, falando do MVP, e dos Architecture
Components, que são componentes que a nossa equipe no Google
desenvolveu para ajudar os desenvolvedores a criar aplicativos mais robustos
e estruturados. Esses tópicos permitirão que o leitor consiga fazer aplicativos
de alta qualidade e com uma arquitetura moderna, fator que pode ajudar
muito na busca por um emprego, ou evolução para aqueles que já
programavam na plataforma.

E como eu mesmo disse, a internet tem papel fundamental nas plataformas
móveis, e isso é muito bem explorado nos capítulos que tratam
especificamente de acesso à web, mas também em outros capítulos que vão
melhorar essa experiência de forma complementar, como, por exemplo, a
persistência de dados, Receivers, Services e toda parte de agendamento e
execução de tarefas. Capítulos de EXTREMA importância, para aplicativos
de qualidade, pois ao longo do tempo a plataforma Android evoluiu,
tornando-se exigente no ponto de vista de consumo de bateria, rede e



memória.
No entanto, não apenas de internet “vive” um smartphone, correto? Os

telefones hoje em dia são praticamente computadores portáteis, com diversos
recursos avançados e nesse ponto o livro é incrivelmente completo,
abordando assuntos como sensores, gestos, toques na tela, Bluetooth,
animações etc. Assuntos que farão o seu aplicativo ter um nível de
profissionalismo maior se aplicados da forma correta, e com os exemplos e
recomendações do Nelson, fica mais fácil de entender.

Outro assunto que é importante para o desenvolvedor Android é conhecer o
seu próprio ambiente de trabalho e distribuição. Nisso, mais uma vez, o livro
é muito feliz em oferecer um capítulo sobre Gradle, que irá ajudar o leitor a
entender como funciona o sistema de build do Android, como criar versões
diferentes para teste e produção, por exemplo, e diversas outras boas práticas.
E também o capítulo sobre Google Play, afinal é importante conhecer as
regras, boas práticas e maneiras de distribuição para atingir o sucesso com
seu aplicativo Android.

A parte técnica é extremamente importante, mas tão importante quanto
funcionar bem é o aplicativo ser agradável, fácil de usar e com um bom
design. O capítulo sobre Material Design e outras bibliotecas será muito útil
nessa missão, pois pode se tornar um diferencial do seu aplicativo, fazendo
com que o usuário prefira ou deixe de usar o seu app.

Como podemos ver, trata-se de um livro completo para quem quer se tornar
um programador Android, ou para aqueles que já trabalham na plataforma
mas querem melhorar suas habilidades. Nelson é um dos nossos GDEs
(Google Developer Expert) mais ativos, e tenho o prazer de acompanhá-lo
desde o começo dessa jornada conosco, e ver uma obra como esta é uma
grande satisfação, pois ele está contribuindo de forma incrível para que
tenhamos cada vez mais melhores programadores Android.



Antonio Marin Neto,
Senior Developer Advocate no Google

A quem se destina este livro
Este livro é destinado a estudantes e profissionais de desenvolvimento de
software que querem aprender a desenvolver aplicativos nativos para a
plataforma Android. O conteúdo apresentado aqui parte da premissa que o
leitor já possui bons conhecimentos de lógica de programação, orientação a
objetos e linguagem de programação Java, além de conceitos básicos de
arquivos XML e banco de dados SQL.

Os exemplos apresentados aqui serão desenvolvidos utilizando a linguagem
de programação Kotlin, uma linguagem moderna, concisa e flexível. Mantida
pela JetBrains, o Kotlin é open-source e vem sendo amplamente utilizado
pela comunidade de desenvolvedores, e passou a ter suporte oficial do
Google em 2017.

Por ter uma curva de aprendizado baixíssima, principalmente para os
desenvolvedores Java, este livro não possui um capítulo dedicado à
linguagem, em vez disso, cada diferença significativa entre Kotlin e Java será
explicada detalhadamente. Assim, o leitor aprenderá Kotlin diretamente no
contexto do desenvolvimento de aplicativos Android.

Entretanto, o propósito deste livro não é ensinar a linguagem Kotlin, e sim a
criação de aplicativos Android utilizando Kotlin. Caso o leitor prefira se
familiarizar um pouco com a linguagem antes de começar a leitura deste
livro, eu disponibilizei um vídeo no endereço https://youtu.be/FHZ6bI3zb4M
no qual apresento uma introdução ao Kotlin, mostro os principais recursos da
linguagem e as diferenças mais significativas para o Java. Recomendo
também o site Kotlin Koans (https://try.kotlinlang.org em inglês) que permite
compilar e executar o código Kotlin online além de ensinar desde os
fundamentos mais básicos da linguagem até tópicos mais avançados.

Mesmo que você possua algum conhecimento sobre Android, sugiro que
você dê uma olhada neste livro. Pois ao mostrá-lo a outros desenvolvedores,
inclusive aos que já trabalham com Android, ouvi muitas frases como “Olha
só! Eu não sabia disso...”, “Bacana! Eu fazia de outra forma, mas assim
parece ser bem melhor” ou, ainda, “Nossa... Eu nunca tinha entendido isso!”.



Então, espero que este livro seja útil também para desenvolvedores mais
experientes.

Exemplos do livro e grupo de discussão
O código-fonte atualizado de todos os exemplos apresentados no livro estão
disponíveis no GitHub (https://github.com/nglauber/dominando_android3),
separados por capítulo e o leitor poderá consultá-los livremente em caso de
dúvidas. Também recomendo registrar-se no grupo de discussão
(http://bit.ly/dominando_android3) para esclarecer dúvidas, relatar possíveis
erros e deixar sua sugestão de melhoria para esta obra.

Espero realmente que você aproveite todo o conteúdo apresentado aqui para
que consiga dominar o Android com a linguagem Kotlin. Boa leitura e bons
estudos!



Introdução

Atualmente, a plataforma Android é líder absoluta no mercado de
dispositivos móveis e desenvolver aplicativos para esses aparelhos é muito
divertido, mas, acima de tudo, desafiador. Neste capítulo começaremos nossa
jornada pelo mundo do desenvolvimento mobile para a plataforma do
Google, conhecendo um pouco sobre ela e configurando o ambiente de
desenvolvimento para construirmos os projetos ao longo do livro.

O que é o Android?
O Android é o sistema operacional para dispositivos móveis mais utilizado
em todo o mundo com mais de dois bilhões de dispositivos ativos,
principalmente em smartphones e tablets. Entretanto, o Android também está
presente em outros dispositivos como automóveis, TVs, relógios, entre
outros.

Na verdade, o Android não é apenas um sistema operacional, mas um
conjunto completo de software para dispositivos móveis que inclui: um
sistema operacional, um middleware e aplicações-chave. O sistema
operacional tem como base o kernel do Linux, que é responsável pelo
gerenciamento de processos, drivers, memória e energia. O middleware, por
sua vez, controla a interação entre os aplicativos instalados no aparelho,
facilitando a comunicação entre eles. E as aplicações-chave são programas
comuns, como discador, navegador, contatos, mensagens etc.

O Android é open-source e seu código-fonte pode ser baixado livremente
no endereço http://source.android.com. O código-fonte é distribuído sob
licença da Apache, que permite que qualquer fabricante de aparelhos utilize o
AOSP (Android Open Source Project) em seus aparelhos e faça as
modificações que desejar. Entretanto, a licença não os obriga a compartilhar
essas mudanças com os seus concorrentes, fazendo com que cada fabricante
tenha um “Android personalizado”. Contudo, para que um aparelho saia de
fábrica com os aplicativos do Google (Gmail, Maps, Google Play, YouTube



etc.), ele terá que ser homologado com base em dois itens: o CDD (Android
Compatibility Definition Document) que enumera os requisitos de software e
hardware que o aparelho deve possuir; e passar pelo CTS (Compatibility Test
Suite) que é uma bateria de testes para evitar que o fabricante, com suas
modificações, tenha afetado alguma API que os desenvolvedores utilizam.

A primeira versão do Android foi lançada em 2008, e de lá para cá tivemos
várias versões onde cada uma possui um nome de um doce e um número
sequencial que chamamos de API Level. Essa informação é muito importante
para sabermos quais recursos, classes e bibliotecas estão disponíveis para o
desenvolvedor em cada versão. A Tabela 0.1 lista todas as versões do
Android lançadas até a publicação deste livro.

Tabela 0.1 – Versões do Android
Nome da versão Versão API Level

Cupcake 1.5 3
Donut 1.6 4
Eclair 2.0 5

2.0.1 6
2.1 7

Froyo 2.2 8
Gingerbread 2.3 9

2.3.3 10
Honeycomb 3.0 11

3.1 12
3.2 13

Ice Cream Sandwich 4.0.1 – 4.0.2 14
4.0.3 – 4.0.4 15

Jellybean 4.1 16
4.2 17
4.3 18

KitKat 4.4 19
4.4W1 20

Lollipop 5.0/5.1 21/22
Marshmallow 6.0 23
Nougat 7.0 24

7.1 25
Oreo 8.0 26

8.1 27
Pie 9.0 28
1 O Android 4.4W é o KitKat para dispositivos vestíveis como os relógios com Android Wear.

É importante conhecer essas versões para sabermos quais APIs estão



disponíveis para serem utilizadas em nossas aplicações, pois se acessarmos
uma classe ou até mesmo um atributo ou método que não esteja disponível
em determinada versão, ocorrerá um erro quando esse trecho de código for
chamado durante a execução da aplicação.

Até a versão Gingerbread, o Android rodava exclusivamente em
smartphones, mas quando os primeiros tablets Android foram lançados, eles
vinham com a versão Honeycomb, que era exclusiva para esse tipo de
aparelho. Com o lançamento do Ice Cream Sandwich, houve a reunificação
da plataforma, e novamente a mesma versão do Android passou a rodar em
smartphones e tablets. Com o lançamento da versão Lollipop, o Android
passou também a executar em relógios inteligentes (smartwatches) com o
Android Wear (atualmente Wear OS), em TVs com o Android TV e em
automóveis com o Android Auto.

Google Play
O Google Play é a loja de aplicativos, livros, filmes e músicas do Android, e
é por meio dela que usuários de todo o mundo podem fazer o download de
conteúdo para seu aparelho.

Para publicar aplicativos na loja, é necessário criar uma conta de
desenvolvedor e pagar uma taxa de 25 dólares uma única vez, ou seja, não é
preciso ficar renovando periodicamente. Pode-se optar por disponibilizar os
aplicativos de forma gratuita ou paga, e nesse segundo caso o desenvolvedor
fica com 70% do valor arrecadado sobre as vendas do aplicativo.

Ao publicar uma aplicação, é possível visualizar quantos usuários já
baixaram o aplicativo, inclusive por versão do Android. Outro recurso
bastante útil são os relatórios de erros, que indicam a causa do problema de
modo a facilitar a sua resolução. O processo de publicação de um aplicativo
na Google Play será apresentado no Capítulo 32.

Android Studio
Uma vez apresentado um pouco do histórico da plataforma, partiremos para a
configuração do ambiente de desenvolvimento necessário para criar os
aplicativos. Será preciso um computador com no mínimo 3 GB de memória
RAM (o recomendado é 8 GB ou mais) executando o sistema operacional



Microsoft Windows, Linux ou Mac OS X.
O Android Studio é o IDE (Integrated Development Environment) padrão

para desenvolvimento de aplicações Android. Ele é uma personalização do
IntelliJ IDEA Community criado pela Jetbrains e lançado no Google I/O1 de
2013. O Android Studio traz diversas ferramentas para auxiliar o processo de
desenvolvimento, testes, análise e depuração de aplicações. Por esta razão,
utilizaremos o Android Studio para criarmos os projetos que
desenvolveremos no decorrer do livro.

Faça o download do Android Studio no endereço
https://developer.android.com/studio e instale-o no local de sua preferência2.
O processo de instalação não tem nada de especial, devendo apenas serem
seguidas as etapas do assistente, mantendo selecionadas as opções-padrão.

Após a instalação, execute o Android Studio e será exibida a tela Figura
0.1. Clique na opção Configure > Check for Updates para instalar as
atualizações disponíveis.

Figura 0.1 – Tela inicial do Android Studio.
O Android Studio já vem com o Open JDK (http://openjdk.java.net) que

possui as bibliotecas e ferramentas do Java – linguagem de programação
padrão da plataforma. O Android Studio também inclui o Android SDK
(Software Development Kit), que contém as bibliotecas e ferramentas



necessárias para criar os aplicativos. Uma dessas ferramentas é o SDK
Manager, que permite instalar e atualizar os componentes do SDK do
Android. Para acessar o SDK Manager, selecione a opção Configure > SDK
Manager na tela inicial do Android Studio e será exibida a tela da Figura 0.2.

Na aba SDK Platforms, clique no checkbox Show Package Details e
certifique-se de que os seguintes itens estejam marcados ou já instalados:

• Android 9.0 (Pie) > Android SDK Platform 28
• Google Play Intel x86 Atom System Image
O primeiro item é necessário para ter acesso às APIs do Android, e o

segundo para a imagem do emulador desta versão do Android. Os demais
itens são opcionais, mas você pode fazer o download, se preferir.

Figura 0.2 – Android SDK Manager.
Selecione agora a aba SDK Tools, e teremos as opções conforme a Figura

0.3.



Figura 0.3 – Aba SDK Tools do Android SDK Manager.
Verifique se os itens a seguir estão instalados e atualizados:
• Android SDK Build-Tools (o de maior versão)
• Android Emulator
• Android SDK Platform-Tools
• Android SDK Tools
• Intel x86 Emulator Accelerator (HAXM Installer)
• Support Repository (todos os itens)
Instale os pacotes que estiverem marcados para instalação e atualização

(indicados com o texto Update available). Certifique-se de manter sempre os
pacotes atualizados para ter acesso aos recursos mais recentes do Android.

Versões das ferramentas utilizadas no livro
Todos os exemplos deste livro foram desenvolvidos utilizando a versão 3.3
do Android Studio. Caso algo esteja diferente do que for apresentado aqui,
verifique a opção correspondente na versão atual do Android Studio usada
em seu computador.



A mesma recomendação aplica-se às diversas bibliotecas utilizadas nos
exemplos ao longo do livro. Tanto as bibliotecas do Google quanto as de
terceiros podem mudar repentinamente e fazer com que o exemplo deixe de
funcionar. Portanto, a versão da biblioteca utilizada no exemplo será indicada
explicitamente, o que garantirá que o projeto funcione corretamente naquela
versão específica. Sinta-se à vontade para utilizar uma versão mais recente da
biblioteca e verificar se o projeto continua funcionando. Caso encontre algum
problema, procure na documentação da biblioteca como fazer os ajustes
necessários.

Se tiver dúvidas, consulte o código-fonte do projeto no repositório do livro,
e caso ainda encontre dificuldades, entre em contato por meio do grupo de
discussão do livro.

1 Convenção anual do Google voltada para desenvolvedores.
2 Escolha um local no seu computador onde haja permissões de escrita, pois o Android Studio baixa

pacotes para esse diretório. Preferencialmente, escolha um diretório que não contenha espaços,
caracteres especiais ou acentuados.



CAPÍTULO 1
Conceitos básicos

Neste capítulo será criado o primeiro projeto Android, que analisará
detalhadamente sua estrutura e principais arquivos. Em seguida, será
demonstrado como executar o aplicativo em um dispositivo Android e em um
emulador. Por fim, é explicado como funciona a alocação dinâmica de
recursos e o acesso aos componentes de interface gráfica utilizando a
linguagem Kotlin.

Iniciando um novo projeto com Android Studio
Para criarmos nosso primeiro projeto, abra o Android Studio e a tela de boas-
vindas será exibida conforme a Figura 1.1 onde podemos optar por:

• criar um novo projeto;
• abrir um projeto existente;
• fazer checkout a partir de um sistema de controle de versão (como Git ou

Subversion);
• analisar ou depurar um APK (Android Package);
• importar um projeto existente (do Gradle, Eclipse/ADT etc.);
• importar um código de exemplo do Android.
Selecione a opção Start a new Android Studio project e será exibida a

primeira tela do assistente de criação do projeto, similar à mostrada na Figura
1.2.

Nessa tela do assistente é possível adicionar uma Activity ao projeto
partindo de um template. As Activities serão explicadas em detalhes no
Capítulo 3, mas, por ora, saiba que uma Activity é responsável por criar uma
janela na qual é exibida a interface gráfica do aplicativo. Por padrão, o
assistente nomeia essa classe como MainActivity, pois ela será a tela principal
(Main) da aplicação e por convenção, usa-se “Activity” no final do nome da



classe de modo a facilitar sua identificação no decorrer do processo de
desenvolvimento.

Figura 1.1 – Tela de boas-vindas do Android Studio.



Figura 1.2 – Tela do assistente de criação de um novo projeto.
Cada activity tem o seu conteúdo visual definido em arquivos XML que

daqui em diante será chamada simplesmente de “arquivo de layout”.
Selecione Empty Activity e clique em Next para exibir a tela da Figura 1.3.

Figura 1.3 – Definindo as configurações iniciais do projeto.
No campo Name devemos preencher o nome do aplicativo que aparecerá

no aparelho. Em Package Name devemos informar o nome do pacote, que
determina onde ficarão as classes do projeto, mas, além disso, ele serve como
identificador único do aplicativo, ou seja, não pode haver duas aplicações
com o mesmo nome de pacote instalados no aparelho. É essencial escolher
um bom nome de pacote, pois não é possível publicar uma aplicação no
Google Play com um nome de pacote que já exista. Como os domínios na
internet são únicos, utilizar o padrão “domínio invertido + nome do
aplicativo” (br.com.nglauber.hello, por exemplo) reduz drasticamente a
possibilidade de haver algum conflito de identificadores da aplicação. Caso
não possua um domínio, ou seja, um projeto pessoal, você pode usar as suas
iniciais seguida do nome da aplicação.

Em seguida, em Save location podemos selecionar em que local do



computador o projeto será salvo. Por padrão, os projetos ficarão armazenados
no subdiretório AndroidStudioProjects dentro diretório do seu usuário no
sistema operacional (por exemplo, C:\Users\seu_usuario para Windows1 ou
/Users/seu_usuario no Mac OS X). Selecione o local de sua preferência,
evitando caminhos com espaços, acentos ou caracteres especiais.

Todos os exemplos desse livro serão desenvolvidos com a linguagem
Kotlin, por isso, no campo Language, selecione Kotlin.

No campo Minimum API Level, devemos selecionar a versão mínima do
Android que o aparelho deve possuir para executar a aplicação. Quanto
menor a versão, mais dispositivos podem utilizar a aplicação; entretanto,
teremos menos APIs disponíveis. Durante a escrita deste livro, mais de 89%
dos aparelhos estavam com a versão 5.0 (API Level 21) do Android ou
superior, e a tendência é que versões mais antigas deixem de ser utilizadas.
Dessa forma, todos os exemplos apresentados aqui devem funcionar no
Android Lollipop ou superior, mas será comentado explicitamente quando for
usada alguma API que necessite de uma versão específica. Selecione então a
API 21.

A opção This project will support instant apps é um recurso que não será
abordado nesse livro. Por isso, deixe essa opção desmarcada. Selecione a
opção Use AndroidX artifacts, ela será explicada na próxima seção.Clique
em Finish para concluir o assistente e criar o projeto2.

Por questão de praticidade, nos próximos projetos a serem criados no
decorrer do livro será informado apenas o nome do projeto, do pacote e da
activity principal da aplicação. Caso seja necessário definir algo diferente do
que foi visto aqui, isso será mencionado explicitamente. Fique à vontade para
escolher o nome que preferir, mas fique atento para usar o nome escolhido
quando for necessário. Para criação desse projeto, por exemplo, apenas as
informações mostradas a seguir seriam fornecidas.

Application Name Hello
Package Name dominando.android.hello
Activity Name MainActivity

Android Jetpack
O Jetpack é uma coleção de bibliotecas para facilitar o desenvolvimento de
aplicativos Android. Elas ajudam o desenvolvedor a seguir as práticas mais



recomendadas e simplifica tarefas complexas. As bibliotecas do Jetpack são
separadas das APIs da plataforma, isso significa que elas oferecem
compatibilidade com versões anteriores e são atualizadas com mais
frequência que o sistema operacional, garantindo que o desenvolvedor tenha
sempre acesso às versões mais recentes dos componentes.

Antes do Jetpack não havia uma padronização nos nomes de pacotes das
bibliotecas do Google para Android, tínhamos por exemplo: android.arch.*,
com.android.support.*, android.databinding.* etc. Com o Jetpack, todas as bibliotecas
passam a utilizar o pacote androidx.*. Entretanto, como as bibliotecas anteriores
são utilizadas há vários anos, você encontrará muitos exemplos na internet
utilizando os nomes dos pacotes “antigos”.

Durante a escrita deste livro, o Google ainda fornecia suporte a ambas as
bibliotecas, mas a tendência é que em breve, apenas o Jetpack seja utilizado.
Entretanto, por padrão, o Android Studio 3.3 ainda utiliza as bibliotecas de
suporte anteriores ao Jetpack. Por isso a opção Use AndroidX artifacts deve
ser selecionada durante a criação do projeto. Caso tenha esquecido, existe
uma opção simples para migrar o projeto para o Jetpack. Basta selecionar a
opção de menu Refactor > Migrate to Android X e clicar em Do Refactor
na tela que for exibida.

Todos os exemplos deste livro utilizam o Jetpack, por essa razão, sempre
que criar um novo projeto, marque a opção correspondente durante a criação
do projeto ou selecione a opção de menu para migrar para o AndroidX antes
de começar a implementação do exemplo.

Estrutura de um projeto Android
Depois que o projeto for criado, no lado esquerdo é exibida a estrutura do
projeto; na parte superior, ao selecionar a opção Project, é exibida outra
forma de visualização do projeto mais próxima que existe no sistema de
arquivos. Esse tipo de visualização será utilizado no decorrer do livro similar
ao mostrado na Figura 1.4.



Figura 1.4 – Estrutura de um projeto no Android Studio.
Alguns arquivos dessa estrutura serão detalhados neste capítulo começando

pelo AndroidManifest.xml.

AndroidManifest.xml
No arquivo AndroidManifest.xml fica boa parte das informações que foram
declaradas no assistente de criação do projeto. Além disso, ele armazenará
informações importantes que veremos ao longo do livro, tais como:
permissões, requisitos de hardware, serviços etc.:
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="dominando.android.hello" >
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme" >



        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>

Na tag <manifest>, na propriedade package é definido o pacote da aplicação. Em
seguida, na tag <application>, são adicionadas algumas configurações do
aplicativo. A propriedade android:allowBackup informa se o sistema operacional
deverá realizar o backup dos dados da aplicação (abordado no Capítulo 10).
Na propriedade android:supportsRtl é informado que o aplicativo dará suporte a
idiomas em que a leitura e a escrita são feitas da direita para a esquerda
(Right To Left) tais como: árabe, hebreu etc. Se seu aplicativo não dará esse
suporte, defina essa propriedade como false.

Todas as activities da aplicação que serão exibidas para o usuário devem
estar declaradas no AndroidManifest.xml com a tag <activity>, e na propriedade
android:name informamos o nome da classe.

As tags <intent-filter>, <action> e <category> serão explicadas no Capítulo 3, mas,
por enquanto, saiba que a ação android.intent.action.MAIN indica que essa activity é
um ponto de entrada da aplicação, ou seja, por onde o usuário pode acessá-la,
e a categoria android.intent.category.LAUNCHER indica que a Activity aparecerá na
lista de aplicações do aparelho.

Um detalhe curioso desse arquivo é a propriedade android:icon, onde é
definido o ícone da aplicação, pois ele está com o valor @mipmap/ic_launcher. O
que isso significa?

Arquivos de recursos
Os recursos da aplicação (imagens, textos, layouts etc.) ficam localizados na
pasta app/src/main/res, e cada um deles é mapeado em um identificador3 na
classe R, que é gerada automaticamente. Por exemplo, ao observar a pasta
res/mipmap-mdpi, nota-se que há um arquivo chamado ic_launcher.png, que
está representado na classe R pelo identificador R.mipmap.ic_launcher, que pode
ser referenciado no código Kotlin. Para usar essa mesma imagem em
arquivos XML – como o AndroidManifest.xml –, usa-se @mipmap/ic_launcher.
Por que ter várias pastas mipmap? Cada uma delas armazena as imagens



correspondentes a uma densidade de tela específica. Esse conceito será
explicado mais adiante ainda neste capítulo.

Voltando um pouco ao AndroidManifest.xml, na propriedade android:roundIcon
é definido o ícone arredondado que é usado em aparelhos com Android 7.1
ou superior. A propriedade android:label está apontando para @string/app_name.
Seguindo a lógica do ícone da aplicação, deveria existir uma pasta chamada
string, certo? Quase! Os textos da aplicação ficam localizados no arquivo
res/values/strings.xml.
<resources>
    <string name="app_name">Hello</string>
</resources>

Assim, para acessar o texto “Hello” no código Kotlin, seria usada a função
getString(int) passando o identificador R.string.app_name como parâmetro
(getString(R.string.app_name)), enquanto em arquivos XML usamos @string/app_name.

Pode-se utilizar a propriedade android:label na tag <activity> para informar o
texto que aparecerá no título da tela (usando um texto declarado no
res/values/strings.xml).

O resumo de alguns recursos e seu mapeamento na classe R e a forma de
acessá-los em arquivos XML estão descritos na Tabela 1.1.

Tabela 1.1 – Mapeamento dos recursos na classe R e no XML
Recurso ID da classe R Em arquivos XML

res/mipmap/ic_launcher.png R.mipmap.ic_launcher @mipmap/ic_launcher
res/drawable/imagem.png R.drawable.imagem @drawable/imagem
res/layout/activity_main.xml R.layout.activity_main @layout/activity_main
res/menu/menu_main.xml R.menu.menu_main @menu/menu_main
res/values/strings.xml <string name="ola"> R.string.ola @string/ola
res/values/dimens.xml <dimen name="margem"> R.dimen.margem @dimen/margem

MainActivity.kt
Finalmente será analisado o primeiro código em Kotlin. Abra a classe
MainActivity que deve estar como a seguir:
package dominando.android.hello
 
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
 



class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}

Podem-se observar diversas diferenças em relação ao Java. Primeiramente,
a extensão do arquivo “.kt” ao invés de “.java”. Diferentemente do Java, o “;”
ao final de cada instrução é opcional e por padrão não é utilizado, mas pode
ser usado para separar instruções na mesma linha, apesar de este uso ser bem
incomum.

Para indicar que uma classe está herdando de uma superclasse ou
implementando uma interface, é utilizado o “:”. Então, a classe MainActivity
herda da AppCompatActivity, que, por sua vez, é uma subclasse de Activity, mas
que permite utilizar alguns recursos de versões mais recentes do Android em
versões mais antigas.

No Java, toda classe herda de Object, enquanto em Kotlin toda classe herda
direta ou indiretamente de Any. Outro detalhe é sobre a sobrescrita (override)
de métodos. Ao contrário do Java, onde os métodos são anotados com o
@Override, no Kotlin deve-se informar explicitamente que um método está
sendo sobrescrito utilizando a palavra reservada override. Observe que o
método onCreate(Bundle), que originalmente está declarado na classe Activity, está
sendo sobrescrito.

Toda função em uma classe Kotlin utiliza a seguinte sintaxe:
<modificador> fun nomeDaFunção(<parâmetros>) : <tipo de retorno>

Temos a palavra fun seguida do nome da função e a lista de parâmetros entre
parênteses. Perceba que o nome do parâmetro é declarado primeiro, seguido
pelo seu tipo separado por “:”. O tipo de retorno da função é declarado após o
parêntese de fechamento, separado também por “:”. Quando um método não
retorna nada, ele retorna Unit (equivalente ao void do Java), e nesse caso pode-
se omitir, como é o caso do onCreate(Bundle). O último detalhe é que as funções
em Kotlin são públicas por padrão (public do Java).

Observe um exemplo completo de função, onde é usado o modificador
private, para a função soma, que recebe dois parâmetros (a e b) do tipo Int e
retorna um Int com o resultado da soma dos dois números:
private fun soma(a: Int, b: Int): Int {
    return a + b



}
No Kotlin é utilizado o termo “função”, enquanto em Java usa-se o termo

“método”. Ambos os termos serão utilizados aqui. Perceba que no Kotlin não
existem primitivos como no Java. Os tipos Byte, Short, Char, Int, Long, Float, Double
e Boolean são classes.

Kotlin possui o recurso de nulabilidade (nullability) no qual é obrigatório
declarar se um atributo, variável ou parâmetro pode ser nulo ou não. Nesse
caso, é adicionado o símbolo de interrogação ao tipo. Como se pode observar
no onCreate(Bundle), o parâmetro savedInstanceState pode ser nulo. Observe estes
outros exemplos:
var a: String = "Kotlin"
a = null // Não compila! "a" não aceita nulo
var b: String? = "abc"
b = null // ok. "b" aceita nulo (note a interrogação)
val lenA = a.length // Ok! É garantido que "a" não é nulo
val lenB = b.length // Não compila, pois "b" pode ser nulo
val lenB1 = if (b != null) b.length else -1
val lenB2 = b?.length ?: -1

Nesse código existem várias diferenças entre Kotlin e Java. A palavra var é
utilizada para declarar uma variável, ou seja, um espaço em memória que
pode ser escrito e substituído. Já a palavra val indica que está sendo criada
uma constante (como o final do Java), ou seja, algo que não mudará. Perceba
que foram declarados os tipos das variáveis a e b, mas não das demais
constantes, pois o Kotlin possui um conceito de inferência automática de
tipos. Por exemplo, a constante lenA é do tipo Int, pois o retorno de a.length é um
Int e o Kotlin detecta isso automaticamente.

Outro detalhe curioso é que a estrutura if/else retorna um valor. No exemplo
anterior, caso b for diferente de null, lenB1 recebe o tamanho da string b, caso
contrário, recebe -1. Por fim, temos “?:” chamado de “elvis operator” que
serve para verificar se determinada expressão é nula, e, caso positivo, retorna
um valor não nulo. No exemplo anterior, se b for nulo, -1 é retornado, caso
contrário o resultado será o tamanho da string.

O conceito de nulabilidade é muito importante no Kotlin, pois obriga o
desenvolvedor a tratar todos os casos em que o objeto pode ser nulo. Não se
preocupe em entender todos esses conceitos agora. Diversos exemplos ao
longo do livro demonstrarão tudo que foi visto até aqui nos mais diversos
cenários.



Voltando ao código da MainActivity, o método onCreate(Bundle) é chamado
quando a Activity é criada4, e nele é chamado o método setContentView(int) para
informar qual é o arquivo de layout dessa tela, ou seja, qual é seu aspecto
visual.

Arquivo de layout
O arquivo de layout é um XML com a descrição dos componentes que devem
ser exibidos na tela e está localizado em res/layout. Note que estamos usando
a classe R para referenciá-lo na MainActivity usando R.layout.activity_main. Ao dar
um Ctrl+Clique será exibido o editor visual de layouts, similar ao da Figura
1.5.

Figura 1.5 – Editor visual de layouts.
A paleta com os componentes que podem ser adicionados ao layout está

localizada no lado superior esquerdo. Abaixo dela está a Component Tree,
que permite visualizar a estrutura do arquivo de layout, ou seja, como os
componentes estão organizados hierarquicamente. No lado direito está a lista
de propriedades do componente, as quais podem ser editadas.

Na área central, além da pré-visualização do layout, existem algumas
opções interessantes na parte superior para simular variações do layout, como



vê-lo em landscape (na horizontal), em um idioma diferente ou em outros
aparelhos.

Na parte inferior é possível notar duas abas: Design e Text. A segunda
exibe o XML do arquivo de layout, que deve estar como a seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

Layouts e componentes serão explicados detalhadamente nos próximos
capítulos, mas para você ter uma ideia do que está acontecendo, o
ConstraintLayout é um gerenciador de layout que posiciona cada componente
baseado em regras e facilita bastante a criação de layouts por meio do editor
visual. Dentro do ConstraintLayout temos um <TextView> que representa um texto
estático a ser exibido na tela.

Para visualizar a aplicação em execução é necessário possuir um aparelho
Android ou utilizar um emulador. Será abordado nas próximas seções como
realizar as configurações necessárias para executar o aplicativo.

Configuração do aparelho
Para executar aplicações em um aparelho real, o primeiro passo é habilitar o
menu Opções do desenvolvedor nas configurações do aparelho. Isso pode
ser feito acessando as configurações do aparelho e selecionando a opção
Sobre o telefone (a partir do Android 8.0 esse item está dentro da opção
Sistema) e clique sete vezes seguidas sobre a opção Número da Versão5 (ou
Build Number). Ao fazer isso, aparecerá a mensagem “Você agora é um
desenvolvedor”. Volte para a tela anterior, e a opção estará disponível



conforme a Figura 1.6.
Clique em Opções do desenvolvedor (ou Programador) e habilite a opção

Depuração USB (USB Debugging), depois disso é só conectar seu aparelho
ao computador por meio de um cabo USB. Caso apareça uma mensagem de
confirmação no aparelho, confirme para permitir que seu computador tenha
acesso ao dispositivo. Feito isso, normalmente no Mac OS X e no Linux, o
dispositivo é reconhecido automaticamente pela IDE; já no Windows, às
vezes será necessário baixar o driver do aparelho no site do fabricante6.

Figura 1.6 – Aparelho com as “Opções do desenvolvedor” habilitadas.

Android Virtual Device
Um Android Virtual Device, ou simplesmente AVD, é um emulador do
Android no qual podemos testar nossas aplicações. Nele podemos configurar



a versão do sistema operacional, o tamanho de tela, o espaço para o cartão de
memória etc. Por padrão, normalmente o Android Studio já cria um AVD
para nós, mas podemos criar os nossos próprios AVDs para testar o aplicativo
em diferentes versões e configurações de aparelhos.

Para deixar o AVD mais rápido é necessário instalar o acelerador de
hardware disponibilizado para computadores com processador Intel. O
HAXM (Hardware Accelerated Execution Manager) encontra-se na pasta do
SDK7, na subpasta extras/intel/Hardware_Accelerated_Execution_Manager.
Clique no instalador disponível nessa pasta e você obterá uma tela similar à
da Figura 1.7.

Figura 1.7 – Instalação do acelerador de hardware da Intel.
Em versões mais recentes do Android Studio, ele já é instalado por padrão.

Caso já esteja, o assistente de instalação exibirá uma mensagem. Caso ainda
não esteja instalado, clique em Continue e siga as etapas do assistente. Um
ponto importante aqui é que alguns computadores não vêm com suporte à
virtualização habilitado por padrão. Então, caso você tenha algum problema
durante a instalação do HAXM, certifique-se de que seu computador tem
suporte a esse recurso e verifique como habilitá-lo.

Para criar um AVD, dentro do Android Studio selecione a opção Tools >



AVD Manager e será exibida uma janela similar à da Figura 1.8.
Essa janela exibe os AVDs já criados. Por padrão o Android Studio já cria

um AVD com a imagem do Pixel. Se quiser criar um novo AVD, clique no
botão Create Virtual Device... e será exibida a janela da Figura 1.9.

É possível selecionar a categoria do AVD desejada: TV, Wear, Phone ou
Tablet. Em seguida, deve-se selecionar um dos modelos do Nexus, Pixel ou
ainda criar um modelo com as configurações que desejar clicando no botão
New hardware profile. Selecione algum modelo preexistente e clique em
Next para exibir a tela da Figura 1.10.

Escolha a imagem do sistema que o emulador executará. Nessa tela, o
Android sempre recomenda a versão mais atual, mas é possível baixar a
imagem da versão desejada. Caso ainda não tenha feito o download,
aparecerá o link para que o SDK Manager o faça automaticamente. Um
detalhe importante aqui é que devemos escolher as imagens com as APIs do
Google (descritas com “Google Play”), pois utilizaremos essas APIs mais
adiante em nossos exemplos. Clique em Next para ir para a última tela do
assistente mostrada na Figura 1.11.

Figura 1.8 – Android Virtual Device Manager.



Figura 1.9 – Selecionando a categoria e o modelo do AVD.

Figura 1.10 – Selecionando a imagem do sistema utilizado pelo AVD.



Figura 1.11 – Tela final do assistente para criação do AVD.
Na última tela do assistente pode-se simplesmente clicar em Finish para

criar o AVD, ou, se preferir, clicar no botão Show Advanced Settings e fazer
alterações nas seguintes configurações-padrão do emulador:

• a orientação-padrão do aparelho (portrait ou landscape) no campo Startup
orientation;

• em Front Camera e Back Camera – é possível simular a câmera frontal e
traseira do aparelho, usando a webcam do computador ou um ambiente
fictício criado pelo emulador;

• tipo de rede e a latência nos campos Network speed e Latency
respectivamente;

• em Emulated performance, temos três opções:
• Graphics que define como será feita a renderização da tela.
• Boot option que estabelece como o emulador será iniciado, podendo

ser: Cold boot para iniciar como se estivesse sendo ligado a partir do
botão de power; Quick Boot para iniciar a partir do último estado salvo;
ou Choose from snapshot para escolher um estado salvo anteriormente.

• Multi-Core CPU especifica a quantidade de núcleos do processador que



o emulador utilizará.
• na seção Memory and Storage define a quantidade de memória RAM e

heap, além do tamanho da área de armazenamento interno e do SD card
que será reservado para o emulador.

• podemos definir o skin do emulador no campo Custom skin definition.
• e, por fim, no campo Enable keyboard input determina se é permitido

digitar no emulador utilizando do teclado do computador.
Feito isso, clique em Finish e o emulador aparecerá na lista. Clique no

emulador recém-criado, pressione o botão Start (seta verde) e o emulador
inicializará. Esse processo pode demorar alguns minutos, principalmente a
primeira vez. A Figura 1.12 mostra o emulador em execução com a Home
Screen sendo exibida.

Essa é a tela principal do aparelho, na qual podem-se adicionar atalhos para
os aplicativos e widgets. Na Figura 1.13 é mostrado o Launcher, onde ficam
todos os aplicativos instalados no aparelho e que podem ser iniciados
diretamente pelo usuário. Para exibi-lo, basta fazer o gesto de swipe (deslizar)
para cima a partir da parte inferior da tela.

Figura 1.12 – Emulador do Android em execução.



Figura 1.13 – Tela de aplicações (Launcher).

Emulador Genymotion
Como visto na seção anterior, podemos utilizar o emulador para testar as
aplicações. Entretanto, o emulador do Android pode ser lento em máquinas
menos potentes, e apesar de ser muito melhor (e recomendado) testar sua
aplicação em um aparelho de verdade (aliás, em vários), o emulador pode
ajudar a verificar como o aplicativo se comporta em outros tamanhos de telas
ou outras versões do Android.

O Genymotion surge como uma alternativa em máquinas que não suportam
o emulador nativo por alguma razão. Para usá-lo é necessário registrar-se
gratuitamente no site http://www.genymotion.com/fun-zone, fazer o download
e seguir as etapas descritas no assistente de instalação. Ele funciona em
Windows, Mac e Linux e utiliza o Virtual Box para criar uma máquina virtual
com a imagem de um dispositivo Android.

Faça o login no Genymotion com a conta criada no site, em seguida é
necessário fazer o download da imagem do dispositivo desejado
selecionando-o na seção Available Templates e, em seguida, clicar em
Install. Cada imagem tem em torno de 200 MB, dependendo o aparelho



escolhido, em nossos exemplos, usaremos as imagens do Pixel 2 e Nexus 9.
A Figura 1.14 mostra o Genymotion em execução com algumas imagens
adicionadas.

Figura 1.14 – Genymotion com algumas imagens adicionadas.
Ao clicar no botão com “...”, será exibida a tela da Figura 1.15, onde é

possível alterar algumas configurações do emulador, tais como: tamanho de
tela, memória, exibir ou não o teclado virtual e exibir os controles de
navegação.



Figura 1.15 – Configurações do emulador Genymotion.
Para executar um emulador, basta dar um duplo clique sobre a imagem

desejada8. A Figura 1.16 mostra o emulador do Genymotion em execução
com a Home Screen sendo exibida.

Após executar o emulador, ele deve ser reconhecido automaticamente pelo
Android Studio, e com isso poderemos executar nele as aplicações que
desenvolveremos.



Figura 1.16 – Emulador Genymotion em execução.
Ambos os emuladores atenderão a quase totalidade dos aplicativos que

serão desenvolvidos ao longo do livro. Entretanto, alguns exemplos só
funcionarão em dispositivos que possuam o Google Play instalado, que é o
caso do emulador nativo e da maioria dos telefones ou tablets. Entretanto, ao
testar os exemplos em um aparelho real, temos a vantagem de economizar a
memória RAM do computador que seria alocada para o emulador. Escolha a
opção que preferir e vamos finalmente ver o nosso aplicativo em execução.

Executando a aplicação
Para executar a aplicação, basta clicar no botão Run app (botão verde em
forma de play) do Android Studio e será exibida a tela da Figura 1.17, onde
podemos selecionar o dispositivo (se houver mais de um) no qual desejamos
executar a aplicação. Selecione o aparelho (ou emulador) e clique em OK, e o
aplicativo será exibido no dispositivo selecionado conforme a Figura 1.18.

Figura 1.17 – Seleção do aparelho para executar a aplicação.



Figura 1.18 – Aplicação Hello World rodando no emulador.
Pronto! Nossa primeira aplicação está em execução e na próxima seção

veremos as etapas que ocorreram para que isso acontecesse.

Processo de compilação
Para realizar a compilação do aplicativo, o Android Studio utiliza o Gradle
(http://www.gradle.org), uma avançada ferramenta para automação e
gerenciamento do processo de build. Uma grande vantagem de utilizar o
Gradle é que ele é independente do Android Studio, ou seja, é possível
compilar o projeto via linha de comando, o que facilita a integração com
outras ferramentas. O Gradle será abordado em mais detalhes no Capítulo 29,
mas serão detalhados aqui alguns fundamentos básicos.

Cada projeto no Android Studio, por padrão, possui pelo menos dois
arquivos build.gradle: um na raiz do projeto e outro em cada módulo. Ao
criar um projeto, apenas o módulo app é criado, então primeiramente observe
o arquivo build.gradle do módulo:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
 



android {
    compileSdkVersion 28
    defaultConfig {
        applicationId "dominando.android.hello"
        minSdkVersion 21
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'),
                'proguard-rules.pro'
        }
    }
}
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
    implementation 'androidx.appcompat:appcompat:1.0.2'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.0'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.1'
}

Na primeira linha é aplicado o plugin do Android para Gradle, que é
responsável por executar todo o processo de compilação e empacotamento do
APK (Android Package) que é instalado no aparelho. Em seguida, o plugin
do Kotlin é aplicado para que o código-fonte escrito em Kotlin seja
compilado. Logo abaixo, o plugin de extensões do Kotlin traz alguns recursos
extras da linguagem específicos para Android.

No bloco android, são estabelecidas as opções de build específicas do
Android. A propriedade compileSdkVersion indica qual a API Level do Android
está sendo usada para compilar o projeto. No nosso caso, Android Pie (API
Level 28), assim, todos os recursos desta versão estarão disponíveis para nós.

Em defaultConfig ficam as configurações que serão comuns para todos os tipos
de compilação. Nela, definimos o applicationId que é o identificador único da
aplicação para publicação do aplicativo (entretanto, o código-fonte pode usar
internamente o nome de pacote definido no campo android:packageName do



AndroidManifest.xml). O minSdkVersion define a versão mínima do Android que
o aparelho deve possuir para executar o aplicativo, e o targetSdkVersion é a
versão do Android em que o aplicativo foi testado, ou seja, qual a versão
máxima do Android que o aplicativo é compatível.

O campo versionCode não é visível para o usuário, mas é importantíssimo,
pois define o código sequencial do aplicativo que é usado para publicação no
Google Play. Ou seja, cada vez que uma nova versão da aplicação for
submetida, é necessário incrementar esse valor. Já o campo versionName
aparecerá para o usuário ao acessar as informações do aplicativo nas
configurações do aparelho e pode-se nomeá-lo da maneira que desejar, mas
normalmente usa-se algo como ‘1.0.0’.

As dependências de outros módulos ou de bibliotecas externas são definidas
no bloco dependencies, utilizando a palavra implementation seguida do nome da
dependência. Por padrão, o Android Studio já adiciona a dependência da
standard library do Kotlin (kotlin-stdlib-jdk7), da appcompat e do constraintlayout. A
primeira traz a biblioteca-padrão do Kotlin, a segunda disponibiliza classes
que facilitam a compatibilidade entre versões do Android (como a
AppCompatActivity) e a última permite utilizar o gerenciador de layout
ContraintLayout (que exploraremos em mais detalhes no Capítulo 2). Perceba que
estão sendo usadas as bibliotecas que começam com androidx.* do Jetpack. As
demais dependências são utilizadas para a escrita de testes da aplicação que
veremos no Capítulo 31.

Note que no final de cada dependência temos sua respectiva versão. Muito
provavelmente as versões das bibliotecas já terão mudado quando você
estiver lendo este livro. Então procure sempre utilizar a versão mais recente
das bibliotecas. Caso o código apresentado aqui não funcione com a versão
mais nova da biblioteca, verifique o código atualizado no repositório do livro
no Github. E se mesmo assim o código apresentar erros, deixe sua dúvida no
grupo de discussão do livro.

No build.gradle localizado na raiz do projeto definimos os repositórios
onde se encontram as dependências que serão utilizadas em todos os módulos
do projeto como build tools do Gradle e o plugin do Kotlin:
buildscript {
    ext.kotlin_version = '1.3.20'
    repositories {
        google()



        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.3.1'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}
allprojects {
    repositories {
        google()
        jcenter()
    }
}
task clean(type: Delete) {
    delete rootProject.buildDir
}

Na próxima seção será apresentado um recurso bastante poderoso do
Android: a alocação dinâmica de recursos.

Alocação dinâmica de recursos
Todos os recursos de uma aplicação (strings, imagens, estilos, layouts etc.)
devem, obrigatoriamente, estar na pasta res (abreviação de resources), mas
cada subdiretório tem um objetivo específico. Os principais são:

• anim e animator – arquivos XML de animações quadro-a-quadro ou de
efeito;

• drawable – arquivos de imagens da aplicação *.jpg ou *.png, ou ainda
arquivos XML que descrevem algo que será desenhado na tela;

• font – arquivos de fontes *.ttf ou *.otf, ou arquivos XML que descrevem
famílias de fontes;

• layout – arquivos XML com a definição do conteúdo visual das telas;
• menu – arquivos XML com as opções de menu;
• mipmap – ícone da aplicação;
• raw – arquivos binários diversos que podem ser usados no projeto;
• transition – arquivos XML para descrever animações de transição;
• values – arquivos XML com valores tais como: strings (texto simples);

string_arrays (lista de valores), dimensions (definição de tamanhos);
colors (definição de cores); e styles (estilos);



• xml – essa pasta normalmente armazena arquivos XML de metadados da
aplicação.

Todos os arquivos armazenados nessas pastas devem, obrigatoriamente, ser
nomeados com todas as letras minúsculas e não devem conter quaisquer
símbolos (exceto underline “_”), mas podem conter números a partir do
segundo caractere. A extensão do arquivo não é utilizada na geração do id na
classe R, consequentemente, também não é possível ter o mesmo arquivo
com extensões diferentes.

O Android tem um conceito de alocação dinâmica de recursos, em que o
sistema operacional seleciona o recurso mais apropriado de acordo com a
configuração do aparelho. Para isso, é preciso apenas criar variações dos
diretórios adicionando sufixos, e o Android se encarregará de obter o recurso
mais adequado. A Tabela 1.2 lista os principais sufixos em ordem de
prioridade com alguns exemplos.

Tabela 1.2 – Sufixos para alocação de recursos
Configuração Exemplo do sufixo Recurso para

Operadora mcc724-mnc05 Operadora do Brasil (mcc-724) e código 05 (Claro) e 31 (Oi)
mcc724-mnc31

Idioma en Inglês (qualquer país)
en-rUS Inglês dos Estados Unidos
pt Português (qualquer país)
pt-rBR Português do Brasil
es Espanhol
fr Francês
de Alemão

Tamanho de tela small Telas pequenas
(ver Tabela 1.5) normal Telas normais

large Telas grandes
xlarge Telas extragrandes

Orientação de tela port Portrait (vertical)
land Landscape (horizontal)

Densidade da tela (ver Tabela 1.3) ldpi Baixa densidade (120 dpi)
mdpi Média densidade (160 dpi)
tvdpi Densidade de TV (213 dpi)
hdpi Alta densidade (240 dpi)
xhdpi Densidade extra-alta (320 dpi)
xxhdpi Densidade extra-alta (480 dpi)
xxxhdpi Densidade extra-alta (640 dpi)

API Level (ver Tabela 0.1) v14 Aparelhos com Android 4.0 ou superior
v21 Aparelhos com Android 5.0 ou superior
v24 Aparelhos com Android 7.0 ou superior

É importante ressaltar que podemos combinar os sufixos descritos
anteriormente, como, por exemplo, layout-pt-rBR-large; values-mcc724-mnc31-v21 ou



drawable-land-hdpi.
Outro detalhe importante é que o Android buscará o recurso mais próximo,

e caso não exista ele procurará algo mais genérico. Por exemplo, o aparelho
está no idioma “Português (Brasil)”, se seu projeto possuir uma pasta values-pt-
rBR, ele a utilizará, se não tiver, ele procurará por values-pt, caso não tenha, ele
utilizará a pasta values padrão.

Idioma
Para fixar os conceitos apresentados, internacionalizaremos nosso aplicativo
de modo que, quando o aparelho estiver com o idioma configurado para
português, os textos da aplicação mudarão automaticamente. Abra o arquivo
res/values/strings.xml e adicione o texto a seguir:
<resources>
    <string name="app_name">Hello</string>
    <string name="hello_world">Hello World!</string>
</resources>

Agora referenciaremos essa string no arquivo res/layout/activity_main.xml
fazendo a seguinte modificação:
<androidx.constraintlayout.widget.ConstraintLayout ...>
    <TextView...
        android:text="@string/hello_world" />
</androidx.constraintlayout.widget.ConstraintLayout>

A única mudança foi adicionar a referência à string que acabamos de criar.
Não é recomendado utilizar textos diretamente nos arquivos XML ou no
código-fonte. Ao invés disso, todos os textos da aplicação devem ser
declarados no res/values/strings.xml, pois isso facilita a tradução para outros
idiomas.

Clique sobre a pasta app/src/main/res e escolha a opção New > Android
Resource File. No campo File name preencha como strings.xml, em seguida,
selecione Locale na listagem da esquerda e clique no botão >>. Selecione o
idioma português e a tela ficará conforme a Figura 1.19. Clique em OK para
criar o arquivo.



Figura 1.19 – Criando um novo arquivo de strings.
Agora copie o conteúdo do arquivo strings.xml da pasta res/values para o

novo arquivo que criamos. E modifique-o para ficar como a seguir:
<resources>
    <string name="app_name">Olá</string>
    <string name="hello_world">Olá Mundo!</string>
</resources>

Por padrão, o idioma do emulador é o inglês, então, ao executarmos a
aplicação, o texto “Hello world!” ainda será exibido. Agora modifique o
idioma do dispositivo9 para português nas configurações do aparelho
selecionando a opção Language & input (Idiomas e entrada), e por fim o
idioma português no campo Language (Idioma). Execute a aplicação e agora
o texto “Olá mundo!” deverá ser exibido.

DIP – Density Independent Pixel
Voltando à nossa discussão sobre alocação de recursos, podemos notar que,
quando o projeto foi criado, o próprio Android Studio adicionou algumas
variações da pasta mipmap para nós:
res/mipmap-anydpi-v26
res/mipmap-hdpi
res/mipmap-mdpi
res/mipmap-xhdpi
res/mipmap-xxhdpi



res/mipmap-xxxhdpi
Isso fará com que o sistema operacional selecione o ícone da aplicação de

acordo com a qualidade da tela, que é medida em DPIs (Dots Per Inch –
Pontos por polegadas). Atualmente temos dispositivos Android de diversos
tamanhos e com qualidade de tela diferentes. É importante conhecermos a
Tabela 1.3 para definirmos imagens adequadamente para cada uma delas.

Tabela 1.3 – Densidades de tela
Densidade Dots per inch Proporção
ldpi 120 dpi 0.75
mdpi 160 dpi 1.00
tvdpi 213 dpi 1.33
hdpi 240 dpi 1.50
xhdpi 320 dpi 2.00
xxhdpi 480 dpi 3.00
xxxhdpi 640 dpi 4.00

Ao analisar essa tabela é possível constatar que imagens para aparelhos
xxhdpi devem ter o dobro do tamanho (largura e altura) de imagens para
aparelhos hdpi, por exemplo. Então é importante ter imagens para cada
densidade de tela, pois, caso contrário, elas podem ficar distorcidas. Caso seja
preciso que determinada imagem mantenha suas dimensões
independentemente da densidade, podemos utilizar o sufixo –nodpi. É
importante ressaltar que estamos falando de imagens PNG (Portable Network
Graphics) ou JPEG (Joint Photographic Experts Group).

Podemos observar que o nosso projeto possui uma pasta com o sufixo –
anydpi, que indica que a imagem pode ser redimensionada para qualquer
densidade. Nessa pasta temos um Vector Drawable, que é uma imagem
vetorial descrita em um arquivo XML e que pode ser redimensionada sem
perda de qualidade. Entraremos em detalhes sobre os Vector Drawables no
Capítulo 30.

Orientação e resolução de tela
Seguindo o mesmo princípio, é possível criar arquivos de layout para quando
o aparelho estiver em landscape ou para resoluções de tela diferentes (ou
combinando ambas). A Tabela 1.4 exibe alguns exemplos comuns de pastas
de layout.



Tabela 1.4 – Exemplo de pastas de Layout
Pasta Propósito

res/layout Layout em portrait ou landscape, independente do tamanho da tela.
res/layout-land Layout em landscape, independente do tamanho da tela.
res/layout-large Layout em portrait ou landscape, para telas grandes.
res/layout-xlarge-land Layout para telas extragrandes em landscape.

O que determina se uma tela é pequena, normal, grande ou extragrande? O
Android estipula alguns intervalos para classificá-las, os quais estão listados
na Tabela 1.5.

Tabela 1.5 – Classificação de telas
Classificação Tamanho mínimo
small 426 dp x 320 dp
normal 470 dp x 320 dp
large 640 dp x 480 dp
xlarge 960 dp x 720 dp

Se você observar, a medida da tela é definida em DP (ou DIP – Density
Independent Pixels), que é uma unidade de medida que leva em consideração
a quantidade de pixels na tela em sua área física. Sendo assim, quanto mais
pixels tivermos por área, melhor será a qualidade da tela. Então como saber
quantos dp tem a tela? Basta usar a seguinte fórmula:

dp = pixels / (dpi / 160)
Por exemplo, qual o tamanho da tela em dp de um aparelho com resolução

de 1.024 por 768 pixels com densidade HDPI (240 dpi)?
dp = 1.024 / (240 / 160) dp = 768 / (240 / 160)
dp = 1.024 / 1,5 dp = 768 / 1,5
dp = 680 dp = 512

Com base na Tabela 1.5 pode-se constatar que uma tela de 680 dp x 512 dp
é considerada grande (large).

É possível descobrir todas as configurações de recursos que podem variar
de acordo com o aparelho por meio da classe android.content.res.Configuration ou da
classe android.util.DisplayMetrics.

Adicione o código a seguir no método onCreate(Bundle) da MainActivity:
val config = resources.configuration
val metrics = resources.displayMetrics
val orientation = config.orientation



val density = metrics.density
val height = metrics.heightPixels
val width = metrics.widthPixels
val mcc = config.mcc
val mnc = config.mnc
val locale = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N)
    config.locales[0] else config.locale
 
val tag = "NGVL"
Log.d(tag, "density: $density")
Log.d(tag, "orientation: $orientation")
Log.d(tag, "height: $height")
Log.d(tag, "width: $width")
Log.d(tag, "language: ${locale.language} - ${locale.country}")
Log.d(tag, "mcc: $mcc")
Log.d(tag, "mnc: $mnc")

Com as informações obtidas no código anterior, podemos criar recursos
mais apropriados para o aparelho. O atributo density da classe Metrics traz a
proporção da densidade da tela, como vimos na Tabela 1.3. Já os atributos
heightPixels e widthPixels trazem a largura e a altura da área útil da tela, ou seja,
desconsiderando a barra de título e a barra com os botões de navegação. Com
a classe Configuration obtemos o MCC e o MNC da operadora de telefonia que o
aparelho está utilizando.

Diferentemente do Java que utiliza os getters e setters para acessar e
modificar os atributos internos, o Kotlin utiliza o conceito de propriedades
que nos dá um atalho para esses métodos. Se uma classe Person possui, por
exemplo, um método getName() e setName(String), é possível acessar essa
propriedade utilizando person.name (que chamará o getName()) e modificar o valor
da seguinte forma person.name = "Glauber" que invocará o método setName(String)).
Nesse exemplo, a classe Activity possui um método getResources() que retorna
um objeto do tipo Resources, esse objeto, por sua vez, possui um método
getConfiguration() que retorna um objeto do tipo Configuration. Sendo assim, no
código Kotlin pode-se acessar simplesmente utilizando resources.configuration (em
vez de getResources().getConfiguration()).

O Java possui o operador ternário “? :” que não existe no Kotlin. Entretanto,
como já visto, no Kotlin a estrutura if/else retorna um valor. Com o objeto
Locale conseguimos saber o idioma e o país que estão definidos nas
configurações do aparelho. Note que é checada a versão do Android que está
rodando no aparelho por meio da constante Build.VERSION.SDK_INT, pois o



atributo locale foi descontinuado (deprecated) no Android 7.0 dando lugar a
propriedade locales, que retorna um array de objetos Locale onde obtemos a
primeira posição. A classe Build.VERSION_CODES possui as constantes para cada
versão (version code) do Android.

Como referido, o Kotlin possui inferência automática de tipo. Isso quer
dizer que ao fazer a inicialização juntamente com declaração da variável ou
constante não precisamos informar seu tipo. No exemplo acima, poderíamos
ter usado a seguinte instrução, mas ela seria desnecessária:
val config : Configuration = resources.configuration

Se o código apresentar erro, é porque falta importar alguma classe.
Posicione o cursor em cima do nome da classe e selecione o menu Code >
Optimize imports... (ou a tecla de atalho correspondente). Porém, uma boa
alternativa é habilitar as opções mostradas na Figura 1.20 disponíveis na
seção Auto Import das preferências do Android Studio. Com ela, o import das
classes é feito automaticamente pelo Android Studio, e caso haja duplicidade
de nomes, o Android Studio exibirá as opções disponíveis para que você
possa escolher.

O Kotlin fornece um recurso chamado interpolação de strings, que é a
combinação de variáveis dentro de uma string. No caso de uma variável
simples basta utilizar o "$variável", para expressões mais complexas, utilize
"${expressão}". Essa técnica foi utilizada no método Log.d(String, String), que é
utilizado para gerar um log da nossa aplicação. O primeiro parâmetro é uma
tag, que pode ser uma string qualquer (aqui estou usando minhas iniciais) e o
segundo parâmetro é usado para o texto do log que será gerado. Veremos na
próxima seção como visualizar esses logs.



Figura 1.20 – Auto import de classes no Android Studio.

Android Device Tools
O Android Studio possui um poderoso conjunto de ferramentas para análise e
depuração de aplicações. Com elas, podemos visualizar os processos que
estão sendo executados no aparelho, o sistema de arquivos, o consumo de
memória, threads, logs da aplicação etc.

Para visualizar o sistema de arquivos do aparelho, basta selecionar a opção
View > Tool Windows > Device File Explorer, e será exibida a janela
mostrada na Figura 1.21. Nela podemos enviar ou copiar arquivos do
aparelho.

Porém, sem dúvida, a janela mais importante dessa ferramenta é o Logcat,
conforme a Figura 1.22. Para acessá-lo basta selecionar o menu View > Tool
Windows > Logcat. Com ele, podemos visualizar todos os logs gerados pelas
aplicações, ver a lista dos dispositivos conectados ao computador, tirar um
screenshot da tela do aparelho selecionado ou até gravar um vídeo da tela do
aparelho.

No Logcat podemos filtrar os logs por aplicação, por textos específicos, por
número de processo e por nível, que pode ser: verbose, debug, info, warning



e error. Para criar um filtro, basta selecionar a opção Edit Filter
Configuration e preencher as informações do filtro.

Figura 1.21 – Janela Device File Explorer.

Figura 1.22 – Janela Logcat.
Para entender melhor o log, vejamos o que é exibido: na primeira coluna

temos o mês, dia e hora do log; depois o número do processo seguido do id
da thread (separado por “-“); logo após, temos o nome do pacote da
aplicação; o tipo do log (“D” de debug) e a tag separados por “/”; e, por
último, a mensagem do log.



Colocar logs na aplicação durante o processo de desenvolvimento ajuda
bastante a entender o fluxo de execução do código. Se quisermos analisar
com mais detalhes a alocação de memória e consumo de CPU, podemos
utilizar a janela Android Profiler disponível no menu View > Tool Windows
> Profiler.

findViewById e evento de clique
No próximo exemplo, será demonstrado como adicionar alguma interação à
aplicação, obtendo a referência de um componente declarado em um arquivo
de layout e tratando o evento de clique em um botão. Crie um novo projeto
com os dados a seguir.

Application Name Basico
Package Name dominando.android.basico
Activity Name MainActivity

Abra o arquivo res/layout/activity_main.xml, remova o TextView que contém
o “Hello World” e, em seguida, adicione um Plain Text arrastando-o da seção
Text da paleta de componentes. Abaixo dele adicione um Button localizado na
seção Common e posicione-o abaixo da caixa de texto que adicionamos
anteriormente. Não se preocupe com alinhamento e posicionamento agora,
falaremos sobre isso no próximo capítulo. Por agora, clique no botão “Infer
constraints”. Observe que ao selecionar o botão suas propriedades serão
exibidas do lado direito como mostra a Figura 1.23.



Figura 1.23 – Propriedades de um componente no editor visual do
Android Studio.

Perceba que existem duas propriedades “text”. A que possui um ícone só
será utilizada em tempo de projeto, ou seja, não será usada na aplicação em
tempo de execução. Selecione as reticências (...) ao lado da outra propriedade
text e será exibida a tela da Figura 1.24 que exibe a lista de todas as strings
declaradas no projeto.



Figura 1.24 – Strings que podem ser utilizadas no projeto.
Para adicionar uma nova string clique na opção Add new resource > New

string value... e será exibida a janela da Figura 1.25. No campo Resource
name, informe o id da string que será gerada na classe R e no campo
Resource value informamos o texto propriamente dito. Preencha com os
valores main_button_toast e Exibir toast respectivamente e clique em OK.

Figura 1.25 – Criando uma nova string para o projeto.



Ao criar a string, perceba que agora na propriedade text temos o valor
@string/main_button_toast, e se abrirmos o arquivo res/values/strings.xml
perceberemos que foi adicionada a string que acabamos de criar:
<resources>
    ...
    <string name="main_button_toast">Exibir toast</string>
</resources>

Poderíamos ter feito essa operação manualmente sem problemas, então
daqui para a frente escolha a maneira que preferir.

Volte para o arquivo de layout, selecione o botão e altere a propriedade ID
para buttonToast. Em seguida, selecione a caixa de texto, altere a propriedade
ID para editTexto e apague o conteúdo da propriedade text. O XML deve estar
similar ao código listado a seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">
    <EditText
        android:id="@+id/editTexto"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="16dp"
        android:layout_marginTop="16dp"
        android:ems="10"
        android:inputType="textPersonName"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <Button
        android:id="@+id/buttonToast"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/main_button_toast"
        app:layout_constraintStart_toStartOf="@+id/editTexto"
        app:layout_constraintTop_toBottomOf="@+id/editTexto" />
</androidx.constraintlayout.widget.ConstraintLayout>

Perceba que as alterações que fizemos no editor são refletidas aqui.
Alteramos a propriedade android:text do Button e a propriedade android:id de ambos
os componentes que serão utilizadas para obtermos a referência desse



componente no código Kotlin. Os valores @+id/editTexto e @+id/buttonToast
indicam que esses ids serão criados na classe R, assim teremos R.id.editTexto e
R.id.buttonToast respectivamente. As propriedades que iniciam com tools só serão
utilizadas internamente pelo editor visual. Entenderemos as demais
propriedades no próximo capítulo quando falarmos sobre layouts.

Implementaremos agora o comportamento da nossa tela. Abra o arquivo
MainActivity.kt e deixe-o conforme a seguir10:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button
import android.widget.EditText
import android.widget.Toast
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val edtTexto = findViewById<EditText>(R.id.editTexto)
        val button = findViewById<Button>(R.id.buttonToast)
        button.setOnClickListener {
            val texto = edtTexto.text.toString()
            Toast.makeText(this, texto, Toast.LENGTH_SHORT).show()
        }
    }
}

No método onCreate(Bundle) obtemos a referência do EditText por meio do
findViewBydId(int) passando o id do componente que definimos no arquivo de
layout, e o mesmo é feito para obtermos a referência do botão. Para tratar o
evento do clique, devemos chamar o método
setOnClickListener(View.OnClickListener) passando um objeto que implemente a
interface View.OnClickListener, que no nosso caso é uma expressão lambda.

Quando temos interfaces que possuem apenas um método, podemos utilizar
expressões lambda. Uma maneira mais completa de declarar o evento de
clique seria como a seguir:
button.setOnClickListener(object: View.OnClickListener {
    override fun onClick(v: View?) {
        val texto = edtTexto.text.toString()
        Toast.makeText(this@MainActivity, texto, Toast.LENGTH_SHORT).show()
    }
})



Para acessar a instância da classe externa (outer class) a partir de uma casse
interna (inner class) utilizamos this@ClasseExterna. No exemplo anterior, o
OnClickListener é a classe interna e a MainActivity é a classe externa. Dessa forma,
para acessar a MainActivity no OnClickListener utilizamos this@MainActivity.

Perceba que o parâmetro v do tipo View nem foi declarado no lambda, pois
não foi utilizado, deixando o código ainda mais limpo. O parâmetro do
método onClick(View) representa o componente que disparou o evento. Se
precisar desse parâmetro, basta declará-lo como a seguir:
button.setOnClickListener { v ->
    if (v is Button) {
        val texto = edtTexto.text.toString()
        Toast.makeText(this, "${v.text} - $texto", Toast.LENGTH_SHORT).show()
    }
}

A conversão de tipos (cast) no Kotlin é feito utilizando a palavra reservada
as, enquanto a checagem de tipo é feita com a palavra is:
val animal = chooseAnimal()
if (animal is Dog) {
    val dog = animal as Dog
    // Faça algo
}

Estamos verificando se o método chooseAnimal() retornou um cachorro
(instância de Dog), em caso positivo, criamos uma constante chamada dog e
fazemos o cast. Porém, na realidade, o cast nesse exemplo é desnecessário,
pois o Kotlin possui o conceito de smart cast. Uma vez que checamos que a
constante animal é do tipo Dog, automaticamente ela já é tratada dentro do if
como um Dog sem a necessidade do cast.

É exatamente o mesmo que fizemos com o botão. Uma vez que checamos
se o parâmetro v (que é do tipo View) é do tipo Button, dentro do if o parâmetro
v é automaticamente um Button. Por essa razão, conseguimos acessar a
propriedade text do botão.

No evento de clique, obtemos o texto contido no EditText e atribuímos à
constante texto e depois criamos um Toast com o método makeText(Context, String,
int). Um Toast é uma mensagem que aparece durante um tempo e depois
desaparece automaticamente. A duração pode ser LENGTH_SHORT e
LENGTH_LONG, onde utilizando a primeira a mensagem será exibida por cerca
de 2 segundos e com a segunda, 3,5 segundos. Execute a aplicação, digite



algum texto e pressione o botão. A mensagem será exibida centralizada na
parte inferior da tela, conforme podemos observar na Figura 1.26.

Figura 1.26 – Exibindo uma mensagem com um Toast.

Kotlin Android Extensions
Na seção anterior foi visto que para obter uma referência para um
componente declarado no arquivo de layout, é utilizado o método
findViewById(int). Essa é a maneira padrão da plataforma e ainda é bastante
utilizada e necessária em algumas situações, entretanto, o Kotlin Android
Extenstions permite realizar essa tarefa de uma maneira muito mais simples.
Para tal devemos aplicar o plugin no build.gradle do módulo (que o Android
Studio já adiciona por padrão):
apply plugin: 'kotlin-android-extensions'

Em seguida, importar o arquivo de layout em sua activity:
import kotlinx.android.synthetic.main.seu_arquivo_de_layout.*

Pronto! Agora basta acessar diretamente os componentes definidos no seu
arquivo de layout de acordo com o android:id informado. A MainActivity ficará da
seguinte forma:
import android.os.Bundle



import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        buttonToast.setOnClickListener {
            val texto = editTexto.text.toString()
            Toast.makeText(this, texto, Toast.LENGTH_SHORT).show()
        }
    }
}

É importante ressaltar que utilizamos no código Kotlin o mesmo id do
componente que foi definido no arquivo de layout e que o acesso a eles deve
ser feito após a chamada ao método setContentView(int).

A partir de agora utilizaremos Kotlin Android Extensions em todos os
exemplos. Por isso, lembre-se de verificar se o plugin está declarado ao
build.gradle do módulo e conferir o id do componente no arquivo de layout.

Debug no Android Studio
A depuração aplicações Android é bastante simples. É preciso apenas
adicionar os pontos de parada (breakpoints) no código-fonte como mostrado
na Figura 1.27 e clicar no botão Debug ‘app’. Cada breakpoint suspende a
execução do aplicativo antes de a linha de código correspondente ser
executada.



Figura 1.27 – Adicionando breakpoints ao código da aplicação.
Enquanto o fluxo de execução da aplicação estiver suspenso, é possível

visualizar as variáveis em memória na janela Debug, como mostra a Figura
1.28.

Figura 1.28 – Janela de debug do Android Studio.
Pause o cursor do mouse sobre os botões dessa janela e você verá uma dica

do seu funcionamento. Os principais são:
• Step Over – executará a linha corrente e passará para a próxima;
• Step Into – se a linha corrente for a chamada de um método, o fluxo de

execução mudará para a primeira linha desse método;
• Step Out – se estiver em um método, o fluxo sairá desse método e voltará

para o fluxo anterior;
• Evaluate expression – é possível avaliar um trecho de código em tempo

de execução;



• Resume Program – fará com que o fluxo de execução continue;
• Stop Program – encerra a depuração da aplicação;
• View breakpoints – podemos visualizar todos os breakpoints adicionados

ao projeto.
A partir de agora, quando algo der errado em sua aplicação, procure fazer a

depuração do seu código para analisar o que está acontecendo. Aconselho
também usar essa abordagem para entender melhor o fluxo de execução dos
exemplos que construiremos ao longo do livro.

Tratando erros na aplicação
Quando ocorre algum erro no aplicativo costumamos dizer que ele deu
“Crash” ou “Force close”. A segunda expressão é usada porque nas
primeiras versões do Android uma mensagem era exibida informando que a
aplicação tinha sido interrompida quando um erro havia acontecido. E essa
mensagem possuía apenas um botão com o texto Force close como mostra a
Figura 1.29.

Figura 1.29 – Mensagem de “Force close” no Android 2.3.
Atualmente a mensagem que é exibida é mais similar à mostrada na Figura

1.30, entretanto o termo Force close ainda é bastante utilizado por muitos
desenvolvedores, enquanto outros utilizam o termo crash ou algo similar. O



fato é que, quando sua aplicação dispara qualquer erro ou exceção que não é
tratada, essa mensagem é exibida para o usuário e seu aplicativo fechará
automaticamente.

Figura 1.30 – Mensagem de erro no Android P.
Quando isso acontecer, é importante verificar o Logcat para ver o log de

erro que foi gerado. Por exemplo, comente a linha a seguir do projeto que
acabamos de criar:
// setContentView(R.layout.activity_main)

Uma vez que a chamada ao método setContentView(int) está comentada, o
Kotlin extensions não conseguirá obter a referência do arquivo de layout,
pois ele não foi definido. Ao executar a aplicação, a seguinte mensagem de
erro será exibida e um log similar ao seguinte será gerado no Logcat:
FATAL EXCEPTION: main
Process: dominando.android.basico, PID: 5746
java.lang.RuntimeException: Unable to start activity

ComponentInfo{dominando.android.basico/dominando.android.basico.MainActivity}:
java.lang.NullPointerException: Attempt to invoke virtual method 'void
android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object
reference

    ...
 Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void



android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object
reference

    at dominando.android.basico.MainActivity.onCreate(MainActivity.kt:13)
    ...

O segredo para analisar o log, é primeiramente procurar pelas classes do
projeto. Normalmente estará lá a causa do erro, mas não necessariamente o
problema em si. Como se pode observar, o log nos informa que aconteceu um
NullPointerException, que indica que o código queria acessar um objeto que não
foi inicializado ainda. Isso está acontecendo no método onCreate localizado a
linha 13 da MainActivity.kt, mas a causa do erro é não termos definido o
arquivo de layout da activity. Agora que o erro foi analisado e descoberto,
descomente a linha e execute a aplicação novamente e ela voltará a funcionar
normalmente.

É muito importante sabermos analisar os erros de uma aplicação, pois a
correção de bugs faz parte do dia a dia do desenvolvedor. Colocar logs e
depurar o código é uma boa maneira de encontrar esses erros.

Esse foi um longo capítulo cheio de teorias introdutórias que devem ser
revisitadas com certa frequência para serem assimiladas mais efetivamente,
pois serão necessárias no decorrer do livro e no dia a dia de um
desenvolvedor Android.

1 Caso o nome do seu usuário tenha acento ou espaços, você poderá ter problemas durante a
compilação da aplicação, então escolha outro local do seu computador.

2 É importante que você tenha conexão com a internet nesse momento (principalmente a primeira vez),
pois o Android Studio fará o download de algumas dependências do projeto.

3 Esse identificador é um inteiro de 32 bits do Java (int).
4 Não devemos usar o construtor de uma subclasse de Activity para fazer inicializações.
5 Essa opção pode variar um pouco de aparelho para aparelho.
6 O Windows Update às vezes não encontra os drivers de aparelhos menos “famosos”. Nesse caso,

entre no site do fabricante e procure por “Android ADB Driver” do seu aparelho. Caso não encontre,
existe um driver genérico não oficial disponível em http://www.adbdriver.com.

7 Você pode descobrir onde está instalado o SDK por meio do SDK Manager no campo “Android SDK
Location”.

8 Em alguns casos, podem acontecer problemas na execução do emulador. Isso pode ocorrer devido a
placa de vídeo (que não tinha processador gráfico – GPU) ou do processador que não suporta
máquinas virtuais.

9 A forma de mudar o idioma do aparelho pode variar um pouco de acordo com o modelo e/ou versão
do Android. Tente achar a opção correspondente no seu aparelho. A partir do Android 8, a opção de
mudança de idiomas fica dentro da opção “Sistema”.

10 Perceba que omitimos o nome do pacote no código-fonte. Faremos isso no decorrer do livro, mas
você deve adicioná-lo/mantê-lo no seu código-fonte.



CAPÍTULO 2
Layouts

Boa parte do sucesso de uma aplicação deve-se ao seu aspecto visual, e no
desenvolvimento Android há um grande desafio devido à grande variedade
de tamanhos e densidades de tela disponíveis no mercado. Neste capítulo
serão abordados os gerenciadores de layout que ajudam a organizar os
componentes visuais na tela de modo a atingir o design desejado para o maior
número de aparelhos possível. Será apresentado pelo menos um exemplo de
cada gerenciador de layout e serão destacadas suas propriedades mais
importantes.

Gerenciadores de layout
Todos os componentes visuais do Android herdam direta ou indiretamente da
classe android.view.View, e todos os gerenciadores de layout são subclasses de
android.view.ViewGroup, que também é subclasse de View. Um ViewGroup pode
conter vários objetos View e consequentemente (devido à herança) outros
ViewGroup. Alguns desses ViewGroup são chamados de gerenciadores de layout.

O Android possui diversos gerenciadores de layout, cada um com uma
característica particular. A Tabela 2.1 lista os principais gerenciadores de
layout do Android.

Tabela 2.1 – Principais gerenciadores de layout do Android
Classe Característica principal

FrameLayout É o layout mais simples. Permite adicionar componentes um sobre o outro e o alinhamento só
pode ser feito pelas bordas do layout (topo, inferior, esquerda, direita) ou centralizado.

RelativeLayout Faz o mesmo que o FrameLayout, mas permite alinhar os componentes um em relação aos
outros.

LinearLayout Permite adicionar os componentes sequencialmente na horizontal ou na vertical.
TableLayout Organiza o layout em forma de tabela, onde cada componente representa uma coluna e pode

ocupar duas ou mais colunas.
ScrollView Permite fazer a rolagem na tela quando não houver espaço suficiente para todos os



HorizontalScrollView componentes.
FlexBoxLayout Faz o mesmo que o LinearLayout, mas permite a “quebra de linha/coluna” quando não há

espaço suficiente para o componente.
GridLayout Similar ao TableLayout, mas permite que um componente ocupe mais de uma linha.
ConstraintLayout Permite alinhar os componentes baseados em regras.

Os cinco primeiros gerenciadores de layout são padrão da plataforma desde
as primeiras versões do Android, enquanto os três últimos devem ser
adicionados no build.gradle para serem utilizados.

A partir do Android Studio 2.2 o ConstraintLayout tornou-se o layout-padrão
devido à sua flexibilidade e facilidade de criar os layouts utilizando o editor
visual. Ele reúne todas as funcionalidades de praticamente todos os demais
gerenciadores (FrameLayout, LinearLayout, RelativeLayout, TableLayout e GridLayout) e
possui ainda mais recursos. Entretanto, por ser um recurso relativamente
novo, apresentaremos exemplos de todos os outros gerenciadores de layout
primeiro, pois, caso você precise trabalhar com algum projeto “legado” ou
precise de um layout mais simples, poderá utilizar esses outros layouts.

Além disso, entendendo o funcionamento dos demais gerenciadores de
layout, será mais fácil entender os conceitos do ConstraintLayout e quão poderoso
ele é.

Editor visual de layout do Android Studio
Ao abrir um arquivo de layout, o editor visual de layout do Android Studio é
apresentado similar ao apresentado na Figura 2.1. Aqui estamos utilizando a
versão 3.3 do Android Studio, se estiver utilizando uma versão diferente, o
posicionamento dos componentes pode ser levemente diferente.

Na parte superior esquerda está a paleta de componentes (Palette) que é
separada por categorias. Abaixo da paleta de componentes fica o Component
Tree, que mostra a hierarquia do arquivo de layout onde é possível selecionar
mais rapidamente um componente adicionado ao layout.

No centro existem duas barras de ferramentas na parte superior como se
pode observar na Figura 2.2. O primeiro botão da parte superior permite
alterar a forma de visualização do layout: Design, Blueprint ou ambos. A
visualização Design é a padrão, os componentes são visualizados como eles
realmente são. Blueprint, por sua vez, exibe o layout como se fosse a planta
de uma casa, onde poucos detalhes visuais dos componentes são exibidos,
mas é possível visualizar o alinhamento e distância entre eles.



Figura 2.1 – Editor visual de layouts do Android Studio.
Nos botões seguintes, é possível visualizar o layout em diferentes

configurações, tais como: em portrait (aparelho na vertical) ou landscape
(horizontal); em outros aparelhos; em versões do Android; com outro tema
(falaremos sobre temas no Capítulo 6); em outros idiomas; e, por fim, os
botões para controlar o zoom do layout. No entanto, uma opção
interessantíssima dessa barra de ferramentas é o ícone que aparece no final.
Ele indica as melhorias e erros que o seu layout possui baseado nas boas
práticas da criação de layouts. Por exemplo: ao criarmos novo projeto, o
arquivo de layout já vem com um warning informando que não devemos
utilizar o texto “Hello world” diretamente no arquivo de layout, e sim criar
um texto no res/values/strings.xml.

Os botões da segunda barra de ferramentas variam de acordo com o
gerenciador de layout que estiver sendo utilizado.

Figura 2.2 – Barra de ferramentas do editor de layouts do Android
Studio.

No lado direito, fica a lista de propriedades do componente selecionado.



Perceba que ela exibirá as propriedades mais comuns como ID, tamanho,
texto etc. Para ver todas as propriedades é preciso clicar na opção View all
attributes, representado pelo ícone de duas setas na parte superior direita.

Daqui para a frente, fique à vontade para editar seus arquivos de layout pelo
editor visual ou pelo editor de texto.

Largura e altura
Cada objeto View deve, obrigatoriamente, possuir uma altura e uma largura
que são definidas nas propriedades android:layout_width e android:layout_height,
respectivamente. Esses atributos podem assumir os valores wrap_content,
match_parent (ou fill_parent, que é a mesma coisa, mas deixou de ser utilizado no
Android 2.2) ou um valor fixo.

Ao definir a largura ou altura do componente como wrap_content, informamos
que ele poderá expandir tanto quanto precisar. Um TextView, por exemplo, que
usar esse valor crescerá de acordo com o texto que ele contiver. Utilizando
match_parent, indicamos que o componente ocupará todo o espaço (de largura
ou altura) restante do seu “pai”, ou seja, do ViewGroup de onde ele estiver
contido.

Ao colocar um valor de tamanho fixo, como, por exemplo, 100dp, o tamanho
em pixels se ajustará de acordo com a densidade da tela. Por exemplo, 100dp
em um aparelho MDPI terá 100 pixels, já em um aparelho XHDPI o mesmo
componente teria 200 pixels (veja a Tabela 1.3). Por isso, devemos sempre
utilizar dp para medidas em arquivos de layout.

Crie um novo projeto para analisar os principais gerenciadores de layout do
Android.

Application Name Layouts
Package Name dominando.android.layouts
Activity Name MainActivity

Clique com o botão direito sobre a pasta res/layout e selecione New >
Layout resource file... na janela que for exibida, preencha o campo File
name como ex_largura_altura e o campo Root element deixe como LinearLayout.
Pressione OK para criar o novo arquivo de layout e faça as modificações para
deixá-lo como a seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"



    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Primeiro"/>
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Segundo botão"/>
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Terceiro Botão"/>
    <Button
        android:layout_width="200dp"
        android:layout_height="match_parent"
        android:text="Quarto botão"/>
</LinearLayout>

O resultado deve ficar similar ao da Figura 2.3 e você pode implementar
tanto utilizando o editor visual – arrastando e soltando os componentes e
utilizando a janela de propriedades – ou alterando o XML diretamente.



Figura 2.3 – Altura e largura dos componentes.
Daqui para a frente, sempre será mostrado o XML e uma figura com o

resultado final do layout.
Esse arquivo de layout tem como seu elemento-raiz um LinearLayout. A

propriedade android:orientation indica que os componentes serão exibidos
sequencialmente na vertical ou na horizontal. A largura e a altura estão
definidas como match_parent, e por ser o elemento-raiz do layout, ele terá o
tamanho da tela. Como se pode observar, os dois primeiros botões estão com
a propriedade android:layout_width com o valor wrap_content, ficando suas larguras
determinadas pelo tamanho do texto que possuem. Dessa forma, o segundo
botão ficará maior que o primeiro. O terceiro botão tem a largura match_parent,
ocupando assim toda a largura restante do seu “pai”, ou seja, do LinearLayout e,
consequentemente, da tela. Já o último botão está com a altura match_parent,
fazendo que toda a área restante da tela seja atribuída a ele. Na largura,
usamos um valor fixo de 200dp.

O ideal é evitar ao máximo utilizar valores fixos, pois isso pode atrapalhar a
adaptação do layout em telas de tamanhos variados. Porém, caso precise
dessa abordagem, use o arquivo res/values/dimens.xml para declarar esses
valores e utilize a referência @dimen/seu_valor no seu arquivo de layout. Crie um
arquivo res/values/dimens.xml e deixe-o conforme a seguir:
<resources>
    <dimen name="largura_botao">200dp</dimen>
</resources>

Agora altere a largura do botão para apontar para essa dimensão:
<Button
        android:layout_width="@dimen/largura_botao" ...

Isso facilita a portabilidade do layout, uma vez que não será preciso alterá-
lo; teremos apenas que criar pastas res/values com sufixos diferentes para
atingir o resultado desejado, como, por exemplo, res/values-large ou
res/values-xxxhdpi.

Padding e Margin
Todo componente pode definir margin e padding. Essas duas propriedades
são semelhantes, e às vezes o uso de uma ou outra pode causar o mesmo
efeito visual, entretanto internamente elas realizam tarefas diferentes. A



propriedade android:margin é o espaçamento do componente em relação às
bordas ou ao componente vizinho. O android:padding, por sua vez, é o
espaçamento da borda do componente para seu interior. Como observamos na
Figura 2.4, o padding altera o tamanho do componente, enquanto a margin
apenas o afasta da borda ou de outro componente.

Figura 2.4 – Diferença entre margin e padding.
A Tabela 2.2 ilustra as variações das propriedades margin e padding e seu

propósito.
Tabela 2.2 – Utilização das propriedades margin e padding

Propriedade Descrição
android:layout_margin android:padding Aplica o valor informado nas partes superior, inferior e nas laterais.
android: android:paddingBottom Aplica o valor informado na parte inferior.
layout_marginBottom
android: android:paddingTop Aplica o valor informado na parte superior.
layout_marginTop
android: android:paddingStart Aplica o valor informado no lado esquerdo em idiomas LTR (left to
layout_marginStart right) e do lado direito em idiomas RTL (right to left).
android: android:paddingEnd Aplica o valor informado no lado direito em idiomas LTR (left to
layout_marginEnd right) e do lado esquerdo em idiomas RTL (right to left).

Para checar a diferença entre essas duas propriedades, crie o arquivo de
layout res/layout/ex_margin_padding.xml, deixe-o como a seguir e ele deve
ficar conforme a Figura 2.5:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Margin"
        android:background="#00FF00"



        android:layout_margin="40dp"/>
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Padding"
        android:background="#00FF00"
        android:padding="40dp"/>
</LinearLayout>

Figura 2.5 – Exemplo de margin e padding.
Usamos o LinearLayout com a orientação vertical contendo dois TextView. Para

podermos visualizar a área que o componente possui, atribuímos uma cor de
background para ambos, utilizando a propriedade android:background. Nela
usamos a notação #RRGGBB (Red Green Blue) para informarmos esse valor.

Para o primeiro TextView, definimos a propriedade android:layout_margin para
40dp enquanto para o segundo, atribuímos esse mesmo valor para a
android:padding. Note que visualmente o texto dos dois componentes está
alinhado à esquerda, entretanto o primeiro ficou com o tamanho que o seu
texto determinou e o espaçamento foi adicionado fora da sua área, já o
segundo TextView ficou com o tamanho maior.

FrameLayout
O FrameLayout é o gerenciador de layout mais simples, e normalmente é usado
para colocar um único elemento dentro dele. Porém, ao adicionar mais
componentes, eles ficarão sobrepostos, ou seja, o primeiro elemento ficará
mais atrás e os próximos ficarão à frente do anterior, criando assim um visual
de camadas.

Adicione o arquivo res/layout/ex_frame.xml para entender melhor esse



conceito, colocando um FrameLayout como elemento-raiz e modificando-o para
ficar como a seguir:
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ImageView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:scaleType="centerCrop"
        android:src="@drawable/recife"/>
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Recife-PE"
        android:padding="10dp"
        android:background="#000"
        android:textColor="#FFFFFF"
        android:layout_gravity="bottom"/>
    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="end|top"
        android:src="@mipmap/ic_launcher"/>
</FrameLayout>

É a primeira vez que foi utilizado o componente ImageView. Para definir a
imagem que será exibida é necessário informar a sua referência na
propriedade android:src. Nesse exemplo, foi utilizada uma imagem chamada
recife.jpg (use a imagem que preferir, mas lembre-se das regras de nomeação
de recursos), que deve estar armazenada na pasta res/drawable do projeto,
logo, teremos @drawable/recife. O primeiro ImageView está ocupando toda a tela e
está utilizando a propriedade android:scaleType que informa como a imagem deve
ser redimensionada. Os tipos de escala de uma ImageView estão listados na
Tabela 2.3.

Tabela 2.3 – Utilização da propriedade scaleType da ImageView
Propriedade Descrição
center Centraliza a imagem da ImageView, mas não realiza nenhuma escala na imagem.
centerCrop Redimensiona a imagem uniformemente de modo que a altura e largura da imagem sejam igual ou

maior à ImageView. Com isso, as laterais ou as partes inferior e superior da imagem serão cortadas.
centerInside Caso a imagem seja maior que a ImageView, a imagem será redimensionada uniformemente de modo



que a altura e largura da imagem sejam menor ou igual que a dimensão correspondente da ImageView.
Com isso, a ImageView não será totalmente preenchida, ficando as laterais ou as partes inferior e
superior vazias. Caso a imagem seja menor, ela será apenas centralizada na ImageView.

fitCenter Similar ou anterior, mas a imagem será redimensionada e centralizada independente de ser maior ou
menor que a ImageView.

fitStart Similar ao anterior, mas a imagem ficará alinhada ao início da ImageView. Se a largura for maior que a
altura, a imagem ficará alinhada à esquerda (ou à direita em idiomas RTL), caso contrário ficará
alinhada ao topo.

fitEnd Similar ao fitCenter, mas a imagem ficará alinhada ao fim da ImageView. Se a largura for maior que a
altura, a imagem ficará alinhada à direita (ou à esquerda em idiomas RTL), caso contrário ficará
alinhada à parte inferior da ImageView.

fitXY Redimensionará a imagem de modo a preencher toda a ImageView, podendo distorcer a imagem.
matrix A imagem será desenhada a partir da parte superior esquerda sem realizar nenhum redimensionamento.

O resultado deve ficar conforme a Figura 2.6. Aproveite para testar as
outras opções do android:scaleType.

Figura 2.6 – Exemplo do FrameLayout.
Uma propriedade interessante dos componentes contidos em um FrameLayout

e que deve ser ressaltada aqui é a android:layout_gravity, que determina o
posicionamento do componente dentro do layout: esquerda, direita, centro,
topo ou abaixo. E, como pode-se observar, é possível combinar esses valores
usando “|” (pipe ou barra em pé).



RelativeLayout
Esse layout é bem flexível, pois permite posicionar os componentes em
relação a outros componentes, ou às bordas. É possível indicar, por exemplo,
que um componente ficará acima, abaixo ou ao lado de outro. Adicione o
arquivo res/layout/ex_relative.xml listado a seguir:
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="8dp">
    <ImageView
        android:id="@+id/imgIcone"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentStart="true"
        android:layout_alignParentTop="true"
        android:layout_marginEnd="8dp"
        android:src="@mipmap/ic_launcher" />
    <CheckBox
        android:id="@+id/chkEnable"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentTop="true"
        android:layout_alignParentEnd="true" />
    <TextView
        android:id="@+id/txtTitulo"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentTop="true"
        android:layout_toStartOf="@+id/chkEnable"
        android:layout_toEndOf="@+id/imgIcone"
        android:text="Título" />
    <TextView
        android:id="@+id/txtSubtitulo"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/txtTitulo"
        android:layout_toEndOf="@+id/imgIcone"
        android:text="Subtítulo" />
</RelativeLayout>

O resultado ficará conforme a Figura 2.7.



Figura 2.7 – Exemplo do RelativeLayout.
O posicionamento dos componentes está da seguinte forma:
• O ImageView está na parte superior esquerda, isso está descrito nas

propriedades android:layout_alignParentTop e android:layout_alignParentStart.
Colocamos uma margem de 8dp à direita para o texto não ficar “colado” na
imagem utilizando android:layout_marginEnd.

• O CheckBox está na parte superior direita de acordo com as propriedades
android:layout_alignParentTop e android:layout_alignParentEnd.

• O TextView do título está alinhado ao topo e posicionado à direita da
imagem (android:layout_toEndOf) e à esquerda do CheckBox
(android:layout_toStartOf). Isso garantirá que o texto não sobreponha o Checkbox
caso ele seja muito extenso.

• Por fim, o TextView com o subtítulo ficará abaixo (android:layout_below) e à
direita da imagem (android:layout_toEndOf).

Perceba que foram utilizadas as propriedades android:layout_alignParentStart,
android:layout_alignParentEnd, android:layout_toStartOf e android:layout_toEndOf. Elas fazem
com que nossos arquivos de layout fiquem compatíveis com idiomas RTL
(Right To Left), aqueles em que a leitura é feita da direita para a esquerda.

Dominar esse layout (assim como os demais) requer tempo e prática, mas o
editor visual já nos ajuda bastante. O RelativeLayout tem uma vasta lista de
propriedades para posicionar os componentes, e as principais estão listadas na
Tabela 2.4.

Tabela 2.4 – Propriedades do RelativeLayout
Propriedade Aplicação

android:layout_above Acima do componente indicado.
android:layout_below Abaixo do componente indicado.
android:layout_toEndOf À direita do componente indicado. Ou à esquerda nos idiomas RTL.
android:layout_toStartOf À esquerda do componente indicado. Ou à direita nos idiomas RTL.
android:layout_alignParentTop Alinha o componente ao topo do layout.
android:layout_alignParentStart Alinha o componente à esquerda do layout. Ou à direita nos idiomas RTL.



android:layout_alignParentEnd Alinha o componente à direita do layout. Ou à esquerda nos idiomas RTL.
android:layout_alignParentBottom Alinha o componente na parte inferior do layout.
android:layout_alignEnd Alinha o componente à direita de outro. Ou à esquerda nos idiomas RTL.
android:layout_alignStart Alinha o componente à esquerda de outro. Ou à direita nos idiomas RTL.
android:layout_alignTop Alinha o componente ao topo de outro.
android:layout_alignBottom Alinha o componente à parte inferior de outro.
android:layout_centerVertical Centraliza o componente verticalmente no layout.
android:layout_centerHorizontal Centraliza o componente horizontalmente no layout.
android:layout_centerInParent É a combinação dos dois anteriores.

Caso adicione componentes sem utilizar as propriedades da Tabela 2.4, o
RelativeLayout se comportará como um FrameLayout, ou seja, deixará os
componentes sobrepostos.

LinearLayout
O LinearLayout organiza os componentes um ao lado do outro, ou um abaixo do
outro, dependendo da propriedade android:orientation. Com a propriedade
android:layout_gravity é possível alinhar o componente verticalmente quando a
orientação for horizontal, e horizontalmente quando a orientação for vertical.

Entretanto, sem dúvida, a propriedade mais interessante desse gerenciador é
o android:layout_weight, que define como o espaço restante do layout deve ser
distribuído pelos componentes. Porém, esse comportamento pode variar de
acordo com o valor definido na propriedade android:layout_width e
android:layout_height. Implemente o arquivo de layout res/layout/ex_linear.xml
que deve ficar como a seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <!-- Linha 1 -->
    <LinearLayout
        android:layout_height="wrap_content"
        android:layout_width="match_parent">
        <Button
            android:text="Um"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"/>
        <Button
            android:text="Exemplo"
            android:layout_width="wrap_content"



            android:layout_height="wrap_content"/>
        <Button
            android:text="de peso"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"/>
    </LinearLayout>
    <!-- Linha 2-->
    <LinearLayout
        android:layout_height="wrap_content"
        android:layout_width="match_parent">
        <Button
            android:text="Um"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"/>
        <Button
            android:text="Exemplo"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"/>
        <Button
            android:text="de peso"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"/>
    </LinearLayout>
    <!-- Linha 3 -->
    <LinearLayout
        android:layout_height="wrap_content"
        android:layout_width="match_parent">
        <Button
            android:text="Um"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="0.25"/>
        <Button
            android:text="Exemplo"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="0.50"/>
        <Button
            android:text="de peso"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="0.25"/>



    </LinearLayout>
</LinearLayout>

O resultado deve ficar conforme a Figura 2.8.

Figura 2.8 – Exemplo da propriedade layout_weight.
O layout anterior contém um LinearLayout vertical (android:orientation="vertical")

com três LinearLayout horizontais, onde cada um desses três possui três botões
com os respectivos textos: “Um”, “exemplo” e “de peso”. Acima da
declaração de cada LinearLayout foi adicionado um comentário indicando cada
linha para guiar a explicação:

• Linha 1 – Aqui não foi feita nenhuma modificação. Os botões estão sem
peso (android:layout_weight) e com a largura e a altura (android:layout_width e
android:layout_height) definidas como wrap_content. Desse modo, eles terão o
tamanho que o seu texto determinar.

• Linha 2 – Como foi visto na linha 1, sobrou um espaço entre o terceiro
botão e a margem direita. O peso serve justamente para determinar como
essa área será preenchida. Foi definida a propriedade android:layout_width dos
botões como 0dp, e nesse caso o componente não deveria aparecer.
Entretanto, como o peso foi usado, o espaço restante da tela será
distribuído igualmente para os três botões. Como os três botões estão com
tamanho zero, o espaço restante (que será dividido entre os componentes)
é a largura total da tela. Assim a largura de cada botão será o da largura da
tela dividido por 3.

• Linha 3 – Igual à anterior, mas foi modificada a proporção dos
componentes. O segundo ocupa 50% da tela (com o peso 0,50) e os outros
dois, 25% cada (peso 0,25).

TableLayout



O TableLayout organiza os itens em forma de tabela, onde cada linha será uma
TableRow e cada componente será a própria coluna da tabela. Adicione o
arquivo de layout res/layout/ex_table.xml deixando-o como a seguir:
<TableLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    android:stretchColumns="1,2">
    <TableRow>
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Nome:"/>
        <EditText
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_span="2"/>
    </TableRow>
    <TableRow>
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Avisos por:"
            android:id="@+id/textView2"/>
        <CheckBox
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Telefone"/>
        <CheckBox
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Email"/>
    </TableRow>
</TableLayout>

O resultado deve ficar conforme a Figura 2.9.



Figura 2.9 – Exemplo de TableLayout.
Duas propriedades interessantes nesses arquivos são: android:stretchColumns

informa quais colunas (indicando os índices separados por vírgula) irão
expandir caso haja espaço sobrando no layout; e android:layout_span indica
quantas colunas o componente ocupará. O TableLayout também possui uma
propriedade chamada android:shrinkColumns que indica as colunas que devem
ficar menores caso não haja espaço suficiente para todos os componentes.

É importante ressaltar que esse layout não deve ser utilizado para exibir
tabelas grandes e dinâmicas. Para esses casos, usaremos a ListView ou a
RecyclerView que será apresentado no Capítulo 5. O TableLayout atende a layouts
onde a disposição dos componentes está em formato de uma tabela com
várias células. Mesmo assim, para esse tipo de layout ainda é mais comum
utilizar o GridLayout ou (melhor ainda) o ConstraintLayout, que será mostrado a
seguir.

GridLayout
O GridLayout organiza os componentes em uma tabela onde se pode especificar
em qual linha e coluna ele se encontra. Além disso, é possível determinar
quantas linhas e colunas um componente pode ocupar. Esse gerenciador de
layout está disponível a partir do Android 4.0 ou superior (API Level 14),
mas deve-se utilizar a classe GridLayout disponível no Jetpack. Na verdade, é
até uma recomendação utilizar essa versão, pois ela possui a correção de
alguns bugs existentes na versão nativa.

Sendo assim, adicione a seguinte dependência no arquivo app/build.gradle:
dependencies {
    ...
    implementation 'androidx.gridlayout:gridlayout:1.0.0'
}

Clique na opção Sync Now que aparecerá na parte superior ou no menu
File > Sync Project with Gradle Files para que seja feito o download da
biblioteca e adicionada a dependência ao projeto.

Para entender melhor o funcionamento do GridLayout, crie o layout
res/layout/ex_grid.xml apresentado a seguir:
<androidx.gridlayout.widget.GridLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"



    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:columnCount="4"
    app:rowCount="3">
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Botão 1"
        app:layout_column="0"
        app:layout_row="0" />
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Botão 2"
        app:layout_column="1"
        app:layout_row="0" />
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Botão 3"
        app:layout_column="0"
        app:layout_columnSpan="2"
        app:layout_gravity="fill_horizontal"
        app:layout_row="1" />
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Botão 4"
        app:layout_column="2"
        app:layout_columnSpan="2"
        app:layout_gravity="fill"
        app:layout_row="0"
        app:layout_rowSpan="2" />
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Botão 5"
        app:layout_column="0"
        app:layout_columnSpan="3"
        app:layout_gravity="fill_horizontal"
        app:layout_row="2" />
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Botão 6"



        app:layout_column="3"
        app:layout_row="2" />
</androidx.gridlayout.widget.GridLayout>

O resultado ficará conforme a Figura 2.10.

Figura 2.10 – Exemplo de GridLayout.
Nas propriedades app:rowCount e app:columnCount do GridLayout é definida a

quantidade de linhas e colunas que o layout terá. Em seguida, adicionamos
seis botões, posicionando-os de acordo com as propriedades app:layout_row e
app:layout_column. Com a propriedade app:layout_columnSpan informamos, por
exemplo, que o “Botão 3” ocupará duas colunas, enquanto o “Botão 4”
ocupará duas linhas, conforme a propriedade app:layout_rowSpan. O último ponto
a destacar é a propriedade app:layout_gravity, onde indicamos que o restante da
célula será preenchido na vertical, na horizontal ou em ambas (fill_vertical,
fill_horizontal e fill).

ConstraintLayout
O ConstraintLayout foi lançado em 2016 juntamente com o Android Studio 2.2 e
tornou-se o gerenciador de layout-padrão do Android, pois reúne todos os
recursos dos outros gerenciadores de layout e uma série de outras
funcionalidades. Isso sem contar a facilidade que o editor visual traz para
posicionar e redimensionar os componentes.

Outro benefício do ConstraintLayout é que ele permite criar “layouts planos”,
ou seja, sem o encadeamento de layouts (LinearLayout dentro de FrameLayout
dentro de RelativeLayout ...). Dessa forma, os layouts tendem a ser renderizados
de forma mais rápida e eficiente.

Para poder utilizar o ConstraintLayout, verifique se a dependência a seguir
encontra-se no app/build.gradle. Isso normalmente já é feito por padrão pelo



Android Studio:
dependencies {
    ...
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
}

Para começar a explorar em detalhes o ConstraintLayout crie um novo arquivo
chamado res/layout/ex_constraint.xml e deixe-o apenas com o ConstraintLayout
como elemento-raiz:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
</androidx.constraintlayout.widget.ConstraintLayout>

Caso tenha criado o arquivo com outro gerenciador de layout, ou
simplesmente deseja convertê-lo para ConstraintLayout, basta clicar com o botão
direito sobre o layout no editor visual e selecionar a opção Convert [layout]
to ConstraintLayout.

Posicionamento
Ao arrastar um componente da paleta de componentes para editor visual, este
componente ainda não possui uma posição real definida. Ao executar a
aplicação o componente será exibido na parte superior esquerda da tela. Isso
acontece porque, por padrão, o editor visual definirá as propriedades
tools:layout_editor_absoluteX e tools:layout_editor_absoluteY para posicionar o
componente em tempo de projeto. Lembre-se de que o prefixo tools indica que
a propriedade será utilizada apenas pelo editor visual e não tem nenhuma
função em tempo de execução.

Por isso, a primeira premissa que se deve ter em mente ao trabalhar com o
ConstraintLayout é que é preciso informar ao menos uma constraint para o
posicionamento horizontal e outra para o posicionamento vertical. Ao pausar
o mouse sobre um componente pode-se notar que aparecem quatro alças em
formato de círculo na parte superior, outra na parte inferior e outras duas nas
laterais. Ao clicar e arrastar o mouse a partir dessa alça, aparecerá uma seta
que indicará onde o componente será ancorado como mostra a Figura 2.11.



Figura 2.11 – Posicionando um componente no ConstraintLayout.
É definida uma constraint para o posicionamento vertical do componente,

uma vez que foi utilizada a alça que fica na parte superior do componente.
Note que ao soltar o botão do mouse, o componente fica próximo da borda,
isso pode ser ajustado arrastando o componente para baixo. Isso fará com que
a margem (android:layout_marginTop) do componente seja modificada.

Utilizando as alças laterais, pode-se determinar a constraint para o
posicionamento horizontal. Clique na alça da esquerda e arraste até a borda
esquerda da tela. O XML do botão deve ficar similar ao apresentado a seguir:
<Button
    android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Button"
    android:layout_marginStart="16dp"
    android:layout_marginTop="16dp"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toTopOf="parent" />

Perceba que, ao invés das propriedades começando com tools, foram
definidas duas constraints para o posicionamento do componente
app:layout_constraintTop_toTopOf e app:layout_constraintStart_toStartOf. O botão foi
posicionado em relação ao seu parent, mas poderia ter sido alinhado em
relação a outro componente.

Arraste outro botão para tela e tente alinhá-lo de modo que ele fique na
diagonal inferior direita do primeiro botão como mostra a Figura 2.12. Para
fazer isso, arraste a alça de um componente até a alça do outro componente.
O XML do segundo botão deve ficar como a seguir.



Figura 2.12 – Posicionando um componente no ConstraintLayout.
<Button
    android:id="@+id/button2"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginStart="8dp"
    android:layout_marginTop="8dp"
    android:text="Button"
    app:layout_constraintStart_toEndOf="@+id/button"
    app:layout_constraintTop_toBottomOf="@+id/button" />

Se quiser remover uma constraint de posicionamento, basta clicar sobre a
alça. Para apagar todas as constraints de uma vez, clique no botão com um
“x” que é exibido ao selecionar o componente.

Como foi possível verificar, o ConstraintLayout possui a mesma flexibilidade
de posicionamento dos componentes que o RelativeLayout.

Tamanho
Ao pausar o mouse sobre o componente, podemos notar que são exibidas
quatro alças quadradas nas esquinas do componente. Utilizando essas alças é
possível redimensionar o componente para um valor específico (como 200dp,
por exemplo). Como visto nos outros layouts, podem-se utilizar os valores
wrap_content ou 0dp, sendo esse último descrito na documentação como
“match_constraint”, que seria o equivalente ao match_parent.

Adicione um novo botão no arquivo de layout criado anteriormente e
posicione-o abaixo do segundo botão e ancorado nas bordas esquerda e
direita da tela como mostra a Figura 2.13 e o XML ficará como a seguir:



Figura 2.13 – Botão centralizado no ConstraintLayout.
<Button
    android:id="@+id/button3"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginStart="8dp"
    android:layout_marginTop="8dp"
    android:layout_marginEnd="8dp"
    android:text="Button"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toBottomOf="@+id/button2" />

Selecione o botão e perceba que na parte superior da janela de propriedades
temos algo similar ao mostrado na Figura 2.14.

Figura 2.14 – Propriedades de largura, altura e margem do componente.
Pode-se observar que o botão está com uma margem de 8dp na parte



superior e nas laterais. O que significam esses “>>>” e “<<<”? Esse símbolo
indica que o componente está com o tamanho definido como wrap_content. Se
você clicar sobre “>>>” ou “<<<”, ele ficará como uma linha contínua e um
tamanho fixo será atribuído automaticamente. Ao clicar novamente, veremos
um símbolo diferente e que a largura do componente mudará para 0dp (na
paleta de propriedades aparecerá match_constraint), mas seu funcionamento
é similar ao que acontece quando usamos 0dp + layout_weight=1 no LinearLayout.

Bias (Inclinação)
Quando um componente está ancorado nas duas extremidades, por padrão o
ConstraintLayout irá centralizá-lo. Para que ele fique um pouco mais à esquerda
ou à direita podemos utilizar a propriedade bias. Próximo às propriedades
layout_width e layout_height temos um slider, que, por padrão, está com o
valor 50. Nele, podemos definir se o componente ficará mais para um lado ou
para o outro. Altere a largura do terceiro botão para wrap_content e altere o bias
horizontal para 20. Você notará que ele ficará mais à esquerda como mostra a
Figura 2.15.

Observe que no XML será adicionada a propriedade
app:layout_constraintHorizontal_bias com o valor 0.2. Se tivéssemos um componente
ancorado nas partes superior e inferior, poderíamos definir o bias por meio da
propriedade app:layout_constraintVertical_bias.



Figura 2.15 – Utilizando a propriedade bias para alinhar o componente.

Chains
Quando falamos do LinearLayout destacamos um recurso poderoso que era o
conceito de peso definido na propriedade android:layout_weight. Entretanto, o
peso do componente apenas o redimensionava para ocupar a área restante. No
ConstraintLayout, esse conceito foi expandido para as chains, que acontece
quando temos uma referência cruzada no posicionamento dos componentes.
Por exemplo: “A” está à esquerda de “B”, e “B” está à direita de “A”. Com
isso está formada a chain entre “A” e “B”. Veremos como isso funciona na
prática.

Arraste três botões para a tela (buttonA, buttonB e buttonC). Deixe todos os
botões alinhados horizontalmente (um ao lado do outro) e, em seguida,
selecione os três botões, clique com o botão direito do mouse e selecione a
opção “Chains > Create horizontal chain” como mostra a Figura 2.16.

Ainda com os botões selecionados, clique com o botão direito e selecione a
opção “Align > Vertical centers” para alinharmos todos os botões
verticalmente. Por fim, certifique-se de que a alça superior do buttonA está
conectada à parte inferior do último botão que tínhamos adicionado (button3).



Figura 2.16 – Criando uma chain pelo editor visual.
Os botões deverão estar da seguinte forma no XML:

<Button
    android:id="@+id/buttonA"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="16dp"
    android:text="A"
    app:layout_constraintEnd_toStartOf="@+id/buttonB"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toBottomOf="@+id/button3" />
<Button
    android:id="@+id/buttonB"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="B"
    app:layout_constraintBottom_toBottomOf="@+id/buttonA"
    app:layout_constraintEnd_toStartOf="@+id/buttonC"
    app:layout_constraintStart_toEndOf="@+id/buttonA"
    app:layout_constraintTop_toTopOf="@+id/buttonA" />
<Button
    android:id="@+id/buttonC"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="C"
    app:layout_constraintBottom_toBottomOf="@+id/buttonB"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toEndOf="@+id/buttonB"
    app:layout_constraintTop_toTopOf="@+id/buttonB" />

Perceba que existe uma corrente (chain) entre os componentes, pois o
buttonA está à esquerda do buttonB (app:layout_constraintEnd_toStartOf) e o buttonB está à
direita do buttonA (app:layout_constraintStart_toEndOf). O mesmo acontece com buttonB
que está à esquerda de buttonC, que está à direita do buttonB. O resultado deve
ficar conforme a Figura 2.17.

Figura 2.17 – Chain no estilo Spread.
É importante destacar que a chain é controlada pelo componente da chain

que possui a propriedade app:layout_constraintHorizontal_chainStyle (ou
app:layout_constraintVertical_chainStyle para chain vertical). Existem 4 tipos de chain:



• Spread Chain – o valor “spread” é o padrão, onde os componentes ficam
distribuídos pela tela;

• Spread Inside Chain – definindo “spread_inside”, temos um resultado similar
ao anterior, mas os primeiro e último componentes ficam junto à borda;

• Packed Chain – utilizando o valor “packed”, os componentes são colocados
juntos e centralizados. Para alterar o alinhamento, basta mudar o bias do
componente;

• Weighted Chain – esse último tipo, na verdade, é uma variação do
primeiro e tem o mesmo comportamento que o peso LinearLayout. Os
componentes ocupam a área restante do layout baseando-se no respectivo
peso. Para isso, basta utilizar o spread chain, definir a largura dos
componentes como 0dp, e por fim, definir o peso para cada componente
utilizando a propriedade app:layout_constraintHorizontal_weight (ou
app:layout_constraintVertical_weight para chains verticais).

Para alternar entre os tipos de chain, selecione qualquer componente da
chain e clique no botão Cycle Chain Mode como mostra a Figura 2.18.

Figura 2.18 – Alterando o tipo da chain pelo editor visual.
Obviamente essa mudança pode ser feita diretamente no XML como a

seguir:



<Button
    android:id="@+id/buttonA"
    ...
    app:layout_constraintHorizontal_chainStyle="spread_inside" />

Com essa mudança, os componentes serão exibidos como apresentado na
Figura 2.19.

Figura 2.19 – Chain no estilo Spread Inside.
Alterando o estilo da chain para “packed” e o resultado ficará similar ao da

Figura 2.20.

Figura 2.20 – Chain no estilo Packed.
Para criar uma chain usando o peso, devemos mudar o tipo da chain para

“spread” e atribuir o valor do peso para cada componente utilizando a
propriedade horizontal_weight. Em seguida, devemos definir a largura dos
componentes para 0dp. O resultado ficará conforme a Figura 2.21. E o XML
como a seguir:
<Button
    android:id="@+id/buttonA"
    android:layout_width="0dp"
    app:layout_constraintHorizontal_chainStyle="spread"
    app:layout_constraintHorizontal_weight="1"
    ... />
<Button
    android:id="@+id/buttonB"
    android:layout_width="0dp"
    app:layout_constraintHorizontal_weight="1"
    ... />
<Button
    android:id="@+id/buttonC"
    android:layout_width="0dp"
    app:layout_constraintHorizontal_weight="1"
    ... />



Figura 2.21 – Chain no estilo Weighted.
Com esse exemplo é possível observar que o ConstraintLayout pode substituir o

LinearLayout, pois podemos colocar os componentes sequencialmente na
vertical e na horizontal e distribuí-los proporcionalmente na tela utilizando
chains.

GuideLines
Como foi visto, é possível posicionar os componentes em relação a outros
componentes, às bordas, ou, ainda, utilizar as chains para distribuí-los pela
tela. Entretanto, em certas situações esses recursos podem não ser suficientes.
Nesses casos, podemos utilizar as guidelines, que nada mais são que linhas
(horizontais ou verticais) que não aparecem na tela em tempo de execução,
mas onde os componentes podem se posicionar. A posição da guideline pode
ser em “dp” ou em percentual.

Para adicionar uma guideline, clique com o botão direito sobre o layout e
selecione a opção Helpers > Add Vertical Guideline. Aparecerá uma linha
pontilhada no layout conforme a Figura 2.22.

Perceba que no topo da linha tracejada temos uma seta apontando para a
esquerda indicando que o posicionamento do guideline é relativo a essa
direção. Ao clicar nessa seta, ela mudará a direção para a direita. E ao clicar
mais uma vez, ela mudará para o posicionamento percentual. Dessa forma é
possível colocar uma linha que ficará posicionada a 70% da largura da tela e,
com isso, posicionar componentes usando essa guideline como referência,
como mostra a Figura 2.23.



Figura 2.22 – Guideline adicionado ao arquivo de layout.

Figura 2.23 – Alinhando um componente usando a guideline.
O XML do botão e da guideline ficariam como a seguir:

<androidx.constraintlayout.widget.Guideline
    android:id="@+id/guideline"



    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    app:layout_constraintGuide_percent="0.7" />
<Button
    android:id="@+id/buttonGL"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="32dp"
    android:layout_marginEnd="8dp"
    android:text="Button"
    app:layout_constraintEnd_toStartOf="@+id/guideline"
    app:layout_constraintStart_toStartOf="@+id/guideline"
    app:layout_constraintTop_toBottomOf="@+id/buttonA" />

Como podemos constatar nessa seção, o ConstraintLayout tem a mesma
flexibilidade de posicionamento do RelativeLayout. Possui o recurso de chains
que é ainda mais poderoso que o conceito de peso do LinearLayout. E podemos
até criar tabelas e grids facilmente utilizando chains e/ou guidelines
(substituindo o TableLayout e o GridLayout). Com isso, fica fácil de entender por
que o ConstraintLayout se tornou o gerenciador de layout-padrão do Android. No
entanto, isso não significa que você deve abandonar os demais gerenciadores
de layout. Se a implementação da tela ficar mais simples com os demais
layouts, não há razão para não os usar.

CardView
O componente CardView nada mais é que um FrameLayout com bordas
arredondadas e uma sombra. Ele foi adicionado ao Android 5.0 Lollipop, mas
é disponibilizado em uma biblioteca de compatibilidade que permite usá-lo
em versões anteriores. Para adicionar a biblioteca ao nosso projeto, abra o
arquivo build.gradle e adicione a seguinte linha à seção dependencies:
dependencies {
    ...
    implementation 'androidx.cardview:cardview:1.0.0'
}

Para utilizar o CardView, crie o arquivo res/layout/ex_card.xml e deixe-o
como a seguir:
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"



    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <androidx.cardview.widget.CardView
        android:id="@+id/card_view"
        android:layout_width="200dp"
        android:layout_height="200dp"
        android:layout_gravity="center"
        app:cardBackgroundColor="#FFFF00"
        app:cardCornerRadius="5dp">
        <ImageView
            android:id="@+id/imageView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:scaleType="centerCrop"
            android:src="@drawable/recife" />
    </androidx.cardview.widget.CardView>
</FrameLayout>

Na propriedade app:cardCornerRadius definimos a curvatura das quinas do
cartão e com app:cardBackgroundColor definimos sua cor de background.

É importante ressaltar que em versões anteriores ao Lollipop 5.0 (API Level
21) é possível ver as bordas do CardView, enquanto no Lollipop ou posterior o
conteúdo parece estar por trás ou cortado pela borda curva do componente
como podemos ver na Figura 2.24.



Figura 2.24 – Exemplo de CardView.

ScrollView
Quando o tamanho do layout exceder a altura da tela, o Android não adiciona
uma barra de rolagem automaticamente. É preciso ter em mente que a altura
da tela em landscape é menor que em portrait. Então é quase uma regra
colocar nosso layout dentro de uma ScrollView para evitar que ele fique
“cortado”. O único ponto para o qual devemos ficar atentos é que só podemos
possuir uma única view dentro da ScrollView.

Adicione o arquivo res/layout/ex_scroll.xml e deixe-o como a seguir:
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <include layout="@layout/ex_largura_altura"/>
        <include layout="@layout/ex_margin_padding"/>
        <include layout="@layout/ex_frame"/>
        <include layout="@layout/ex_grid"/>
        <include layout="@layout/ex_table"/>
        <include layout="@layout/ex_linear"/>
        <include layout="@layout/ex_card"/>
        <include layout="@layout/ex_constraint"/>
    </LinearLayout>
</ScrollView>

Para seguir a regra, incluímos apenas um LinearLayout vertical dentro da
ScrollView. Aproveitamos esse exemplo para falar da tag <include>, que como o
próprio nome sugere permite incluir um arquivo de layout dentro de outro
arquivo layout. Então incluímos todos os layouts que usamos neste capítulo.
Execute a aplicação e veja o scroll em funcionamento.

Altere a MainActivity para exibir esse layout. O resultado pode ser visto na
Figura 2.25:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {



        super.onCreate(savedInstanceState)
        setContentView(R.layout.ex_scroll)
    }
}

Figura 2.25 – Exemplo de ScrollView.
Caso precise fazer scroll na horizontal, é só usar uma HorizontalScrollView.
A criação de layouts é uma das tarefas que mais demandam tempo no

desenvolvimento de aplicativos, tendo em vista a grande diversidade de
tamanhos de tela. Isso sem contar a possibilidade de versões diferentes para
portrait e landscape. Por isso, é muito importante que o leitor exercite a
utilização dos layouts apresentados neste capítulo tentando criar suas próprias
telas de modo a fixar os conceitos.

No próximo capítulo será explicado como criar e exibir novas telas, bem
como passar parâmetros para elas.



CAPÍTULO 3
Activity e Intents

Neste capítulo será explicado como funciona o ciclo de vida de uma activity,
como salvar o seu estado e a importância de fazê-lo. Será visto também como
enviar e recuperar informações entre telas. E, por fim, será demonstrado
como utilizar a classe Intent para chamar outras activities da própria aplicação
e de outros aplicativos instalados no dispositivo.

Activity
A classe Activity herda de Context, que traz informações sobre o ambiente da
aplicação. Com um contexto é possível carregar arquivos de recursos, acessar
serviços do sistema, iniciar outras activities etc. Para abrir uma nova activity
é necessário instanciar um objeto da classe Intent, que representa a ação que o
usuário deseja realizar, e então invocar o método startActivity(Intent) da classe
Context.

Para exemplificar esse processo, modificaremos o projeto Basico que
criamos no Capítulo 1 para abrir uma nova Activity ao clicarmos em um
botão. Abra o arquivo res/layout/activity_main.xml e arraste um novo botão
para o layout e faça os ajustes necessários para que ele fique similar ao da
Figura 3.1.
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="dominando.android.basico.MainActivity">
    <EditText
        android:id="@+id/editTexto"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"



        android:layout_marginStart="16dp"
        android:layout_marginTop="16dp"
        android:ems="10"
        android:inputType="textPersonName"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <Button
        android:id="@+id/buttonToast"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/main_button_toast"
        app:layout_constraintStart_toStartOf="@+id/editTexto"
        app:layout_constraintTop_toBottomOf="@+id/editTexto" />
    <Button
        android:id="@+id/buttonTela2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/main_button_tela2"
        app:layout_constraintStart_toStartOf="@+id/buttonToast"
        app:layout_constraintTop_toBottomOf="@+id/buttonToast" />
</androidx.constraintlayout.widget.ConstraintLayout>

Figura 3.1 – Tela modificada com dois botões.
O novo botão tem o id @+id/buttonTela2, e o texto apontando para



@string/main_button_tela2. Adicione esse texto no arquivo res/values/strings.xml
conforme a seguir:
<string name="main_button_tela2">Tela 2</string>

Crie uma nova activity clicando com o botão direito sobre o pacote da
aplicação e selecione a opção New > Activity > Empty Activity. Será
exibida a tela da Figura 3.2.

Figura 3.2 – Tela de criação de uma nova activity.
Preencha o campo Activity Name como Tela2Activity e automaticamente o

campo Layout Name será modificado para activity_tela2. Verifique se a
linguagem Kotlin está selecionada no campo Source Language e clique em
Finish. Em seguida, altere a MainActivity para ficar como a seguir:
import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)



        setContentView(R.layout.activity_main)
        buttonToast.setOnClickListener {
            val texto = editTexto.text.toString()
            Toast.makeText(this, texto, Toast.LENGTH_SHORT).show()
        }
        buttonTela2.setOnClickListener {
            val intent = Intent(this, Tela2Activity::class.java)
            startActivity(intent)
        }
    }
}

No método onCreate(Bundle) definimos o evento de clique do segundo botão,
assim como fizemos anteriormente. Então, criamos um objeto da classe Intent
passando dois parâmetros: o primeiro é um objeto Context que nesse caso, é a
MainActivity; e o segundo, é a classe da activity que será exibida, que nesse
exemplo é a Tela2Activity.

KOTLINxJAVA: A chamada SuaClasse::class retorna um objeto do tipo
KClass<SuaClasse> do Kotlin, enquanto SuaClasse::class.java retornará uma Class<SuaClasse>
do Java.

Modificaremos o arquivo de layout res/layout/activity_tela2 para que ele
exiba os parâmetros vindos da primeira tela. Deixe-o conforme a seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".Tela2Activity">
    <TextView
        android:id="@+id/textMensagem"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

Adicionamos apenas um TextView com o id @+id/textMensagem e o
centralizamos na tela. Isso pode ser feito pelo editor visual clicando com o



botão direito sobre o TextView e selecionando a opção Center >
Horizontally/Vertically.

Passando parâmetros para uma Activity
Uma activity não tem acesso à instância de outra, então, se quisermos passar
informações de uma tela para outra, devemos fazê-lo por meio de parâmetros
adicionados ao objeto Intent.

Modifique o evento de clique do botão para passarmos dois parâmetros para
a Tela2Activity, “nome” e “idade” com os valores “Glauber” e 35, respectivamente:
buttonTela2.setOnClickListener {
    val intent = Intent(this, Tela2Activity::class.java)
    intent.putExtra("nome", "Glauber")
    intent.putExtra("idade", 35)
    startActivity(intent)
}

Para ler esses parâmetros na Tela2Activity, devemos obter o objeto Intent que a
invocou usando a propriedade intent, e, em seguida, ler os parâmetros usando
getStringExtra(String) e getIntExtra(String,int), respectivamente:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import kotlinx.android.synthetic.main.activity_tela2.*
 
class Tela2Activity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_tela2)
        val nome = intent.getStringExtra("nome")
        val idade = intent.getIntExtra("idade", -1)
        textMensagem.text = "Nome: $nome / Idade: $idade"
    }
}

KOTLINxJAVA: ao ler a propriedade intent, o método getIntent() da activity será
chamado como qualquer outra propriedade em Kotlin.

O método getStringExtra(String) retornará o valor do parâmetro “nome”, mas
caso ele não tenha sido informado, a variável nome receberá null; o mesmo é
feito com o método getIntExtra(String, int), onde o valor do parâmetro “idade” será
atribuído à variável idade, mas caso ele não tenha sido definido, o valor -1 será



usado.
Execute a aplicação e clique no segundo botão. A Tela2Activity deverá ser

exibida com os parâmetros informados, conforme mostra a Figura 3.3.

Figura 3.3 – Tela 2 exibindo os parâmetros informados.
Perceba que foram usados valores simples como um texto e um número,

mas e se for necessário passar informações mais complexas, como objetos?

Passando objetos em Intents
Um exemplo típico de passagem de objetos entre activities é uma tela de
listagem (como uma agenda de contatos, por exemplo), e ao clicar em algum
item dessa lista, os detalhes desse item são exibidos em outra tela.

Para passar objetos entre activities, a classe do objeto que queremos passar
via Intent deve implementar a interface android.os.Parcelable. Adicione uma nova
classe ao projeto chamada Cliente e deixe-a como a seguir:
import android.os.Parcelable
class Cliente(var codigo: Int, var nome: String) : Parcelable

O Android Studio mostrará um ícone de uma lâmpada vermelha, indicando
que essa classe possui erros. Ao clicar nessa lâmpada, aparecerá um menu
suspenso com uma lista de opções, onde o primeiro item sugere que



implementemos os métodos dessa interface, como mostra a Figura 3.4.
Clique em Add Parcelable implementation e os métodos necessários serão
gerados automaticamente e a classe Cliente ficará como a seguir:

Figura 3.4 – Android Studio sugerindo para implementar os métodos da
interface Parcelable.

import android.os.Parcel
import android.os.Parcelable
 
class Cliente(var codigo: Int, var nome: String): Parcelable {
    constructor(parcel: Parcel) : this(
            parcel.readInt(),
            parcel.readString()) {
    }
    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeInt(codigo)
        parcel.writeString(nome)
    }
    override fun describeContents(): Int {
        return 0
    }
    companion object CREATOR : Parcelable.Creator<Cliente> {
        override fun createFromParcel(parcel: Parcel): Cliente {
            return Cliente(parcel)
        }
        override fun newArray(size: Int): Array<Cliente?> {
            return arrayOfNulls(size)



        }
    }
}

A classe Cliente implementa a interface Parcelable que contém dois métodos
que devem ser implementados: writeToParcel(Parcel, int) e describeContents(). O
primeiro método serve para serializar (transformar em bytes) os atributos da
classe, enquanto o segundo é um inteiro que servirá de identificador único
dessa classe no projeto.

Outro detalhe importante é o companion object CREATOR que é do tipo
Parcelable.Creator. Todas as classes que implementam Parcelable devem conter esse
atributo, que é responsável por criar o objeto a partir de um Parcel para
deserializá-lo. Perceba que o método createFromParcel(Parcel) chama o construtor
de Cliente que recebe um Parcel, que permite ler os bytes e preencher os
atributos.

KOTLINxJAVA: Em Kotlin, atributos e métodos de classe (static em Java) devem
ser declarados dentro de um bloco chamado companion object.

Adicione um outro botão ao res/layout/activity_main.xml como listado a
seguir:
<Button
    android:id="@+id/buttonParcel"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginEnd="8dp"
    android:layout_marginTop="8dp"
    android:text="@string/main_button_parcel"
    app:layout_constraintRight_toRightOf="parent"
    app:layout_constraintTop_toBottomOf="@+id/buttonTela2" />

Lembre-se de adicionar a string main_button_parcel com o texto “Parcelable via
Intent” no res/values/strings.xml. E, em seguida, defina o evento de clique
para o botão buttonParcel no método onCreate(Bundle) da MainActivity como mostrado
a seguir:
buttonParcel.setOnClickListener {
    val cliente = Cliente(1, "Glauber")
    val intent = Intent(this, Tela2Activity::class.java)
    intent.putExtra("cliente", cliente)
    startActivity(intent)
}



Na Tela2Activity, ajuste o onCreate(Bundle) para ler o parâmetro informado:
class Tela2Activity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_tela2)
        val nome = intent.getStringExtra("nome")
        val idade = intent.getIntExtra("idade", -1)
        val cliente = intent.getParcelableExtra<Cliente>("cliente")
        textMensagem.text = if (cliente != null) {
            "Nome:${cliente.nome} / Código:${cliente.codigo}"
        } else {
            "Nome: $nome / Idade: $idade"
        }
    }
}

KOTLINxJAVA: A instrução if/else no Kotlin retorna a última linha do bloco.
Nesse exemplo, uma String.

Utilizar a interface Parcelable é a ação mais completa, performática e
recomendada pelo Google. Entretanto, existe uma maneira bem mais simples
de fazer a passagem de objetos entre activities. Basta fazer com que a classe
implemente a interface java.io.Serializable e nada mais. Adicione ao projeto a
classe Pessoa como a seguir:
import java.io.Serializable
class Pessoa(var nome : String, var idade : Int) : Serializable

Uma vez que a classe Pessoa implementa a interface Serializable, é possível
passar objetos dessa classe via Intent utilizando o método
putExtra(String,Serializable). Adicione mais um botão ao arquivo
res/layout/activity_main.xml:
    <Button
        android:id="@+id/buttonSerializable"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginEnd="8dp"
        android:layout_marginTop="8dp"
        android:text="@string/main_button_serializable"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/buttonParcel" />

Defina o texto main_button_serializable no res/values/strings.xml com o texto



“Serializable via Intent”. Em seguida, declare o evento de clique no método
onCreate(Bundle) da MainActivity:
buttonSerializable.setOnClickListener {
    val intent = Intent(this, Tela2Activity::class.java)
    intent.putExtra("pessoa", Pessoa("Nelson", 35))
    startActivity(intent)
}

E para recuperar, utilize o método getSerializableExtra(String) como a seguir:
val pessoa = intent.getSerializableExtra("pessoa") as Pessoa? // O objeto pessoa pode ser nulo
if (pessoa != null) {
    textMensagem.text = "Nome: ${pessoa.nome} / Idade: ${pessoa.idade}"
}

KOTLINxJAVA: A linguagem Kotlin é Null-Safety. Isso quer dizer que ela tentar
evitar ao máximo o NullPointerException do Java. Ao declarar uma variável (ou
constante), por padrão ela não aceita valores nulos. Como podemos observar,
estamos fazendo o cast do objeto para a classe Pessoa. Entretanto, esse objeto pode
ser nulo, sendo assim, verificamos essa condição antes de atribuirmos o texto ao
textMensagem.

É importante ressaltar que por utilizar o recurso de reflection do Java, o uso
da interface Serializable é bem mais lento que Parcelable, mas isso só é perceptível
quando utilizamos objetos maiores ou listas de objetos. Para se ter uma ideia,
enquanto um objeto simples de uma classe que implementa Serializable gasta 1
milissegundo para ser transferido, o que implementa Parcelable demora 0,08
milissegundo, ou seja, 12 vezes mais lento, mas estamos falando de uma
fração de milissegundo, e esse resultado pode variar bastante de acordo com
o aparelho. Se você estiver usando Serializable e começar a notar um leve
“engasgo” durante a transição das telas, então está na hora de mudar para
Parcelable; caso contrário, podemos usar Serializable sem problemas. Entretanto,
existem situações em que teremos que obrigatoriamente usar o Parcelable.

Dissemos que não é uma boa prática colocar textos diretamente no código e
estamos fazendo isso na Tela2Activity. Por isso, crie os seguintes textos no
res/values/strings.xml:
<string name="tela2_texto1">Nome: %1$s / Código: %2$d</string>
<string name="tela2_texto2">Nome: %1$s / Idade: %2$d</string>

Os textos contêm duas partes que serão variáveis, onde usamos %1$s e %2$d.
O número representa a ordem do parâmetro enquanto o “s” significa um texto



e o “d” um inteiro. Isso segue o mesmo padrão do String.format do Java (s =
String, d = int, f = float etc.). Alteraremos a Tela2Activity para usar esses textos:
val nome = intent.getStringExtra("nome")
val idade = intent.getIntExtra("idade", -1)
val cliente = intent.getParcelableExtra<Cliente>("cliente")
val pessoa = intent.getSerializableExtra("pessoa") as Pessoa?
textMensagem.text = if (cliente != null) {
    getString(R.string.tela2_texto1, cliente.nome, cliente.codigo)
} else if (pessoa != null) {
    getString(R.string.tela2_texto2, pessoa.nome, pessoa.idade)
} else {
    getString(R.string.tela2_texto2, nome, idade)
}

Perceba que utilizamos o método getString(int,Object...) passando o id da string
declarada no res/values/strings.xml e o valor que preencherá cada parte
variável da string deixando o código bem mais organizado.

Execute a aplicação e verifique que os três botões deverão passar os
parâmetros que devem ser exibidos corretamente na Tela2Activity.

Biblioteca: Parceler
Como mencionamos na seção anterior, é recomendável utilizar a interface
Parcelable para passar objetos entre activities. Entretanto, quando a classe
possui muitos atributos, implementar os métodos de serialização e
deserialização, além de ser tedioso e sujeito a erros, tendem a deixar a classe
enorme.

Para evitar esse incômodo, podemos utilizar a biblioteca Parceler
(https://github.com/johncarl81/parceler) que gera todo o código necessário
da interface Parcelable de forma simples e em tempo de compilação.

Para utilizá-la, basta fazer as seguintes mudanças no build.gradle:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'
android {
    // Nada muda aqui...
}
dependencies {
    ...
    implementation 'org.parceler:parceler-api:1.1.12'



    kapt 'org.parceler:parceler:1.1.12'
}

A primeira mudança nesse arquivo foi aplicar o plugin do kapt (Kotlin
Annotation Processing Tool), que deve sempre ser utilizado ao adicionar a
dependência de uma biblioteca que gere códigos em tempo de compilação,
normalmente baseado em anotações como é o caso do Parceler. Ele substitui
o annotationProcessor utilizado em projetos Android com Java.

Com essa biblioteca, nossa classe Cliente ficaria da seguinte forma:
import org.parceler.Parcel
@Parcel
class Cliente(var codigo: Int = 0, var nome: String = "")

É necessário apenas colocar a anotação @Parcel e pronto! Perceba que estão
sendo utilizados valores-padrão para os parâmetros do construtor. Com isso,
o compilador do Kotlin gera um construtor vazio que é usado pelo Parceler.
Construtores e métodos em Kotlin aceitam parâmetros com valores-padrão.
Isso diminui bastante a quantidade de sobrecarga (overload) de métodos.
Dessa forma podemos instanciar objetos Cliente assim:
val c1 = Cliente() // codigo = 0, nome = ""
val c2 = Cliente(10) // codigo = 10, nome = ""
val c3 = Cliente(12, "Glauber") // codigo = 12, nome = "Glauber"
val c4 = Cliente(nome="Glauber") // codigo = 0, nome "Glauber"

A constante c4 é particularmente interessante, pois podemos passar um
parâmetro específico baseado no seu nome.

Uma outra versão da nossa classe que faria o mesmo efeito seria a como
definida a seguir:
import org.parceler.Parcel
import org.parceler.ParcelConstructor
@Parcel
class Cliente(var codigo: Int, var nome: String) {
    @ParcelConstructor constructor() : this(0, "")
}

O construtor principal, que recebe parâmetros, não possui valores-padrão,
mas definimos um construtor vazio que está com anotação @ParcelConstrutor
indicando que esse construtor deve ser usado pelo Parceler. Perceba que ele
está chamando o construtor principal utilizando this.

Para utilizar a biblioteca para passar parâmetros, precisaremos fazer dois
pequenos ajustes:



// Na MainActivity
intent.putExtra("cliente", Parcels.wrap(cliente))
// Na Tela2Activity
val cliente = Parcels.unwrap<Cliente?>(intent.getParcelableExtra("cliente"))

Para enviar um objeto via Intent é necessário utilizar o método wrap(Parcel) da
classe Parcels, e para obter o objeto enviado deve-se usar o método
unwrap(Parcelable).

Parcelize
A biblioteca Kotlin Extensions já possui o recurso para converter o objeto em
Parcelable, bastando para isso apenas utilizar a anotação @Parcelize. Durante a
escrita deste livro, esse recurso ainda está em modo experimental, mas
funcionando muito bem. Para habilitá-lo adicione a seguinte linha no
build.gradle do módulo:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'
android {
    ...
    androidExtensions {
        experimental = true
    }
}

Certifique-se de que o plugin “android-extensions” foi aplicado e então os
recursos experimentais do Kotlin estarão habilitados. Feito isso, altere a
classe Pessoa para ficar da seguinte forma:
import android.os.Parcelable
import kotlinx.android.parcel.Parcelize
 
@Parcelize
data class Pessoa(val nome: String, val idade: Int) : Parcelable

Depois faça os seguintes ajustes para utilizá-la:
// Na MainActivity
intent. putExtra("pessoa", Pessoa("Nelson", 34))
// Na Tela2Activity
val pessoa = intent.getParcelableExtra<Pessoa>("pessoa")

Um último detalhe a ressaltar aqui é que não podemos adicionar uma
grande quantidade de dados a um Bundle. A documentação informa apenas que



temos um limite de alguns Kilobytes (KB). Caso esse valor seja excedido,
uma exceção será lançada (TransactionTooLargeException). Para esses casos, é
melhor utilizar alguma forma de persistência que mostraremos no Capítulo
10.

Ciclo de vida da Activity
Já comentamos aqui que o método onCreate(Bundle) é chamado quando a activity
é criada. Porém, o que acontece quando chamamos uma nova tela? E ao
clicarmos no botão Back ou no botão Home? E quando atendemos a uma
chamada telefônica, o que acontece com a aplicação?

Para entender o que acontece nesses cenários, devemos conhecer o ciclo de
vida de uma activity apresentado na Figura 3.5.

Ao iniciar a activity, o método onCreate(Bundle) é chamado, e logo a seguir os
métodos onStart() e onResume() são executados para então a Activity tornar-se
totalmente visível. Quando uma nova tela é invocada (pela sua aplicação ou
pelo próprio sistema, como em uma chamada telefônica), o onPause() da
activity atual é chamado, e então os métodos onCreate(Bundle), onStart() e
onResume() da nova tela são disparados. Por fim, o método onStop() da tela
anterior é chamado. Nesse momento, a primeira activity não ficará mais
visível para o usuário, enquanto a segunda estará sendo exibida.

Figura 3.5 – Ciclo de vida de uma Activity. Fonte:
developer.android.com.

Nessa segunda tela, ao pressionarmos o botão Back, o método onPause() da



segunda tela será chamado; em seguida, os métodos onRestart(), onStart() e
onResume() da primeira tela serão invocados, para daí então o onStop() e onDestroy()
da segunda tela são executados. Após a chamada do onDestroy(), a activity é
destruída, e se quisermos vê-la novamente teremos que disparar uma nova
Intent para ela. A Figura 3.6 ilustra esse fluxo.

Figura 3.6 – Sequência de chamadas aos métodos do ciclo de vida de
uma activity.

Pressionar a tecla Back terá o mesmo comportamento que chamar o método
finish() da activity. Já ao clicar no botão Home, apenas os métodos onPause() e
onStop() serão chamados. Nesse caso, ao voltarmos para a aplicação, o fluxo
continuará na seguinte sequência onRestart(), seguido do onStart() e onResume().

Faça um teste: implemente os métodos do ciclo de vida das duas activities
criadas anteriormente (MainActivity e Tela2Activity) e coloque um Log.i(String,String)
em cada um desses métodos como demonstrado a seguir:
override fun onStart() {
    super.onStart()
    Log.i("NGVL", "Tela1::onStart")
}
override fun onResume() {
    super.onResume()
    Log.i("NGVL", "Tela1::onResume")
}
// Coloque a seguir o onRestart(), onPause(), onStop() e onDestroy()



Ao executarmos a aplicação, teremos as seguintes mensagens no LogCat:
dominando.android.basico I/NGVL: Tela1::onCreate
dominando.android.basico I/NGVL: Tela1::onStart
dominando.android.basico I/NGVL: Tela1::onResume

Se abrirmos a Tela2Activity, teremos o seguinte resultado:
dominando.android.basico I/NGVL: Tela1::onPause
dominando.android.basico I/NGVL: Tela2::onCreate
dominando.android.basico I/NGVL: Tela2::onStart
dominando.android.basico I/NGVL: Tela2::onResume
dominando.android.basico I/NGVL: Tela1::onStop

E ao pressionar a tecla Back na Tela2Activity será gerado o seguinte log:
dominando.android.basico I/NGVL: Tela2::onPause
dominando.android.basico I/NGVL: Tela1::onRestart
dominando.android.basico I/NGVL: Tela1::onStart
dominando.android.basico I/NGVL: Tela1::onResume
dominando.android.basico I/NGVL: Tela2::onStop
dominando.android.basico I/NGVL: Tela2::onDestroy

Por fim, feche a MainActivity clicando na tecla Back novamente:
dominando.android.basico I/NGVL: Tela1::onPause
dominando.android.basico I/NGVL: Tela1::onStop
dominando.android.basico I/NGVL: Tela1::onDestroy

Um comportamento bastante comum durante a execução de uma activity é
pressionar a tecla de aplicativos recentes. Isso pode variar de acordo com a
versão do Android. Nas versões 4.0 e 4.1, por exemplo, nenhum método do
ciclo de vida é chamado. Já no Lollipop em diante, os métodos onPause() e
onStop() são chamados.

Esse mesmo comportamento também é apresentado quando o aplicativo
está em execução e o usuário clica no botão Home. Isso fará com que os
métodos onPause() e onStop() sejam invocados. Ao sair do aplicativo por meio da
tecla Home, e logo em seguida remover a aplicação da lista de aplicativos
recentes, a activity será destruída. Entretanto, não é garantido que o onDestroy()
seja chamado, por isso é recomendado que aloquemos os recursos no onStart()
ou onResume() e desaloquemos no onPause() ou onStop().

Enfim, existe uma série de combinações que podem ocorrer durante a
execução da aplicação. É importante que você conheça os métodos do ciclo
de vida para tratar o comportamento do seu aplicativo da melhor forma.



Tratando mudança de orientação
Por padrão, quando algumas configurações do aparelho mudam, a activity
atual é destruída e recriada automaticamente pelo sistema operacional. Nesses
casos, as informações que o usuário inseriu diretamente em um componente
visual, como o texto de um EditText ou um Checkbox são mantidas. Entretanto,
os atributos da activity e os dados que foram carregados dinamicamente serão
perdidos. Um exemplo muito comum de mudança de configuração é a
orientação de tela do aparelho, que pode estar em portrait (na vertical) ou
landscape (na horizontal). E para contornar esse problema temos três opções.

Opção 1: Forçar uma orientação
Na declaração da Activity, no AndroidManifest.xml, pode-se usar a
propriedade android:screenOrientation para manter a aplicação em uma orientação
fixa (portrait/landscape) e evitar que a tela seja recriada:
<activity
    android:name="MainActivity"
    android:screenOrientation="portrait" />

Ou por meio de código com a propriedade requestedOrientation da activity:
requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT

Exceto para jogos ou alguns casos isolados, essa opção não é a
recomendada, pois obriga o usuário a utilizar o aparelho em uma posição
específica. Isso não é bom, principalmente quando estamos falando em
tablets.

Opção 2: Tratar mudança de orientação manualmente
Para evitar que o Android destrua a activity ao girar o aparelho, pode-se
simplesmente informar no AndroidManifest.xml que, ao mudar a
configuração de orientação, ele não recrie a Activity:
<activity
   android:name=".MainActivity"
   android:configChanges="orientation|keyboardHidden|screenSize"/>

Com essa abordagem, o sistema operacional é avisado que a mudança de
orientação do aparelho será tratada manualmente. Então deve-se sobrescrever
o método onConfigurationChanged(Configuration) da classe Activity para detectar a
mudança de configuração e realizar as ações desejadas. O valor keyboardHidden



foi adicionado para tratar aparelhos que possuam teclados físicos, pois, nesse
tipo de aparelho, ao abrir o teclado físico, a activity será destruída.

Um outro detalhe importante ao utilizar esse tratamento é que, como a
activity não é recriada, nenhum método do ciclo de vida é chamado ao girar a
tela do aparelho.

Opção 3: Salvar o estado da Activity
Ambas as opções resolvem o problema da activity ser destruída quando o
aparelho é rotacionado. O detalhe é que existem outros cenários em que o
Android destrói a activity, como na mudança de idioma, ou quando a sua
aplicação está suspensa (pressionando Home por exemplo) e o sistema
precisa de memória. Então, independente das duas abordagens anteriores, a
boa prática é sempre salvar o estado da Activity. Para fazer isso, deve-se
sobrescrever o método onSaveInstanceState(Bundle) da activity e salvar as
informações necessárias. E para recuperá-las podemos sobrescrever o método
onRestoreInstanceState(Bundle), ou utilizar o próprio onCreate(Bundle).

Em relação ao ciclo de vida, o método onSaveInstanceState(Bundle) é invocado
depois o onPause() e imediatamente antes do onStop(), enquanto o método
onRestoreInstanceState(Bundle) é chamado após o onStart() e antes do onResume().

Orientação e o estado da Activity
Criaremos novo projeto para entendermos como salvar e recuperar o estado
de uma activity sem perder dados. O objetivo desse exemplo é preencher uma
lista com os valores digitados pelo usuário em uma caixa de texto.
Obviamente, os dados digitados pelo usuário devem ser mantidos após
girarmos o aparelho. Outro detalhe é que teremos layouts diferentes para a
aplicação em portrait e landscape.

Application Name Orientacao
Package Name dominando.android.orientacao
Activity Name MainActivity

Com o projeto criado, adicione as strings que serão utilizadas neste
exemplo ao arquivo res/values/strings.xml:
<resources>
    <string name="app_name">Orientação</string>
    <string name="label_name">Digite o nome</string>



    <string name="btn_add">Adicionar</string>
</resources>

Em seguida, deixe o arquivo res/layout/activity_main.xml conforme a
seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp">
    <TextView
        android:id="@+id/txtLabelName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/label_name"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <EditText
        android:id="@+id/edtName"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:ems="10"
        android:inputType="textPersonName"
        app:layout_constraintEnd_toStartOf="@+id/btnAdd"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/txtLabelName" />
    <Button
        android:id="@+id/btnAdd"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:onClick="btnAddClick"
        android:text="@string/btn_add"
        app:layout_constraintBottom_toBottomOf="@+id/edtName"
        app:layout_constraintEnd_toEndOf="parent" />
    <ListView
        android:id="@+id/lstNames"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:layout_marginTop="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/edtName" />
</androidx.constraintlayout.widget.ConstraintLayout>



No arquivo de layout, além do TextView, EditText e Button que já usamos nos
capítulos anteriores, estamos adicionando uma ListView, que é o componente
responsável por exibir uma lista de informações na tela. Outro detalhe
interessante aqui é a propriedade android:onClick que adicionamos no botão,
onde informamos o nome do método que será disparado ao clicarmos no
botão. Essa é outra forma de tratarmos eventos de clique1, mas esse método
deve seguir algumas regras: deve ser público, não retornar nada (ou seja,
retornar Unit), ter exatamente o mesmo nome definido na propriedade e
receber um objeto View como parâmetro.

Agora deixe a MainActivity conforme o código a seguir:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.view.View
import android.widget.ArrayAdapter
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    var names = arrayListOf<String>()
    var adapter : ArrayAdapter<String>? = null
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, names)
        lstNames.adapter = adapter
    }
    fun btnAddClick(view : View) {
        names.add(edtName.text.toString())
        edtName.text.clear()
        adapter?.notifyDataSetChanged()
    }
}

O atributo names do tipo ArrayList foi declarado e inicializado com o método
arrayListOf() que retorna uma lista vazia. No Kotlin existem as listas mutáveis e
imutáveis. Como o próprio nome diz, as mutáveis podem ser modificadas
após sua criação, ou seja, novos itens podem ser adicionados e os existentes
podem ser alterados ou removidos. Já as listas imutáveis devem ter seus
elementos definidos no momento da criação e não podem ser modificados. O
código a seguir demonstra como criar os dois tipos de listas, como acessar
seus elementos e remover um elemento de uma lista mutável:



val imutableList = listOf("Nelson","Glauber", "Marcia","Regina")
val secondName = imutableList[1] // Glauber
val mutableList = mutableListOf("Cicrano")
mutableList.add("Nelson")
mutableList.add("Glauber")
mutableList.removeAt(0) // Cicrano removido

Para preencher o componente ListView, devemos instanciar um ArrayAdapter
cujo trabalho é pegar elemento da lista e preencher um TextView que
representará uma linha da ListView. Esse TextView encontra-se no arquivo de
layout do próprio Android que está mapeado na constante
android.R.layout.simple_list_item_1. Tudo isso é feito nos bastidores, mas veremos
como criar listas customizadas no Capítulo 5.

Ao clicar no botão, o texto digitado no EditText é inserido na lista, e, em
seguida, o adapter é atualizado ao chamarmos o método notifyDataSetChanged() e
com isso a ListView é atualizada automaticamente.

O exemplo é bem simples, mas se executarmos o aplicativo e girarmos o
aparelho, os dados digitados que estavam sendo exibidos na ListView são
perdidos. Isso porque eles estão armazenados no atributo names, que é
destruído junto com a activity ao mudar a orientação.

Antes de resolver esse problema, criaremos um layout diferente para
quando a activity estiver em landscape. Mude o tipo de visualização do
projeto para Project, então clique com o botão direito sobre a pasta res e
selecionando a opção New > Directory. Nomeie a pasta como “layout-land”
e pressione OK.

Copie o arquivo de layout res/layout/activity_main.xml para essa nova pasta
e faça as seguintes mudanças:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp">
    <TextView
        android:id="@+id/txtLabelName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/label_name"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />



    <EditText
        android:id="@+id/edtName"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:ems="10"
        android:inputType="textPersonName"
        app:layout_constraintEnd_toStartOf="@+id/lstNames"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/txtLabelName" />
    <Button
        android:id="@+id/btnAdd"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:onClick="btnAddClick"
        android:text="@string/btn_add"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/edtName" />
    <ListView
        android:id="@+id/lstNames"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:layout_marginTop="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toEndOf="@+id/edtName"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

Note que, apesar de termos os mesmos componentes e apenas algumas
pequenas mudanças, para dividir a tela proporcionalmente usamos o conceito
de chains que vimos no capítulo anterior. A propriedade
layout_constraintEnd_toStartOf do EditText aponta para o ListView, que tem a
propriedade layout_constraintStart_toEndOf apontando para o EditText.

Agora salvaremos o estado da activity para não perdermos os dados quando
o aparelho for rotacionado. Para isso, implemente o método
onSaveInstanceState(Bundle) conforme a seguir:
override fun onSaveInstanceState(outState: Bundle?) {
    super.onSaveInstanceState(outState)
    outState?.putStringArrayList("names_list", names)
}

Como podemos observar, esse método utiliza um objeto da classe Bundle
para salvar o estado da tela (no caso, os itens da lista). Esse estado é passado
para o método onCreate(Bundle) por meio do parâmetro savedInstanceState, que



utilizaremos para restaurar esse valor. Sendo assim, no onCreate(Bundle), logo
após o setContentView, adicione o código a seguir:
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    if (savedInstanceState != null) {
        names = savedInstanceState.getStringArrayList("names_list")
    }
    adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, names)
    lstNames.adapter = adapter
}

Execute a aplicação e adicione alguns nomes e ela ficará semelhante à
Figura 3.7. Agora rotacione o aparelho e veja que os dados serão mantidos
conforme a Figura 3.8, mas com o arquivo de layout que colocamos na pasta
layout-land.

Figura 3.7 – Aplicação em portrait.



Figura 3.8 – Aplicação em landscape.
Um detalhe interessante é que o texto digitado no EditText não precisou ser

salvo, mas por qual motivo? A razão é que o Android salva automaticamente
o conteúdo de todos os componentes da tela que possuam um id associado e
que não foram modificados programaticamente, ou seja, via código. Esse é
exatamente o caso do ListView, que está sendo preenchido pelo ArrayAdapter que
definimos no onCreate(Bundle).

Esse exemplo demonstrou também como é possível ter, para a mesma tela,
layouts diferentes para as duas orientações. Perceba que isso só foi possível
porque temos o mesmo nome de arquivo em pastas diferentes e os mesmos
ids dos componentes em ambos os arquivos.

Outra forma de retermos informações da activity ao girarmos a tela do
aparelho é utilizando o método onRetainCustomNonConfigurationInstance para salvar
apenas um objeto, que poderá ser recuperado posteriormente utilizando a
propriedade lastCustomNonConfigurationInstance:
override fun onRetainCustomNonConfigurationInstance(): Any {
    return names
}
// No onCreate, logo abaixo do setContentView
if (lastCustomNonConfigurationInstance != null) {
    names = lastCustomNonConfigurationInstance as ArrayList<String>
}

Porém, quando usar um ou outro? O método
onRetainCustomNonConfigurationInstance() só pode retornar um único objeto e ele só
será mantido durante mudanças de configuração. Caso a activity esteja
pausada, e haja outras aplicações requisitando memória, o Android precisará
destruir a activity pausada, e nesse caso o objeto retido será removido da



memória. Já ao salvarmos o estado, o Android conseguirá recriar a tela
baseado no estado salvo.

Obtendo dados de outra activity
A criação de componentes reutilizáveis é uma boa prática no
desenvolvimento de software de uma maneira geral. No Android podemos
componentizar uma activity de modo que ela retorne determinada informação
para quem a chamar. Para isso, basta seguir estas três etapas:

• Iniciar a activity usando o método startActivityForResult(Intent,int), sendo o
primeiro parâmetro a Intent para a activity da qual se quer obter os dados e
o segundo um Int definido pelo desenvolvedor para identificar a requisição
realizada.

• Na activity que retornará a informação, deve-se chamar o método
setResult(int) ou setResult(int,Intent). A Intent conterá os dados a serem retornados,
enquanto o Int indica se a operação foi bem-sucedida ou não. Em caso
positivo, deve ser retornada a constante Activity.RESUL_OK; caso contrário,
Activity.RESULT_CANCELED.

• O último passo é tratar na activity de origem, os dados retornados pela
activity que foi chamada. Para isso, é preciso sobrescrever o método
onActivityResult(int, int, Intent), que é disparado assim que a segunda tela é
fechada. Esse método contém os seguintes parâmetros:
– O primeiro parâmetro, normalmente nomeado de requestCode, é o mesmo

Int que informamos no startActivityForResult(Intent,int). E com ele podemos
checar se o retorno está de acordo com a requisição que fizemos.

– O segundo parâmetro, normalmente nomeado de resultCode, indica o
resultado da requisição, que pode ser sucesso ou falha. Se o usuário
realmente fez a ação na outra tela o valor será RESULT_OK; caso
contrário, será RESULT_CANCELED.

– O último parâmetro, do tipo Intent, trará os dados retornados pela activity
que foi chamada.

Faremos um exemplo em que veremos na prática como funciona todo esse
processo. Teremos duas activities, na qual a primeira terá apenas um botão,
que ao ser clicado exibirá a segunda tela com uma lista dos Estados do
Nordeste do Brasil. Ao selecionar um item da lista, o nome do Estado



escolhido aparecerá no botão da primeira tela. Caso o botão seja clicado
novamente, o Estado selecionado anteriormente já deverá estar marcado.

Crie um novo projeto com os dados a seguir e depois edite o arquivo
res/values/strings.xml para adicionar algumas strings que utilizaremos no
projeto.

Application Name ActivityResult
Package Name dominando.android.activityresult
Activity Name MainActivity

<resources>
    <string name="app_name">ActivityResult</string>
    <string name="label_select_state">Selecione um estado</string>
    <string name="title_activity_selection">Lista de estados</string>
    <string-array name="states">
        <item>Alagoas</item>
        <item>Bahia</item>
        <item>Ceará</item>
        <item>Maranhão</item>
        <item>Paraíba</item>
        <item>Pernambuco</item>
        <item>Piauí</item>
        <item>Sergipe</item>
        <item>Rio Grande do Norte</item>
    </string-array>
</resources>

Nesse arquivo declaramos um <string-array> que será utilizado na tela de
listagem e acessado por meio do identificador R.array.states. Agora crie uma
nova activity chamada StatesListActivity desmarcando a opção para criar o
arquivo de layout. Em seguida, deixe-a conforme a seguir:
import android.app.Activity
import android.content.Intent
import android.os.Bundle
import android.widget.AbsListView
import android.widget.ArrayAdapter
import android.widget.ListView
import androidx.appcompat.app.AppCompatActivity
 
class StatesListActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val listView = ListView(this)
        setContentView(listView)



        val statesList = resources.getStringArray(R.array.states)
        val listAdapter = ArrayAdapter(this,
                android.R.layout.simple_list_item_single_choice, statesList)
        listView.adapter = listAdapter
        listView.choiceMode = AbsListView.CHOICE_MODE_SINGLE
        val state = intent.getStringExtra(EXTRA_STATE)
        if (state != null) {
            val position = statesList.indexOf(state)
            listView.setItemChecked(position, true)
        }
        listView.setOnItemClickListener { l, _, position, _ ->
            val result = l.getItemAtPosition(position) as String
            val it = Intent()
            it.putExtra(EXTRA_RESULT, result)
            setResult(Activity.RESULT_OK, it)
            finish()
        }
    }
    companion object {
        const val EXTRA_STATE = "estado"
        const val EXTRA_RESULT = "result"
    }
}

Instanciamos uma ListView em tempo de execução e a definimos como
conteúdo da Activity. Em seguida, carregamos o array de Estados que
declaramos no res/values/strings.xml usando a chamada
resources.getStringArray(Int), passado R.array.states. Em seguida, atribuímos o adapter
à ListView, mas diferentemente do que fizemos no exemplo anterior, estamos
usando o arquivo de layout android.R.layout.simple_list_item_single_choice,
que terá a aparência de um RadioButton, indicando que podemos selecionar
apenas uma opção.

Em seguida, lemos o parâmetro da Intent que chamou essa activity e
atribuímos à variável state. Caso esse parâmetro tenha sido passado,
procuramos a posição do Estado na lista e selecionamos posição
correspondente no ListView usando o método setItemChecked(int,boolean).

KOTLINxJAVA: Em instruções lambda, quando não necessitamos do parâmetro,
podemos omiti-lo. Entretanto, caso precisemos de qualquer parâmetro, devemos
declarar todos, mas os que não forem usados, podemos substituir por “_” como
fizemos no tratamento do evento do item da lista.



Para tratar o evento de clique nos itens da ListView e sabermos qual foi o
Estado selecionado, devemos chamar o método
setOnItemClickListener(OnItemClickListener). A interface OnItemClickListener possui
apenas um método onItemClick(AdapterView<?>, View, int, long), então podemos
utilizar um lambda. O primeiro parâmetro é a própria ListView, o segundo é a
View da linha que foi clicada, já o parâmetro do tipo Int nos informa qual a
posição da lista que foi clicada. Estamos usando o método getItemAtPosition(int)
para obter a String do Estado selecionado, mas poderíamos ter o mesmo
resultado simplesmente usando:
val result = states[position]

Depois disso, criamos um objeto Intent que apenas devolverá dados para a
tela anterior. Adicionamos o parâmetro EXTRA_RESULT com o nome do Estado
selecionado e chamamos o método setResult(int, Intent). Para finalizar, chamamos
o método finish() para encerrar a activity.

KOTLINxJAVA: Um companion object é um objeto compartilhado entre as instâncias
da classe. Então atributos e métodos de classes devem ser declarados nesse objeto,
similar aos modificados static do Java.

Por fim, declaramos um companion object no qual declaramos duas constantes
(EXTRA_STATE e EXTRA_RESULT) para nomearmos os parâmetros que serão
recebidos e enviados por essa activity2.

Feito isso, partiremos para a implementação da tela principal, começando
pelo arquivo de layout res/layout/activity_main.xml que deve ficar como a
seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <Button
        android:id="@+id/btnState"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/label_select_state"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />



</androidx.constraintlayout.widget.ConstraintLayout>
O arquivo anterior não tem nada que já não tenhamos visto, então passemos

agora para o código da MainActivity:
class MainActivity : AppCompatActivity() {
    var state: String? = null
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        btnState.setOnClickListener {
            val intent = Intent(this, StatesListActivity::class.java)
            intent.putExtra(StatesListActivity.EXTRA_STATE, state)
            startActivityForResult(intent, REQUEST_STATE)
        }
        if (savedInstanceState != null) {
            state = savedInstanceState.getString(EXTRA_STATE)
            if (state != null) {
                btnState.text = state
            }
        }
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (resultCode == Activity.RESULT_OK && requestCode == REQUEST_STATE) {
            state = data?.getStringExtra(StatesListActivity.EXTRA_RESULT)
            btnState.text = state
        }
    }
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putString(EXTRA_STATE, state)
    }
    companion object {
        private const val REQUEST_STATE = 1
        private const val EXTRA_STATE = "estado"
    }
}

No evento de clique do botão, criamos um objeto Intent, passando o Estado
atual como parâmetro (que inicialmente é null) usando a constante
EXTRA_STATE (declaradas no final da classe), depois chamamos a activity de
listagem com o método startActivityForResult(Intent, int).

No método onActivityResult(int,int,Intent), checamos se a operação foi realizada



com sucesso por meio do parâmetro resultCode. Em caso positivo,
armazenamos o Estado selecionado na tela de listagem no atributo state e
alteramos o texto do botão.

Para evitar que o texto do botão seja perdido ao girar o aparelho, salvamos
o valor do atributo estado no método onSaveInstanceState(Bundle) e inicializamos no
onCreate(Bundle). Em seguida, atribuímos esse valor ao texto do botão, mas
apenas se o Estado for diferente de null, uma vez que, se girarmos o aparelho
sem selecionar um Estado, o atributo ainda será nulo.

Para finalizar, certifique-se de que StatesListActivity esteja declarada no
AndroidManifest.xml e altere seu título como a seguir:
<activity android:name=".StatesListActivity"
    android:label="@string/label_select_state"/>

Execute a aplicação e ela ficará conforme a Figura 3.9. Ao clicar no botão,
a listagem de Estados será exibida, e após selecionar um Estado da lista, ele
aparecerá no botão da tela inicial. Se clicarmos no botão novamente, o Estado
selecionado anteriormente já deverá estar marcado. A Figura 3.10 mostra
nosso aplicativo em execução.

Figura 3.9 – Exemplo do startActivityForResult.



Figura 3.10 – Tela de listagem de Estados.
Já vimos dois exemplos em que chamamos activities que estão declaradas

em nosso projeto. E se quisermos chamar uma activity de outra aplicação?

Intents implícitas
As Intents podem ser classificadas em dois tipos: explícitas ou implícitas. Até
agora utilizamos apenas o primeiro tipo, em que informamos explicitamente a
activity que queremos executar. No entanto, um grande benefício da
plataforma Android são as Intents implícitas, que permitem a comunicação
com outras aplicações instaladas no aparelho. Com esse recurso, podemos
disparar uma Intent genérica e o sistema operacional tentará resolvê-la; e caso
haja uma aplicação para tratá-la, a activity correspondente será iniciada. Caso
contrário, será levantada uma exceção.

Veremos agora como usar algumas Intents nativas mais comuns do
Android.

Application Name Intents
Package Name dominando.android.intents
Activity Name MainActivity

Crie um novo projeto e adicione as strings a seguir ao arquivo
res/values/strings.xml:



<string-array name="intent_actions">
    <item>Browser</item>
    <item>Realizando uma chamada</item>
    <item>Mapa</item>
    <item>SMS</item>
    <item>Compartilhar</item>
    <item>Alarme</item>
    <item>Buscar na web</item>
    <item>Configurações</item>
    <item>Minha ação 1</item>
    <item>Minha ação 2</item>
    <item>Sair</item>
</string-array>
<string name="error_intent">Ação não suportada.</string>

Em seguida, deixe a MainActivity conforme a seguir:
import android.app.SearchManager
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.provider.AlarmClock
import android.provider.Settings
import android.widget.ArrayAdapter
import android.widget.ListView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import java.util.*
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val listView = ListView(this)
        setContentView(listView)
        val adapter = ArrayAdapter(this,
                android.R.layout.simple_list_item_1,
                resources.getStringArray(R.array.intent_actions))
        listView.adapter = adapter
        listView.setOnItemClickListener { _, _, position, _ ->
            openIntentAtPosition(position)
        }
    }
    private fun openIntentAtPosition(position: Int) {
        val uri: Uri?
        val intent: Intent?
        when (position) {



            0 -> { // Abrindo uma URL
                uri = Uri.parse("http://www.nglauber.com.br")
                intent = Intent(Intent.ACTION_VIEW, uri)
                openIntent(intent)
            }
            1 -> { // Realiza uma chamada
                uri = Uri.parse("tel:999887766")
                intent = Intent(Intent.ACTION_DIAL, uri)
                openIntent(intent)
            }
            2 -> { // Pesquisa uma posição do mapa
                // Seu emulador/aparelho deve ter o Google Maps
                uri = Uri.parse("geo:0,0?q=Rua+Amelia,Recife")
                intent = Intent(Intent.ACTION_VIEW, uri)
                openIntent(intent)
            }
            3 -> { // Abrindo o editor de SMS
                uri = Uri.parse("sms:12345")
                intent = Intent(Intent.ACTION_VIEW, uri)
                        .putExtra("sms_body", "Corpo do SMS")
                openIntent(intent)
            }
            4 -> { // Compartilhar
                intent = Intent()
                        .setAction(Intent.ACTION_SEND)
                        .putExtra(Intent.EXTRA_TEXT, "Compartilhando via Intent.")
                        .setType("text/plain")
                openIntent(intent)
            }
            5 -> { // Alarme
                intent = Intent(AlarmClock.ACTION_SET_ALARM)
                        .putExtra(AlarmClock.EXTRA_MESSAGE, "Estudar Android")
                        .putExtra(AlarmClock.EXTRA_HOUR, 19)
                        .putExtra(AlarmClock.EXTRA_MINUTES, 0)
                        .putExtra(AlarmClock.EXTRA_SKIP_UI, true)
                        .putExtra(AlarmClock.EXTRA_DAYS, arrayListOf(
                            Calendar.MONDAY,
                            Calendar.WEDNESDAY,
                            Calendar.FRIDAY)
                        )
                openIntent(intent)
            }
            6 -> { // Busca na web
                intent = Intent(Intent.ACTION_SEARCH)
                        .putExtra(SearchManager.QUERY, "Novatec")



                openIntent(intent)
            }
            7 -> { // Configurações do aparelho
                intent = Intent(Settings.ACTION_SETTINGS)
                openIntent(intent)
            }
            8 -> { // Ação customizada 1
                intent = Intent("dominando.android.CUSTOM_ACTION")
                openIntent(intent)
            }
            9 -> { // Ação customizada 2
                uri = Uri.parse("produto://Notebook/Slim")
                intent = Intent(Intent.ACTION_VIEW, uri)
                openIntent(intent)
            }
            else -> finish()
        }
    }
    private fun openIntent(intent: Intent) {
        if (intent.resolveActivity(packageManager) != null) {
            startActivity(intent)
        } else {
            Toast.makeText(this, R.string.error_intent, Toast.LENGTH_SHORT).show()
        }
    }
}

KOTLINxJAVA: No Kotlin a estrutura when substitui o switch do Java com a
vantagem de funcionar com tipos além de inteiros e enums. É possível utilizar o
when com strings ou intervalos:

when (x) {
    1, 2 -> print("x é 1 ou 2")
    in 3..10 -> print("x está no intervalo")
    !in 1..10 -> print("x está fora do intervalo")
    else -> print("nenhum dos casos anteriores ")
}

Conforme podemos observar na Figura 3.11, foi criada uma lista com várias
opções de intents, e quando o usuário clicar em qualquer uma delas, a
respectiva ação será disparada.



Figura 3.11 – Exemplo de intents nativas em execução.
Em várias dessas opções, para criar a Intent, utilizamos um objeto Uri

(Uniform Resource Indentifier) que aponta para algum recurso do aparelho
que queremos acessar. Em conjunto com a Uri, associamos uma ação que
queremos realizar sobre o recurso. Vejamos como o Android entende a
solicitação de abrir uma URL utilizando o browser: “O usuário está com a
intenção (Intent) de visualizar (ACTION_VIEW) o recurso (Uri)
http://www.nglauber.com.br”. Nesse momento, o sistema fará uma busca
para saber se existe alguma activity apta a tratar essa intenção, que no caso
será o browser.

No caso de discar um número, utilizamos a ação ACTION_DIAL e o schema tel:
seguido do número do telefone a ser discado. Note que aqui há uma diferença
entre “discar” (ACTION_DIAL) e “ligar” (ACTION_CALL). A primeira opção
apenas disca o número, enquanto a segunda efetivamente faz a ligação. Se
quisermos realmente realizar a chamada, devemos utilizar a ACTION_CALL e
declararmos no manifest dentro da tag <manifest> que nossa aplicação tem a
permissão CALL_PHONE conforme a seguir:
<uses-permission android:name="android.permission.CALL_PHONE"/>

Qualquer ação que possa onerar ou pôr em risco os dados do usuário deve



requisitar permissão para executá-la. Até o Lollipop, antes de fazer o
download do aplicativo no Google Play, uma tela como a da Figura 3.12 era
exibida para o usuário informando quais permissões a aplicação necessitava;
e, caso concordasse com essas permissões, a instalação era iniciada.

Figura 3.12 – Tela de permissões do aplicativo.
A partir do Android Marshmallow (API Level 23) o usuário pode

desabilitar a qualquer momento uma permissão que o aplicativo tenha. Dessa
forma, para utilizar a exemplo de realizar uma chamada em um aparelho ou
emulador com o Android 6.0 (ou superior), faça os seguintes ajustes:
class MainActivity : AppCompatActivity() {
    // Método onCreate não mudou
    private fun callNumber(){
        val uri = Uri.parse("tel:999887766")
        val intent = Intent(Intent.ACTION_CALL, uri)
        openIntent(intent)
    }
    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>,
            grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (grantResults.first() == PackageManager.PERMISSION_GRANTED) {
            callNumber()



        }
    }
    private fun openIntentAtPosition(position: Int) {
            ...
            1 -> { // Realiza uma chamada
                if (ActivityCompat.checkSelfPermission(this,
                        android.Manifest.permission.CALL_PHONE)
                            != PackageManager.PERMISSION_GRANTED){
                    ActivityCompat.requestPermissions(this,
                        arrayOf<String>(android.Manifest.permission.CALL_PHONE ), 0);
                } else {
                    callNumber();
                }
            }
     ...
    }
    // Método dispararIntent não mudou
}

Detalharemos mais adiante o conceito de permissões introduzido no
Android Marshmallow, mas por ora saiba que está com o método
checkSelfPermission(Activity, String) da classe ActivityCompat está sendo verificada se a
permissão de ligação foi concedida pelo usuário (por padrão, não é). Caso a
aplicação não tenha essa permissão, solicitamos que o usuário a conceda.
Nesse momento é exibida uma mensagem da Figura 3.13. Ao clicar em uma
das opções do dialog, o método onRequestPermissionsResult(int,String[],int[]) é
invocado, e nele verificamos se a permissão requisitada foi concedida. Em
caso positivo, realizamos a ligação.



Figura 3.13 – Requisitando a permissão de chamadas telefônicas.
Voltando ao nosso exemplo, para abrirmos a ação com o schema geo:,

devemos ter alguma aplicação de mapas instalada (como o Google Maps ou
Waze). Para indicar a localização desejada no mapa, é possível usar a latitude
e a longitude do local (onde estamos passando 0,0) ou informar o parâmetro ?
q= seguido do endereço.

Se houver mais uma aplicação que trate a mesma ação, o Android exibirá
uma mensagem similar à da Figura 3.14 questionando com qual aplicativo
desejamos concluir a ação.

Na ação de SMS, passamos o número do telefone para onde a mensagem
deve ser enviada usando o schema sms: e o parâmetro sms_body define o texto
da mensagem.

Para efetuar a ação de criar um alarme, passamos um título para ele, a hora
e o minuto em que deve ser disparado. Além desses parâmetros, é informado
se se deve criar o alarme sem a necessidade de confirmação do usuário; dessa
forma, apenas um Toast de confirmação será exibido. A partir do Android
KitKat, é possível também passar a lista dos dias da semana desejados que o
alarme dispare.

Para podermos criar alarmes, devemos adicionar uma permissão dentro da



tag <manifest> do arquivo AndroidManifest.xml:
<uses-permission android:name="com.android.alarm.permission.SET_ALARM"/>

Figura 3.14 – Escolha de qual aplicativo realizará a ação.
Além das Intents que chamam outros aplicativos, foram adicionadas à lista

duas ações customizadas – uma que responderá pela ação
ngvl.android.CUSTOM_ACTION e outra que responderá pela visualização de
recursos com o schema produto:. Para tratar essas ações, crie uma nova Activity
chamada ActionActivity e deixe-a conforme a seguir:
import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import kotlinx.android.synthetic.main.activity_action.*
 
class ActionActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_action)
        if (intent.action == Intent.ACTION_VIEW) {
            val uri = intent.data
            txtAction.text = getString(R.string.custom_action2, uri.toString(),
                uri.host, uri.path)
        } else if (intent.action == "dominando.android.CUSTOM_ACTION") {



            txtAction.text = getString(R.string.custom_action1)
        }
    }
}

Adicione os textos no res/values/strings.xml:
<string name="custom_action1">Ação customizada 1.</string>
<string name="custom_action2">Ação customizada 2.\nUri: %1$s\nHost:%2$s \nPath: %3$s</string>

No onCreate(Bundle) estamos utilizando o txtAction, então adicione esse TextView
ao arquivo res/layout/activity_action.xml e atribua este id ao componente.

Perceba que foi usada a propriedade action para saber a ação da Intent que
iniciou a activity e a propriedade data para obter o objeto Uri. Como fazemos
essa activity tratar as ações customizadas que disparamos? Abra o manifest e
deixe a declaração da ActionActivity como a seguir:
<activity android:name=".ActionActivity">
    <intent-filter>
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:scheme="produto"/>
    </intent-filter>
    <intent-filter>
        <action android:name="dominando.android.CUSTOM_ACTION"/>
        <category android:name="android.intent.category.DEFAULT"/>
    </intent-filter>
</activity>

As tags <intent-filter> informam ao Android que essa activity poderá ser
chamada de duas formas: a primeira por meio da ação android.intent.action.VIEW
com o schema produto:, ou, ainda, pela ação dominando.android.CUSTOM_ACTION
(poderia ser qualquer nome, mas, por convenção, é utilizado
pacote.da.app.ACAO). Note que, em ambos os casos, estamos usando a <category>,
que é uma String usada para complementar a ação. Para usar Intents
customizadas devemos usar a categoria android.intent.category.DEFAULT. Como
vimos no Capítulo 1, usamos a category android.intent.category.LAUNCHER para
indicar que a Activity aparecerá na tela de aplicativos (Launcher). Outra
categoria importante é a android.intent.category.BROWSEABLE, que permite que a
Activity seja executada a partir de um link do browser.

Com a declaração do <intent-filter>, qualquer aplicação poderá chamar nossa
Activity desde que saiba a ação customizada ou simplesmente queira
visualizar (ACTION_VIEW) um produto usando o schema produto:. Execute a



aplicação e veja se tudo funciona como esperado.
Caso não exista um aplicativo para tratar a ação disparada, um erro será

levantado e sua aplicação fechará. Para evitar que isso aconteça, no método
openIntent(Intent) é verificado se a Intent pode ser tratada usando o método
resolveActivity(PackageManager).

Display cutout
O Android Pie (API 28) dá suporte a telas edge-to-edge que são utilizadas em
aparelhos onde a parte frontal é completamente composta da tela, ou seja, não
possuem borda e têm áreas cortadas para a câmera dianteira e/ou para o alto-
falante e microfone do aparelho.

É possível testar esse recurso em qualquer aparelho ou emulador Android 9.
Para isso, basta acessar as configurações e, em seguida, selecionar Sistema >
Avançado > Opções do Desenvolvedor. Na seção Desenho, selecione a
opção Simular uma tela com corte e será exibida a tela da Figura 3.15.

Figura 3.15 – Opção para selecionar tela com corte.
A imagem exibe um exemplo de tela com dois cortes. É importante testar os

aplicativos nessas novas configurações, mas, por padrão, as APIs que
utilizaremos já fazem praticamente todo o trabalho para nós.



No próximo capítulo, veremos os principais componentes visuais do
Android e suas propriedades e eventos mais importantes.

1 Essa abordagem só funciona para eventos de clique. Para os demais eventos é necessário definir o
listener como mostrado anteriormente.

2 É uma boa prática criar constantes e evitar valores hard-coded.



CAPÍTULO 4
Componentes – Parte I

A maior parte do tempo gasto no desenvolvimento de um aplicativo mobile é
na elaboração da interface gráfica. Neste capítulo apresentaremos os
principais componentes de UI (User Interface) do Android, suas propriedades
e os eventos mais interessantes. Com esses componentes, podemos montar
aplicativos com interfaces ricas e atrativas para os usuários.

TextView
Nos capítulos anteriores, utilizamos bastante o componente TextView, que
permite exibir textos estáticos na aplicação. Exploraremos agora algumas
propriedades importantes deste componente.

Para colocarmos em prática o que apresentaremos aqui, crie um novo
projeto como descrito a seguir.

Application Name TextView
Package Name dominando.android.textview
Activity Name MainActivity

AutoLink
A propriedade android:autoLink habilita no texto a detecção automática de
números de telefone, URLs e endereços de email. Essas partes do texto se
tornarão links clicáveis e dispararão uma Intent implícita para o aplicativo
correspondente. Nessa propriedade, é possível atribuir os valores phone, map,
web, email, combiná-los usando o operador | (pipe), ou, ainda, usar a opção all
para habilitar todas as opções.

Para definir que um link abrirá uma Activity do próprio projeto, pode-se
utilizar a classe Linkify, que permite criar links baseados em uma expressão
regular:
textView.text = "Testando esse CEP 55555-4444"



val pattern = Pattern.compile("\\d{5}([\\-]\\d{4})?")
val scheme = "glauber://"
Linkify.addLinks(txt1, pattern, scheme)

Note que foi passado o esquema glauber://, então é necessário declarar alguma
activity que responda por chamadas a esse “protocolo”. Para isso, basta
adicionar uma <intent-filter> na declaração da activity no AndroidManifest.xml
como fizemos no exemplo de Intents do capítulo anterior:
<activity
    android:name="ActivityQueSeraChamada">
    <intent-filter>
        <action android:name="android.intent.action.VIEW"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:scheme="glauber"/>
    </intent-filter>
</activity>

Para obter o valor do link clicado, basta usar intent.dataString, que neste
exemplo seria glauber://55555-4444.

Ellipsize + MaxLines
A propriedade android:maxLines, como o próprio nome diz, limita a quantidade
de linhas de um TextView. Caso o texto exceda o tamanho especificado, pode-
se usar a propriedade android:ellipsize que colocará reticências no começo (start),
no meio (middle) ou no fim do texto (end). Um outro valor possível para essa
propriedade é o marquee, que fará com que o texto deslize horizontalmente se
estiver com foco e tiver apenas uma linha.

Espaçamento
É possível definir o espaçamento entre as linhas de um TextView utilizando as
propriedades android:lineSpacingMultiplier ou android:lineSpacingExtra. E a partir do
Android Lollipop, podemos utilizar a propriedade android:letterSpacing para
aumentar o espaçamento entre as letras.

Alterando a fonte
Por padrão, o Android possui apenas quatro fontes que podem ser utilizadas
nos componentes visuais: normal, serif, sans-serif e monospace. Para usar cada uma
delas, basta atribuir o valor desejado à propriedade android:typeface. Podemos
ainda alterar a propriedade android:textStyle para bold ou italic (negrito ou itálico);



já para o strike ou underline (riscado ou sublinhado) precisamos utilizar o
método setPaintFlags(int), passando o parâmetro Paint.STRIKE_THRU_TEXT_FLAG ou
Paint.UNDERLINE_TEXT_FLAG.

A partir da versão 4.0, o Android utiliza a fonte “Roboto” e suas variações.
E desde a versão 4.1 (API Level 16), é possível utilizar cada uma dessas
variações por meio da propriedade android:fontFamily em combinação com a
propriedade android:textStyle descrita anteriormente. Por exemplo, poderíamos
utilizar os valores sans-serif, sans-serif-light ou sans-serif-condensed.

Apesar de a Roboto ser a fonte recomendada, para utilizar outra fonte no
projeto basta adicionar o arquivo *.ttf (TrueType Font) à pasta res/font e
referenciá-la no arquivo de layout por meio da propriedade android:fontFamily ou
carregá-la dinamicamente utilizando a classe TypeFace.

Em nosso exemplo utilizaremos uma fonte customizada chamada “Frijole”,
que pode ser baixada gratuitamente em: https://fonts.google.com/?
selection.family=Frijole. Descompacte o arquivo baixado e copie o arquivo
*.ttf para a pasta res/font do projeto (se essa pasta não existir, crie-a).
Lembre-se de que não podemos ter recursos com letras maiúsculas, então
renomeie o arquivo para frijole_regular.ttf.

Autosize
Para melhor experiência do usuário, é recomendado utilizar tamanhos de
textos dinâmicos em vez de simplesmente cortá-lo como vimos na
propriedade ellipsize. O componente TextView possui o recurso de autosizing,
que pode ser habilitado simplesmente definindo a propriedade
app:autoSizeTextType para uniform (o padrão é none). Com isso, o texto se ajustará
ao tamanho do componente e ignorará o atributo android:textSize. Porém, para
utilizar texto com tamanho dinâmico não devemos utilizar wrap_content em
ambas as propriedades android:layout_width e android:layout_height, caso contrário,
podemos ter comportamentos inesperados.

O recurso de autosize permite ainda customizar alguns detalhes do
redimensionamento, tais como: o tamanho máximo e mínimo do texto por
meio da propriedade app:autoSizeMaxTextSize e app:autoSizeMinTextSize
respectivamente; de quantos em quantos pixels a fonte será redimensionada
utilizando a propriedade app:autoSizeStepGranularity; ou, ainda, a propriedade
app:autoSizePresetSizes informando um array com os tamanhos de fontes



permitidos.

Usando HTML
O TextView também suporta algumas tags HTML, bastando para isso atribuir o
seu texto usando o retorno do método Html.fromHtml(String). Porém, se o HTML
contiver tags <img> e desejarmos tratá-las, podemos usar Html.fromHtml(String,
ImageGetter, TagHandler), onde o segundo parâmetro é um objeto que será
responsável por tratar especificamente a tag <img> que carregará e exibirá a
imagem, enquanto o terceiro tratará outras tags que o TextView não consiga
interpretar.

Pondo em prática
Para vermos na prática todas as propriedades do TextView que comentamos,
altere o arquivo res/layout/activity_main.xml deixando-o como a seguir:
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp"
        tools:context="dominando.android.textview.MainActivity">
        <TextView
            android:id="@+id/txtAutoLink"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:autoLink="phone|email|web"
            android:text="Nelson Glauber
            \nEmail: nglaubervasc@gmail.com
            \nFone: 88990099
            \nURL: http://www.nglauber.com.br" />
        <TextView
            android:id="@+id/txtBigText"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:ellipsize="end"
            android:maxLines="2"
            android:text="Texto bem grande para não caber em apenas uma linha nem em duas"
            android:textSize="28sp" />



        <TextView
            android:id="@+id/txtMonospaced"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Fonte monospace"
            android:textSize="20sp"
            android:typeface="monospace" />
        <TextView
            android:id="@+id/txtFonte"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:fontFamily="@font/frijole_regular"
            android:text="Fonte customizada"
            android:textSize="20sp" />
        <TextView
            android:id="@+id/txtStrike"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Texto Strike"
            android:textSize="20sp" />
        <TextView
            android:id="@+id/txtHtml"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" />
        <TextView
            android:id="@+id/txtSpan"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:bufferType="spannable" />
    </LinearLayout>
</ScrollView>

No txtAutoLink usamos a propriedade android:autoLink para habilitar os links de
números de telefone, endereços de email e URLs. Na propriedade android:text,
usamos o caracter “\n” para realizar a quebra de linhas. O txtBigText utiliza a
propriedade android:maxLines limitando a quantidade de linhas para duas, e
android:ellipsize para colocar “…” ao final do texto.

Em seguida, o txtMonospaced está usando a propriedade android:typeface com o
valor monospace, que deixará todos os caracteres com a mesma largura. Outra
propriedade que foi utilizada nesse componente foi o android:textSize, onde
indicamos o tamanho do texto. É interessante observar que aqui usamos o
valor 20sp. Onde “sp” (ou “sip”) significa Scale Independent Pixels, que é a
unidade de medida recomendada para textos. Seu uso é indicado para que,



caso o usuário altere o tamanho da fonte do sistema, a aplicação reflita essa
preferência. Essa configuração normalmente encontra-se em Acessibilidade
> Tamanho da fonte e facilita a leitura de textos para usuários com
dificuldades de enxergar.

No componente txtFonte, estamos simplesmente utilizando a fonte que
adicionamos no diretório res/font. Já o txtStrike exibirá o texto riscado. O txtHtml
exibirá um HTML com figuras que teremos que carregar programaticamente.
Para que tudo isso funcione, deixe a MainActivity conforme a seguir:
import kotlinx.android.synthetic.main.activity_main.*
import android.graphics.BitmapFactory
import android.graphics.Paint
import android.graphics.drawable.BitmapDrawable
import android.os.Build
import android.os.Bundle
import android.text.Html
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
import java.io.IOException
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        txtStrike.paintFlags = txtStrike.paintFlags or Paint.STRIKE_THRU_TEXT_FLAG
        val htmlText = """
                    <html>
                    <body>Html em <b>Negrito</b>, <i>Itálico</i>
                    e <u>Sublinhado</u>.<br>
                    Mario: <img src='mario.png' /><br>
                    Yoshi: <img src='yoshi.png' /><br>
                    Um texto depois da imagem
                    </body>
                    </html>"""
        val imgGetter = Html.ImageGetter { source ->
            try {
                val bmp = BitmapFactory.decodeStream(assets.open(source))
                val drawable = BitmapDrawable(resources, bmp)
                drawable.setBounds(0, 0, bmp.width, bmp.height)
                drawable
            } catch (e : IOException) {
                e.printStackTrace()
                null
            }



        }
        txtHtml.text = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            Html.fromHtml(htmlText, Html.FROM_HTML_MODE_COMPACT, imgGetter, null)
        } else {
            Html.fromHtml(htmlText, imgGetter, null)
        }
    }
}

Um detalhe interessante desse exemplo é a declaração da constante htmlText.
No Kotlin, é possível definir strings com múltiplas linhas colocando-as entre
três aspas duplas (ex: """texto"""). O método trimIdent(), por sua vez, remove a
identação de cada linha do texto, caso necessário.

KOTLINxJAVA: Os operadores binários do Kotlin são: or, and, xor, inv (inversão de
bits), shl (shift left), shr (shift right) e ushr (unsigned shift right) que em Java são
respectivamente |, &, ^, ~, <<, >>, >>>.

Para o txtStrike, definimos que o texto será riscado utilizando a propriedade
paintFlags. No txtHtml, atribuímos o texto contendo diversas tags HTML,
inclusive com duas tags <img> que serão interpretadas pelo objeto ImageGetter
no método getDrawable(String) (que foi omitido pela instrução lambda que
utilizamos).

KOTLINxJAVA: A seguir, é listada uma versão mais completa e talvez mais
didática do imgGetter. Entretanto, a própria IDE nos sugere substituirmos por um
lambda. Perceba que o try/catch, assim como o if/else e o when, também retorna um
valor. Esse método recebe como parâmetro o valor da propriedade src da tag <img>
e, com ele, usamos a classe BitmapFactory para carregar a imagem da pasta
app/src/main/assets. Sendo assim, copie duas imagens para essa pasta (aqui estou
usando mario.png e yoshi.png) e execute a aplicação. Ela ficará conforme a
Figura 4.1:

val imgGetter = object : Html.ImageGetter {
    override fun getDrawable(source: String?): Drawable? {
        return try {
            val bmp = BitmapFactory.decodeStream(assets.open(source))
            val drawable = BitmapDrawable(resources, bmp)
            drawable.setBounds(0, 0, bmp.width, bmp.height)
            drawable
        } catch (e: IOException) {
            e.printStackTrace()



            null
        }
    }
}

Figura 4.1 – Exemplos de uso do TextView.
É importante enfatizar que as propriedades e métodos utilizados neste

exemplo podem ser aplicados a qualquer subclasse de TextView como Button e
EditText.

CharSequence e Spanned
CharSequence é a interface base que representa qualquer sequência de caracteres
no Android, inclusive a classe String implementa essa interface. Já a interface
Spanned herda de CharSequence e permite adicionar marcações a uma sequência
de caracteres.

Defina o método a seguir na MainActivity e chame-o no onCreate(Bundle). Nele,
temos alguns exemplos de subclasses de customizações que podem ser
realizadas no texto:
private fun initTextSpan() {
    val textTitle = " ExemploSpanned"
    val textLarge = "Texto grande"



    val textBold = "Negrito"
    val textUnderline = "Sublinhado"
    val textColored = "Cor do texto"
    val textBackground = "Com Background"
    val textClick = "Click here"
    val textUrl = "www.nglauber.com.br"
    val textComplete = """
            $textTitle
            $textLarge
            $textBold
            $textUnderline
            $textColored
            $textBackground
            $textClick
            $textUrl""".trimIndent()
 
    val spannableString = SpannableString(textComplete)
    spannableString.setSpan(
            RelativeSizeSpan(2f),
            textComplete.indexOf(textLarge),
            textComplete.indexOf(textLarge) + textLarge.length,
            Spanned.SPAN_INCLUSIVE_INCLUSIVE)
    spannableString.setSpan(
            StyleSpan(Typeface.BOLD),
            textComplete.indexOf(textBold),
            textComplete.indexOf(textBold) + textBold.length,
            Spanned.SPAN_INCLUSIVE_INCLUSIVE)
    spannableString.setSpan(
            UnderlineSpan(),
            textComplete.indexOf(textUnderline),
            textComplete.indexOf(textUnderline) + textUnderline.length,
            Spanned.SPAN_INCLUSIVE_INCLUSIVE)
    spannableString.setSpan(
            ForegroundColorSpan(Color.BLUE),
            textComplete.indexOf(textColored),
            textComplete.indexOf(textColored) + textColored.length,
            Spanned.SPAN_INCLUSIVE_INCLUSIVE)
    spannableString.setSpan(
            BackgroundColorSpan(Color.YELLOW),
            textComplete.indexOf(textBackground),
            textComplete.indexOf(textBackground) + textBackground.length,
            Spanned.SPAN_INCLUSIVE_INCLUSIVE)
    spannableString.setSpan(
            object: ClickableSpan() {
                override fun onClick(widget: View?) {



                    Toast.makeText(this@MainActivity, "Click!",
                            Toast.LENGTH_SHORT).show()
                }
            },
            textComplete.indexOf(textClick),
            textComplete.indexOf(textClick) + textClick.length,
            Spanned.SPAN_INCLUSIVE_INCLUSIVE)
    spannableString.setSpan(
            URLSpan("http://$textUrl"),
            textComplete.indexOf(textUrl),
            textComplete.indexOf(textUrl) + textUrl.length,
            Spanned.SPAN_INCLUSIVE_INCLUSIVE)
    spannableString.setSpan(
            ImageSpan(this, R.mipmap.ic_launcher),
            0, 1, Spanned.SPAN_INCLUSIVE_INCLUSIVE
    )
    txtSpan.movementMethod = LinkMovementMethod.getInstance() // Apenas para click
    txtSpan.text = spannableString
}

Cada parte da variável spannableString tem uma customização:
• RelativeSizeSpan aumenta o tamanho do texto N vezes de acordo com o

parâmetro passado no construtor.
• StyleSpan permite mudar o estilo do texto como negrito, itálico ou

monoespaçado.
• UnderlineSpan marca o texto como sublinhado.
• As classes ForegroundSpan e BackgroundSpan mudam a cor do texto e de

background, respectivamente.
• ClickableSpan define uma área clicável do texto.
• URLSpan é uma subclasse de ClickableSpan que abre um link para uma URL.
• ImageSpan permite adicionar uma imagem dentro do texto. Aqui passamos

uma imagem da pasta res/mipmap, mas poderíamos passar um Bitmap.
Em todos os casos, ao chamar o método setSpan(Object,int,int,int), além do Span,

passamos a posição inicial e final do texto que deve ser customizado. O
último parâmetro é uma flag que define como um texto adicionado
posteriormente no intervalo do span deve ser formatado.

Perceba que na definição do txtSpan foi atribuído o valor “spannable” à
propriedade android:bufferType para garantir que o valor retornado pela
propriedade text seja um Spannable (e não um simples CharSequence).



Execute a aplicação e verifique se todas as formatações atribuídas ao
TextView estão sendo aplicadas corretamente.

EditText
O EditText permite que o usuário digite valores na aplicação usando o teclado
virtual ou físico. Apesar de ser um componente bem simples, veremos
algumas propriedades importantes para facilitar a interação do usuário no
momento da digitação.

Hint
Apesar de ser uma propriedade do TextView, ela é mais útil no EditText. O
objetivo do android:hint é exibir uma dica para o usuário de como preencher o
campo, e esse texto será exibido enquanto o componente estiver vazio.
Quando o usuário digitar o primeiro caractere, esse texto desaparecerá
automaticamente.

Assim como todos os outros textos da aplicação, é recomendado que os
hints sejam definidos no res/values/strings.xml.

Input Type e Ime Options
Na propriedade android:inputType indicamos o tipo do teclado virtual mais
adequado para a digitação. Os principais valores estão listados na Tabela 4.1.

Tabela 4.1 – Principais valores do inputType
android:inputType Descrição
text Texto simples.
textCapCharacters Texto com todos os caracteres em maiúsculo.
textCapWords Primeira letra de cada palavra em maiúsculo.
textAutoCorrect Pode ser combinada com os anteriores para habilitar a função de autocorreção (sugestão) de

palavras.
textEmailAddress Usado para endereços de email.
textUri Usado para endereços de recursos como URLs.
textPassword Usado para campos de senha.
textPersonName Usado para nomes de pessoas.
number Permite a digitação apenas de números (sem sinal).
numberSigned Permite a digitação apenas de números (com sinal).
phone Para digitação de números de telefone.



É importante ressaltar que essa propriedade não valida o conteúdo do
EditText, serve apenas para facilitar a digitação disponibilizando o teclado
virtual com as teclas mais úteis para determinado tipo de dado. Se
escolhermos, por exemplo, textEmailAddress, os caracteres “@” e “.” estarão
disponíveis no teclado; já se escolhermos number, só serão exibidos números
(e, nesse caso, não será permitido digitar letras).

Outra propriedade bastante útil é a android:imeOptions, que indica qual será a
tecla de ação do teclado virtual que fica na parte inferior direita. O Android já
tem alguns valores predefinidos que estão listados na Tabela 4.2.

Tabela 4.2 – Principais valores do imeOptions
android:imeOptions Texto do botão
actionGo Go / Ir
actionSearch Search / Buscar
actionSend Send / Enviar
actionNext Next / Avançar
actionDone Done / Concluído
actionPrevious Prev. / Anterior

Para tratar a tecla de ação do teclado, utilizamos a interface
OnEditorActionListener e informamos no método
setOnEditorActionListener(OnEditorActionListener) do EditText qual objeto tratará esse
evento. Caso seja necessário utilizar um texto diferente do listado na Tabela
4.2, pode-se especificar o texto desejado na propriedade android:imeActionlabel.

Digits
A propriedade android:digits permite limitar os caracteres que podem serem
digitados em um EditText. Basta preencher essa propriedade com os caracteres
que se deseja habilitar.

Pondo em prática
Vamos fazer um exemplo que usa todas as propriedades que citamos nesta
seção. Crie um novo projeto e adicione os seguintes textos no arquivo
res/values/strings.xml.

Application Name EditText



Package Name dominando.android.edittext
Activity Name MainActivity

<string name="hint_name">Nome</string>
<string name="hint_email">Email</string>
<string name="hint_password">Senha</string>
<string name="hint_cep">C.E.P.</string>
<string name="msg_error_name">O campo nome é obrigatório</string>
<string name="msg_error_email">Email inválido</string>
<string name="msg_error_password">Senha inválida</string>
<string name="msg_success">Usuário %1$s com email %2$s cadastrado com sucesso!</string>

Agora deixe o arquivo de layout res/layout/activity_main.xml como a
seguir:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/linearLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">
    <EditText
        android:id="@+id/edtName"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="@string/hint_name"
        android:imeOptions="actionNext"
        android:inputType="textPersonName|textCapWords" />
    <EditText
        android:id="@+id/edtEmail"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="@string/hint_email"
        android:imeOptions="actionNext"
        android:inputType="textEmailAddress" />
    <EditText
        android:id="@+id/edtPassword"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="@string/hint_password"
        android:imeOptions="actionDone"
        android:inputType="textPassword" />
</LinearLayout>

No primeiro EditText usamos a combinação textPerson e textCapWords na



propriedade android:inputType, onde o primeiro dará sugestões de nomes logo
acima do teclado virtual e o segundo fará com que a primeira letra de cada
palavra fique maiúscula. O resultado ficará conforme a Figura 4.2.

Figura 4.2 – inputType textPersonName.
No campo de email, usamos o valor textEmailAddress na propriedade

android:inputType como mostra a Figura 4.3.



Figura 4.3 – inputType textEmailAddress.
Perceba que atribuímos nesses dois campos o valor actionNext à propriedade

android:imeOptions, que fará com que o próximo EditText receba o foco ao
pressionar a tecla de ação do teclado virtual. Por fim, para o EditText de senha,
usamos o valor actionDone para indicar o fim do processo de digitação. A tela
ficará como apresentado na Figura 4.4.



Figura 4.4 – inputType textPassword.
Vejamos agora como deve ficar a MainActivity:

import android.os.Bundle
import android.util.Patterns
import android.view.inputmethod.EditorInfo
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        edtPassword.setOnEditorActionListener { v, actionId, event ->
            if (v == edtPassword && EditorInfo.IME_ACTION_DONE == actionId) {
                registerUser()
            }
            false
        }
    }
    fun registerUser() {
        val name = edtName.text.toString()
        val email = edtEmail.text.toString()
        val password = edtPassword.text.toString()



        var isValid = true
        if (!Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
            edtEmail.error = getString(R.string.msg_error_email)
            isValid = false
        }
        if (password != "123") {
            edtPassword.error = getString(R.string.msg_error_password)
            isValid = false
        }
        if (isValid) {
            Toast.makeText(this,
                    getString(R.string.msg_success, name, email),
                    Toast.LENGTH_SHORT).show()
        }
    }
}

A senha é o último campo a ser preenchido, então atribuímos ao edtPassword o
tratamento do evento do teclado por meio do método setOnEditorActionListener
(OnEditoActionListener), passando como parâmetro um lambda que é uma
implementação da interface OnEditorActionlistener. Dessa forma, ao
pressionarmos o botão Done do teclado, o método
onEditorAction(TextView,int,KeyEvent) é chamado, então verificamos se quem
disparou o evento foi o EditText de senha e se a ação do teclado foi
EditorInfo.IME_ACTION_DONE1. Nesse caso, verificamos se email é
válido por meio da expressão regular da classe Patterns e se a senha é igual a
“123”. Caso algum dos testes falhe, a propriedade error do EditText foi
modificada para tenhamos um resultado similar ao da Figura 4.5.

O intuito desse exemplo é enfatizar a importância de facilitar a digitação de
informações por parte do usuário por meio de propriedades simples como
android:hint, android:inputType e android:imeOptions. Além disso, ressaltamos o
benefício de colocar um tratamento no próprio teclado, pois o fato de o
usuário já estar com ele aberto facilitará a execução de determinada ação.
Outro ponto que vimos foi como informar erros utilizando a propriedade error,
dando um aspecto visual mais interessante à aplicação, além de chamar a
atenção do usuário para os problemas que ocorreram.



Figura 4.5 – EditText com mensagem de erro.

Máscara no EditText
Um recurso muito comum em aplicações desktop e web é a utilização de
máscaras em caixas de texto. As máscaras colocam alguns caracteres entre os
dados digitados pelo usuário, e alguns exemplos comuns são CPF, CNPJ,
CEP, placa de veículos etc. O EditText não tem uma propriedade para isso, mas
podemos usar a interface TextWatcher que detecta quando o texto é alterado.

O exemplo a seguir mostra como implementar uma máscara para um campo
CEP, mas com poucos ajustes poderíamos adaptar este exemplo para outros
propósitos como CPF, CNPJ etc. Adicione mais uma caixa de texto no
exemplo anterior (antes do campo de senha) e coloque seu android:id como
@+id/edtCep:
<EditText
    android:id="@+id/edtCep"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:hint="@string/hint_cep"
    android:inputType="number"
    android:maxLength="10"/>



Agora coloque o código a seguir no onCreate(Bundle) da MainActivity:
edtCep.addTextChangedListener(object : TextWatcher {
    var isUpdating = false
    override fun afterTextChanged(s: Editable?) {
    }
    override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {
    }
    override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
        // Quando o texto é alterado o onTextChange é chamado
        // Essa flag evita a chamada infinita desse método
        if (isUpdating) {
            isUpdating = false
            return
        }
        // Ao apagar o texto, a máscara é removida, então o posicionamento
        // do cursor precisa saber se o texto atual tinha ou não máscara
        val hasMask = s.toString().indexOf('.') > -1 ||
                s.toString().indexOf('-') > -1
        // Remove o '.' e '-' da String
        var str = s.toString().filterNot { it == '.' || it == '-' }
        // Os parâmetros before e count dizem o tamanho
        // anterior e atual da String digitada, se count > before é
        // porque está digitando, caso contrário, está apagando
        if (count > before) {
            if (str.length > 5) {
                // Se tem mais de 5 caracteres (sem máscara) coloca o '.' e o '-'
                str = "${str.substring(0, 2)}.${str.substring(2, 5)}-${str.substring(5)}"
            } else if (str.length > 2) {
                // Se tem mais de 2, coloca só o ponto
                str = "${str.substring(0, 2)}.${str.substring(2)}"
            }
            // Seta a flag para evitar chamada infinita
            isUpdating = true
            // Seta o novo texto
            edtCep.setText(str)
            // Seta a posição do cursor
            edtCep.setSelection(edtCep.text?.length ?: 0)
        } else {
            isUpdating = true
            edtCep.setText(str)
            // Se estiver apagando posiciona o cursor no local correto
            // Isso trata a deleção dos caracteres da máscara
            edtCep.setSelection(Math.max(0,
                    Math.min(if (hasMask) start - before else start, str.length)))



        }
    }
})

KOTLINxJAVA: Para remover da string os caracteres “.” e “-“ invocamos o
método filterNot que utiliza um conceito chamado predicate, que nada mais é que
uma expressão para filtrar os caracteres indesejados. No nosso exemplo, temos
uma cadeia de caracteres, então nosso predicate recebe um caracter como
parâmetro e define se ele deve ser excluído ou não. Esse caractere é representado
na expressão lambda pelo it. O método filter realiza tarefa semelhante, mas
filtrando os caracteres desejados.

O código listado anteriormente está todo comentado, mas, em linhas gerais,
ele adiciona um listener para detectar a mudança do texto do EditText usando o
método addTextChangedListener(TextWatcher). Ao digitar algo no EditText, o método
onTextChanged(CharSequence, int, int, int) é chamado e então fazemos toda a lógica
para formatar o CEP, colocamos o “.” e o “-” no lugar apropriado,
dependendo do tamanho do texto. Para evitar a digitação de letras nesse
campo, usamos o valor number na propriedade android:inputType.

A biblioteca de componentes do Material Design
Com o lançamento do Android Lollipop (5.0), o Google apresentou o
Material Design, que tem por objetivo criar uma identidade visual unificada
para os aplicativos em qualquer tipo de dispositivo ou tamanho de tela. Ou
seja, o Material Design não é exclusivo do Android, e seus princípios podem
ser empregados também em aplicações web, desktop etc. Para utilizá-lo
corretamente é essencial ler o guia de boas práticas disponível no site
https://material.io.

No decorrer do livro mostraremos como aplicar alguns conceitos do
Material Design de acordo com a necessidade. Para trazer boa parte do que é
descrito nas guidelines para versões anteriores do Android, o Google criou
uma biblioteca de compatibilidade chamada Material Components for
Android. Para utilizá-la, basta adicionar a seguinte dependência no
build.gradle:
dependencies {
    ...
    implementation 'com.google.android.material:material:1.0.0'



}
Feito isso, utilizaremos a biblioteca do material design no nosso exemplo.

TextInputLayout
O componente TextInputLayout contém um EditText e adiciona algumas
características especificadas no guia do Material Design. Por exemplo,
quando o EditText recebe o foco, o texto do hint será animado e posicionado
logo acima do conteúdo da caixa de texto. Ao perder o foco, caso o texto não
tenha sido preenchido, a animação inversa será realizada. Outra vantagem é
utilizar as propriedades errorEnabled e error, que também receberão uma
animação automaticamente.

Para isso, no arquivo res/layout/activity_main.xml envolva o EditText com
um TextInputLayout, como a seguir, e substitua cada EditText por um
TextInpuEditText:
<com.google.android.material.textfield.TextInputLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content">
    <com.google.android.material.textfield.TextInputEditText … />
</com.google.android.material.textfield.TextInputLayout>

Faça isso com as quatro caixas de texto do exemplo anterior e, em seguida,
execute a aplicação. Quando cada EditText receber foco, o hint fará uma
animação para aparecer na parte superior, como mostra a Figura 4.6.



Figura 4.6 – EditText com TextInputLayout.
O componente TextInputLayout possui algumas propriedades interessantes

como a app:counterEnabled que exibirá a quantidade de caracteres digitados no
EditText, e definindo a propriedade app:counterMaxLength a quantidade máxima de
caracteres também será exibida. Para os campos de senha, uma propriedade
que pode ser bem útil é a app:passwordToggleEnabled, que permite exibir ou ocultar
a senha digitada. A Figura 4.7 mostra os TextInputLayout de CEP e senha com
essas propriedades habilitadas.



Figura 4.7 – Propriedades counterEnabled e passwordToggleEnabled do
TextInputLayout.

Para que as mensagens de erro do EditText sejam exibidas no padrão do
Material design, faça o seguinte ajuste no método:
private fun registerUser() {
    val name = edtName.text.toString()
    val email = edtEmail.text.toString()
    val password = edtPassword.text.toString()
    var isValid = true
    if (!Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
        tilEmail.error = getString(R.string.msg_error_email)
        isValid = false
    } else {
        tilEmail.error = null
    }
    if (password != "123") {
        tilPassword.error = getString(R.string.msg_error_password)
        isValid = false
    } else {
        tilPassword.error = null
    }
    if (isValid) {
        Toast.makeText(this,



                getString(R.string.msg_success, name, email),
                Toast.LENGTH_SHORT).show()
    }
}

Perceba que está sendo usada a propriedade error do TextInputLayout, por isso,
no res/layout/activity_main.xml atribua um id aos TextInputLayout do edtEmail e
edtPassword.
<com.google.android.material.textfield.TextInputLayout
    android:id="@+id/tilEmail"...>
    <com.google.android.material.textfield.TextInputEditText
        android:id="@+id/edtEmail" ...>
    ...
<com.google.android.material.textfield.TextInputLayout
    android:id="@+id/tilPassword" ...>
        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/edtPassword" ...>

Execute a aplicação e digite um email e senha inválidos e o resultado ficará
conforme a Figura 4.8.

Figura 4.8 – Exibindo mensagens de erro com o TextInputLayout.

Mais componentes



Nesta seção apresentaremos mais alguns componentes em um único exemplo:
CheckBox, Switch, ToggleButton, SeekBar, Spinner e RadioGroup.

Application Name Componentes
Package Name dominando.android.componentes
Activity Name MainActivity

Crie um novo projeto e adicione as seguintes strings no
res/values/strings.xml:
<resources>
    <string name="app_name">Componentes</string>
    <string name="text_on">Ligado</string>
    <string name="text_off">Desligado</string>
    <string name="text_enabled">Habilitado</string>
    <string name="text_disabled">Desabilitado</string>
    <string name="text_option1">Opção 1</string>
    <string name="text_option2">Opção 2</string>
    <string name="text_option3">Opção 3</string>
    <string name="btn_show_values">Ver valores</string>
    <string name="msg_result">%1$s\nProgress: %2$d\nNome: %3$s\nOpção: %4$s</string>
</resources>

Em seguida, deixe o arquivo de layout res/layout/activity_main.xml
conforme a seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp"
    tools:context="dominando.android.componentes.MainActivity">
    <CheckBox
        android:id="@+id/chkEnabled"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/text_enabled" />
    <ToggleButton
        android:id="@+id/tgbEnabled"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textOff="@string/text_off"
        android:textOn="@string/text_on" />
    <Switch
        android:id="@+id/swtEnabled"
        android:layout_width="wrap_content"



        android:layout_height="wrap_content"
        android:checked="true"
        android:text="@string/text_on"
        android:textOff="@string/text_off"
        android:textOn="@string/text_on" />
    <SeekBar
        android:id="@+id/skbValue"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:max="30" />
    <TextView
        android:id="@+id/txtValue"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="0" />
    <Spinner
        android:id="@+id/spnNames"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:spinnerMode="dialog" />
    <RadioGroup
        android:id="@+id/rgOptions"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">
        <RadioButton
            android:id="@+id/rbOption1"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/text_option1" />
        <RadioButton
            android:id="@+id/rbOption2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:checked="true"
            android:text="@string/text_option2" />
        <RadioButton
            android:id="@+id/rbOption3"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/text_option3" />
    </RadioGroup>
    <Button
        android:id="@+id/btnShowValues"
        android:layout_width="wrap_content"



        android:layout_height="wrap_content"
        android:layout_gravity="end"
        android:drawableStart="@drawable/ic_check"
        android:drawablePadding="8dp"
        android:text="@string/btn_show_values" />
</LinearLayout>

Os três primeiros componentes que adicionamos ao LinearLayout têm
comportamentos bem semelhantes. CheckBox, Switch e ToggleButton indicam algo
mutuamente exclusivo (ligado/desligado ou habilitado/desabilitado, por
exemplo). O CheckBox exibe apenas um texto ao lado do botão definido pela
propriedade android:text. No ToggleButton podemos utilizar as propriedades
android:textOn e android:textOff para definir um texto a ser exibido dentro do
componente para quando ele estiver marcado e outro para quando estiver
desmarcado, respectivamente. O Switch suporta as propriedades android:text,
android:textOn e android:textOff.

Logo em seguida temos uma SeekBar, que é uma barra horizontal na qual o
usuário pode arrastar o seletor para modificar seu valor. Um exemplo típico
do uso desse componente é o ajuste do volume do aparelho. Alteramos a
propriedade android:max, que é o valor máximo que o usuário poderá selecionar.

Abaixo dele está um TextView, que recebe o valor do SeekBar enquanto ele
estiver sendo alterado.

Outro componente que adicionamos foi o Spinner, que é bem similar ao
combo-box de aplicações desktop. Uma propriedade interessante desse
componente é a android:spinnerMode, que define como os itens do Spinner serão
exibidos e que pode receber o valor “dialog” ou “dropdown”.

Depois do Spinner, temos um RadioGroup que agrupa três RadioButton, onde
marcamos o segundo como checado (android:checked) por padrão.

O botão tem dois detalhes interessantes: a propriedade android:layout_gravity
que alinha o botão dentro do RadioGroup; e a propriedade android:drawableStart que
adiciona uma imagem à esquerda do texto do botão. Podemos associar uma
imagem à esquerda, à direita, na parte superior ou inferior de qualquer
TextView, consequentemente de um Button ou EditText, bastando para isso usar,
respectivamente, as propriedades android:drawableStart, android:drawableEnd,
android:drawableTop e android:drawableBottom.

Estamos utilizando a imagem “ic_check” que não existe no projeto.
Adicione essa imagem clicando com o botão direito na pasta res/drawable, e,



em seguida, selecionando New > Vector Asset e será exibida a janela da
Figura 4.9. Mantenha a opção Clip Art selecionada e clique no botão Clip
Art. Será apresentada uma lista com todos os ícones disponíveis no Android
Studio. Procure pelo ícone “Check”, selecione-o e clique em OK. No campo
name, preencha com “ic_check”, em seguida, pressione o botão Next e
finalmente clique em Finish.

Figura 4.9 – Criando um novo ícone no Android Studio.
Você perceberá que será criado um arquivo XML. Como assim? Uma

imagem é um XML? O Android utiliza imagens vetoriais por meio de
“Vector Drawables”. Detalharemos esse assunto no Capítulo 30, mas por
agora saiba que esse é o padrão recomendado para ícones utilizados dentro da
aplicação, pois eles se adéquam à diversidade de tamanhos e densidades de
tela.

Adicione agora o comportamento da tela deixando a MainActivity conforme a
listagem a seguir:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.ArrayAdapter
import android.widget.RadioButton



import android.widget.SeekBar
import android.widget.Toast
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        initSpinner()
        initSeekbar()
        initSwitch()
        // Atribuindo programaticamente os valores-padrão
        chkEnabled.isChecked = true
        skbValue.progress = 20
        spnNames.setSelection(2)
        rgOptions.check(R.id.rbOption2)
        btnShowValues.setOnClickListener { showValues() }
    }
    private fun initSpinner() {
        val names = arrayOf("Eric", "Diana", "Presto", "Hank", "Sheila", "Bob")
        val adapter = ArrayAdapter(
                this, android.R.layout.simple_spinner_item, names)
        adapter.setDropDownViewResource(
                android.R.layout.simple_spinner_dropdown_item)
        spnNames.adapter = adapter
    }
    private fun initSeekbar() {
        skbValue.setOnSeekBarChangeListener(
                object : SeekBar.OnSeekBarChangeListener {
                    override fun onProgressChanged(seekBar: SeekBar, i: Int, b: Boolean) {
                        txtValue.text = i.toString()
                    }
                    override fun onStartTrackingTouch(seekBar: SeekBar) {}
                    override fun onStopTrackingTouch(seekBar: SeekBar) {}
                })
    }
    private fun initSwitch() {
        swtEnabled.setOnCheckedChangeListener { compoundButton, b ->
            chkEnabled.isEnabled = compoundButton.isChecked
            tgbEnabled.isEnabled = b
        }
    }
    private fun showValues() {
        val idSelectedRadio = rgOptions.checkedRadioButtonId
        val radio = findViewById<RadioButton>(idSelectedRadio)



        val enabledText = getString(
            if (chkEnabled.isChecked) R.string.text_enabled
            else R.string.text_disabled
        )
        val message = getString(R.string.msg_result,
            enabledText,
            skbValue.progress,
            spnNames.selectedItem,
            radio.text.toString()
        )
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }
}

No método initSpinner() preenchemos os itens do Spinner usando um ArrayAdapter.
Já usamos essa classe no Capítulo 2 quando precisávamos preencher uma
ListView. Aqui usamos a mesma ideia, a diferença é o arquivo de layout que
usamos (android.R.layout.simple_spiner_item), que também é do Android,
mas é específico para o Spinner. Outra mudança é que estamos chamando o
método setDropDownViewResource(int), por meio do qual informamos o arquivo de
layout que será usado quando o Spinner estiver fechado, ou seja, quando não
estiver exibindo a lista de valores.

Em initSeekbar() atribuímos um listener para quando o valor da SeekBar for
alterado. Para isso, usamos a interface OnSeekBarChangeListener, que contém os
métodos onStartTrackingTouch(SeekBar) e onStopTrackingTouch(SeekBar), por meio dos
quais conseguimos saber quando o usuário iniciou ou parou de arrastar o
controle do componente. O que nos interessa aqui é o onProgressChanged(SeekBar,
int, boolean), onde o segundo parâmetro é o valor atual do Seekbar. Nesse método
simplesmente atribuímos esse valor ao texto do TextView.

No método initSwitch() definimos um listener para sabermos quando o Switch
mudou de estado usando a interface OnCheckedChangeListener. No método
onCheckedChanged (CompoundButton,boolean) (omitido pela expressão lambda)
estamos habilitando ou desabilitando o toggleButton e o checkBox conforme o
estado do switchButton. Podemos observar que o primeiro parâmetro é do tipo
CompoundButton, que é a superclasse de CheckBox, Switch e ToggleButton. Dessa
forma, podemos utilizá-la para qualquer um desses componentes.

Após configurar o Spinner, o Switch e o SeekBar, atribuímos programaticamente
os valores iniciais aos componentes: para o CheckBox, usamos a propriedade
isChecked informando se ele deve ficar checado ou não; no SeekBar definimos o



valor corrente usando a propriedade progress; para o Spinner informamos a
posição selecionada usando o método setSelection(int); e para o RadioGroup,
informamos o id do RadioButton selecionado usando check(int).

Ao clicarmos no botão, será chamado o método showValues() e nele obtemos
os valores dos componentes para exibirmos em um Toast. Para sabermos se o
CheckBox está marcado, usamos a propriedade isChecked. Para obter o valor atual
do Seekbar é usada a propriedade progress. Já para pegarmos o texto do item
selecionado do RadioGroup, obtemos primeiro o id do RadioButton por meio da
propriedade checkedRadioButtonId, depois recuperamos o RadioButton com o
findViewById(int), para enfim pegar o texto do RadioButton. Por fim, para pegarmos
o item selecionado do Spinner, usamos a propriedade selectedItem.

A Figura 4.10 mostra a aplicação em execução.

Figura 4.10 – Aplicação de componentes em execução.
Neste capítulo vimos diversos componentes de entrada de dados que podem

ser utilizados para criar a interface gráfica de um aplicativo. No próximo
capítulo veremos como utilizar componentes de listagem.

1 Se estiver utilizando o Genymotion, habilite a opção “Use virtual keyboard for typing” nas
configurações do emulador.



CAPÍTULO 5
Componentes – Parte II

O Android possui vários componentes visuais que exibem uma lista de
informações. Até agora, usamos dois desses componentes em nossos
projetos: o ListView e o Spinner. Neste capítulo estudaremos outros componentes
de listagem e veremos como customizá-los utilizando os adapters.

ListView e Adapter customizados
Para preencher componentes que exibem listas de dados utilizamos um
Adapter, que tem o papel de criar uma representação visual (ou seja, uma View)
para cada objeto da lista. Até agora usamos diretamente o ArrayAdapter, que
retornava, para cada objeto da lista, um TextView preenchido com o toString() do
objeto. Como usamos apenas listas de Strings, exibimos apenas listas de
textos simples.

Imagine que você queira exibir uma lista de objetos da classe Vehicle
(veículo) onde cada item da lista teria vários TextView (um para cada atributo
do veículo) e uma ImageView para exibir a logomarca da fabricante do veículo.
Para isso, é necessário criar um Adapter personalizado que exiba cada
informação do veículo em sua respectiva View. Por isso se faz necessário
entender como funciona esse processo internamente.

O componente (a ListView, por exemplo) pergunta ao adapter quantas linhas
ele terá que exibir. Então, para cada objeto da lista, o componente solicita ao
Adapter sua representação visual baseado no índice da lista. Então o Adapter
retornará uma View preenchida com as informações do objeto. A Figura 5.1
demonstra essa interação.

Para criar uma lista customizada é preciso criar uma classe que herde de
BaseAdapter, implementar alguns métodos e usar uma instância dessa classe em
algum componente. Para exemplificar esses conceitos, criaremos uma
listagem de carros em que cada carro tenha os atributos modelo, ano,



fabricante e combustível.

Figura 5.1 – Interação entre ListView e Adapter.
Crie um novo projeto e adicione a classe Vehicle conforme a seguir.

Application Name Adapter
Package Name dominando.android.adapter
Activity Name MainActivity

data class Vehicle(
        var model: String,
        var year: Int,
        var manufacturer: Int, // 0=VW;1=GM;2=Fiat;3=Ford
        var gasoline: Boolean,
        var ethanol: Boolean
)

Frequentemente classes são criadas apenas para armazenar dados, em
Kotlin essas são data classes. Perceba que os parâmetros do construtor usam
var (se fossem só leitura, usaríamos val), indicando que, na verdade, eles são
atributos da classe, assim a declaração fica bem sucinta. Porém, os data
classes possuem algumas restrições, entre elas estão: não podem ser
abstratas; não se podem criar subclasses de uma data class; não podem ser
internas (inner class). Além disso, o construtor precisa ter ao menos um
atributo (var ou val).

Agora crie o arquivo de layout que representará cada linha a ser exibida na
ListView. Adicione o arquivo res/layout/item_vehicle.xml e deixe-o conforme a
seguir:
<androidx.constraintlayout.widget.ConstraintLayout



    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="8dp">
    <ImageView
        android:id="@+id/imgLogo"
        android:layout_width="72dp"
        android:layout_height="75dp"
        android:src="@mipmap/ic_launcher"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <TextView
        android:id="@+id/txtModel"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="8dp"
        android:textSize="18sp"
        app:layout_constraintStart_toEndOf="@+id/imgLogo"
        app:layout_constraintTop_toTopOf="@+id/imgLogo"
        tools:text="Modelo" />
    <TextView
        android:id="@+id/txtYear"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintStart_toStartOf="@+id/txtModel"
        app:layout_constraintTop_toBottomOf="@+id/txtModel"
        tools:text="2017" />
    <TextView
        android:id="@+id/txtFuel"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="@+id/txtYear"
        tools:text="Gasolina/Etanol" />
</androidx.constraintlayout.widget.ConstraintLayout>

Este arquivo de layout contém uma ImageView que exibirá a logomarca do
fabricante e três TextView que exibirão as demais informações. O próximo
passo é criar o adapter, então crie a classe chamada VehicleAdapter e deixe-a
conforme a seguir:
import android.content.Context
import android.content.res.TypedArray
import android.view.LayoutInflater



import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import androidx.annotation.StringRes
import kotlinx.android.synthetic.main.item_vehicle.view.*
 
class VehicleAdapter(
                     private val ctx: Context,
                     private val vehicles: List<Vehicle>) : BaseAdapter() {
    private val logos: TypedArray by lazy {
        ctx.resources.obtainTypedArray(R.array.logos)
    }
 
    override fun getCount(): Int = vehicles.size
 
    override fun getItem(position: Int) = vehicles[position]
 
    override fun getItemId(position: Int) = position.toLong()
 
    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
        // 1 passo
        val vehicle = vehicles[position]
        // 2 passo
        val row = LayoutInflater.from(ctx).inflate(R.layout.item_vehicle, parent, false)
        // 3 passo
        row.imgLogo.setImageDrawable(logos.getDrawable(vehicle.manufacturer))
        row.txtModel.text = vehicle.model
        row.txtYear.text = vehicle.year.toString()
        row.txtFuel.text = ctx.getString(getFuel(vehicle))
        // 4 passo
        return row
    }
    @StringRes
    private fun getFuel(vehicle : Vehicle) : Int =
            if (vehicle.gasoline && vehicle.ethanol) R.string.fuel_flex
            else if (vehicle.gasoline) R.string.fuel_gasoline
            else if (vehicle.ethanol) R.string.fuel_ethanol
            else R.string.fuel_invalid
}

O Kotlin possui um conceito de delegates onde passamos a
responsabilidade da criação do objeto para outra entidade do seu código.
Nesse exemplo utilizamos o delegate lazy que só iniciará o objeto quando
precisarmos dele a primeira vez. É importante notar que o lazy só pode ser
utilizado por constantes, ou seja, atributos val. Outro detalhe curioso do Kotlin



neste código é que métodos que possuem apenas uma linha podem ser
reduzidos como fun sum(a: Int, b: Int) = a + b como essa função apenas realiza a
ação de somar dois números, podemos simplesmente utilizar essa sintaxe
mais curta para realizar o retorno da função.

A classe VehicleAdapter herda de BaseAdapter e tem dois atributos que são
inicializados no construtor da classe. O atributo da classe Context será utilizado
para carregarmos o arquivo de layout, textos e as imagens dos logos dos
fabricantes, pois com ela temos acesso aos recursos da aplicação. E o outro
atributo dessa classe é a lista de objetos Vehicle que queremos exibir.

Ao criar um adapter, é necessário implementar quatro métodos. O getCount()
retorna a quantidade total de linhas que a ListView deverá exibir, e, já que
estamos exibindo uma lista de veículos, retornamos o tamanho da lista de
objetos. Por meio do getItem(int) podemos acessar um objeto da lista de
veículos com base na sua posição. Sendo assim, apenas retornamos o objeto
da lista.

No método getItemId(int) devemos retornar um identificador único de um
objeto da lista. Se a classe Vehicle tivesse um atributo “código” ou “id”, eles
seriam uma boa opção para serem retornados, mas como não temos,
retornamos simplesmente à posição do objeto na lista.

O método getView(int,View,ViewGroup) é o mais importante, pois é nele que será
gerada a View que representará cada item da lista. Isso é feito em quatro
etapas:

• inicialmente é obtido o objeto Vehicle a partir da lista de objetos usando a
posição recebida no parâmetro position;

• em seguida, o arquivo de layout é carregado;
• então preenchemos os componentes visuais com os atributos do objeto

Vehicle;
• por fim, retornamos o layout devidamente preenchido com as informações

do objeto.
Para carregar o arquivo de layout, utilizamos a classe LayoutInflater, que ao

chamar o método inflate(int,ViewGroup) retorna o elemento-raiz do mesmo, que
em nosso exemplo é um ConstraintLayout. Com esse objeto, conseguimos obter a
referência dos componentes que ele contém usando o Kotlin extensions. Uma
vez que temos as instâncias dos componentes, preenchemos cada um com as
informações do objeto Vehicle. E, por fim, retornamos o layout preenchido.



Procure na internet as imagens da logomarca de cada fabricante nos
formatos PNG ou JPG e coloque na pasta res/drawable. Para preencher a
ImageView com a logomarca do fabricante poderíamos simplesmente ter feito
como a seguir, obviamente de acordo com o fabricante:
imgLogo.setImageResource(R.drawable.ford)

Entretanto, como você deve ter notado, estamos usando uma instância da
classe TypedArray que obtivemos a partir do método obtainTypedArray(int) da classe
Resources. Com esse objeto, podemos acessar o array de imagens baseado no
índice. Creio o arquivo res/values/arrays.xml, e deixe-o conforme a seguir:
<resources>
    <array name="logos">
        <item>@drawable/vw</item>
        <item>@drawable/gm</item>
        <item>@drawable/fiat</item>
        <item>@drawable/ford</item>
    </array>
</resources>

Também devemos adicionar no res/values/strings.xml os textos que
utilizamos para representar os combustíveis:
 <string name="fuel_gasoline">Gasolina</string>
<string name="fuel_ethanol">Etanol</string>
<string name="fuel_flex">Flex</string>
<string name="fuel_invalid">Não informado</string>

Perceba que definimos o método getFuel(Vehihcle) que retorna a string
correspondente ao combustível do vehicle passado como parâmetro. Note que
esse método está anotado com @StringRes indicando que não estamos
retornando um inteiro qualquer, ele deve representar o id de uma string
declarada no res/values/strings.xml.

Feito isso, testaremos o adapter na activity criando uma lista de objetos
Vehicle, instanciando o VechicleAdapter, e o definindo como adapter da ListView.
Modifique a classe MainActivity e deixe-a conforme a seguir:
import android.os.Bundle
import android.widget.ListView
import androidx.appcompat.app.AppCompatActivity
 
class MainActivity : AppCompatActivity() {
    // 0=VW;1=GM;2=Fiat;3=Ford
    private val vehicles = mutableListOf(
            Vehicle("Onix", 2018, 1, true, true),



            Vehicle("Uno", 2007, 2, true, false),
            Vehicle("Del Rey", 1988, 3, false, true),
            Vehicle("Gol", 2014, 0, true, true)
    )
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val listView = ListView(this)
        setContentView(listView)
        val adapter = VehicleAdapter(this, vehicles)
        listView.adapter = adapter
    }
}

Execute a aplicação e teremos um resultado similar ao que mostra a Figura
5.2.

Figura 5.2 – ListView com Adapter customizado.
A aplicação deve estar funcionando corretamente e a lista de veículos deve

estar sendo exibida. Vamos recapitular um pouco... O método
getView(int,View,ViewGroup) é chamado para cada objeto da lista. Então, se
tivermos 3 mil objetos, teremos essa mesma quantidade de views
instanciadas? Exatamente! E isso não é nada bom, mas não se desespere, os
engenheiros do Android criaram um mecanismo para otimizar esse processo.



Adicione o código a seguir à VehicleAdapter logo abaixo da chave de
fechamento do método getView(int, View, ViewGroup):
class VehicleAdapter (...) {
    // Demais métodos...
    companion object {
        data class ViewHolder(val view: View) {
            val imgLogo: ImageView = view.imgLogo
            val txtModel: TextView = view.txtModel
            val txtYear: TextView = view.txtYear
            val txtFuel: TextView = view.txtFuel
        }
    }
}

A classe ViewHolder tem como atributos os mesmos componentes que
declaramos no arquivo de layout. Pois, com esses atributos, manteremos as
referências das views e evitaremos ficar chamando o findViewById(int) (o Kotlin
Extensions faz isso internamente) cada vez que preenchermos o layout. Com
isso já melhoramos um pouco o desempenho do nosso adapter. No entanto, o
ponto principal que queremos ilustrar aqui é a reutilização de views.

Ao exibirmos uma lista na qual a quantidade de itens visíveis excede o
tamanho da tela, o Android não cria todas as linhas de uma vez (ao contrário
do que mostramos na Figura 5.1). À medida que fazemos scroll, a ListView vai
requisitando mais linhas ao adapter, que vão sendo criadas sob demanda, mas
podemos reaproveitar as linhas que saíram da tela e apenas preenchê-las com
novos valores.

Caso haja uma View que já tenha sido criada e não esteja visível no
momento, ela será passada como segundo parâmetro para o método getView(int,
View, ViewGroup), pronta para ser reutilizada. Faça a seguinte mudança no
método getView(int, View, ViewGroup) para vermos isso na prática:
override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
    // 1 passo
    val vehicle = vehicles[position]
    // 2 passo
    val holder: ViewHolder
    val row: View
    if (convertView == null) {
        row = LayoutInflater.from(ctx).inflate(R.layout.item_vehicle, parent, false)
        holder = ViewHolder(row)
        row.tag = holder



    } else {
        row = convertView
        holder = convertView.tag as ViewHolder
    }
    // 3 passo | 0=VW;1=GM;2=Fiat;3=Ford
    holder.imgLogo.setImageDrawable(logos.getDrawable(vehicle.manufacturer))
    holder.txtModel.text = vehicle.model
    holder.txtYear.text = vehicle.year.toString()
    holder.txtFuel.text = ctx.getString(getFuel(vehicle))
    // 4 passo
    return row
}

KOTLINxJAVA: Em Kotlin, parâmetros de métodos não podem ser reatribuídos,
ou seja, eles serão sempre val (não var).

Caso o parâmetro convertView seja igual a null, isso significa que não há uma
view para reaproveitar, então é preciso criar uma nova. Inicializamos a
constante row com o arquivo de layout carregado pela classe LayoutInflater. Em
seguida, instanciamos o ViewHolder passando como parâmetro a view do
arquivo de layout que acabamos de carregar. Então atribuímos o ViewHolder na
propriedade tag (que pode armazenar qualquer objeto) da constante row, pois,
desta forma, poderemos obter a instância do ViewHolder facilmente quando a
view for reutilizada.

Quando a View puder ser reutilizada (convertView diferente de null), teremos
apenas que pegar o ViewHolder a partir da propriedade tag (que atribuímos
anteriormente) e já teremos a referência de todos os componentes. Perceba
que todo o trabalho feito no if será executado apenas nas primeiras linhas que
ficarão visíveis na tela, e à medida que fizermos scroll apenas o código do else
será executado.

Se quiser visualizar o funcionamento dessa abordagem de
reaproveitamento, coloque um Log.d(String,String) no if e outro no else, adicione
mais carros até que seja possível fazer scroll na lista e execute a aplicação.
Role a lista e você notará que o código do if só será executado para a
quantidade de linhas visíveis na tela e mais algumas, depois, só o log do else
aparecerá:
if (convertView == null) {
    Log.d("NGVL", "View Nova => position: $position")
    // Restante do código aqui...



} else {
    Log.d("NGVL", "View existente => position: $position")
    // Restante do código aqui...
}

No Logcat aparecerá algo como a Figura 5.3.

Figura 5.3 – Logcat mostrando a reutilização da View no Adapter.
Essa boa prática deve ser adotada em todos os adapters customizados que

forem criados, pois ela torna a rolagem da lista mais suave e economiza
memória.

Detectando o clique em um item da ListView
Para detectar o evento de clique em um item da lista, basta passar um objeto
que implemente a interface OnItemClickListener como parâmetro para o método
setOnItemClickListener(OnItemClickListener). Dessa forma, ao clicarmos em um item, o
método onItemClick(AdapterView,View,int,long) será chamado. Adicione o código a
seguir no método onCreate(Bundle) da MainActivity:
listView.setOnItemClickListener { parent, view, position, id ->
    val (model, year) = vehicles[position]
    Toast.makeText(this, "$model $year", Toast.LENGTH_SHORT).show()
}

O Kotlin possui um conceito chamado destructuring que basicamente serve
para desmembrar um objeto. Neste exemplo, a classe Vehicle possui os
atributos model e year. Então desmembramos essas duas propriedades e
passamos para duas constantes usando val (model,year) e evitamos usar
vehicle.model e vehicle.year e usamos apenas as respectivas constantes.



O primeiro parâmetro do lambda é a ListView que disparou o evento, o
segundo é a View que foi clicada, o terceiro é o índice da linha que foi clicada
e o último é o id do objeto da lista (obtido com o método getItemId(int) do
adapter).

Se quiséssemos criar uma tela que exibisse os detalhes desse veículo,
bastaria iniciarmos uma nova activity passando o objeto vehicle como
parâmetro. Porém, lembre-se de que a classe Vehicle teria de implementar a
interface Serializable ou Parcelable.

Cabeçalho e rodapé
Podemos adicionar cabeçalho e rodapé ao componente ListView, usando
respectivamente os métodos addHeaderView(View) e addFooterView(View).
Adicionaremos esse detalhe à nossa aplicação declarando o método a seguir e
chamá-lo no onCreate(Bundle):
// Defina esse atributo dentro da classe MainActivity
private lateinit var txtFooter: TextView
 
// No onCreate, após atribuir o adapter ao ListView
listView.adapter = adapter
initHeaderAndFooter(listView, adapter)
 
// Adicione esse método abaixo do onCreate
private fun initHeaderAndFooter(listView : ListView, adapter: VehicleAdapter) {
    val padding = 8
    val txtHeader = TextView(this)
    txtHeader.setBackgroundColor(Color.GRAY)
    txtHeader.setTextColor(Color.WHITE)
    txtHeader.setText(R.string.header_text)
    txtHeader.setPadding(padding, padding, 0, padding)
    listView.addHeaderView(txtHeader)
 
    txtFooter = TextView(this)
    txtFooter.text = resources.getQuantityString(
            R.plurals.footer_text, adapter.count, adapter.count)
    txtFooter.setBackgroundColor(Color.LTGRAY)
    txtFooter.gravity = Gravity.END
    txtFooter.setPadding(0, padding, padding, padding)
    listView.addFooterView(txtFooter)
}

A palavra reservada lateinit informa ao compilador que essa variável não



poderá ser nula, mas que ela será inicializada posteriormente. Essa é uma
abordagem perigosa, pois pode causar NullPointerException se esquecermos de
inicializar o objeto.

Pela primeira vez estamos criando os componentes no código em vez de
usarmos um arquivo de layout. Poderíamos ter criado um arquivo de layout
com o cabeçalho da lista e outro com o rodapé e carregá-lo usando a classe
LayoutInflater. Queríamos deixar registrado aqui que é possível (e bem comum)
instanciar os componentes visuais programaticamente.

Outro ponto interessante é alterarmos algumas propriedades que só
tínhamos feito no XML, tais como:

• setBackgroundColor(Color) – passamos um Int (no formato RGB), que nesse
exemplo está definido na classe Color. Já existem alguns predefinidos, mas
poderíamos criar qualquer cor usando o método Color.rgb(int,int,int);

• setTextColor(Color) – também passamos um Int (no formato RGB), que nesse
exemplo está definido na classe Color para definir a cor do texto;

• setText(Int) – definimos o texto passando apenas o id da String gerada na
classe R (ex.: R.string.texto);

• setPadding(int,int,int,int) – adicionamos um espaçamento entre as partes
superior, esquerda, direita e inferior (nessa ordem) do componente para o
seu conteúdo;

• setGravity(Gravity) – estabelecemos o alinhamento do texto.
Uma coisa interessante que temos aqui é a chamada getQuantityString(int, int,int),

que nos permite obter strings que variam de acordo com a quantidade. Alguns
idiomas têm textos gramaticalmente diferentes de acordo com a quantidade e
o português do Brasil é um bom exemplo. Se temos apenas um carro na lista,
devemos exibir “1 carro”, e se tivermos mais que isso, exibimos “N carros”,
em que N seria a quantidade de carros na lista. Podemos fazer isso usando a
tag <plurals>. Adicione o trecho de código a seguir no arquivo
res/values/strings.xml:
<string name="header_text">Carros</string>
<string name="no_vehicles">Nenhum carro cadastrado</string>
<plurals name="footer_text">
    <item quantity="one">1 carro</item>
    <item quantity="other">%d carros</item>
</plurals>



Além das strings header_text e no_vehicles que são textos simples, definimos
uma string que varia de acordo com o plural chamada footer_text. Na tag <item>
indicamos um texto para quando a quantidade for 1 (one) e outro texto quando
tivermos qualquer outro valor (other). O resultado ficará conforme a Figura
5.4.

Figura 5.4 – Cabeçalho e rodapé na ListView.
É importante ressaltar que adicionar um cabeçalho e um rodapé afetam a

quantidade de views que a ListView exibe. Faça um teste: execute a aplicação e
clique no cabeçalho. Provavelmente sua aplicação dará erro. Isso acontece
porque, ao clicar no cabeçalho, o método onItemClick(AdapterView, View, int, long) é
chamado, mas a chamada ao método getItemAtPosition(int) não encontra nenhum
carro nessa posição. Por isso, faça o seguinte ajuste no evento de clique:
listView.setOnItemClickListener { parent, _, position, _ ->
    val vehicle = parent.getItemAtPosition(position) as? Vehicle
    if (vehicle != null) {
        val (model, year) = vehicle
        Toast.makeText(this, "$model $year", Toast.LENGTH_SHORT).show()
    } }

KOTLINxJAVA: Os parâmetros não utilizados em um lambda podem ser
substituídos por “_”.



Pronto! Agora a aplicação deve funcionar corretamente.

Empty View
Caso não haja dados a serem exibidos, uma tela em branco será exibida, o
que não é muito amigável e nada profissional. É possível definir um conteúdo
para ser exibido quando a ListView estiver vazia. Basicamente o que
precisamos fazer é adicionar uma View qualquer com o id @android:id/empty para
informar ao usuário que a lista está vazia. Altere o arquivo
res/layout/activity_main.xml para ficar como a seguir:
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ListView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/listView"/>
    <TextView android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:gravity="center"
        android:drawableTop="@mipmap/ic_launcher"
        android:text="@string/no_vehicles"
        android:id="@android:id/empty"/>
</FrameLayout>

Na MainActivity, substitua a ListView que instanciamos programaticamente pelo
arquivo de layout chamando o método setContentView(int) passando
R.layout.activity_main. E, em seguida, defina a view que será exibida quando a
ListView estiver vazia utilizando a propriedade emptyView:
class MainActivity : AppCompatActivity() {
    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        listView.emptyView = findViewById(android.R.id.empty)
        ...

Para testar essa implementação, removeremos o item da lista quando ele for
clicado:
listView.setOnItemClickListener { parent, view, position, id ->



    val vehicle = parent.getItemAtPosition(position) as? Vehicle
    if (vehicle != null) {
        val (model, year) = vehicle
        Toast.makeText(this, "$model $year", Toast.LENGTH_SHORT).show()
        vehicles.remove(vehicle)
        adapter.notifyDataSetChanged()
        txtFooter.text = resources.getQuantityString(
                R.plurals.footer_text, adapter.count, adapter.count)
    }
}

Ao clicar no item da lista, o carro é removido da lista. Notificamos o
adapter que a lista sofreu mudanças invocando o notifyDataSetChanged() e
atualizamos o rodapé da lista.

Clique em cada um dos itens até que todos sejam removidos. O resultado
ficará conforme a Figura 5.5.

Figura 5.5 – Usando emptyView da ListView.

Invertendo os itens da ListView
A última dica para concluirmos o assunto sobre ListView é que se quisermos
fazer com que os itens de uma ListView comecem de baixo, basta usar a
propriedade android:stackFromBottom="true". Isso pode ser útil em aplicativos de



mensagens, em que as mais recentes ficam na parte inferior.
No decorrer do livro, veremos mais exemplos de adapters e ListView, mas os

principais conceitos foram apresentados nesta seção.

AutoCompleteTextView
O AutoCompleteTextView é uma caixa de texto em que pode ser realizado algum
tipo de pesquisa à medida que o usuário digita. Nesse momento, ele poderá
selecionar alguma opção entre os resultados exibidos em uma lista suspensa.

Crie um novo projeto e adicione ao arquivo de layout um
AutoCompleteTextView que fica na seção Text da paleta de componentes. Ajuste-o
para ficar conforme a seguir.

Application Name AutoComplete
Package Name dominando.android.autocomplete
Activity Name MainActivity

<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="8dp"
    tools:context=".MainActivity">
    <AutoCompleteTextView
        android:id="@+id/actCities"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:completionHint="Selecione uma cidade"
        android:completionThreshold="2"
        android:hint="Busca de cidades"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

Temos duas propriedades importantes aqui: android:completionThreshould e
android:completionHint. A primeira informa com quantos caracteres digitados a
busca deve iniciar, enquanto o segundo é uma dica que aparecerá na parte
inferior na lista de resultados que é exibida. Agora altere a MainActivity para
ficar como a seguir:
import androidx.appcompat.app.AppCompatActivity



import android.os.Bundle
import android.widget.ArrayAdapter
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val cities = listOf<String>(
                "Caruaru",
                "Cabo de Santo Agostinho",
                "Recife",
                "São Paulo",
                "Santos",
                "Santa Cruz"
        )
        val adapter = ArrayAdapter<String>(this, android.R.layout.simple_dropdown_item_1line, cities)
        actCities.setAdapter(adapter)
    }
}

No código anterior criamos uma lista com o nome de algumas cidades. Em
seguida, instanciamos o ArrayAdapter que será usado para exibir a lista dos
resultados e o atribuímos ao AutoCompleteTextView. Execute a aplicação e digite
“sa” e você terá o resultado similar à Figura 5.6.

Como podemos observar, ele já tem um mecanismo de busca padrão por
meio do qual é checado se o texto digitado está contido no toString() de cada
objeto da lista. Então, quando digitamos “sa”, ele busca todos os resultados
que contenham essas duas letras em qualquer parte do seu nome. Entretanto,
ele diferencia os caracteres acentuados dos não acentuados, já que “São
Paulo” não apareceu nos resultados.



Figura 5.6 – AutoCompleteTextView.
Para ignorarmos os acentos, vamos criar extension function que fará esse

trabalho. Crie um arquivo Kotlin chamado StringExtensions.kt e deixe-o
como a seguir:
import java.util.regex.Pattern
 
fun String.removeAccents() : String {
    val replaces = arrayOf("a", "e", "i", "o", "u", "c")
    val patterns = arrayOf(
            Pattern.compile("[âãáàä]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("[éèêë]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("[íìîï]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("[óòôõö]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("[úùûü]", Pattern.CASE_INSENSITIVE),
            Pattern.compile("[ç]", Pattern.CASE_INSENSITIVE)
    )
    var result = this
    for ((index, value) in patterns.withIndex()) {
        val matcher = value.matcher(result)
        result = matcher.replaceAll(replaces[index])
    }
    return result.toLowerCase()
}



O Kotlin permite criar funções que estendem a funcionalidade de uma
classe. Estamos fazendo isso nessa função, adicionando um método à classe
String que nos permite remover os acentos de qualquer String do projeto.

O código anterior utiliza as classes Pattern e Matcher para checar a presença de
caracteres acentuados e substituí-los pelos caracteres correspondentes sem
acentuação. Observe que só estão sendo tratadas as vogais e o cedilha, para
textos em outros idiomas (como o ‘ñ’ do espanhol, por exemplo) seria
necessário fazer alguns ajustes.

Para fazer nossa busca personalizada (ignorando acentuação) devemos criar
um adapter customizado, implementar a interface Filterable e implementar o
método getFilter(). Esse método deve retornar um objeto da classe Filter que fará
a pesquisa e devolverá o resultado da busca.

Crie uma nova classe chamada CitySearchAdapter e deixe-a conforme descrito a
seguir:
import android.content.Context
import android.widget.ArrayAdapter
import android.widget.Filter
import android.widget.Filterable
 
class CitySearchAdapter(ctx: Context,
                        layout: Int,
                        private val fullList: List<String>
) : ArrayAdapter<String>(ctx, layout, fullList), Filterable {
 
    private var results: List<String>
    private val cityFilter: Filter
 
    init {
        this.results = fullList
        this.cityFilter = CityFilter()
    }
 
    override fun getCount(): Int = results.size
 
    override fun getItem(position: Int): String? =
            if (results.isNotEmpty() && position < results.size) {
                results[position]
            } else {
                null
            }
 



    override fun getFilter(): Filter = cityFilter
 
    private inner class CityFilter : Filter() {
        override fun performFiltering(constraint: CharSequence?): Filter.FilterResults {
            val filterResults = Filter.FilterResults()
            var temp: List<String> = ArrayList()
            if (constraint != null) {
                val term = constraint.toString().trim().toLowerCase()
                temp = fullList.filter {
                    it.removeAccents().indexOf(term) > -1
                }
            }
            filterResults.values = temp
            filterResults.count = temp.size
            return filterResults
        }
        override fun publishResults(constraint: CharSequence?,
                                    filterResults: Filter.FilterResults) {
            results = filterResults.values as List<String>
            notifyDataSetChanged()
        }
    }
}

A classe anterior tem duas listas de strings: a original e a que será usada
como resultado da busca. Note que os métodos getCount() e getItem(int) trabalham
em cima da lista dos resultados. O outro atributo da classe é do tipo CityFilter,
que é retornado no método getFilter().

A classe interna CityFilter faz a busca personalizada que desejamos. Essa
filtragem é realizada no método performFiltering(CharSequence), que retorna um
objeto da classe FilterResults e que possui o resultado da busca e o total de
registros encontrados. Esse resultado é passado para o método
publishResults(CharSequence, FilterResults), que associa o resultado da busca no
atributo results e logo em seguida atualiza o adapter por meio do método
notifyDatasetChanged().

As threads serão discutidas no Capítulo 12, mas é importante ressaltar que o
método performFiltering(CharSequence) é executado em uma thread separada,
enquanto o publishResults(CharSequence,FilterResults) é executado na UI thread.

Na activity, substitua o ArrayAdapter pelo CitySearchAdapter conforme a seguir.
Execute a aplicação e digite “sa” novamente e agora a cidade de São Paulo
aparecerá nos resultados:



val adapter = CitySearchAdapter(this, android.R.layout.simple_dropdown_item_1line, cities)
Esse componente agiliza a inserção de dados nos casos em que temos um

conjunto de valores já existente e que o usuário pode selecionar, mas também
pode digitá-lo livremente.

RecyclerView
Desde a primeira versão do Android, o componente utilizado para exibir uma
listagem de informações sempre foi a ListView, juntamente com alguma
subclasse de BaseAdapter. Esse conjunto funciona muito bem, mas, conforme o
tempo foi passando, ele foi apresentando algumas “limitações” que
atrapalhavam sua conformidade com os requisitos e padrões de UI/UX atuais.
Nada que fosse impossível de ser implementado, mas era bastante trabalhoso
de ser feito.

Nesse contexto, aparece a RecyclerView, um componente para exibir uma lista
de informações que traz diversos benefícios em comparação com a ListView:

• Performance na atualização de itens: a ListView está ligada a um Adapter, que
possui uma lista de objetos. Se inserirmos um objeto nessa lista, temos
que invocar o método notifyDatasetChanged() que fará com que toda a lista seja
redesenhada. Com a RecyclerView podemos atualizar apenas um item
específico da lista (inserindo/atualizando/excluindo) ou determinado
intervalo.

• Layouts diferenciados para cada situação: com a RecyclerView podemos
configurar gerenciadores de layouts, indicando, por exemplo, que a lista
terá uma única coluna quando o aparelho estiver em portrait e duas
quando estiver em landscape. Ou, ainda, dizer que o primeiro item da lista
será diferente dos demais.

• Animações e gestos: com a RecyclerView, à medida que os itens vão sendo
adicionados ou removidos, uma animação é realizada dando um feedback
visual para o usuário do que aconteceu. A utilização de gestos também
ficou bastante simples. Ações como o swipe sobre um item da lista é algo
trivial de ser feito.

• Scroll em ambos os sentidos: a RecyclerView permite o scroll tanto na
horizontal quanto na vertical, o que não era possível nativamente na
ListView.



Crie um novo projeto de exemplo para explorarmos o uso desse
componente. Será um pequeno aplicativo de cadastro em memória utilizando
a RecyclerView.

Application Name Recycler
Package Name dominando.android.recycler
Activity Name MainActivity

A RecyclerView é distribuída em uma biblioteca separada, por isso devemos
adicioná-la como dependência no build.gradle:
dependencies {
    ...
    implementation 'androidx.recyclerview:recyclerview:1.0.0'
    implementation 'com.google.android.material:material:1.0.0'
}

Adicionamos também a biblioteca de design que também utilizaremos
nesse exemplo. Começaremos esse exemplo adicionando a classe Message:
data class Message(var title: String, var text: String)

Nada a comentar sobre essa classe, então vamos adicionar o arquivo
res/layout/item_message.xml que representará cada item da lista:
<com.google.android.material.card.MaterialCardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="4dp"
    app:cardCornerRadius="8dp">
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="?attr/selectableItemBackground"
        android:gravity="center"
        android:orientation="vertical"
        android:padding="8dp">
        <TextView
            android:id="@+id/txtTitle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center"
            android:textSize="20sp" />
        <TextView
            android:id="@+id/txtText"



            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="16sp" />
    </LinearLayout>
</com.google.android.material.card.MaterialCardView>

Um ponto interessante a ressaltar nesse layout é a propriedade
android:background. A RecyclerView, por padrão, não fornece o feedback de toque
como faz a ListView, pois ela parte do pressuposto de que seus itens não são
clicáveis, ao contrário da ListView, que mesmo que não haja tratamento do
evento de clique, um feedback visual é dado quando o item é clicado. Outro
detalhe é que estamos utilizando o MaterialCardView da biblioteca de design que
é uma subclasse da CardView que vimos anteriormente.

Agora implementaremos o layout da activity, deixando o arquivo
res/layout/activity_main.xml da seguinte forma:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".MainActivity">
    <com.google.android.material.textfield.TextInputLayout
        android:id="@+id/tilTitle"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent">
        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/edtTitle"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/hint_title" />
    </com.google.android.material.textfield.TextInputLayout>
    <com.google.android.material.textfield.TextInputLayout
        android:id="@+id/tilText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/tilTitle">



        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/edtText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/hint_text" />
    </com.google.android.material.textfield.TextInputLayout>
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/rvMessages"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/tilText" />
    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/fabAdd"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginEnd="16dp"
        android:layout_marginBottom="16dp"
        android:clickable="true"
        android:focusable="true"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:srcCompat="@drawable/ic_add" />
</androidx.constraintlayout.widget.ConstraintLayout>

Estamos utilizando o TextInputLayout para os campos que o usuário
preencherá. Logo a seguir adicionamos o RecyclerView, que exibirá os registros
cadastrados. Para salvar a informação estamos utilizando o FloatingActionButton
(ou simplesmente FAB), um botão redondo que é um padrão do Material
Design. Falaremos em detalhes sobre esse componente no Capítulo 8.

Adicione a imagem utilizada no FAB clicando com o botão direito sobre a
pasta res/drawable e selecionando a opção New > Vector Asset. Selecione a
opção Clip Art e procure por “add” e escolha o ícone de sua preferência. Por
fim, no campo Color deixe como branco (#FFFFFF), nomeie o ícone como
ic_add, clique em Next e Finish.

Também adicione os textos no res/values/strings.xml:
<string name="hint_title">Título</string>
<string name="hint_text">Texto</string>

Implemente agora o adapter a ser utilizado na RecyclerView. Crie a classe
MessageAdapter e deixe-a como a seguir:



import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import kotlinx.android.synthetic.main.item_message.view.*
 
class MessageAdapter(
        private val messages: List<Message>,
        private val callback: (Message) -> Unit) :
        RecyclerView.Adapter<MessageAdapter.VH>() {
 
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
        val v = LayoutInflater.from(parent.context)
                .inflate(R.layout.item_message, parent, false)
        val vh = VH(v)
        vh.itemView.setOnClickListener {
            val message = messages[vh.adapterPosition]
            callback(message)
        }
        return vh
    }
    override fun onBindViewHolder(holder: VH, pos: Int) {
        val (title, text) = messages[pos]
        holder.txtTitle.text = title
        holder.txtText.text = text
    }
    override fun getItemCount(): Int = messages.size
 
    class VH(itemView: View) : RecyclerView.ViewHolder(itemView) {
        val txtTitle: TextView = itemView.txtTitle
        var txtText: TextView = itemView.txtText
    }
}

Essa sem sombra de dúvida é a classe mais importante desse exemplo,
então vamos aos detalhes sobre ela. Para definir um adapter para a RecyclerView
devemos criar uma subclasse de RecyclerView.Adapter e, como podemos observar,
ela é “tipada”. Ou seja, ela necessita de um tipo que deve ser uma subclasse
de RecycleView.ViewHolder. Neste exemplo, esse ViewHolder foi nomeado
simplesmente como VH e está declarado dentro da própria classe
MessageAdapter.

Para criar uma instância do adapter, além da lista de mensagens, estamos



passando um objeto que tratará o evento de clique do item da lista.
Diferentemente do que é feito na ListView, onde temos o OnItemClickListener, o
evento de clique em um item da RecyclerView é definido no adapter. Perceba
que esse parâmetro é uma função, que recebe um objeto do tipo Message e não
retorna nada (Unit). Essa função será chamada quando o evento de clique
ocorrer. Em Kotlin, é possível passar funções como parâmetros de outras
funções. Esse recurso é conhecido como higher-order functions (funções de
alta-ordem).

No adapter, obrigatoriamente implementam-se três métodos:
• onCreateViewHolder(ViewGroup,Int) será o responsável por criar a instância do

ViewHolder baseado no arquivo de layout que representa cada item (no
nosso caso res/layout/item_message.xml). Este método já implementa, por
padrão, a abordagem de um adapter eficiente da ListView que explicamos
anteriormente, mas de forma padronizada. Neste método também
definimos o evento de clique do item da lista. Perceba que por meio do
atributo itemView (que já é da classe ViewHolder) definimos o evento de
clique. E usando a propriedade adapterPosition obtemos o índice da posição
da lista que foi clicado;

• no onBindViewHolder(ViewHolder,Int) é onde deve ser preenchido o ViewHolder
com as informações do objeto;

• o getItemCount() define a quantidade de itens que a lista exibirá, como já é de
costume em qualquer adapter.

Implemente agora a lógica do nosso exemplo. Deixe a MainActivity como a
seguir:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Toast
import androidx.recyclerview.widget.GridLayoutManager
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    private var messages = mutableListOf<Message>()
    private var adapter = MessageAdapter(messages, this::onMessageItemClick)
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        initRecyclerView()



        fabAdd.setOnClickListener {
            addMessage()
        }
    }
    private fun initRecyclerView() {
        rvMessages.adapter = adapter
        val layoutManager = GridLayoutManager(this, 2)
        layoutManager.spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() {
            override fun getSpanSize(pos: Int): Int {
                return if (pos == 0) 2 else 1
            }
        }
        rvMessages.layoutManager = layoutManager
    }
    private fun addMessage() {
        val message = Message(
                edtTitle.text.toString(),
                edtText.text.toString()
        )
        messages.add(message)
        adapter.notifyItemInserted(messages.lastIndex)
        edtTitle.text?.clear()
        edtText.text?.clear()
        edtTitle.requestFocus()
    }
    private fun onMessageItemClick(message: Message) {
        val s = "${message.title}\n${message.text}"
        Toast.makeText(this, s, Toast.LENGTH_SHORT).show()
    }
}

Perceba que na criação do adapter, além da lista de mensagens estamos
passando como parâmetro a função onMessageItemClick(Message), que possui a
mesma assinatura do parâmetro callback definido no construtor da classe
MessageAdapter. Sendo assim, essa função será chamada quando o item for
clicado.

No onCreate(Bundle) estamos primeiramente invocando o método
initRecyclerView() onde a RecyclerView é configurada. Estamos utilizando o
gerenciador de layout GridLayoutManager que permite dividir a lista em colunas.
Neste exemplo, no segundo parâmetro do construtor do GridLayoutManager
informamos que teremos duas colunas.

A propriedade spanSizeLookup indica quais itens ocuparão mais de uma
coluna. Para esse exemplo, foi definido que apenas o primeiro item da lista



ocupará duas colunas, os demais ocuparão apenas uma.
Existem ainda os gerenciadores de layout LinearLayoutManager e

StaggeredGridLayoutManager. O primeiro organiza os itens da lista de forma linear
(igual a ListView) enquanto o segundo organiza os itens em forma de grid, mas
suporta itens de tamanhos completamente diferentes e os exibe como se
fossem um “mosaico”. Podemos também criar nossos próprios gerenciadores
de layout.

Perceba que no evento de clique do FAB, ao inserirmos um item na lista,
utilizamos o método notifyItemInserted(), que notifica o RecyclerView para exibir
esse novo item. E como sempre adicionamos o item ao final da lista,
passamos o último índice da lista. Existem também os métodos
notifyItemRemoved(), notifyItemChanged(), notifyItemMoved() para quando um item da
lista foi respectivamente removido, alterado ou movido de uma posição para
a outra da lista. Podemos utilizar os métodos notifyItemRangeInserted(),
notifyItemRangeRemoved() e notifyItemRangeChanged(). Que indicam que um intervalo
de itens da lista foi inserido, removido ou alterado. Obviamente existe o
notifyDatasetChanged(), que possui o mesmo comportamento da ListView.

Ao executar a aplicação e adicionar alguns registros, você terá um resultado
similar ao da Figura 5.7.



Figura 5.7 – RecyclerView.
O aplicativo está adicionando novos itens à lista, mas e para remover? Que

tal usar o gesto de swipe? Com a RecyclerView isso ficou bem simples também.
Adicione o método a seguir na MainActivity:
private fun initSwipeGesture() {
    val swipe = object : ItemTouchHelper.SimpleCallback(
            0, // Posições permitidas para mover a view. zero = nenhuma
            ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT // Posições de swipe
    ) {
        override fun onMove(recyclerView: RecyclerView,
            viewHolder: RecyclerView.ViewHolder,
            target: RecyclerView.ViewHolder): Boolean = false // Não permite mover itens
 
        override fun onSwiped(viewHolder: RecyclerView.ViewHolder, swipeDir: Int) {
            val position = viewHolder.adapterPosition
            messages.removeAt(position)
            adapter.notifyItemRemoved(position)
        }
    }
    val itemTouchHelper = ItemTouchHelper(swipe)
    itemTouchHelper.attachToRecyclerView(rvMessages)
}

Com a classe ItemTouchHelper estamos configurando o gesto de swipe para
esquerda e para direita. E no método onSwiped() removemos o item da lista e
notificamos o adapter. Perceba que com essa classe também é possível
implementar o evento de mover itens na lista, mas não utilizamos aqui.

Para concluir, chame o método que acabamos de criar no initRecyclerView() da
MainActivity:
private fun initRecyclerView() {
    ...
    initSwipeGesture()
}

Execute a aplicação novamente e insira alguns itens. Em seguida, tente
excluí-los utilizando o gesto de swipe. Perceba que após um item ser
excluído, os demais itens são reorganizados com uma animação.

Note que ao girar a tela do aparelho os dados são perdidos. Resolva esse
problema simplesmente salvando a lista de mensagens no método
onRetainCustomNonConfigurationInstance() e recuperando-as no onCreate(Bundle) como
listado seguir:



class MainActivity : AppCompatActivity() {
    var messages = mutableListOf<Message>()
    var adapter = MessageAdapter(messages, this::onMessageItemClick)
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        lastCustomNonConfigurationInstance.let { savedMessages ->
            if (savedMessages is MutableList<*>) {
                messages.addAll(savedMessages.filterIsInstance(Message::class.java))
            }
        }
        initRecyclerView()
        fabAdd.setOnClickListener {
            addMessage()
        }
    }
    override fun onRetainCustomNonConfigurationInstance(): Any {
        return messages
    }
    // Restante da classe permanece igual

KOTLINxJAVA: A função let executa o bloco de código e retorna a última linha
do bloco. Ele é muito utilizado como substituto do if (objeto != null), pois utilizando
objeto?.let { ... } o bloco só será executado se o objeto for diferente de null.

Como podemos observar, o método onRetainCustomNonConfigurationInstance() pode
retornar qualquer objeto. Por essa razão, no método onCreate(Bundle) checamos
se o objeto salvo é uma MutableList. Nesse caso, adicionamos todos os itens
salvos anteriormente na lista da instância atual da activity. Porém, ainda
existe um problema: não podemos garantir que todos os itens da lista salva
são objetos do tipo Message (nós sabemos, mas o Kotlin não). Por essa razão,
utilizamos o método filterIsInstance(Class) do Kotlin, que retornará uma nova lista
apenas com objetos do tipo que passamos como parâmetro.

No próximo capítulo, veremos mais componentes, formas de customizá-los
e como criar os nossos próprios componentes.



CAPÍTULO 6
Componentes – Parte III

Neste capítulo daremos continuidade ao nosso estudo dos componentes
visuais do Android, que já são bem atraentes, mas dar um toque pessoal e
trazer a identidade visual da empresa ou produto para o aplicativo também é
importante. Veremos como customizá-los dando um visual diferente
utilizando estilos e, em seguida, aprenderemos como criar os nossos próprios
componentes.

Utilizando o Material Design
Abra o exemplo de Componentes que criamos no Capítulo 4 e observe como
está o arquivo res/values/styles.xml:
<resources>
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>
</resources>

Com essa declaração estamos utilizando o tema chamado AppTheme, e por
meio da propriedade parent, indicamos que ele herda do
Theme.AppCompat.Light.DarkActionBar. Utilizar o Theme.AppCompat permite a utilização
do Material Design em versões anteriores ao Lollipop, e esse tema possui
algumas variações:

• Theme.AppCompat – versão mais escura com os textos claros;
• Theme.AppCompat.Light – variação com a tela clara e com os textos escuros;
• Theme.AppCompat.Light.DarkActionBar – idêntico ao anterior, mas com a barra de

título mais escura;
A Figura 6.1 mostra a aplicação utilizando essas três variações do tema do

Material Design.



  

Figura 6.1 – Variações do tema Material Design.
A propriedade colorPrimary determina a cor da barra de título, enquanto a

colorPrimaryDark determina a cor da barra de status (que funciona apenas no
Lollipop ou superior). Por fim, a colorAccent determina a cor de foco dos
componentes. Lembrando que o tema da aplicação é declarado na
propriedade android:theme da tag <application> no AndroidManifest.xml:
<manifest ... >
    <application …
        android:theme="@style/AppTheme" >

Por fim, todas as Activities devem herdar da classe AppCompatActivity:
public class MainActivity extends AppCompatActivity {
    ...
}

Abordaremos o Material Design em vários capítulos do livro, mas será feito
um exemplo completo no Capítulo 30.

Formato 9-Patch
Como foi possível observar no decorrer dos exemplos implementados até
agora, os componentes visuais do Android podem assumir tamanhos
diferentes de acordo com o seu conteúdo. Dessa forma, se quisermos alterar o



background de um componente usando uma imagem, como saberemos qual
tamanho essa imagem deve ter? É nesse cenário em que se encaixam as
imagens no formato 9-patch. Esse tipo de arquivo permite adicionar
marcações às imagens PNG (Portable Network Graphics) indicando áreas
que podem crescer horizontal e verticalmente sem que haja perda de
qualidade, além de permitir adicionar um padding para determinar onde
ficará o conteúdo do componente que usará essa imagem. A Figura 6.2
demonstra as marcações feitas na imagem.

Figura 6.2 – Indicação das áreas de marcação de uma imagem 9-patch.
Fonte: http://radleymarx.com/blog/simple-guide-to-9-patch/.

Porém, como adicionar essas marcações à imagem? No Android Studio
podemos clicar com o botão direito sobre uma imagem localizada na pasta
res/drawable e selecionar a opção Create 9-patch file.

Para exemplificar o uso do 9-patch, usaremos nossos dotes de designer para
criar a imagem na qual colocaremos a marcação 9-patch. Abra qualquer
ferramenta de edição de imagens que permita criar uma imagem com
background transparente (Paint.net, Paintbrush, Gimp, Photoshop etc.) e crie
um novo arquivo1 similar ao da Figura 6.3 e salve-o como balao.png.
Usaremos esse arquivo como background de um TextView para uma conversa
de um chat.



Figura 6.3 – Imagem para aplicarmos 9-patch.
Agora veremos como ele fica na prática. Crie um novo projeto, adicione o

arquivo balao.png na pasta res/drawable. Como foi mencionado
anteriormente, o ideal é criar uma imagem para cada densidade de tela, mas,
para esse exemplo, criaremos apenas uma que será usada em todas as
densidades.

Application Name Estilos
Package Name dominando.android.estilos
Activity Name MainActivity

Clique com o botão direito sobre a imagem, selecione a opção Create 9-
patch file e salve-a na pasta res/drawable. Note que a imagem será salva
como balao.9.png, indicando que é uma imagem 9-patch. Em seguida, exclua
a imagem original e então teremos algo similar à Figura 6.4.



Figura 6.4 – Ferramenta draw9patch em execução.
Observe que, do lado direito, temos uma pré-visualização do que acontecerá

se usarmos a imagem em algum componente do jeito que está, sem nenhuma
marcação ela ficará toda distorcida. Agora adicionaremos as marcações à
imagem para resolver esse problema.

Inclua as marcações clicando nas bordas da imagem e deixe-a conforme a
Figura 6.5. Para apagar algum ponto, pressione a tecla Shift e clique no ponto
desejado. Note que, à medida que adicionamos os pontos, a pré-visualização
nos mostra como ficará a imagem redimensionada. Lembrando que as
marcações superior e esquerda representam a área da imagem que esticará
caso o componente seja maior que a imagem, e as marcações direita e inferior
demarcam a área onde ficará o conteúdo do componente que usará a imagem.



Figura 6.5 – Adicionando marcações no draw9patch.
Adicionadas as marcações, utilizaremos a imagem no arquivo de layout

res/layout/activity_main.xml como a seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    android:orientation="vertical">
    <TextView
        android:text="Um Texto qualquer"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="@drawable/balao"/>
    <TextView
        android:text="Outro texto com\n duas quebras\nde linha"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="@drawable/balao"/>
    <TextView
        android:text="Texto usando match_parent"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@drawable/balao"/>



</LinearLayout>
O resultado ficará conforme a Figura 6.6, e como podemos constatar,

independente da largura ou da altura do TextView, a imagem se adéqua ao
componente sem perda de qualidade visual.

Figura 6.6 – TextView com background 9-patch.

Utilização de estilos
O Android tem um conceito de estilos muito similar ao do CSS (Cascade
Style Sheets), em que várias propriedades de um componente são modificadas
de uma única vez, com o objetivo de alterar sua aparência.

Como foi possível observar nos exemplos apresentados até aqui, ao criar
um novo projeto o arquivo res/values/styles.xml é criado automaticamente.
Neste arquivo é declarado o tema da aplicação e onde se deve definir os
demais estilos do aplicativo. Também foi mencionado anteriormente que é
recomendado centralizar a definição de cores no arquivo
res/values/colors.xml.

Na verdade, os nomes dos arquivos da pasta res/values não precisam
necessariamente serem esses, é apenas uma convenção. A Tabela 6.1 resume
os principais arquivos que podem ser adicionados nessa pasta e o seu



respectivo propósito.
Tabela 6.1 – Arquivos da pasta values

Arquivo Tag Propósito
arrays.xml <array> Declarar arrays de recursos como imagens e cores.
colors.xml <color> Declaração de cores.
dimens.xml <dimen> Dimensões para componentes.
strings.xml <string> <string-array> <plurals> Armazenar os textos da aplicação.
styles.xml <style> Estilos para elementos de UI.
bools.xml <bool> Valores boleanos, inteiros ou arrays de inteiros.
integer.xml <integer>

<integer-array>

Adicione as seguintes cores ao arquivo colors.xml na pasta res/values do
projeto:
<resources>
    ...
    <color name="app_red">#D50000</color>
    <color name="app_green">#38833C</color>
    <color name="app_white">#FFFFFF</color>
    <color name="app_black">#000000</color>
</resources>

Declaramos as cores usando a tag <color> passando o valor em hexadecimal
utilizando a notação RRGGBB (Red Green Blue). Poderíamos adicionar uma
transparência usando a notação AARRGGBB (Alpha Red Green Blue).
Agora faça as seguintes mudanças no arquivo res/values/styles.xml:
<resources>
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
         ...
        <item name="android:textColor">@color/app_red</item>
    </style>
    <style name="MyStyle">
        <item name="android:textSize">20sp</item>
        <item name="android:textColor">@color/app_white</item>
        <item name="android:background">@color/app_green</item>
        <item name="android:textStyle">italic</item>
    </style>
</resources>

O estilo AppTheme herda de Theme.AppCompat.Light.DarkActionBar que contém
todos os estilos da aplicação. Então o que alteramos dentro dele afetará todo
o visual do aplicativo. Para exemplificar isso, foi alterada a propriedade



android:textColor que fará com a cor do texto de todos os componentes seja
vermelha (@color/app_red). Em seguida, foi criado um estilo chamado MyStyle
que modificará, de uma só vez, as propriedades android:textSize, android:textColor,
android:textStyle e android:background do componente que utilizar esse estilo.

Adicione mais um TextView ao layout que usamos no exemplo da seção
anterior, e altere a propriedade style para apontar para o estilo @style/MyStyle. O
resultado ficará como o da Figura 6.7:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    android:orientation="vertical">
    <!-- Mesmos TextViews do exemplo anterior... -->
    <TextView android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="TextView com Estilo"
        style="@style/MyStyle"/>
</LinearLayout>

Figura 6.7 – Aplicando estilo em um TextView.
Note que os primeiros TextView foram afetados pela mudança que fizemos no

tema geral da aplicação, enquanto o último não foi afetado porque usamos



um estilo sobrescrevendo o tema geral.
Sempre que houver componentes com um conjunto de propriedades em

comum sendo modificadas, é aconselhável criarmos um estilo e usá-lo nestes
componentes, pois assim deixamos essas configurações centralizadas em um
único local.

Selectors
Todos os componentes visuais do Android que são selecionáveis ou clicáveis
podem utilizar um selector, esse recurso permite atribuir uma imagem para
cada estado do componente. Os principais estados estão listados na Tabela
6.2.

Tabela 6.2 – Principais estados dos componentes
Estado Exemplo

android:state_pressed Button sendo clicado.
android:state_focused EditText com o usuário inserindo o texto.
android:state_selected Navegando em um ListView com o direcional de um teclado físico.
android:state_checked CheckBox ou RadioButton marcados.
android:state_enabled Componente está habilitado ou não.
android:state_activated Quando um componente usa seleção permanente como em listas de múltipla seleção.
android:state_window_focused Componente está em uma tela com foco.

Selector para um Button
Exemplificaremos o uso dos selectors criando um botão customizado. Para
isso, crie três imagens com o um editor de imagem: uma para quando estiver
pressionado; outra para quando estiver desabilitado; e a última para quando
não estiver em nenhum desses dois estados. Nesse exemplo foram criadas
imagens de 20 x 48 e salvas como button_normal.png, button_pressed.png e
button_disabled.png. As imagens são as mesmas, mudando apenas a cor.

Copie os arquivos para a pasta res/drawable e faça o 9-patch dessas
imagens para permitirmos que o botão possa ter qualquer tamanho sem afetar
o seu visual. Adicione as marcações nas três imagens como mostra a Figura
6.8 e salve-as como button_normal.9.png, button_pressed.9.png e
button_disabled.9.png.



Figura 6.8 – Adicionando 9-patch à imagem do botão.
Copie as três imagens para a pasta res/drawable do projeto e criaremos

agora o selector do botão. Clique com o botão direito sobre a pasta
res/drawable e selecione a opção New > Drawable resource file. Na janela
que for exibida, preencha o campo File name com selector_button e clique em
OK. Em seguida, deixe o arquivo conforme a seguir:
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true"
            android:drawable="@drawable/button_pressed"/>
    <item android:state_enabled="false"
            android:drawable="@drawable/button_disabled"/>
    <item android:drawable="@drawable/button_normal"/>
</selector>

No selector, definimos a imagem @drawable/button_pressed para quando o botão
estiver pressionado (android:state_pressed=true), a imagem @drawable/button_disabled
para quando estiver desabilitado (android:state_enabled=false), e para os demais
casos a imagem @drawable/button_normal.

Com o selector criado, poderíamos usá-lo definindo a propriedade
android:background para @drawable/selector_button, mas imagine ter de fazer isso para
todos os botões da aplicação. Não seria muito produtivo, principalmente se



você tivesse que mudar depois. Em vez disso, crie um estilo e defina que
todos os botões da aplicação seguirão esse estilo. Altere o
res/values/styles.xml para ficar como a seguir:
<resources>
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        ...
        <item name="buttonStyle">@style/AppButton</item>
    </style>
    <style name="AppButton" parent="Widget.AppCompat.Button">
        <item name="android:background">@drawable/selector_button</item>
        <item name="android:textColor">@color/app_white</item>
    </style>
    …
</resources>

Foi criado um novo estilo chamado AppButton, e na propriedade android:parent
indicamos que ele herdará do estilo do Button do Android
(Widget.AppCompat.Button). Em seguida, dentro do tema da aplicação, informamos
que o android:buttonStyle deve usar esse novo estilo. Adicione três botões no
arquivo de layout dentro de um LinearLayout horizontal, conforme listado a
seguir e o resultado ficará similar à Figura 6.9:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    android:orientation="vertical">
    <!-- Demais componentes que tínhamos adicionado -->
    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Botão 1"
            android:id="@+id/button"/>
        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Botão 2"
            android:id="@+id/button2"/>



        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Botão 3"
            android:enabled="false"
            android:id="@+id/button3"/>
    </LinearLayout>
</LinearLayout>

Como podemos observar, o primeiro botão não tem nenhuma interação, o
segundo está pressionado e o terceiro está desabilitado.

Figura 6.9 – Selector aplicado em botões.

Selector para texto
No exemplo anterior, utilizamos o <selector> para determinar a imagem de
background do botão, mas poderíamos utilizá-lo também com cores. Por
exemplo, se quisermos mudar a cor do texto do botão quando ele for
pressionado, podemos criar o arquivo res/drawable/selector_button_text.xml
como a seguir:
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:color="@color/app_black" android:state_pressed="true"/>



    <item android:color="@color/app_white"/>
</selector>

E, em seguida, alterar o tema AppButton no res/values/styles.xml:
<style name="AppButton" parent="Widget.AppCompat.Button">
    <item name="android:background">@drawable/selector_button</item>
    <item name="android:textColor">@drawable/selector_button_text</item>
</style>

Execute a aplicação e clique no botão. Você perceberá que a cor do texto do
botão ficará preto enquanto ele estiver pressionado.

Selector para RadioButton
Criaremos mais um selector, agora para um RadioButton. Para isso, crie duas
imagens no Android Studio clicando com o botão direito no diretório res e
selecionando a opção New > Vector Asset. Neste exemplo, utilizaremos as
imagens ic_star e ic_star_border.

Agora crie o selector res/drawable/selector_radio.xml da mesma forma que
fizemos com o botão e deixe-o conforme a seguir:
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:state_checked="false"
        android:drawable="@drawable/ic_star_border" />
    <item
        android:state_checked="true"
        android:drawable="@drawable/ic_star" />
</selector>

Para aplicar o selector no RadioButton, basta utilizar a propriedade android:button
e apontar para o selector @drawable/selector_radio. O resultado ficará conforme a
Figura 6.10:
    <RadioGroup
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">
        <RadioButton
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:button="@drawable/selector_radio"
            android:checked="true"
            android:id="@+id/rb1"
            android:text="Opção 1"/>
        <RadioButton



            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:button="@drawable/selector_radio"
            android:id="@+id/rb2"
            android:text="Opção 2"/>
        <RadioButton
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:button="@drawable/selector_radio"
            android:id="@+id/rb3"
            android:text="Opção 3"/>
    </RadioGroup>

Figura 6.10 – RadioButton customizado.
Aqui temos o mesmo problema do botão. Teríamos que alterar em todos os

RadioButton da aplicação. Para resolver esse problema, é possível definir um
estilo no res/values/styles.xml e sobrescrever o tema-padrão do Android
como a seguir:
<style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
    ...
    <item name="radioButtonStyle">@style/AppRadio</item>
</style>
<style name="AppRadio" parent="Widget.AppCompat.CompoundButton.RadioButton">



    <item name="android:button">@drawable/selector_radio</item>
</style>

Com essa modificação podemos remover a propriedade android:button dos
RadioButton que adicionamos ao layout, pois ele passará a utilizar o estilo que
definimos.

Nota-se que utilizando os estilos e selectors, é possível customizar todos os
componentes do Android, dando um visual personalizado à sua aplicação,
mas mantendo os componentes-padrão.

WebView
Vimos no capítulo anterior que é possível carregar código HTML dentro de
um TextView. E se precisarmos de algo um pouco mais elaborado, podemos
utilizar o componente WebView que nos permite carregar páginas web dentro
da aplicação.

Crie um novo projeto e adicione uma WebView como elemento-raiz do
arquivo de layout, que deve ficar como a seguir.

Application Name WebView
Package Name dominando.android.webview
Activity Name MainActivity

<WebView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/webView"/>

E na MainActivity, podemos usá-la da seguinte forma:
import android.annotation.TargetApi
import android.os.Build
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.webkit.WebResourceRequest
import android.webkit.WebView
import android.webkit.WebViewClient
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        webView.loadUrl("http://www.nglauber.com.br")



        webView.webViewClient = object : WebViewClient() {
            override fun shouldOverrideUrlLoading(view: WebView, url: String): Boolean {
                view.loadUrl(url)
                return false
            }
            @TargetApi(Build.VERSION_CODES.N)
            override fun shouldOverrideUrlLoading(view: WebView,
s                                                 request: WebResourceRequest): Boolean {
                view.loadUrl(request.url.toString())
                return false
            }
        }
    }
}

No método onCreate(Bundle) é chamado o método loadUrl(String) e isso é o
suficiente para carregar a página. Entretanto, se o usuário clicar em algum
link ou até mesmo se a URL informada redirecionar para outra página, o
browser nativo será chamado para executar essa ação. Para evitar isso, foi
definido um WebViewClient onde o método shouldOverrideUrlLoading(WebView,String)
retorna false; isso fará com que, ao solicitar uma nova URL, ela seja carregada
na própria WebView. Porém, a versão desse método foi descontinuada no
Android Nougat (API 24), por isso implementamos o método
shouldOverrideUrlLoading(WebView, WebResourceRequest) para solucionar esse
problema.

A partir do Android Pie (API Level 28), o TLS (Transport Layer Security)
é habilitado por padrão, ou seja, toda comunicação deve ser criptografada.
Por essa razão, nenhuma comunicação em texto plano é permitida por padrão.
Desta forma a aplicação que realizar acesso à rede deve informar
explicitamente os domínios que acessará. A maneira mais simples de habilitar
a comunicação em texto plano na aplicação é definindo o valor true para o
atributo android:usesCleartextTraffic na tag <application> do AndroidManifest.xml.

Como acessaremos a internet a partir da nossa aplicação, é preciso também
declarar a permissão. Execute o aplicativo, e você terá um resultado similar
ao da Figura 6.11:
<manifest ...>
    <uses-permission android:name="android.permission.INTERNET" />
    <application ...
        android:usesCleartextTraffic="true">
        ...



Com a classe WebViewClient é possível determinar quando a página começou
a carregar e quando o carregamento foi concluído, sobrescrevendo os
seguintes métodos:
webView.setWebViewClient(object : WebViewClient() {
    ...
    override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
        super.onPageStarted(view, url, favicon)
    }
    override fun onPageFinished(view: WebView?, url: String?) {
        super.onPageFinished(view, url)
    }
})

Figura 6.11 – Página web carregada em uma WebView.
Também é possível controlar a navegação da WebView usando os métodos

canGoBack(), canGoForward(), goBack() e goForward(). Os dois primeiros verificam se
podemos ir para trás ou para a frente no histórico de navegação, enquanto os
dois últimos servem respectivamente para ir à página anterior ou para a
próxima página. Sobrescreva o método onBackPressed() da activity:
override fun onBackPressed() {
    if (webView.canGoBack()) {
        webView.goBack()



    } else {
        super.onBackPressed()
    }
}

Além de carregar páginas web, é possível carregar arquivos HTML
armazenados dentro do projeto usando a WebView. E um recurso bem
interessante é a possibilidade de capturar funções JavaScript declaradas
dessas páginas. Crie o arquivo app_page.html dentro da pasta
app/src/main/assets do projeto (crie se ela não existir) e deixe-o conforme a
seguir:
<html>
<header>
    <script type="text/javascript">
    function showAndroidToast(s, t) {
        window.dominando.showToast(s, t);
    }
    </script>
</header>
<body>
<H1>Formulário em HTML</h1>
<form name="meuForm">
    Nome: <input type="text" name="txtName"/><br>
    Idade: <input type="text" name="txtAge"/><br>
    <input type="button"
           onclick="showAndroidToast(txtName.value, txtAge.value);"
           value="Enviar">
</form>
</body>
</html>

Veremos como interceptar a função showAndroidToast(s,t) e chamar o método
showToast(String,String) definido dentro da MainActivity. Dessa forma, quando o
usuário pressionar o botão do HTML, o código da activity será executado.
Para isso, deixe o código da activity como a seguir:
import android.os.Bundle
import android.webkit.JavascriptInterface
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)



        val settings = webView.settings
        settings.javaScriptEnabled = true
        webView.addJavascriptInterface(this, "dominando")
        webView.loadUrl("file:///android_asset/app_page.html")
    }
    @JavascriptInterface
    fun showToast(s: String, t: String) {
        Toast.makeText(this, "Nome: $s Idade: $t", Toast.LENGTH_SHORT).show();
    }}

O JavaScript da WebView é habilitado utilizando a propriedade javaScriptEnabled
do objeto WebSettings. Em seguida, é disponibilizada a interface “dominando”
para que o código JavaScript utilizando o método
addJavaScriptInterface(Object,String). Perceba que no JavaScript, a chamada ficou
window.dominando.showToast(), onde “dominando” é o nome da interface em que
esta foi disponibilizada.

Outro detalhe importante é que a annotation @JavascriptInterface é necessária a
partir do Android 4.2. Em versões anteriores, basta que o método seja
público. Execute a aplicação e o resultado será igual ao da Figura 6.12.

Figura 6.12 – Acessando funções JavaScript na WebView.

Chrome Custom Tabs



Quando falamos sobre Intents, percebemos como é fácil abrir o navegador do
Android em uma URL específica. O problema de usar essa abordagem é que
exige o carregamento de outro aplicativo, o que é custoso
computacionalmente falando e faz com que o usuário deixe seu aplicativo.
Outro ponto negativo é que uma vez que você não tem acesso ao outro
aplicativo (o browser nesse caso), você não consegue fazer nenhuma
customização.

Vimos na seção anterior que podemos utilizar o WebView, que nos dá um
controle maior, uma vez que tudo é feito dentro do seu aplicativo. Entretanto,
é necessário fazer vários controles para a navegação, como o que fizemos ao
tratar o redirecionamento de página. O maior problema que temos com essa
abordagem é que o WebView não compartilha a sessão do browser. Então, o
usuário teria que fazer login novamente em todo e qualquer site que ele já
tenha se autenticado no Chrome do aparelho.

As Chrome Custom Tabs juntam os pontos positivos de ambas as
abordagens, pois, além de fornecerem um maior controle da experiência web
dentro do seu aplicativo, também permitem definir transições customizadas,
personalizar título, adicionar ações específicas da aplicação, fazer pré-
carregamento da página para agilizar o carregamento, entre outros.

Como se pode imaginar, esse recurso só funcionará se o usuário possuir o
Google Chrome instalado no aparelho. Caso contrário, será disparada a Intent
para a URL solicitada.

Application Name ChromeTabs
Package Name dominando.android.chrometabs
Activity Name MainActivity

Para usar o Chrome Custom Tabs, crie um novo projeto e adicione a
dependência no build.gradle:
dependencies {
    ...
    implementation 'androidx.browser:browser:1.0.0'
}

No arquivo de layout da activity, adicione um botão com o id @+id/btnTab
que usaremos para exibir a aba ao ser clicado. Em seguida, deixe a activity
como a seguir:
import android.app.PendingIntent
import android.content.Intent



import android.graphics.BitmapFactory
import android.net.Uri
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.browser.customtabs.CustomTabsIntent
import androidx.core.app.ActivityCompat
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        btnTab.setOnClickListener {
            openTab()
        }
    }
    private fun openTab() {
        val url = "http://www.nglauber.com.br"
        val builder = CustomTabsIntent.Builder()
        builder.setToolbarColor(ActivityCompat.getColor(this, R.color.colorPrimary))
        val icon = BitmapFactory.decodeResource(
                resources, android.R.drawable.ic_menu_agenda)
        val pit = PendingIntent.getActivity(
                this, 0, Intent(this, MainActivity::class.java), 0)
        builder.setActionButton(icon, "Ação", pit, true)
        builder.addMenuItem("Menu", pit)
        builder.setStartAnimations(this, R.anim.slide_in_right, R.anim.slide_out_left)
        builder.setExitAnimations(this, R.anim.slide_in_left, R.anim.slide_out_right)
        val customTabsIntent = builder.build()
        customTabsIntent.launchUrl(this, Uri.parse(url))
    }
}

Como podemos observar, é bastante simples criar as custom tabs do
Chrome. Foi criada uma instância da classe CustomTabsIntent.Builder e com ela foi
feita a customização da aba.

Todas as configurações que foram realizadas são opcionais. A cor do título
foi definida utilizando o método setToolbarColor(int). Em seguida, instanciamos
um Bitmap e uma PendingIntent (que como o nome diz, é uma Intent que está
pendente para ser executada), que podem ser utilizadas para adicionar uma
ação ou uma opção de menu na barra de título (ou no overflow menu). A ação
é adicionada por meio do método setActionButton(Bitmap,String,PendingIntent,boolean) e
o menu por meio do método addMenuItem(String,PendingIntent). Aqui utilizamos



uma Intent para a MainActivity do nosso projeto, mas obviamente poderíamos
redirecionar para qualquer outra activity. Falaremos sobre ActionBar e
opções de menu detalhadamente no Capítulo 8.

As animações foram atribuídas utilizando o método setStartAnimations(Context,
int,int) e setExitAnimations(Context,int,int). Essas animações foram definidas como a
seguir (cada uma em seu respectivo arquivo):
// res/anim/slide_in_left.xml
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="@android:integer/config_mediumAnimTime"
    android:fromXDelta="-100%p"
    android:toXDelta="0" />
 
// res/anim/slide_out_left.xml
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="@android:integer/config_mediumAnimTime"
    android:fromXDelta="0"
    android:toXDelta="-100%p" />
 
// res/anim/slide_in_right.xml
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="@android:integer/config_mediumAnimTime"
    android:fromXDelta="100%p"
    android:toXDelta="0" />
 
// res/anim/slide_out_right.xml
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="@android:integer/config_mediumAnimTime"
    android:fromXDelta="0"
    android:toXDelta="100%p" />

Falaremos sobre animações no Capítulo 26, mas as duas primeiras
animações descritas acima farão com que a activity atual deslize para a
esquerda até sair da tela, ao mesmo tempo em que a aba que está sendo aberta
aparece na tela deslizando na mesma direção. As duas outras animações
fazem o efeito contrário, deslizando para a direita.

Execute a aplicação e a aba será exibida conforme a Figura 6.13. Ao clicar
nas ações que adicionamos, elas farão com que a tela inicial do aplicativo seja
exibida.



Figura 6.13 – Chrome Custom Tab.

Views customizadas
Na maioria das vezes, os componentes de que precisamos já estão disponíveis
na API do Android ou alguém já criou algo que atende às nossas
necessidades. Inclusive existe um site chamado Android Arsenal
(http://android-arsenal.com) onde é possível buscar por componentes
disponíveis. É importante checar a licença destes componentes para não ter
problemas futuros, principalmente se você trabalha em projetos para grandes
empresas.

E se você quiser fugir um pouco dos componentes-padrão e criar algo
diferente? Podemos definir componentes customizados criando uma classe
que herde de View e desenhar o que quisermos em um canvas. Para
exemplificar esse conceito, criaremos uma View que representará um “Jogo da
Velha”. Apesar de ser uma classe simples, envolverá muitos conceitos
importantes.

Crie um novo projeto, adicione a classe JogoDaVelhaView e deixe-a como a
seguir.

Application Name CustomView



Package Name dominando.android.customview
Activity Name MainActivity

import android.content.Context
import android.graphics.*
import android.util.AttributeSet
import android.util.TypedValue
import android.view.View
import android.view.ViewGroup
 
class JogoDaVelhaView @JvmOverloads constructor(
        context: Context,
        attrs: AttributeSet? = null,
        style: Int = 0) : View(context, attrs, style) {
 
    private var tamanho: Int = 0
    private var vez: Int = XIS
    private var tabuleiro = Array(3) { IntArray(3) }
    private val rect: RectF = RectF()
    private lateinit var paint: Paint
    private lateinit var imageX: Bitmap
    private lateinit var imageO: Bitmap
 
    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        paint = Paint(Paint.ANTI_ALIAS_FLAG)
        paint.style = Paint.Style.FILL
        imageX = BitmapFactory.decodeResource(resources, R.drawable.x_mark)
        imageO = BitmapFactory.decodeResource(resources, R.drawable.o_mark)
    }
 
    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        tamanho = when (layoutParams.width) {
             ViewGroup.LayoutParams.WRAP_CONTENT -> {
                (TypedValue.applyDimension(
                        TypedValue.COMPLEX_UNIT_DIP, 48F,
                        resources.displayMetrics
                ) * 3).toInt()
            }
            ViewGroup.LayoutParams.MATCH_PARENT ->
                Math.min(
                    View.MeasureSpec.getSize(widthMeasureSpec),
                    View.MeasureSpec.getSize(heightMeasureSpec)
                )
            else -> layoutParams.width



        }
        setMeasuredDimension(tamanho, tamanho)
    }
 
    override fun onDraw(canvas: Canvas?) {
        super.onDraw(canvas)
        val quadrante = (tamanho / 3).toFloat()
        val tamanhoF = tamanho.toFloat()
        // Desenhando as linhas
        paint.color = Color.BLACK
        paint.strokeWidth = 3F
        // Verticais
        canvas?.drawLine(quadrante, 0F, quadrante, tamanhoF, paint)
        canvas?.drawLine(quadrante * 2, 0F, quadrante * 2, tamanhoF, paint)
        // Horizontais
        canvas?.drawLine(0F, quadrante, tamanhoF, quadrante, paint)
        canvas?.drawLine(0F, quadrante * 2, tamanhoF, quadrante * 2, paint)
 
        tabuleiro.forEachIndexed { rowIndex, rowValue ->
            rowValue.forEachIndexed { columnIndex, columnValue ->
                val x = (columnIndex * quadrante)
                val y = (rowIndex * quadrante)
                rect.set(x, y, x + quadrante, y + quadrante)
                if (columnValue == XIS) {
                    canvas?.drawBitmap(imageX, null, rect, null)
                } else if (columnValue == BOLA) {
                    canvas?.drawBitmap(imageO, null, rect, null)
                }
            }
        }
    }
    companion object {
        const val XIS = 1
        const val BOLA = 2
    }
}

Criamos uma subclasse de View, na qual definimos o atributo tamanho, que
indicará a largura do tabuleiro do jogo; uma vez que será um quadrado, esse
valor também representará a altura. O atributo vez indicará se é a vez do “X”
ou do “O” jogar. Em seguida, temos o tabuleiro que armazenará as jogadas
realizadas na forma de um array bidimensional (ou um array de arrays). No
Kotlin representamos isso como um Array de IntArray, onde o Array são as linhas
e o IntArray são as colunas. Por exemplo, tabuleiro[2][1] representa a terceira linha



e a segunda coluna (lembrando que o índice começa do zero).
0,0 0,1 0,2
1,0 1,1 1,2
2,0 2,1 2,2

O atributo rect representa um retângulo onde será desenhada cada jogada. Já
o atributo paint será usado para desenhar as linhas do tabuleiro. Por fim, os
bitmaps imageX e imageO serão desenhados na View de acordo com o tabuleiro.

Ao criarmos uma subclasse de View, devemos implementar pelo menos uma
das versões de construtor disponíveis:

• View(Context)
• View(Context, AttributeSet)
• View(Context, AttributeSet, int)
Temos que utilizar um dos dois últimos para que nossa view possa ser

adicionada em arquivos de layout e para ser visualizada em tempo de projeto
no editor visual. Graças ao recurso de parâmetros default do Kotlin, fizemos
isso com apenas uma linha. O AttributeSet armazena os atributos definidos no
arquivo de layout, enquanto o terceiro construtor recebe como último
parâmetro o id do estilo (caso você queira aplicar um estilo a sua view).

KOTLINxJAVA: Kotlin dá suporte a valores-padrão em construtores, o que
diminui significativamente (ou em muitos casos remove) a necessidade de overload
(sobrecarga). Porém, como estamos interagindo com a API do Android que é em
Java, devemos adicionar a anotação @JvmOverloads.

O método onAttachedToWindow() é chamado quando a View se torna ativa, ou
seja, assim que ela é inserida em um ViewGroup. Nesse momento, você deve
alocar os recursos de que sua view necessita; neste caso, o objeto Paint e as
duas imagens. Adicione duas imagens chamadas x_mark.png e o_mark.png na
pasta res/drawable2. Podemos utilizar o método onDetachFromWindow() para
liberar os recursos alocados, pois nesse momento a view está sendo removida
da ViewGroup onde ela está inserida.

Cada View é responsável por determinar seu tamanho, e estamos fazendo
isso no método onMeasure(int, int). Nesse método, devemos chamar
setMeasureDimension(int, int) para determinar a largura e a altura do componente.
Se esse tamanho mudar em tempo de execução, temos que avisar ao ViewGroup



(onde a view está) que isso aconteceu chamando o método requestLayout(). Com
isso, o ViewGroup chamará o método onMeasure(int, int) de todos os seus filhos
para recalcular e reposicionar as views.

Em nosso caso, estamos checando se a largura da view foi determinada
como wrap_content no arquivo de layout; nesse caso, determinamos um tamanho
mínimo de 48dp (que é a menor área clicável sugerida pelo Android) vezes 3
(que é a quantidade de quadrantes). Se o valor for match_parent, pegamos o
menor valor entre a largura e a altura para que nossa view não exceda o
tamanho da tela quando o aparelho estiver em landscape. E, por fim, se
passarmos uma largura fixa, só a associaremos ao atributo tamanho.

O método mais importante é o onDraw(Canvas), por meio do qual literalmente
desenhamos o conteúdo do nosso componente na tela. Com o objeto Canvas
recebido como parâmetro, podemos desenhar textos, linhas, imagens e
formas geométricas. Devemos pensar nesse objeto como se fosse um quadro
em branco no qual vamos pintar algo, e para isso precisamos de um pincel,
que é representado pela classe Paint.

No método onDraw(Canvas) é feito inicialmente o cálculo do tamanho de cada
quadrante do tabuleiro. Em seguida, configuramos o objeto Paint com a cor e a
largura das linhas que iremos pintar. E no método drawLine(int, int, int, int, Paint)
desenhamos as quatro linhas, passando as posições x e y, inicial e final.
Lembrando que a posição de y aqui é diferente do sistema cartesiano
convencional, uma vez que seu valor cresce para baixo.

Para finalizar, no onDraw(Canvas) varremos nossa matriz usando dois
forEachIndexed para desenhar as jogadas realizadas. Dentro dessa estrutura,
criamos um objeto Rect que representa um retângulo e que servirá para que a
imagem do “X” ou do “O” seja desenhada dentro dele independentemente do
tamanho real da imagem. Uma curiosidade aqui é que, para criá-lo, passamos
às posições x e y, inicial e final (e não largura e altura, como se poderia
imaginar). Por fim, checamos se no tabuleiro está preenchido com XIS ou BOLA
e desenhamos a imagem correspondente usando o método drawBitmap(Bitmap,
Rect, Rect, Paint).

KOTLINxJAVA: A função forEachIndexed faz parte da biblioteca-padrão do Kotlin e
permite iterar sobre os elementos de uma lista ou array, fornecendo também o
índice da posição corrente do elemento na lista.



KOTLINxJAVA: A função forEach também faz parte da biblioteca-padrão do
Kotlin e permite iterar sobre uma lista. Dentro do bloco de código, o elemento
atual do laço é a constante it.

Adicione a view recém-criada no arquivo de layout
res/layout/activity_main.xml conforme a seguir. O resultado deve ficar como
mostra a Figura 6.14:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:id="@+id/meuLayout">
    <dominando.android.customview.JogoDaVelhaView
        android:layout_width="200dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:id="@+id/jogoDaVelha"/>
</LinearLayout>

Figura 6.14 – View customizada.
Porém, como você deve ter percebido, a iteração ainda não está

funcionando; para isso devemos tratar os eventos de toque diretamente na



View. Declare na classe JogoDaVelhaView o atributo detector do tipo GestureDetector e
o inicialize no onAttachedToWindow():
// Declare junto com os outros atributos
private lateinit var detector: GestureDetector
// Inicialize no onAttachedToWindow()
detector = GestureDetector(context, VelhaTouchListener())
 
// Adicione/sobrescreva o método onTouchEvent
override fun onTouchEvent(event: MotionEvent?): Boolean {
    return detector.onTouchEvent(event)
}
 
// Adicione a classe a seguir (dentro das chaves da classe JogoDaVelhaView)
inner class VelhaTouchListener : GestureDetector.SimpleOnGestureListener() {
    override fun onDown(e: MotionEvent?): Boolean {
        return true
    }
    override fun onSingleTapUp(e: MotionEvent?): Boolean {
        var vencedor = gameOver()
        if (e?.action == MotionEvent.ACTION_UP && vencedor == VAZIO) {
            val quadrante = tamanho / 3
            val linha = (e.y / quadrante).toInt()
            val coluna = (e.x / quadrante).toInt()
            if (tabuleiro[linha][coluna] == VAZIO) {
                tabuleiro[linha][coluna] = vez
                vez = if (vez == XIS) BOLA else XIS
                invalidate()
                vencedor = gameOver()
                if (vencedor != VAZIO) {
                    listener?.fimDeJogo(vencedor)
                }
                return true
            }
        }
        return super.onSingleTapUp(e)
    }
}

O método onTouchEvent(MotionEvent) é disparado quando tocamos na view ou
quando deslizamos e retiramos o dedo da tela. Nele, estamos delegando o
trabalho para o GestureDetector, que, como o próprio nome diz, detecta gestos
sobre a view e os delega para uma instância da classe VelhaTouchListener. Nessa
classe, estamos tratando dois eventos: o onDown(MotionEvent), onde apenas



retornamos true para informar que vamos tratar esse toque, e o
onSingleTapUp(MotionEvent) que é chamado quando liberamos o dedo sobre a
View.

Chamamos o método gameOver() para saber se o jogo acabou e se há algum
vencedor (veremos esse método a seguir). Caso não exista um vencedor,
checamos em que quadrante o usuário clicou baseado na posição x e y e
então verificamos se aquela posição do tabuleiro está vazia. Em caso positivo,
marcamos no tabuleiro com o valor do atributo vez e atualizamos esse atributo
para indicar de quem é a próxima jogada.

O método invalidate() marca nossa view para ser redesenhada pelo framework
de UI do Android assim que possível. E isso fará com que o método
onDraw(Canvas) seja chamado novamente, fazendo com que ela reflita o novo
estado do tabuleiro. Após efetuar a jogada, chamamos o método gameOver()
novamente para saber se o jogo acabou. Caso exista um vencedor ou tenha
havido um empate, notificaremos a quem interessar que o jogo acabou e seu
respectivo resultado.

Seu projeto deve estar com erros nesse momento, mas vamos corrigi-los
agora. Adicione as constantes a seguir dentro da classe JogoDaVelhaView:
companion object {
    ...
    const val VAZIO = 0
            const val EMPATE = 3
}

O valor zero para a constante VAZIO deve ser usado, uma vez que, quando
inicializamos o tabuleiro, ele começa preenchido com zero. E a constante
EMPATE será usada pelo método gameOver() para informar que o jogo terminou
empatado. Agora adicione a interface JogoDaVelhaListener (também dentro da
classe JogoDaVelhaView):
interface JogoDaVelhaListener {
    fun fimDeJogo(vencedor : Int)
}

Ela contém apenas o método fimDejogo(int) e será usada para notificar nossa
activity que o jogo acabou e seu respectivo resultado. Agora declare a
propriedade listener do tipo dessa interface na classe JogoDaVelhaView:
// Adicione esse atributo
var listener : JogoDaVelhaListener? = null

Finalmente, adicione o método gameOver():



private fun gameOver() : Int {
    // Horizontais
    if (ganhou(tabuleiro[0][0], tabuleiro[0][1], tabuleiro[0][2])) {
        return tabuleiro[0][0]
    }
    if (ganhou(tabuleiro[1][0], tabuleiro[1][1], tabuleiro[1][2])) {
        return tabuleiro[1][0]
    }
    if (ganhou(tabuleiro[2][0], tabuleiro[2][1], tabuleiro[2][2])) {
        return tabuleiro[2][0]
    }
    // Verticais
    if (ganhou(tabuleiro[0][0], tabuleiro[1][0], tabuleiro[2][0])) {
        return tabuleiro[0][0]
    }
    if (ganhou(tabuleiro[0][1], tabuleiro[1][1], tabuleiro[2][1])) {
        return tabuleiro[0][1]
    }
    if (ganhou(tabuleiro[0][2], tabuleiro[1][2], tabuleiro[2][2])) {
        return tabuleiro[0][2]
    }
    // Diagonais
    if (ganhou(tabuleiro[0][0], tabuleiro[1][1], tabuleiro[2][2])) {
        return tabuleiro[0][0]
    }
    if (ganhou(tabuleiro[0][2], tabuleiro[1][1], tabuleiro[2][0])) {
        return tabuleiro[0][2]
    }
    // Existem espaços vazios
    if (tabuleiro.flatMap { it.asList() }.any { it == VAZIO }) {
        return VAZIO
    }
    return EMPATE
}
 
private fun ganhou(a : Int, b : Int, c : Int) = (a == b && b == c && a != VAZIO)

A função flatMap nos permite converter uma sequência de dados em uma
nova sequência plana. No nosso exemplo convertemos um Array de IntArray
para um List<Int> ao chamarmos o método toList() de cada array que lemos no
flatMap. Ao final utilizamos o método any para checar se havia algum espaço
vazio.

No método gameOver() checamos cada uma das oito combinações de vitórias
possíveis. Para cada combinação temos que ver se a primeira posição é igual



à segunda e se a segunda é igual à terceira. Se as três posições tiverem
valores iguais e eles forem diferentes de VAZIO (ou seja, zero), temos um
vencedor e retornamos ele.

Caso não haja um vencedor, verificaremos se existem espaços vazios no
tabuleiro; se houver, retornaremos VAZIO; caso contrário, é sinal de que houve
um EMPATE.

Com essas modificações sua view não deve mais conter erros, então
execute a aplicação e veja o comportamento. O resultado deve ficar
semelhante ao da Figura 6.15.

Figura 6.15 – Jogo da velha em execução.
Muito bom! Porém, quando o jogo acaba, temos que sair da aplicação e

abrir novamente para jogar de novo. E obviamente isso não é o desejado.
Adicione no arquivo de layout um botão para reiniciar a partida:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:id="@+id/meuLayout">
    <dominando.android.customview.JogoDaVelhaView
        android:layout_width="200dp"



        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:id="@+id/jogoDaVelha"/>
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Reiniciar"
        android:id="@+id/button"
        android:layout_gravity="center_horizontal"/>
</LinearLayout>

Agora faça alguns ajustes na MainActivity que ficará assim:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Toast
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        jogoDaVelha.listener = object : JogoDaVelhaView.JogoDaVelhaListener {
            override fun fimDeJogo(vencedor: Int) {
                val mensagem = when (vencedor) {
                    JogoDaVelhaView.XIS -> "X venceu"
                    JogoDaVelhaView.BOLA -> "O venceu"
                    else -> "Empatou"
                }
                Toast.makeText(this@MainActivity, mensagem, Toast.LENGTH_LONG).show()
            }
        }
        button.setOnClickListener { jogoDaVelha.reiniciarJogo() }
    }
}

Estamos definindo o listener da JogoDaVelhaView passando uma instância da
interface JogoDaVelhaListener. Assim, quando o jogo acabar, o método
fimDeJogo(int) será invocado e exibiremos um Toast com o resultado. Além disso,
no clique do botão, chamamos o método reiniciarJogo(), que deve ser criado na
classe JogoDaVelhaView, conforme mostrado a seguir:
fun reiniciarJogo() {
    tabuleiro = Array(3) { IntArray(3) }
    invalidate()
}



Ele apenas reinicializa o tabuleiro e invalida a JogoDaVelhaView para que ela seja
redesenhada. Teste a aplicação novamente e agora você receberá uma
mensagem quando o jogo acabar e poderá reiniciá-lo como podemos ver na
Figura 6.16.

Figura 6.16 – Exibindo o resultado do jogo.
Agora temos um jogo totalmente funcional, mas e se girarmos o aparelho?

Salvando o estado da view
Assim como em uma Activity, uma View pode ser destruída a qualquer
momento, e para que a informação que ela exibe não se perca, deve-se manter
seu estado. Para fazer isso, a classe JogoDaVelhaView deve possuir um id (no
arquivo de layout), declarar uma inner class que herda de View.BaseSavedState
para armazenar o seu estado e implementar os métodos onSaveInstanceState() e
onRestoreInstanceState(Parceable). Adicione o código a seguir na classe
JogoDaVelhaView:
override fun onSaveInstanceState(): Parcelable {
    val p = super.onSaveInstanceState()
    return EstadoJogo(p, vez, tabuleiro)
}



override fun onRestoreInstanceState(state: Parcelable?) {
    val estado = state as EstadoJogo
    super.onRestoreInstanceState(estado.superState)
    vez = estado.vez
    tabuleiro = estado.tabuleiro
    invalidate()
}
 
class EstadoJogo : BaseSavedState {
    var vez: Int
    var tabuleiro: Array<IntArray>
 
    constructor(superState: Parcelable?, vez: Int, tabuleiro: Array<IntArray>) : super(superState) {
        this.vez = vez
        this.tabuleiro = tabuleiro
    }
    constructor(p: Parcel?) : super(p) {
        vez = p?.readInt() ?: XIS
        tabuleiro = Array(3) { IntArray(3) }
        tabuleiro.forEach { p?.readIntArray(it) }
    }
    override fun writeToParcel(out: Parcel?, flags: Int) {
        super.writeToParcel(out, flags)
        out?.writeInt(vez)
        tabuleiro.forEach { out?.writeIntArray(it) }
    }
    companion object CREATOR : Parcelable.Creator<EstadoJogo> {
        override fun createFromParcel(source: Parcel?) = EstadoJogo(source)
        override fun newArray(size: Int) = arrayOf<EstadoJogo>()
    }
}

A forma de salvar o estado da View é um pouco diferente da Activity; em vez
de usarmos um objeto Bundle, retornamos um objeto Parcelable. No método
onSaveInstanceState(), obtivemos o estado da superclasse, criamos um novo objeto
EstadoJogo (que herda de BaseSavedState) passando esse estado e os atributos vez e
tabuleiro. Já no método onRestoreInstanceSate(Parcelable), fizemos um cast do estado
recebido como parâmetro e chamamos o método da superclasse passando o
estado da superclasse usando superState. Depois, setamos os atributos da classe
com os valores do estado recuperado. A classe interna EstadoJogo herda de
BaseSavedState, que implementa a interface Parcelable.

Feitas essas mudanças, execute a aplicação e rotacione o aparelho. Você
perceberá que o estado do jogo se manterá.



Atributos personalizados
O jogo está completo e funcionando, mas agora forneceremos a possibilidade
de alterar a cor e a largura da barra do tabuleiro por meio de propriedades
personalizadas que podem ser usadas no arquivo de layout.

Abra o arquivo res/values/styles.xml e adicione a tag <declare-styleable>
conforme a seguir:
<resources>
...
    <declare-styleable name="JogoDaVelhaView">
        <attr name="corDaBarra" format="color"/>
        <attr name="larguraDaBarra" format="dimension"/>
    </declare-styleable>
</resources>

Temos duas novas propriedades: corDaBarra e larguraDaBarra. A primeira é do
tipo color, e a segunda do tipo dimension. Temos a possibilidade de usar outros
tipos: como boolean, float, integer, string, entre outros.

Implemente a lógica de ler esses dois atributos, caso eles tenham sido
especificados no arquivo de layout onde a view está declarada. Adicione os
atributos corDaBarra e larguraBarra na classe JogoDaVelhaView que inicializaremos no
construtor conforme a seguir:
// Adicione esses atributos
var corDaBarra : Int
var larguraBarra : Float
 // Inicialize...
init {
    val styledAttrs = context.obtainStyledAttributes(attrs, R.styleable.JogoDaVelhaView)
    corDaBarra = styledAttrs.getColor(R.styleable.JogoDaVelhaView_corDaBarra, Color.BLACK)
    larguraBarra = styledAttrs.getDimension(R.styleable.JogoDaVelhaView_larguraDaBarra, 3F)
    styledAttrs.recycle()
}

As propriedades personalizadas foram obtidas chamando o método
obtainStyledAttributes(AttributeSet, int), passando como parâmetro o
R.styleable.JogoDaVelhaView, que definimos no styles.xml. Esse método retorna um
TypedArray com o qual tentaremos obter a cor da barra usando o método
getColor(int, int) e a largura da barra usando o método getDimension(int, int). Ambos
os métodos recebem como parâmetro o id da propriedade e um valor default
caso ela não tenha sido definida. Agora altere a chamada a seguir do método
onDraw(Canvas).



// De
paint.color = Color.BLACK
paint.strokeWidth = 3F
// Para
paint.color = corDaBarra
paint.strokeWidth = larguraBarra

Para testar, vá até o arquivo de layout, adicione o xmlns:ngvl (ngvl são minhas
iniciais, você pode usar o que quiser aqui) para que o Android consiga
identificar os atributos que foram adicionados e, em seguida, adicione as
propriedades ngvl:corDaBarra e ngvl:larguraDaBarra:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:ngvl="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:id="@+id/meuLayout">
    <dominando.android.customview.JogoDaVelhaView
        android:layout_width="200dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:id="@+id/jogoDaVelha"
        ngvl:corDaBarra="#FF0000"
        ngvl:larguraDaBarra="10dp" />
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Reiniciar"
        android:id="@+id/button"
        android:layout_gravity="center_horizontal"/>
</LinearLayout>

O resultado deve ficar como a Figura 6.17.



Figura 6.17 – View com atributos customizados.
Este foi mais um longo capítulo no qual vimos vários conceitos

importantes. Caso algum deles não tenha ficado claro, tente ler novamente, e
caso ainda tenha dúvidas, busque outros exemplos na internet, pois seria
impossível colocar tudo aqui. Não falamos de todos os componentes ainda,
mas procuramos listar os mais importantes e que são utilizados com mais
frequência.

1 Se preferir, baixe a imagem no repositório do livro no GitHub.
2 Em um projeto real você precisaria ter as imagens para cada densidade de tela.



CAPÍTULO 7
MVP (Model View Presenter)

Até agora implementamos toda a lógica dos nossos aplicativos na própria
activity. Entretanto, à medida que um projeto cresce é recomendado separar a
lógica de negócio da interface gráfica para facilitar a manutenção e o
entendimento do código. Atualmente, o padrão MVP (Model View Presenter)
é uma das formas mais utilizadas para organizar a camada de apresentação de
aplicativos Android deixando-os mais modularizados e fáceis de manter.
Neste capítulo faremos uma rápida introdução a esse padrão, pois o
utilizaremos nos nossos próximos aplicativos que desenvolveremos.

Model
A camada de modelo é basicamente composta por todo o código não
relacionado à representação visual do seu aplicativo. Ou seja, as classes
responsáveis por persistir dados, acessar a internet, acessar recursos de
hardware etc. Todas elas fazem parte da camada de modelo. É importante
ressaltar que o MVP é um padrão para organizar a camada de apresentação, o
modelo pode utilizar diversos outros padrões para deixá-lo mais robusto.

View
A view possui apenas dois papéis: disparar eventos do usuário ou do sistema
para o presenter, e receber chamadas do presenter para atualizar o conteúdo
na tela. No Android, a view normalmente é implementada por uma activity
(ou fragment que falaremos no próximo capítulo) ou um dos seus
componentes visuais.

Presenter
No presenter fica a lógica de apresentação da aplicação, pois ele intermediará



a comunicação entre a view e o model. Entretanto, o presenter não deve
possuir dependências de frameworks da plataforma. Ou seja, ele deve ser
puramente Kotlin (ou Java). Isso é possível definindo interfaces a serem
implementadas tanto pelo model, quanto pela view. O grande benefício da
utilização dessas interfaces é que caso a implementação da view ou do model
sejam modificados, o presenter permanece inalterado, pois ele não interage
diretamente com nenhuma implementação específica.

Comunicação entre as camadas
Para entendermos melhor como funciona esse padrão, observe a Figura 7.1.
Podemos notar que a view não se comunica diretamente com o model, bem
como o model não conhece nada sobre a view. Quem faz a intermediação
dessa conversa é o presenter.

Figura 7.1 – Arquitetura do padrão MVP.
A título de exemplo, digamos que o seu aplicativo tenha que efetuar uma

pesquisa na internet. O usuário digita o termo a ser pesquisado, pressiona um
botão e a busca é realizada. Após alguns instantes, o resultado é exibido na
tela. Vejamos como esse caso de uso seria implementado utilizando o padrão
MVP.

Primeiro definiríamos uma interface com as ações que a View realizará. Ela
exibirá uma tela de “buscando resultados”, e quando a busca for concluída,
essa mensagem é fechada e os resultados são exibidos. Caso algo dê errado,
uma mensagem de erro deve ser exibida:
interface InternetSearchView {
    fun showProgress()
    fun hideProgress()
    fun showResults(results: List<SearchResult>)
    fun showSearchError()
}



Como podemos observar, apenas olhando essa interface, já temos uma ideia
do que nossa tela faz, sem termos que olhar sua real implementação. O
método showProgress() exibiria algum feedback visual para o usuário
informando que a busca está sendo realizada. Após receber o resultado da
busca, o método hideProgress() seria chamado e os resultados seriam exibidos
pelo método showResults(List<SearchResult>). Se algum erro acontecesse nesse
processo, o método showSearchError() seria exibido.

Também devemos declarar uma interface para definir um contrato com
quem realizará a pesquisa, pois a implementação poderia mudar e não afetaria
as demais camadas:
interface InternetSearch {
    fun search(term: String, listener: SearchResultListener)
}
interface SearchResultListener {
    fun onSearchResult(results: List<SearchResult>)
}

A interface InternetSearch deverá ser implementada pela classe que realizará a
busca, e a SearchResultListener será utilizada pela classe que ficará aguardando a
resposta. Perceba que o método da interface InternetSearch recebe como
parâmetro, além do termo a ser pesquisado, um listener (callback, observer,
como preferir) que é do tipo da interface SearchResultListener. Assim, a busca
pode ser feita de forma assíncrona (esse assunto será abordado no Capítulo
12) e o resultado é retornado posteriormente.

Finalmente teríamos o presenter que une essas duas peças:
class InternetSearchPresenter(
            val view: InternetSearchView,
            val internetSearch: InternetSearch) {
    fun search(term: String) {
        view.showProgress()
        try {
            internetSearch.search(term, object: SearchResultListener {
                override fun onSearchResult(results: List<SearchResult>) {
                    view.hideProgress()
                    view.showResults(results)
                }
            })
        } catch (e: Exception) {
            view.hideProgress()
            view.showSearchError()



        }
    }
}

O presenter recebe como parâmetro a view e o model, mas perceba que ele
recebe apenas a interface. O presenter não sabe como a implementação é
feita, ele apenas confia que o objeto passado como parâmetro segue o
contrato estabelecido pela interface.

No método search(String), pedimos que a view exiba a tela de progresso e,
logo em seguida, realizamos a pesquisa invocando internet.search(String,
SearchResultListener). Quando ela for concluída, o método
onSearchResult(List<SearchResult>) será disparado, então a tela de progresso é
fechada e o resultado exibido.

Em qual classe implementará as interfaces InternetSearch e InternetSearchView? A
primeira pode ser qualquer classe capaz de realizar a busca na web:
class GoogleInternetSearch: InternetSearch {
    override fun search(term: String, listener: SearchResultListener) {
        // Faça a busca...
        // Devolva os resultados
        listener.onSearchResult(results)
    }
}

Para o presenter não importa como essa busca é feita, o que importa é a
interface. Nesse exemplo a classe GoogleInternetSearch faria uma busca real na
internet e retornaria o resultado (mas não listamos aqui). Abstraindo a forma
como a busca é feita, podemos facilmente trocar o mecanismo de busca sem
que a camada de apresentação seja afetada.

Como mencionamos, a classe que implementaria a view, seria uma activity,
como listado a seguir:
class InternetSearchActivity: AppCompatActivity(), InternetSearchView {
    val presenter = InternetSearchPresenter(this, GoogleInternetSearch())
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        buttonSearch.setOnClickListener {
            presenter.search(editText.text.toString())
        }
    }
    override fun showProgress() {
        // Exibir mensagem de progresso (ex.: procurando...)



    }
    override fun hideProgress() {
        // Ocultar progresso...
    }
    override fun showResults(results: List<SearchResult>) {
        // Exibir o resultado (em uma RecyclerView, por exemplo)
    }
    override fun showSearchError() {
        // Exibir mensagem de erro
    }
}

A activity está instanciando o presenter passando as reais implementações
das interfaces que ele necessita para realizar seu trabalho. Isto está sendo
feito na activity, mas isso poderia (e deve) ser feito de outra forma, com uma
biblioteca de injeção de dependência, por exemplo. Falaremos sobre esse
assunto no Capítulo 10, mas deixamos dessa forma para facilitar o
entendimento.

Ao pressionar o botão, o presenter é invocado para executar a lógica da
busca, que, como vimos, envolve os métodos da view e do model.

Variações na implementação do padrão MVP
De acordo com a necessidade, o padrão MVP pode ser implementado de uma
forma um pouco diferente. Alguns desenvolvedores, por exemplo, gostam de
definir uma interface também para o presenter, e não só para a view e o
model como fizemos aqui. Outra implementação bem comum é não passar a
view como parâmetro do presenter, e sim ter os métodos attach(View) e
detach(View), o que pode ser muito útil para sincronizar os ciclos de vida do
presenter e da activity.

Porém, independente dessas nuances, a ideia do MVP é a mesma. Separar a
lógica de apresentação dos dados da lógica interna da aplicação como regras
de negócio, persistência de dados, acesso à rede etc.

Essa foi uma breve introdução ao padrão MVP que será bastante útil para
entendermos os próximos capítulos desenvolvidos no decorrer do livro.



CAPÍTULO 8
Fragments

Neste capítulo falaremos sobre fragments, um recurso fundamental em
qualquer aplicativo Android. Os fragments permitem componentizar pedaços
de uma activity, de modo que eles possam ser reutilizados em outras telas ou
para compor um layout maior, como é o caso de um tablet.

Fragment
Um fragment é uma porção de tela que pode ser componentizada para ser
reutilizada em outras partes da aplicação, ou serem combinados para compor
um layout mais complexo. Em tablets, por exemplo, as telas são maiores e o
ideal é aproveitar melhor toda a área disponível. Um fragment pode ser
considerado uma sub-activity que tem seu próprio ciclo de vida, layout,
eventos etc. Um exemplo clássico do seu uso é apresentado na Figura 8.1.

Figura 8.1 – Aplicação dos fragments. Fonte:



http://developer.android.com/guide/components/fragments.html.
O exemplo da figura apresenta uma lista de itens, na qual ao clicar sobre

um item dessa lista os seus respectivos detalhes são exibidos. Quando a
aplicação estiver executando em um tablet, haverá apenas uma activity com
dois fragments (a listagem e o detalhe), no entanto, ao executá-la em um
smartphone, serão utilizadas duas activities, e cada uma delas com um
fragment.

Existem duas formas de adicionar um fragment a uma activity: a primeira é
por meio do uso da tag <fragment> em um arquivo de layout, em que é preciso
informar o nome da classe do fragment; e a outra forma é instanciando o
fragment em tempo de execução e adicionando-o ao layout
programaticamente.

Todo fragment deve obrigatoriamente estar contido em uma activity, e seus
ciclos de vida andam em paralelo. Ou seja, quando uma activity é pausada,
todos os seus fragments são pausados, e o mesmo acontece com os demais
eventos do ciclo de vida da activity. Entretanto, o fragment contém mais
alguns métodos, como mostrado na Figura 8.2.

Figura 8.2 – Ciclo de vida de um fragment.



Os métodos onCreate(Bundle), onStart(), onResume(), onPause(), onStop() e onDestroy() do
fragment executam logo após os métodos de mesmo nome da activity. O
método onAtach(Activity), por sua vez, é chamado logo que o fragment é
anexado à activity e antes que sua view seja criada. No método
onCreateView(LayoutInflater,ViewGroup,Bundle) é onde deve ser carregado o arquivo de
layout do fragment e retornar a view que representa seu conteúdo visual. O
método onActivityCreated(Bundle), como o próprio nome diz, é disparado quando a
activity é criada. Por fim, o método onDestroyView() é chamado quando a view
do fragment é destruída e o onDetach() quando o fragment é removido da
activity.

Assim como na activity, ao mudar a orientação de tela do aparelho, por
padrão o fragment é destruído. Entretanto, é possível manter a instância do
fragment passando o valor true para a propriedade retainInstance, e nesse caso, o
objeto fragment será mantido assim como seus atributos. Mesmo assim, a
view é sempre destruída, assim o ciclo de vida recomeça, mas os métodos
onCreate() e onDestroy() não são chamados.

Os fragments foram introduzidos no Android 3.0 (API Level 11) e devem
ser utilizados por meio da API de compatibilidade disponibilizada pelo
Google. Ao criar um projeto no Android Studio, essa dependência já é
adicionada automaticamente, como pode ser observado no arquivo
build.gradle do seu projeto, que deve ter algo semelhante ao mostrado a
seguir:
dependencies {
    implementation 'androidx.appcompat:appcompat:1.0.2'
    ...
}

Nessa biblioteca existe o pacote androidx.fragment.app com as classes da
API de fragments que serão usadas no exemplo deste capítulo. As principais
são: Fragment, ListFragment, FragmentManager e FragmentTransaction. Essas classes
também estão no pacote android.app, mas elas foram marcadas como
deprecated (depreciadas) no Android Pie. Portanto, em todo o livro, devem-
se sempre usar as classes do pacote androidx.fragment.app.

Projeto de hotéis com MVP
O projeto que será iniciado neste capítulo será evoluído durante todo o livro,



por isso, antes de começar a implementação, é preciso entender seu
propósito.

Será criado um cadastro de hotéis, no qual na tela principal haverá uma lista
dos hotéis cadastrados. Ao clicar em um hotel dessa lista, seus detalhes serão
exibidos. Quando a aplicação executar em smartphones, duas activities serão
utilizadas com um fragment cada, mas ao executar em tablets, a listagem e os
detalhes do hotel serão exibidos em uma única activity com dois fragments.

Application Name Fragments
Package Name dominando.android.fragments
Activity Name HotelActivity

Crie um novo projeto e adicione a classe Hotel, que deve ficar como a seguir:
data class Hotel(
        var id: Long = 0,
        var name: String = "",
        var address: String = "",
        var rating: Float = 0.0F
) {
    override fun toString(): String = name
}

Esta classe tem apenas quatro atributos que representam respectivamente:
id, nome, endereço e a classificação do hotel em estrelas. Note que o método
toString() foi sobrescrito para poder visualizar o nome do hotel na ListView que
será implementado a seguir.

Este projeto utilizará inicialmente o padrão MVP que foi explicado
brevemente no capítulo anterior. Neste capítulo os objetos Hotel serão
armazenados em memória, mas no Capítulo 10 eles serão persistidos em um
banco de dados. Então a aplicação será planejada de modo que essa mudança
seja o mais suave possível. Para isso, defina a interface HotelRepository:
interface HotelRepository {
    fun save(hotel: Hotel)
    fun remove(vararg hotels: Hotel)
    fun hotelById(id: Long, callback: (Hotel?) -> Unit)
    fun search(term: String, callback: (List<Hotel>) -> Unit)
}

A interface HotelRepository possui alguns detalhes interessantes. O método
remove(Hotel...) pode receber um ou vários objetos do tipo Hotel, pois esse
parâmetro está marcado como vararg. Já os métodos hotelById() e search() recebem
como segundo parâmetro uma função que será chamada quando a busca for



concluída. Na busca por id, é preciso passar uma função que recebe um Hotel
como parâmetro e não retorna nada (Unit), enquanto na busca geral o método
passado como parâmetro deve receber uma List<Hotel>.

Agora adicione a primeira implementação dessa interface que fará a
persistência em memória. Adicione o arquivo MemoryRepository.kt ao seu
projeto e deixe-o como a seguir:
object MemoryRepository : HotelRepository {
    private var nextId = 1L
    private val hotelsList = mutableListOf<Hotel>()
    init {
        save(Hotel(0, "New Beach Hotel", "Av. Boa Viagem", 4.5f))
        save(Hotel(0, "Recife Hotel", "Av. Boa Viagem", 4.0f))
        save(Hotel(0, "Canario Hotel", "Rua dos Navegantes", 3.0f))
        save(Hotel(0, "Byanca Beach Hotel", "Rua Mamanguape", 4.0f))
        save(Hotel(0, "Grand Hotel Dor", "Av. Bernardo", 3.5f))
        save(Hotel(0, "Hotel Cool", "Av. Conselheiro Aguiar", 4.0f))
        save(Hotel(0, "Hotel Infinito", "Rua Ribeiro de Brito", 5.0f))
        save(Hotel(0, "Hotel Tulipa", "Av. Boa Viagem", 5.0f))
    }
    override fun save(hotel: Hotel) {
        if (hotel.id == 0L) {
            hotel.id = nextId++
            hotelsList.add(hotel)
        } else {
            val index = hotelsList.indexOfFirst { it.id == hotel.id }
            if (index > -1) {
                hotelsList[index] = hotel
            } else {
                hotelsList.add(hotel)
            }
        }
    }
    override fun remove(vararg hotels: Hotel) {
        hotelsList.removeAll(hotels)
    }
    override fun hotelById(id: Long, callback: (Hotel?) -> Unit) {
        callback(hotelsList.find { it.id == id })
    }
    override fun search(term: String, callback: (List<Hotel>) -> Unit) {
        callback(
                if (term.isEmpty()) hotelsList
                else hotelsList.filter {
                    it.name.toUpperCase().contains(term.toUpperCase())



                }
        )
    }
}

A implementação começa com um detalhe interessante. Foi definido um
object em vez de uma class. Com isso, esse objeto será uma instância única, ou
seja, um singleton. Definimos o atributo nextId que será incrementado a cada
vez que um novo objeto for inserido. A lista de hotéis será armazenada no
atributo hotelsList. No bloco init são adicionados alguns hotéis apenas para teste,
pois eles serão removidos posteriormente. O método save(Hotel) verifica se o
hotel a ser inserido tem id igual a zero, e nesse caso adiciona o hotel à lista,
caso contrário, por meio do método indexOfFirst é feita uma busca pelo índice
do hotel com o id do hotel passado como parâmetro, caso o índice seja
encontrado, o objeto é atualizado na lista.

Outro detalhe interessante é a utilização das funções de callback que foram
passadas para os métodos hotelById() e search(). Elas são chamadas após realizar
a busca pelo hotel, e perceba que foram utilizadas funções de collections da
biblioteca-padrão do Kotlin: o find() realiza uma busca por um item específico
na lista, que no nosso caso, está sendo feita baseado no id do hotel; já o
método filter() retorna uma nova lista com itens filtrados pelo nome do hotel.

Listagem de hotéis
Uma vez criado o repositório, deve ser definida agora a interface para a view
(do MVP) da tela. Ela possui apenas dois métodos, um para exibir a lista de
hotéis e outro para tratar o evento que exibirá os detalhes de um hotel
específico:
interface HotelListView {
    fun showHotels(hotels: List<Hotel>)
    fun showHotelDetails(hotel: Hotel)
}

O HotelListPresenter receberá a referência para a HotelListView e para o
HotelRepository, e possui um método que obtém a lista de hotéis a partir do
repositório e outro que apenas repassa para view a responsabilidade de exibir
os detalhes do hotel:
class HotelListPresenter(
        private val view: HotelListView,
        private val repository: HotelRepository



) {
    fun searchHotels(term: String) {
        repository.search(term) { hotels ->
            view.showHotels(hotels)
        }
    }
    fun showHotelDetails(hotel: Hotel) {
        view.showHotelDetails(hotel)
    }
}

A próxima etapa é criar o fragment que exibirá a lista dos hotéis. Apesar de
o Android Studio ter uma opção para criar um novo fragment, será criada
uma classe simples e feitas as devidas alterações para que as etapas do que o
exemplo fará sejam mais bem compreendidas. Adicione a classe
HotelListFragment e deixe-a da seguinte forma:
import android.os.Bundle
import android.widget.ArrayAdapter
import androidx.fragment.app.ListFragment
 
class HotelListFragment : ListFragment(), HotelListView {
    private val presenter = HotelListPresenter(this, MemoryRepository)
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        presenter.searchHotels("")
    }
    override fun showHotels(hotels: List<Hotel>) {
        val adapter = ArrayAdapter<Hotel>(requireContext(), android.R.layout.simple_list_item_1,

hotels)
        listAdapter = adapter
    }
    override fun showHotelDetails(hotel: Hotel) {
        // Será implementado em breve...
    }
}

A classe herda de ListFragment, uma subclasse de Fragment que exibe apenas
uma ListView. Outra opção é herdar de Fragment, criar um arquivo de layout com
apenas uma ListView e carregá-lo no onCreateView(LayoutInflater,ViewGroup,Bundle)
como será demonstrado mais adiante com o fragment de detalhes.

O atributo presenter foi declarado e inicializado passando como parâmetro a
view e o repositório. No onActivityCreated(Bundle) é realizada uma busca
chamando o método searchHotels(String) passando uma string vazia que fará com



que todos os registros sejam retornados. O presenter realizará a busca dos
hotéis e chamará o método showHotels(List<Hotel>). Nesse momento um
ArrayAdapter é instanciado e atribuído à ListView do ListFragment por meio da
propriedade listAdapter que fará com que a lista seja exibida. A função
showHotelDetails(Hotel) será implementada em breve.

Agora deixe o arquivo de layout res/layout/activity_hotel.xml da seguinte
forma:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal">
    <fragment
        android:id="@+id/fragmentList"
        android:name="dominando.android.fragments.HotelListFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</LinearLayout>

O layout é bem simples contendo apenas um LinearLayout horizontal com uma
tag <fragment> apontando para a classe HotelListFragment. Note que é usado o
nome do pacote do projeto seguido do nome da classe. Outro detalhe
importante é que se deve sempre atribuir um id para o fragment.

Verifique se a HotelActivity está conforme a seguir e execute a aplicação. Ela
deve ficar como na Figura 8.3:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
 
class HotelActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_hotel)
    }
}



Figura 8.3 – Fragment de listagem de hotéis.

Tela de detalhes do hotel
Para iniciar a implementação da tela de detalhes crie a interface HotelDetailsView
que possui basicamente dois métodos: o primeiro servirá para exibir os
detalhes do hotel; e o segundo para exibir uma mensagem de erro caso o
hotel não possa ser carregado ou não exista:
interface HotelDetailsView {
    fun showHotelDetails(hotel: Hotel)
    fun errorHotelNotFound()
}

Em seguida, implemente a classe HotelDetailsPresenter cujo papel é bem
simples: realizar a busca do hotel no repositório, e por meio da HotelDetailsView
exibe os detalhes do hotel ou uma mensagem de erro caso nenhum hotel seja
retornado:
class HotelDetailsPresenter(
        private val view: HotelDetailsView,
        private val repository: HotelRepository
) {
    fun loadHotelDetails(id: Long) {
        repository.hotelById(id) { hotel ->



            if (hotel != null) {
                view.showHotelDetails(hotel)
            } else {
                view.errorHotelNotFound()
            }
        }
    }
}

O próximo passo é implementar o fragment que exibirá os detalhes do hotel
e a activity que carregará esse fragment quando a aplicação for executada em
um smartphone. Crie o arquivo de layout
res/layout/fragment_hotel_details.xml:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <TextView
        android:id="@+id/txtName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="24sp"
        app:layout_constraintBottom_toTopOf="@+id/txtAddress"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_chainStyle="packed"
        tools:text="Nome do Hotel" />
    <TextView
        android:id="@+id/txtAddress"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="18sp"
        app:layout_constraintBottom_toTopOf="@+id/rtbRating"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/txtName"
        tools:text="Endereço" />
    <RatingBar
        android:id="@+id/rtbRating"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:progressTint="@color/colorAccent"



        android:isIndicator="true"
        android:numStars="5"
        android:stepSize="0.5"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/txtAddress" />
</androidx.constraintlayout.widget.ConstraintLayout>

Foi utilizado um ConstraintLayout que centraliza os itens na tela usando uma
chain. Para criá-la visualmente basta selecionar os três componentes, clicar
com o botão direito e clicar na opção Chains > Create vertical chain.
Depois, basta mudar o tipo da chain para “pack” ou pela propriedade
app:layout_constraintVertical_chainStyle. Para centralizar os componentes, basta
selecioná-los novamente, clicar com o botão direito e selecionar a opção
Center > Horizontally in parent.

O componente RatingBar mostrará a classificação do hotel em estrelas, onde a
propriedade android:stepSize informa a variação no valor da propriedade rating,
que neste caso será de 0,5. Na propriedade android:numStars é determinada
quantas estrelas aparecerão no componente, enquanto em android:isIndicator
mostramos que esse valor será apenas um indicador, ou seja, servirá apenas
para leitura.

Crie agora a classe para exibir os detalhes do hotel chamada
HotelDetailsFragment:
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import kotlinx.android.synthetic.main.fragment_hotel_details.*
class HotelDetailsFragment : Fragment(), HotelDetailsView {
    private val presenter = HotelDetailsPresenter(this, MemoryRepository)
    private var hotel: Hotel? = null
 
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_hotel_details, container, false)
    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        presenter.loadHotelDetails(arguments?.getLong(EXTRA_HOTEL_ID, -1) ?: -1)
    }



    override fun showHotelDetails(hotel: Hotel) {
        this.hotel = hotel
        txtName.text = hotel.name
        txtAddress.text = hotel.address
        rtbRating.rating = hotel.rating
    }
    override fun errorHotelNotFound() {
        txtName.text = getString(R.string.error_hotel_not_found)
        txtAddress.visibility = View.GONE
        rtbRating.visibility = View.GONE
    }
    companion object {
        const val TAG_DETAILS = "tagDetalhe"
        private const val EXTRA_HOTEL_ID = "hotelId"
 
        fun newInstance(id: Long) = HotelDetailsFragment().apply {
            arguments = Bundle().apply {
                putLong(EXTRA_HOTEL_ID, id)
            }
        }
    }
}

O método newInstance(Long) declarado no companion object ao final da classe
permite criar uma nova instância de HotelDetailsFragment recebendo como
parâmetro o id do hotel. Não devem ser utilizados construtores com
parâmetros para a criação de fragments. Quando for necessário passar
parâmetros é recomendado definir um método de classe (static do Java),
também conhecido como método construtor. Nele é criado um objeto Bundle
que armazenará os parâmetros que serão passados para o fragment (nesse
caso, só o id do hotel), similar ao que é feito para passar um parâmetro para a
activity. Então o id do hotel é armazenado em um Bundle, que é passado para o
fragment por meio da propriedade arguments.

Na função newInstance(int) foi utilizada apply da biblioteca-padrão do Kotlin,
que serve para executar um bloco de código e retornar o próprio objeto. As
propriedades e métodos acessados dentro desse bloco são do próprio objeto
que está chamando o método apply. A versão completa da função
newInstance(Long) seria:
fun newInstance(id: Long): HotelDetailsFragment {
    val fragment = HotelDetailsFragment()
    val args = Bundle()
    args.putLong(EXTRA_HOTEL_ID, id)



    fragment.arguments = args
    return fragment
}

Como se pode notar, ao utilizar a função apply, o código ficou mais simples.
Na classe HotelListFragment não foi implementado o método

onCreateView(LayoutInflater,ViewGroup,Bundle) porque, como essa classe herda de
ListFragment, ela já cria uma ListView que representará a view do fragment.
Porém, quando se herda de Fragment, é preciso implementar esse método para
determinar o que o fragment exibirá. Note que assim como foi feito com o
Adapter do capítulo anterior, foi usado o objeto inflater (da classe LayoutInflater)
para carregar o arquivo de layout fragment_hotel_details.xml.

O Kotlin Extensions permite acessar os componentes diretamente (sem usar
o findViewById(int)), mas para utilizá-lo em fragments, é preciso fazê-lo apenas
após a view do fragment ter sido criada, e isso ocorre quando o método
onViewCreated(View, Bundle) é chamado. Nesse método, foi utilizada a propriedade
arguments (que foi atribuída no método newInstance(Long)) para obter o id do hotel
passado como parâmetro e carregar as informações do respectivo hotel.

Quando o objeto hotel é carregado do repositório, o presenter invoca o
método showHotelDetails(Hotel) que preenche os componentes com as
informações do objeto hotel.

Adicione a string de erro no res/values/strings.xml:
<string name="error_hotel_not_found">Hotel não encontrado</string>

A próxima etapa será criar a activity de detalhes que será usada em
smartphones. Seu único papel será receber o id do hotel da tela de listagem,
instanciar fragment e exibi-lo. Adicione uma nova activity ao projeto
acessando o menu File > New > Activity > Empty Activity, chame-a de
HotelDetailsActivity e deixe seu arquivo de layout (activity_hotel_details.xml)
assim:
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/details"/>

O arquivo de layout possui apenas um FrameLayout com o id @+id/details onde
será adicionado em tempo de execução o fragment de detalhes. Agora
implemente o código da HotelDetailsActivity:
import android.content.Context
import android.content.Intent



import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
 
class HotelDetailsActivity : AppCompatActivity() {
    private val hotelId: Long by lazy { intent.getLongExtra(EXTRA_HOTEL_ID, -1) }
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_hotel_details)
        if (savedInstanceState == null) {
            showHotelDetailsFragment()
        }
    }
    private fun showHotelDetailsFragment() {
        val fragment = HotelDetailsFragment.newInstance(hotelId)
        supportFragmentManager
                .beginTransaction()
                .replace(R.id.details, fragment, HotelDetailsFragment.TAG_DETAILS)
                .commit()
    }
    companion object {
        private const val EXTRA_HOTEL_ID = "hotel_id"
        fun open(context: Context, hotelId: Long) {
            context.startActivity(Intent(context, HotelDetailsActivity::class.java).apply {
                putExtra(EXTRA_HOTEL_ID, hotelId)
            })
        }
    }
}

O fragment foi adicionado no método showHotelDetailsFragment() usando a classe
FragmentManager, que é obtida por meio da propriedade supportFragmentManager.
Com esse objeto, uma nova transação é iniciada usando beginTransaction(), que
retorna um FragmentTransaction, e com o método replace(int, Fragment, String) o
fragment é adicionado ao FrameLayout, que foi declarado no arquivo de layout
(com o id @+id/details). O último parâmetro é a tag que identifica esse
fragment.

Perceba que o fragment só é adicionado quando o parâmetro savedInstanceState
é igual a nulo, ou seja, quando a activity não está sendo recriada. Ao abrir a
activity pela primeira vez, ela não possui nenhum estado prévio salvo. Ao
rotacionar a tela, mesmo sem implementar o método onSaveInstanceState(Bundle), o
Android salva algumas informações internamente.



Os fragments declarados em arquivos de layout são identificados pelo
atributo android:id enquanto os fragments adicionados em tempo de execução
são identificados pela tag utilizada ao serem adicionados. Uma vez que os
fragments estão instanciados, é possível obter sua instância usando os
métodos findFragmentById(int) ou findFragmentByTag(String). O primeiro serve para
fragments adicionados diretamente no arquivo de layout, como foi feito com
o fragment de listagem, enquanto o segundo serve para fragments criados
dinamicamente, como o de detalhe.

O método utilitário open(Context,Long) será utilizado para abrir a tela de
detalhes. Isso evita que as classes que forem chamar essa activity tenham que
saber a constante EXTRA_HOTEL_ID. Isso é uma prática bem comum, similar ao
que é feito com o método newInstance() do fragment.

Ao utilizar fragments, a activity passa a ter um novo papel: coordenar,
organizar e servir de canal de comunicação entre os fragments. Sendo assim,
é preciso criar um mecanismo que permita ao fragment de listagem notificar a
HotelActivity que um item foi clicado para que os detalhes do hotel sejam
exibidos. Volte ao HotelListFragment e adicione o seguinte código:
import android.view.View
import android.widget.ListView
class HotelListFragment : ListFragment(), HotelListView {
    // Os métodos onActivityCreated e showHotels não mudaram
    override fun showHotelDetails(hotel: Hotel) {
        if (activity is OnHotelClickListener) {
            val listener = activity as OnHotelClickListener
            listener.onHotelClick(hotel)
        }
    }
    override fun onListItemClick(l: ListView?, v: View?, position: Int, id: Long) {
        super.onListItemClick(l, v, position, id)
        val hotel = l?.getItemAtPosition(position) as Hotel
        presenter.showHotelDetails(hotel)
    }
    interface OnHotelClickListener {
        fun onHotelClick(hotel: Hotel)
    }
}

A interface OnHotelClickListener foi declarada e possui o método
onHotelClick(Hotel). Dessa forma, a activity que usar esse fragment deverá
implementar essa interface caso queira ser notificada quando um item da lista



for clicado. O método onListItemClick(ListView, View, int, long) será invocado quando
o usuário clicar em um item da lista, e nele é checado se a activity (onde esse
fragmento está sendo exibido) implementa a interface OnHotelClickListener. Em
caso positivo, o objeto Hotel referente à posição que foi clicada é obtido por
meio do método getItemAtPosition(int). Como a HotelActivity implementará essa
interface, é possível chamar o seu método onHotelClick(Hotel).

Faça as seguintes mudanças na HotelActivity:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
 
class HotelActivity : AppCompatActivity(),
        HotelListFragment.OnHotelClickListener {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_hotel)
    }
    override fun onHotelClick(hotel: Hotel) {
        showDetailsActivity(hotel.id)
    }
    private fun showDetailsActivity(hotelId: Long) {
        HotelDetailsActivity.open(this, hotelId)
    }
}

Agora a HotelActivity implementa a interface OnHotelClickListener, e no método
onHotelClick(Hotel), a activity de detalhe é chamada. Execute a aplicação e clique
em um hotel, será exibida a tela da Figura 8.4.

A aplicação está totalmente funcional em smartphones, mas ao executar em
tablets, ela terá o mesmo comportamento, ou seja, ao clicar em um item, a
activity de detalhe será exibida. E isso sem dúvida é um desperdício, uma vez
que o tablet tem uma tela maior que pode ser aproveitada de uma forma mais
inteligente.



Figura 8.4 – Tela de detalhes do hotel.

Definindo layout para tablets
O Android não tem nenhum método nativo para informar se um dispositivo é
um smartphone ou um tablet. Isso pode soar estranho, mas o que existe na
verdade são tamanhos de tela diferentes. Sendo assim, o que é preciso é criar
recursos ou uma lógica especial para telas maiores. Nesse sentido, o Android
sugere alguns intervalos apresentados na Tabela 8.1 que são baseados na
smallest width, ou seja, menor largura do dispositivo. Isso é basicamente o
menor valor entre altura e largura da tela do aparelho, ou simplesmente o
valor da largura do aparelho em portrait.

Tabela 8.1 – Padrões de tamanhos de tela no Android
Dispositivo Largura Ex. de pasta de recursos

Smartphone Menor que 600 dp layout, values
Tablets de 7” Igual ou superior a 600 dp layout-sw600dp, values-sw600dp

layout-large, values-large
Tablets de 10” Igual ou superior a 720 dp layout-sw720dp, values-sw720dp

layout-xlarge, values-xlarge

Como podemos ver na tabela, é possível utilizar as notações sw600dp ou large,



por exemplo. Ambas funcionam, mas a recomendação é utilizar a primeira
por ser mais precisa, enquanto a segunda é mantida apenas por questão de
compatibilidade com versões mais antigas.

Os fragments de listagem e detalhes serão exibidos juntos ao executar a
aplicação em tablets, para isso, selecione a visualização de projeto do
Android Studio e crie um novo diretório de layout para tablets, clicando com
o botão direito sobre a pasta res e selecionando a opção New > Directory.
No campo Directory name, preencha com layout-sw600dp e clique em OK.
Copie o arquivo de layout activity_hotel.xml para lá e deixe-o desta forma:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <fragment
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:name="dominando.android.fragments.HotelListFragment"
        android:id="@+id/fragmentList"/>
    <FrameLayout
        android:id="@+id/details"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="2"/>
</LinearLayout>

Foi adicionado um FrameLayout onde o fragment de detalhe será carregado da
mesma forma que foi feito na activity de detalhe. Foi atribuído o valor 0dp
para a largura do <fragment> e do FrameLayout, pois foi usado o peso
(android:layout_weight) para determinar que o primeiro ocupe um terço da tela, e o
outro, dois terços. Volte para HotelActivity e faça as seguintes modificações:
class HotelActivity : AppCompatActivity(),
        HotelListFragment.OnHotelClickListener {
 
    // Nada mudou no onCreate...
    override fun onHotelClick(hotel: Hotel) {
        if (isTablet()) {
            showDetailsFragment(hotel.id)
        } else {
            showDetailsActivity(hotel.id)
        }



    }
    private fun isTablet() = findViewById<View>(R.id.details) != null
 
    private fun showDetailsFragment(hotelId: Long) {
        val fragment = HotelDetailsFragment.newInstance(hotelId)
        supportFragmentManager
                .beginTransaction()
                .replace(R.id.details, fragment, HotelDetailsFragment.TAG_DETAILS)
                .commit()
    }
    // Método showDetailsActivity não mudou
}

O método isTablet() identifica se a aplicação está executando em um tablet
checando se a View details é nula. O arquivo de layout da pasta res/layout-
sw600dp só é carregado pelo Android se a aplicação estiver executando em
um tablet, e a única diferença desse layout para o de smartphones (que está na
pasta res/layout) é que o primeiro não tem o FrameLayout para exibição de
detalhes.

Uma opção mais elegante é criar o arquivo res/values/bools.xml:
<resources>
    <bool name="tablet">false</bool>
    <bool name="smartphone">true</bool>
</resources>

Em seguida, crie a pasta res/values-sw600dp com o arquivo bools.xml com
esses valores invertidos:
<resources>
    <bool name="tablet">true</bool>
    <bool name="smartphone">false</bool>
</resources>

Por fim, adicione a implementação na HotelActivity que faz a checagem:
private fun isTablet() = resources.getBoolean(R.bool.tablet)
private fun isSmartphone() = resources.getBoolean(R.bool.smartphone)

Até agora nenhum exemplo tinha sido testado exclusivamente em tablets.
Caso possua um, conecte-o ao computador e execute a aplicação; caso não
possua, utilize o emulador do Nexus 9. Pode-se utilizar tanto o emulador
nativo ou o Genymotion. Caso não tenha feito o download dessa imagem,
faça o download. Em seguida, execute esse emulador1. Execute a aplicação
no tablet e, ao clicar em um hotel, teremos um resultado como o da Figura
8.5.



Figura 8.5 – Aplicação de hotéis em um tablet.
Ao componentizar as telas com fragments, sua adaptação para execução em

tablets é bastante facilitada. Além disso, é possível reusá-las em outros
pontos da aplicação (caso necessário) e, quem sabe, até em outros projetos.

Tanto em smartphones quanto em tablets a HotelActivity instanciará o
HotelListFragment, que ao clicar em um item da lista, dispara o evento
onHotelClick(Hotel). A activity ouve esse evento e, dependendo do dispositivo,
faz um fluxo diferente. No smartphone, chamará a activity de detalhe, que
instanciará o fragment de detalhe e o exibirá. Já em um tablet, a HotelActivity o
instanciará diretamente o fragment de detalhes e o adicionará na tela.

Action Bar
A Action Bar é utilizada para exibir o título da activity além de permitir
adicionar ações e definir um modelo navegacional para a aplicação. Utilizá-la
traz diversos benefícios como: informar ao usuário em que ponto da
aplicação ele se encontra; deixar as ações mais importantes em evidência para
que possam ser acessadas mais facilmente; disponibilizar ações baseadas em
um contexto específico; definir uma forma padronizada de navegação usando
abas, lista de opções ou de menu lateral.



A Figura 8.6 mostra um exemplo bem completo de uma action bar da
aplicação Google Sheets. No lado esquerdo há um ícone que dará acesso a
um menu lateral (que será abordado no próximo capítulo) e ao seu lado está o
título da aplicação. No lado direito ficam as ações disponíveis nesta tela: uma
ação de buscar com o ícone de uma lupa; uma ação de abrir um documento
representado com o ícone de uma pasta; e por último o chamado de overflow
menu, que indica que existem mais opções a serem exibidas.

Figura 8.6 – ActionBar com ações. Fonte:
https://developer.android.com/training/appbar

Adicionando a action bar ao projeto
Ao criar o projeto, o Android Studio já adiciona por padrão a API de
compatibilidade que permite utilizar a action bar. Para usá-la, é preciso
apenas fazer duas coisas: definir que a activity herde de AppCompatActivity; e o
segundo detalhe é usar um dos temas do Material Design que foram
apresentados no Capítulo 6. Ambos já estão configurados no projeto.

Ao abrir o arquivo res/values/styles.xml, é possível observar que o tema da
aplicação está da seguinte forma:
<style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">...

Esse tema é usado por toda a aplicação, conforme podemos observar no
AndroidManifest.xml:
<application ...
      android:theme="@style/AppTheme" >

Voltando à HotelActivity, adicione dois métodos: onCreateOptionsMenu(Menu) e
onOptionsItemSelected(MenuItem). O primeiro servirá para carregar as ações que
aparecerão na action bar e o segundo é onde cada ação será tratada:
override fun onCreateOptionsMenu(menu: Menu?): Boolean {
    menuInflater.inflate(R.menu.hotel, menu)
    return true
}
override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    return super.onOptionsItemSelected(item)



}
Com a classe MenuInflater, o arquivo res/menu/hotel.xml é carregado com as

ações da tela. Esse arquivo não existe ainda, então crie-o, mas antes adicione
as seguintes strings ao arquivo res/values/strings.xml:
<string name="action_search">Pesquisar</string>
<string name="action_new_hotel">Novo Hotel</string>
<string name="action_info">Info</string>
<string name="hint_search">Procurar por Hotel</string>

Agora adicione o arquivo de menu com as ações que ficarão disponíveis na
action bar. Crie o diretório res/menu, em seguida, clique com o arquivo
hotel.xml e deixe-o da seguinte forma:
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    tools:context="dominando.android.fragments.HotelActivity" >
    <item android:id="@+id/action_search"
        android:title="@string/action_search"
        android:icon="@android:drawable/ic_menu_search"
        app:showAsAction="collapseActionView|ifRoom"
        app:actionViewClass="androidx.appcompat.widget.SearchView" />
    <item
        android:id="@+id/action_new"
        android:icon="@android:drawable/ic_menu_add"
        android:title="@string/action_new_hotel"
        app:showAsAction="ifRoom|withText"/>
    <item
        android:id="@+id/action_info"
        android:icon="@android:drawable/ic_menu_info_details"
        android:title="@string/action_info"
        app:showAsAction="never" />
</menu>

O primeiro item é o mais complexo, pois contém um componente de busca
que será exibido quando a ação for selecionada. Isso é definido nas
propriedades app:showAsAction e app:actionViewClass, onde a primeira informa que a
ação se expandirá na própria ActionBar (collapseActionView), e a segunda declara
a classe da View que será exibida ao clicar na ação, que neste caso é a
androidx.appcompat.widget.SearchView.

Uma curiosidade aqui é o prefixo “app”, que foi utilizado em algumas
propriedades que são específicas da action bar, por isso foi declarado esse
namespace no XML xmlns:app="http://schemas.android.com/apk/res-auto" para que essas



propriedades sejam reconhecidas pela API de compatibilidade.
A segunda ação terá o ícone exibido na action bar apenas se houver espaço

suficiente, e se possível com o título (app:showAsAction="ifRoom|withText"). A
terceira ação será o “sobre” da aplicação e ficará sempre no overflow menu.

Um detalhe importante sobre o overflow menu é que ele só aparecerá em
aparelhos que não tenham a tecla física de menu. O Google desencorajou os
fabricantes de utilizá-la, entretanto alguns modelos mais antigos ainda podem
possuir essa tecla.

Implemente essas ações na HotelActivity:
//Demais imports...
import androidx.appcompat.widget.SearchView
 
class HotelActivity: AppCompatActivity(),
        HotelListFragment.OnHotelClickListener,
        SearchView.OnQueryTextListener,
        MenuItem.OnActionExpandListener {
 
            private var lastSearchTerm: String = “”
            private var searchView: SearchView? = null
 
    private val listFragment: HotelListFragment by lazy {
        supportFragmentManager.findFragmentById(R.id.fragmentList) as HotelListFragment
    }
    // O método onCreate não mudou
    override fun onSaveInstanceState(outState: Bundle?) {
        super.onSaveInstanceState(outState)
        outState?.putString(EXTRA_SEARCH_TERM, lastSearchTerm)
    }
    override fun onRestoreInstanceState(savedInstanceState: Bundle?) {
        super.onRestoreInstanceState(savedInstanceState)
        lastSearchTerm = savedInstanceState?.getString(EXTRA_SEARCH_TERM) ?: ""
    }
    // Demais métodos não sofreram alterações
    private fun showDetailsFragment(hotelId: Long) {
        /* o menu será recriado quando o fragment de detalhe for exibido,
        então o listener deve ser removido para não ser notificado com o texto vazio */
        searchView?.setOnQueryTextListener(null)
        // Restante do método permanece igual...
    }
    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        menuInflater.inflate(R.menu.hotel, menu)
        val searchItem = menu?.findItem(R.id.action_search)



        searchItem?.setOnActionExpandListener(this)
        searchView = searchItem?.actionView as SearchView
        searchView?.queryHint = getString(R.string.hint_search)
        searchView?.setOnQueryTextListener(this)
        if (lastSearchTerm.isNotEmpty()) {
            Handler().post {
                val query = lastSearchTerm
                searchItem.expandActionView()
                searchView?.setQuery(query, true)
                searchView?.clearFocus()
            }
        }
        return true
    }
    override fun onOptionsItemSelected(item: MenuItem?): Boolean {
        return super.onOptionsItemSelected(item)
    }
    override fun onQueryTextSubmit(query: String?) = true
 
    override fun onQueryTextChange(newText: String?): Boolean {
        lastSearchTerm = newText ?: ""
        listFragment.search(lastSearchTerm)
        return true
    }
 
    override fun onMenuItemActionExpand(item: MenuItem?) = true // para expandir a view
 
    override fun onMenuItemActionCollapse(item: MenuItem?): Boolean {
        lastSearchTerm = ""
        listFragment.clearSearch() // para voltar ao normal
        return true
    }
    companion object {
        const val EXTRA_SEARCH_TERM = "lastSearch"
    }
}

A classe cresceu bastante, mas tudo isso para implementar uma busca
funcional usando a action bar. Além da interface OnHotelClickListener, ela está
implementando mais duas interfaces:

• SearchView.OnQueryTextListener – permite tratar o campo de busca na action
bar. O primeiro método dessa interface é o onQueryTextChange(String), que é
disparado a cada caractere que é digitado na caixa de texto, e o
onQueryTextSubmit(String) é chamado quando o botão de busca do teclado



virtual é pressionado. Neste exemplo, o método search(String) do
HotelListFragment está sendo chamado e será implementado a seguir;

• OnActionExpandListener – é utilizada para saber quando uma ação da action bar
expandiu ou quando voltou ao normal. Quando esses eventos acontecem,
os métodos onMenuItemActionExpand(MenuItem) e onMenuItemActionCollapse(MenuItem)
são chamados respectivamente. Como é possível notar, eles retornam um
boolean para indicar se a ação deve ser realizada ou não. Em nosso
exemplo, quando a opção de busca é fechada, o método clearSearch() do
HotelListFragment é chamado e também será implementado a seguir.

O atributo listFragment é inicializado com o delegate lazy usando o método
findFragmentById(int) do objeto supportFragmentManager de modo a obter a instância
do HotelListFragment declarado no arquivo de layout activity_hotel.xml.

O arquivo de menu é carregado em onCreateOptionsMenu(Menu) por meio do
método inflate(int,Menu) do objeto menuInflater e as opções são armazenadas no
objeto menu. Com este objeto, a ação busca é obtida usando o método
findItem(int) e armazenada na constante searchItem. Em seguida, com a chamada
ao método setOnActionExpandListener(OnActionExpandListener) da classe MenuItem é
definido que a classe HotelActivity ouvirá as ações de expandir e recolher o item
da action bar.

O atributo lastSearchTerm armazenará o termo digitado na busca para que ele
não seja perdido ao rotacionar o aparelho. Portanto, esse valor é salvo no
onSaveInstanceState(Bundle) e recuperado no onRestoreInstanceState(Bundle).

A SearchView é a caixa de texto da busca, e é obtida por meio da propriedade
actionView do MenuItem. O hint desse item é definido e, em seguida, é informado
que a HotelActivity ouvirá os seus eventos por meio do método
setOnQueryTextListener (OnQueryTextListener) (da interface OnQueryTextListener). Em
seguida, é verificado se a tela se encontrava em uma busca checando se
lastSearchTerm não está vazio, nesse caso a opção de menu de busca é expandida
por meio do método expandActionView() e o texto é atribuído à SearchView e a
busca é realizada invocando o método setQuery(String,boolean).

Para tratar cada opção da action bar é usado o método
onOptionsItemSelected(MenuItem) checando o id do objeto MenuItem recebido como
parâmetro. Isso será feito mais adiante para as ações de “novo” e “info”.

Agora adicione esses novos métodos à classe HotelListFragment:
fun search(text: String) {



    presenter.searchHotels(text)
}
fun clearSearch() {
    presenter.searchHotels("")
}

A mudança no fragment foi muito simples graças à arquitetura planejada
anteriormente. No método search(String) apenas é chamado o método
searchHotels(String) do presenter para realizar a busca pelo termo digitado,
enquanto para limpar a busca uma string vazia é passada como parâmetro.

Ao executar a aplicação e clicar no botão de busca, o resultado será similar
ao da Figura 8.7. Como é possível observar, o título da aplicação desaparece
dando espaço para a SearchView. Ao lado esquerdo do ícone da aplicação fica
uma seta indicando que a busca pode ser cancelada.

Figura 8.7 – ActionBar com barra de busca.
Agora perceba que, ao clicar no botão de adicionar (com o símbolo de “+”),

nada acontece. Na próxima seção, será adicionada a funcionalidade de inserir
novos hotéis à lista.

AlertDialog e DialogFragment



Até a versão 2.3 do Android, a forma padrão de exibir mensagens para os
usuários era usando a classe AlertDialog. E com o surgimento dos fragments a
recomendação passou a ser a utilização do DialogFragment. Uma das vantagens
dessa abordagem é o maior controle sobre o ciclo de vida do dialog, uma vez
que ele nada mais é que um fragment.

Apenas a título de conhecimento, até o Android 2.3 o seguinte código era
utilizado em uma activity:
var x = 0
override fun onCreateDialog(id: Int): Dialog {
    val dialog = AlertDialog.Builder(this)
            .setTitle("Título")
            .setMessage("Mensagem $x")
            .setPositiveButton("Sim", null)
            .setNegativeButton("Não", null)
            .create()
    return dialog
}
override fun onPrepareDialog(id: Int, dialog: Dialog?) {
    (dialog as AlertDialog).setMessage("Mensagem $x")
    x++
    super.onPrepareDialog(id, dialog)
}
fun abrirAlert() {
    showDialog(0)
}

Essa abordagem era a recomendada, pois, ao abrir um dialog, caso a tela
fosse rotacionada, ele não seria perdido. Todos os dialogs da activity deviam
ser criados no método onCreateDialog(int), onde é criada uma instância de um
AlertDialog baseado no id recebido como parâmetro. Caso fosse necessário
alterar o texto do dialog (no exemplo anterior, o valor de x), era necessário
usar o método onPrepareDialog(int, Dialog). Depois disso, bastava chamar o método
showDialog(int) passando o id do dialog a ser exibido. Um dialog pode ter até
três botões por padrão: positivo, negativo e neutro. Para tratar o evento de
clique desses botões, é necessário passar um objeto do tipo
DialogInteface.OnClickListener e implementar o método onClick(DialogInterface,int).

A classe DialogFragment pode conter um AlertDialog ou pode exibir qualquer
view. Seu uso será exemplificado criando um dialog para o “Sobre” da
aplicação e outro para a tela de cadastro de hotéis.

Adicione a classe AboutDialogFragment conforme a seguir:



import android.app.Dialog
import android.content.DialogInterface
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.DialogFragment
 
class AboutDialogFragment : DialogFragment() {
    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val listener = DialogInterface.OnClickListener { _, i ->
            if (i == DialogInterface.BUTTON_NEGATIVE) {
                val intent = Intent(Intent.ACTION_VIEW,
                        Uri.parse("http://www.nglauber.com.br"));
                startActivity(intent)
            }
        }
        return AlertDialog.Builder(requireContext())
                .setTitle(R.string.about_title)
                .setMessage(R.string.about_message)
                .setPositiveButton(android.R.string.ok, null)
                .setNegativeButton(R.string.about_button_site, listener)
                .create()
    }
}

Observe que é possível criar um DialogFragment (do pacote androidx.fragment.app)
simplesmente implementando o método onCreateDialog(Bundle). Nele deve-se
instanciar um AlertDialog por meio da classe AlertDialog.Builder passando título,
mensagem e os ids das strings de cada botão. Note que estão sendo utilizados
ids das strings que devem ser adicionadas ao res/values/strings.xml.
<string name="about_title">Dominando o Android</string>
<string name="about_message">Desenvolvido por nglauber</string>
<string name="about_button_site">Site</string>

Voltando à classe AboutDialogFragment, no evento de clique está sendo
verificado qual botão foi clicado. Caso tenha sido o botão negativo, uma Intent
é disparada para abrir o navegador nativo. No botão positivo, não está sendo
passado nenhum listener, desta forma, quando esse botão for clicado o dialog
é automaticamente fechado.

Para exibir o dialog, deixe o método onOptionsItemSelected(MenuItem) da
HotelActivity como a seguir:
override fun onOptionsItemSelected(item: MenuItem?): Boolean {



    when (item?.itemId) {
        R.id.action_info ->
                AboutDialogFragment().show(supportFragmentManager, "sobre")
    }
    return super.onOptionsItemSelected(item)
}

O resultado deve ficar como a Figura 8.8.

Figura 8.8 – DialogFragment em execução.
Na próxima seção o exemplo ficará mais dinâmico ao permitir adicionar

novos hotéis à lista.

Adicionando novos hotéis
Assim como na tela de listagem e de detalhes, o padrão MVP será utilizado
na tela de cadastro de hotéis. Adicione a interface HotelFormView como descrita
a seguir:
interface HotelFormView {
    fun showHotel(hotel: Hotel)
    fun errorInvalidHotel()
    fun errorSaveHotel()
}

O método showHotel(Hotel) dessa interface serve apenas para exibir o conteúdo



de um hotel existente para ser alterado. Já o método errorSaveHotel() será
chamado caso algum erro ocorra ao tentar salvar o hotel. O método
errorInvalidHotel() será usado caso o hotel não tenha sido preenchido
corretamente.

Adicione a classe HotelValidator que validará o objeto hotel:
class HotelValidator {
    fun validate(info: Hotel) = with(info) {
        checkName(name) && checkAddress(address)
    }
    private fun checkName(name: String) = name.length in 2..20
    private fun checkAddress(address: String) = address.length in 4..80
}

O método validate(Hotel) verifica se o nome do hotel possui entre 2 e 20
caracteres e se o endereço possui entre 4 e 80. Para isso foi utilizado o
recurso de range do Kotlin para fazer essa verificação.

Agora implemente a classe HotelFormPresenter conforme a seguir:
class HotelFormPresenter(
    private val view: HotelFormView,
    private val repository: HotelRepository
) {
    private val validator = HotelValidator()
 
    fun loadHotel(id: Long) {
        repository.hotelById(id) { hotel ->
            if (hotel != null) {
                view.showHotel(hotel)
            }
        }
    }
    fun saveHotel(hotel: Hotel): Boolean {
        return if (validator.validate(hotel)) {
            try {
                repository.save(hotel)
                true
            } catch (e: Exception) {
                view.errorSaveHotel()
                false
            }
        } else {
            view.errorInvalidHotel()
            false
        }



    }
}

O trabalho do HotelFormPresenter é bem simples: no método loadHotel(Long) ele
tenta carregar um hotel pelo id, caso o hotel exista no repositório, ele o exibe
na view. Já para salvar o hotel, ele primeiramente valida se o hotel é válido
utilizando o objeto validator, em caso positivo o método save(Hotel) do
repositório é chamado, mas caso ocorra algum erro, o método errorSaveHotel() da
view será chamado. Se o hotel for inválido, o método errorInvalidHotel() será
chamado.

Crie agora o DialogFragment customizado para inserir novos hotéis na lista.
Será utilizado o TextInputLayout, então adicione a dependência da biblioteca do
Material Design no build.gradle:
dependencies {
    ...
    implementation 'com.google.android.material:material:1.0.0'
}

Adicione um arquivo de layout chamado
res/layout/fragment_hotel_form.xml e deixe-o conforme a seguir:
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/scrollView"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content">
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp">
        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/tilName"
            android:layout_width="match_parent"
            android:layout_height="match_parent">
            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/edtName"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@string/form_label_name"
                android:imeOptions="actionNext"
                android:inputType="textCapWords" />
        </com.google.android.material.textfield.TextInputLayout>
        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/tilAddress"



            android:layout_width="match_parent"
            android:layout_height="match_parent">
            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/edtAddress"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@string/form_label_address"
                android:imeOptions="actionDone"
                android:inputType="textCapWords" />
        </com.google.android.material.textfield.TextInputLayout>
        <TextView
            android:id="@+id/txtRating"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:text="@string/form_label_rating"
            android:textColor="@color/colorAccent" />
        <RatingBar
            android:id="@+id/rtbRating"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:numStars="5"
            android:progressTint="@color/colorAccent"
            android:stepSize="0.5" />
    </LinearLayout>
</ScrollView>

Este layout é similar ao do fragment de detalhes, mas usando TextInputLayout
em vez do TextView. Note que foram usadas as propriedades android:inputType e
android:imeOptions para poder tratar o evento do teclado virtual no fragment.
Outro detalhe importante é a ScrollView, uma vez que é usado um dialog,
dependendo da tela, o layout pode não aparecer completamente na tela, o que
é normal no smartphone.

Para finalizar, adicione no res/values/strings.xml as strings utilizadas no
arquivo de layout:
<string name="form_label_name">Nome</string>
<string name="form_label_address">Endereço</string>
<string name="form_label_rating">Classificação</string>

Crie a classe HotelFormFragment, que usará o layout que acabamos de criar e
deixe-a da seguinte forma:
import android.os.Bundle
import android.view.*
import android.view.inputmethod.EditorInfo



import android.widget.Toast
import androidx.fragment.app.DialogFragment
import androidx.fragment.app.FragmentManager
import kotlinx.android.synthetic.main.fragment_hotel_form.*
 
class HotelFormFragment : DialogFragment(), HotelFormView {
    private val presenter = HotelFormPresenter(this, MemoryRepository)
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_hotel_form, container, false)
    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val hotelId = arguments?.getLong(EXTRA_HOTEL_ID, 0) ?: 0
        presenter.loadHotel(hotelId)
        edtAddress.setOnEditorActionListener { _, i, _ ->
            handleKeyboardEvent(i)
        }
        dialog.setTitle(R.string.action_new_hotel)
        // Abre o teclado virtual ao exibir o Dialog
        dialog?.window?.setSoftInputMode(
                WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE)
    }
    override fun showHotel(hotel: Hotel) {
        edtName.setText(hotel.name)
        edtAddress.setText(hotel.address)
        rtbRating.rating = hotel.rating
    }
   override fun errorSaveHotel() {
        Toast.makeText(requireContext(), R.string.error_hotel_not_found,
            Toast.LENGTH_SHORT).show()
    }
   override fun errorInvalidHotel() {
        Toast.makeText(requireContext(), R.string.error_invalid_hotel,
            Toast.LENGTH_SHORT).show()
    }
    private fun handleKeyboardEvent(actionId: Int): Boolean {
        if (EditorInfo.IME_ACTION_DONE == actionId) {
            val hotel = saveHotel()
            if (hotel != null) {
                if (activity is OnHotelSavedListener) {
                    val listener = activity as OnHotelSavedListener
                    listener.onHotelSaved(hotel)
                }
                // Feche o dialog



                dialog.dismiss()
                return true
            }
        }
        return false
    }
    private fun saveHotel(): Hotel? {
        val hotel = Hotel()
        val hotelId = arguments?.getLong(EXTRA_HOTEL_ID, 0) ?: 0
        hotel.id = hotelId
        hotel.name = edtName.text.toString()
        hotel.address = edtAddress.text.toString()
        hotel.rating = rtbRating.rating
        if (presenter.saveHotel(hotel)) {
            return hotel
        } else {
            return null
        }
    }
    fun open(fm: FragmentManager) {
        if (fm.findFragmentByTag(DIALOG_TAG) == null) {
            show(fm, DIALOG_TAG)
        }
    }
 
    interface OnHotelSavedListener {
        fun onHotelSaved(hotel: Hotel)
    }
 
    companion object {
        private const val DIALOG_TAG = "editDialog"
        private const val EXTRA_HOTEL_ID = "hotel_id"
 
        fun newInstance(hotelId: Long = 0) = HotelFormFragment().apply {
            arguments = Bundle().apply {
                putLong(EXTRA_HOTEL_ID, hotelId)
            }
        }
    }
}

KOTLINxJAVA: Perceba que nos parâmetros do lambda para tratamento do
evento do teclado foi utilizado o “_” (underline). Isso é recomendado quando os
parâmetros não são utilizados, mas como devem ser declarados, pode-se utilizar



essa notação.

No método onViewCreated(View,Bundle) primeiramente é obtido o id do hotel,
que será carregado por meio do método loadHotel(Int) do HotelPresenter. Esse
parâmetro será informado quando a edição de hotéis existentes for
implementada no próximo capítulo. Em seguida, o comportamento do botão
de ação do teclado é definido invocando o método
setOnEditorActionListener(OnEditorActionListener) onde está sendo passado um lambda
que apenas chama o método handleKeyboardEvent(Int). Por fim, é definido o texto
do título do dialog, e o teclado virtual é exibido por meio do método
setSoftInputMode(int) do objeto Window.

No método handleKeyboardEvent(Int) é verificada se a ação efetuada é
IME_ACTION_DONE. Em caso positivo, o método saveHotel() é chamado para criar
uma instância da classe Hotel que é passada para o presenter que a envia para o
repositório salvá-la. Em seguida, caso a activity implemente a interface
OnHotelSavedListener (definida no final da classe), o método onHotelSaved(Hotel) da
activity é chamado, recebendo como parâmetro o objeto Hotel que foi salvo.
Perceba que essa abordagem é um padrão no uso de fragments. Declarar uma
interface no fragment, implementar essa interface na activity e tratar a ação
do fragment. Isso já foi feito na listagem e agora novamente.

Adicione no res/values/strings.xml a mensagem de erro utilizada no método
errorInvalidHotel() que é exibida quando o hotel não foi preenchido corretamente:
<string name="error_invalid_hotel">Hotel não preenchido corretamente</string>

Um último detalhe que é preciso ajustar é o título do AlertDialog que, por
padrão, não é exibido. Para corrigir esse problema, faça os seguintes ajustes
no res/values/styles.xml:
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        ...
        <item name="android:dialogTheme">@style/CustomDialog</item>
    </style>
    <style name="CustomDialog" parent="@style/Theme.AppCompat.Light.Dialog">
        <item name="android:windowNoTitle">false</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

Com essa mudança o título do dialog é exibido e a cor de foco dos
componentes é configurada.

Para utilizar o HotelFormFragment para adicionar um novo hotel, é preciso fazer



com que a HotelActivity implemente a interface
HotelDialogFragment.OnHotelSavedListener e, em seguida, deixar os métodos
onHotelSaved(Hotel) e onOptionsItemSelected(MenuItem) conforme a seguir:
class HotelActivity : AppCompatActivity(),
        /* Demais interfaces permanecem */
        HotelFormFragment.OnHotelSavedListener {
 
    override fun onOptionsItemSelected(item: MenuItem?): Boolean {
        when (item?.itemId) {
            R.id.action_info ->
                    AboutDialogFragment().show(supportFragmentManager, "sobre")
            R.id.action_new ->
                    HotelFormFragment.newInstance().open(supportFragmentManager)
        }
        return super.onOptionsItemSelected(item)
    }
    override fun onHotelSaved(hotel: Hotel) {
        listFragment.search(lastSearchTerm)
    }

O resultado ficará conforme a Figura 8.9.

Figura 8.9 – DialogFragment para digitação de dados.
Ao confirmar a ação do dialog clicando no botão Done, o método



onHotelSaved(Hotel) da HotelActivity será chamado e então a última busca será
realizada para atualizar a tela de listagem.

Tratando o retorno do dialog
Nesse exemplo, foi utilizada a activity para tratar o retorno do dialog. Caso
queira usar um dialog a partir de um fragment, deve-se utilizar a propriedade
Target Fragment. Ela funciona como o startActivityForResult(Intent,int), só que para
fragments:
// A partir de um Fragment. O valor 1 é o requestCode
val dialogFragment = HotelFormFragment.newInstance()
dialogFragment.setTargetFragment(this, 1)
dialogFragment.open(activity.supportFragmentManager)

Para retornar uma informação (o objeto Hotel, por exemplo) a partir do
HotelFormFragment ficaria desta forma:
val intent = Intent()
intent.putExtra("hotel", newHotel)
targetFragment.onActivityResult(targetRequestCode, Activity.RESULT_OK, intent)

E para tratar o retorno do dialog no fragment de origem:
override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    super.onActivityResult(requestCode, resultCode, data)
    if (resultCode == Activity.RESULT_OK) {
        val hotel = data?.getSerializableExtra("hotel") as? Hotel
        Toast.makeText(activity, hotel?.nome ?: "vazio", Toast.LENGTH_SHORT).show()
    }
}

Essa seria uma forma interessante de tratar o retorno de um DialogFragment
sem utilizar listeners.

Usando o botão Up
Ao executar a aplicação em smartphones e clicar em um item da lista, os
detalhes do hotel são exibidos, assim, o usuário entra em um nível de
profundidade na navegação da aplicação. O botão up serve para exibir a tela
anterior do aplicativo. Ele retorna um nível na hierarquia do aplicativo até
que a tela inicial seja exibida.

Para implementar esse comportamento na activity de detalhes, altere a
declaração da HotelDetailsActivity no AndroidManifest.xml para ficar conforme a
seguir:



<activity
    android:name=".HotelDetailsActivity"
    android:parentActivityName=".HotelActivity" />

Após essa mudança, se a aplicação for executada em um smartphone e um
hotel for selecionado, teremos um resultado similar ao da Figura 8.10. Note
que agora temos uma seta ao lado do título da tela.

Figura 8.10 – Botão up na ActionBar.
Entretanto, ao clicar no botão up, uma nova instância da HomeActivity é

criada. Para evitar isso, podemos utilizar uma propriedade da tag <activity>
chamada android:launchMode. Altere a declaração da HomeActivity no
AndroidManifest.xml como a seguir:
<activity
    android:name=".HotelActivity"
    android:launchMode="singleTop" >

Com essa mudança, ao pressionar o up button, a instância da HotelActivity que
estava sendo usada anteriormente será reutilizada. Outra opção seria
sobrescrever o método getParentActivityIntent() da HotelDetailActivity e deixá-lo como
a seguir:
override fun getParentActivityIntent() : Intent {
    val it = super.getParentActivityIntent()



    it?.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
    return it
}

Essa abordagem obtém a instância da Intent que chamará a activity-pai
(parent activity) definida no AndroidManifest.xml e a chamará adicionando a
flag FLAG_ACTIVITY_CLEAR_TOP.

Seleção múltipla com action bar
A próxima funcionalidade a ser implementada na aplicação é a exclusão de
hotéis usando a seleção múltipla da ListView. Para isso, será utilizado um
recurso chamado Contextual ActionBar que permite exibir opções de menu
na action bar em um momento específico da aplicação. Neste exemplo, esse
momento é a possibilidade de excluir vários itens da lista.

Tornou-se praticamente padrão excluir múltiplos itens de uma lista dando
um clique longo em um dos itens e depois selecionar os demais (podemos ver
isso no Gmail, Google Photos etc.).

Primeiramente adicione alguns métodos à interface HotelListView:
interface HotelListView {
    fun showHotels(hotels: List<Hotel>)
    fun showHotelDetails(hotel: Hotel)
    fun showDeleteMode()
    fun hideDeleteMode()
    fun showSelectedHotels(hotels: List<Hotel>)
    fun updateSelectionCountText(count: Int)
}

O método showDeleteMode() será responsável por habilitar o modo de exclusão,
enquanto o método hideDeleteMode() realizará a operação reversa. O método
showSelectedHotels(List<Hotel>) marcará os hotéis selecionados para exclusão. E,
por fim, o método updateSelectionCountText(Int) será usado para atualizar o título da
tela com a quantidade de itens selecionados.

Faça agora a implementação das mudanças no HotelListPresenter:
class HotelListPresenter(
        private val view: HotelListView,
        private val repository: HotelRepository
) {
    private var lastTerm = ""
    private var inDeleteMode = false
    private val selectedItems = mutableListOf<Hotel>()



 
    fun searchHotels(term: String) {
        lastTerm = term
        repository.search(term) { hotels ->
            view.showHotels(hotels)
        }
    }
    fun selectHotel(hotel: Hotel) {
        if (inDeleteMode) {
            toggleHotelSelected(hotel)
            if (selectedItems.size == 0) {
                view.hideDeleteMode()
            } else {
                view.updateSelectionCountText(selectedItems.size)
                view.showSelectedHotels(selectedItems)
            }
        } else {
            view.showHotelDetails(hotel)
        }
    }
    private fun toggleHotelSelected(hotel: Hotel) {
        val existing = selectedItems.find { it.id == hotel.id }
        if (existing == null) {
            selectedItems.add(hotel)
        } else {
            selectedItems.removeAll { it.id == hotel.id }
        }
    }
    fun showDeleteMode() {
        inDeleteMode = true
        view.showDeleteMode()
    }
    fun hideDeleteMode() {
        inDeleteMode = false
        selectedItems.clear()
        view.hideDeleteMode()
    }
    fun refresh() {
        searchHotels(lastTerm)
    }
    fun deleteSelected(callback: (List<Hotel>)->Unit) {
        repository.remove(*selectedItems.toTypedArray())
        refresh()
        callback(selectedItems)
        hideDeleteMode()



    }
}

KOTLINxJAVA: É possível passar um array para um método que recebe um
varargs simplesmente adicionando um asterisco (*) à frente.

KOTLINxJAVA: Para converter uma lista para um Array, pode-se utilizar o
método toTypedArray().

As mudanças na classe HotelListPresenter começam pela definição de novos
atributos. O primeiro deles é o lastTerm que armazena o último termo
pesquisado que é atualizado a cada nova busca feita pelo método
searchHotels(String). Para saber se a tela se encontra em modo de exclusão foi
definido o atributo inDeleteMode. Por fim, a lista de hotéis selecionados para
exclusão é armazenada em selectedItems.

O método selectHotel(Hotel) será chamado ao clicar em um item da lista. Caso a
tela esteja em modo de exclusão, o método toggleHotelSelected(Hotel) adicionará o
hotel à selectedItems caso ela não esteja na lista, ou a removerá caso contrário.
Após realizar essa ação, se a lista de itens selecionados estiver vazia, o modo
de exclusão é encerrado invocando o método hideDeleteMode(). Caso contrário,
atualiza os itens selecionados invocando os métodos updateSelectionCountText(Int) e
showSelectedHotels(List<Hotel>).

Os demais métodos são mais simples. O showDeleteMode() e hideDeleteMode()
simplesmente alteram a flag inDeleteMode e chamam o respectivo método da
view. Já o método deleteSelected() chama o repositório para remover os hotéis
selecionados, refaz a última busca para atualizar a lista e encerra o modo de
exclusão.

Finalize a implementação fazendo as seguintes mudanças na classe
HotelListFragment:
import androidx.appcompat.view.ActionMode
import androidx.appcompat.app.AppCompatActivity
// Demais imports
 
class HotelListFragment : ListFragment(),
        HotelListView,
        AdapterView.OnItemLongClickListener,
        ActionMode.Callback {
    private var actionMode: ActionMode? = null



     ...
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        presenter.searchHotels("")
        listView.onItemLongClickListener = this
    }
    override fun showHotels(hotels: List<Hotel>) {
        val adapter = ArrayAdapter<Hotel>(requireContext(),
            android.R.layout.simple_list_item_activated_1, hotels)
        listAdapter = adapter
    }
    override fun onListItemClick(l: ListView?, v: View?, position: Int, id: Long) {
        super.onListItemClick(l, v, position, id)
        val hotel = l?.getItemAtPosition(position) as Hotel
        presenter.selectHotel(hotel)
    }
            /* showHotelDetails, search, clearSearch e a interface
               OnHotelClickListener não sofreram alterações */
    override fun onItemLongClick(parent: AdapterView<*>?, view: View?,
                                 position: Int, id: Long): Boolean {
        val consumed = (actionMode == null)
        if (consumed) {
            val hotel = parent?.getItemAtPosition(position) as Hotel
            presenter.showDeleteMode()
            presenter.selectHotel(hotel)
        }
        return consumed
    }
    override fun showDeleteMode() {
        val appCompatActivity = (activity as AppCompatActivity)
        actionMode = appCompatActivity.startSupportActionMode(this)
        listView.onItemLongClickListener = null
        listView.choiceMode = ListView.CHOICE_MODE_MULTIPLE
    }
    override fun hideDeleteMode() {
        listView.onItemLongClickListener = this
        for (i in 0 until listView.count) {
            listView.setItemChecked(i, false)
        }
        listView.post {
            actionMode?.finish()
            listView.choiceMode = ListView.CHOICE_MODE_NONE
        }
    }
    override fun updateSelectionCountText(count: Int) {



        view?.post {
            actionMode?.title = resources.getQuantityString(R.plurals.list_hotel_selected, count, count)
        }
    }
    override fun showSelectedHotels(hotels: List<Hotel>) {
        listView.post {
            for (i in 0 until listView.count) {
                val hotel = listView.getItemAtPosition(i) as Hotel
                if (hotels.find { it.id == hotel.id } != null) {
                    listView.setItemChecked(i, true)
                }
            }
        }
    }
    override fun onActionItemClicked(mode: ActionMode?, item: MenuItem?): Boolean {
        if (item?.itemId == R.id.action_delete) {
            presenter.deleteSelected { hotels ->
                if (activity is OnHotelDeletedListener) {
                    (activity as OnHotelDeletedListener).onHotelsDeleted(hotels)
                }
            }
            return true
        }
        return false
    }
    override fun onCreateActionMode(mode: ActionMode?, menu: Menu?): Boolean {
        activity?.menuInflater?.inflate(R.menu.hotel_delete_list, menu)
        return true
    }
    override fun onPrepareActionMode(mode: ActionMode?, menu: Menu?): Boolean = false
 
    override fun onDestroyActionMode(mode: ActionMode?) {
        actionMode = null
        presenter.hideDeleteMode()
    }
    interface OnHotelDeletedListener {
        fun onHotelsDeleted(hotels: List<Hotel>)
    }
}

A interface ActionMode.Callback permite tratar a mudança de contexto da action
bar. Já a interface AdapterView.OnItemLongClickListener captura o clique longo no
item da lista. Quando esse evento ocorrer, o método
onItemLongClick(AdapterView,View, int,long) será invocado. Nesse momento, é
verificado se o atributo actionMode é igual a nulo; em caso positivo, o método



showDeleteMode() é chamado e o atributo actionMode é inicializado por meio do
método startSupportActionMode(ActionMode.Callback). Neste exemplo, ela exibe a
opção de excluir e mostra quantos itens estão selecionados. Nesse momento,
a seleção múltipla na ListView é habilitada usando a propriedade choiceMode
(ListView.CHOICE_MODE_MULTIPLE). Ainda no evento de clique longo da lista, é
selecionado o item da posição clicada selectHotel(Hotel) do presenter, que
adicionará o hotel na lista dos selecionados, e, em seguida, invocará os
métodos updateSelectionCountText(Int) e showSelectedHotels(List<Hotel>).

No método onListItemClick(ListView, View, int, long), o método selectHotel(Hotel) do
presenter é chamado, então é verificado se o atributo inDeleteMode é igual a false;
nesse caso, a tela não está no modo de exclusão de itens, então o clique do
item deve ser processado normalmente. Caso contrário, a lista é atualizada
com o novo item que foi clicado. Porém, se não houver mais itens
selecionados, o modo de seleção é desativado ao chamar o método
hideDeleteMode() que finaliza o modo de exclusão invocando o método finish() do
objeto actionMode, deseleciona todos os itens da ListView e muda seu choiceMode
para ListView.CHOICE_MODE_NONE.

Note que o arquivo de layout utilizado na criação do adapter foi alterado. O
layout android.R.layout.simple_list_item_activated_1 do próprio Android deixará o item
da lista com uma cor diferente ao ser selecionado. Esse arquivo de layout
contém um <selector> para quando o item estiver marcado.

Observe o código referente à implementação dos métodos da interface
ActionMode.Callback. O método onCreateActionMode(ActionMode,Menu) permite carregar
um arquivo de menu exclusivo para ActionMode. Note que ele está retornando
true para informar que ele pode ser criado. Já o método
onPrepareActionMode(ActionMode,Menu) é usado para atualizar o action mode após
sua criação; é retornado false para indicar que ele não precisa ser atualizado.
Quando uma opção de menu do actionMode é selecionada, o método
onActionItemClicked(ActionMode,MenuItem) é chamado, e nele é verificado se a opção
selecionada foi a de excluir; em caso positivo, o método deleteSelected() do
presenter é chamado. Perceba que esse método possui uma função de
callback que é chamada quando a exclusão dos itens é concluída. A
informação é necessária na versão para tablets do aplicativo, pois se o usuário
estiver visualizando os detalhes de um hotel e este for excluído, o fragment
de detalhes deve ser removido da tela. Isso será feito na activity.



Ao chamar o método finish() do objeto actionMode, o método onDestroyActionMode
(ActionMode) é chamado. Nesse momento, o atributo recebe o valor null, e o
modo de exclusão é finalizado.

KOTLINxJAVA: A estrutura for do Kotlin trabalha com intervalos ou coleções.
Conforme os exemplos:

for (item in myList) { } // itera pelos elementos da myList
for (i in 0..10) { } // de 0 a 10
for (i in 0 until 10) { } // de 0 a 9
for (i in 10 downTo 0) { } // de 10 a 0
for (i in 0..10 step 2) { } // 0, 2, 4, 6, 8 e 10

Crie o arquivo de menu exclusivo para o menu de contexto da action bar.
Adicione o arquivo res/menu/hotel_delete_list.xml e deixe-o conforme a
seguir:
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
        android:id="@+id/action_delete"
        android:icon="@android:drawable/ic_menu_delete"
        android:title="@string/action_delete"
        app:showAsAction="always"/>
</menu>

Estão faltando as strings action_delete e list_hotel_selected, que devem ser
adicionadas ao res/values/strings.xml:
<string name="action_delete">Excluir</string>
<plurals name="list_hotel_selected">
    <item quantity="one">1 selecionado</item>
    <item quantity="other">%d selecionados</item>
</plurals>

Execute a aplicação e dê um clique longo em um item da lista. O resultado
será similar ao da Figura 8.11.



Figura 8.11 – Lista com exclusão múltipla com ActionBar.
Perceba que a action bar muda de cor ao realizar um clique longo na lista.

Para configurar a cor desejada, basta alterar o atributo actionModeBackground do
tema da aplicação no res/values/styles.xml:
<resources>
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        ...
        <item name="actionModeBackground">@color/colorActionMode</item>
    </style>
</resources>

Adicione esta cor no res/values/colors.xml:
<color name="colorActionMode">#79cb98</color>

Execute a aplicação e ela deve estar funcionando bem em smartphones, mas
ao abri-la em um tablet, selecionar um registro e excluí-lo, a informação do
hotel continuará sendo exibida.

É preciso fazer a mudança na HotelActivity para remover o fragment de
detalhe caso o registro referente a esse hotel tenha sido excluído:
class HotelActivity : AppCompatActivity(),
        HotelListFragment.OnHotelClickListener,
        HotelListFragment.OnHotelDeletedListener,
        SearchView.OnQueryTextListener,
        MenuItem.OnActionExpandListener,



        HotelFormFragment.OnHotelSavedListener {
    private var hotelIdSelected: Long = -1
    // Demais atributos... e onCreate...
    override fun onSaveInstanceState(outState: Bundle?) {
        super.onSaveInstanceState(outState)
        outState?.putLong(EXTRA_HOTEL_ID_SELECTED, hotelIdSelected)
        outState?.putString(EXTRA_SEARCH_TERM, lastSearchTerm)
    }
    override fun onRestoreInstanceState(savedInstanceState: Bundle?) {
        super.onRestoreInstanceState(savedInstanceState)
        hotelIdSelected = savedInstanceState?.getLong(EXTRA_HOTEL_ID_SELECTED) ?: 0
        lastSearchTerm = savedInstanceState?.getString(EXTRA_SEARCH_TERM) ?: ""
    }
    override fun onHotelClick(hotel: Hotel) {
        if (isTablet()) {
            hotelIdSelected = hotel.id
            showDetailsFragment(hotel.id)
        } else {
            showDetailsActivity(hotel.id)
        }
    }
   // Demais métodos não mudaram
    override fun onHotelsDeleted(hotels: List<Hotel>) {
        if (hotels.find { it.id == hotelIdSelected } != null) {
            val fragment = supportFragmentManager.findFragmentByTag(
                HotelDetailsFragment.TAG_DETAILS)
            if (fragment != null) {
                supportFragmentManager
                        .beginTransaction()
                        .remove(fragment)
                        .commit()
            }
        }
    }
    companion object {
        const val EXTRA_SEARCH_TERM = "lastSearch"
        const val EXTRA_HOTEL_ID_SELECTED = "lastSelectedId"
    }
}

O atributo hotelIdSelected armazena o id do último hotel que foi clicado, esse
valor é salvo no onSaveInstanceState(Bundle), pois em tablet o usuário pode ter
clicado no hotel, girado a tela antes de excluí-lo. No método
onHotelsDeleted(List<Hotel>), é verificado se o hotel excluído é o mesmo que
tínhamos selecionado previamente, e nesse caso o fragment é removido da



tela.

Retendo a instância do Fragment
Você pode não ter notado, mas a aplicação tem um problema: ao girar o
aparelho em modo de exclusão, os itens selecionados são perdidos e a
aplicação volta ao estado de listagem normal. Para corrigir esse problema,
abra a classe HotelListFragment e substitua a chamada ao método search(String) pelo
método init() da classe HotelListPresenter (que será implementada a seguir). E
modifique a propriedade retainInstance para true conforme a seguir:
class HotelListFragment /*... */ {
    ...
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        retainInstance = true
        presenter.init()
        listView.onItemLongClickListener = this
    }

Com essa mudança, a instância do HotelListFragment será mantida e só será
destruída quando a activity for encerrada. É importante ressaltar que a view
do fragment continua sendo destruída, ou seja, o método
onCreateView(LayoutInflater, ViewGroup, Bundle) será chamado novamente, mas os
atributos do fragment (como o presenter) serão mantidos.

Agora implemente o método init() do presenter que deve ficar como a seguir:
class HotelListPresenter(/* nada mudou aqui */) {
    ...
    fun init() {
        if (inDeleteMode) {
            showDeleteMode()
            view.updateSelectionCountText(selectedItems.size)
            view.showSelectedHotels(selectedItems)
        } else {
            refresh()
        }
    }

Com essa implementação, quando a activity for recriada, o presenter
verificará em que estado ele se encontra (em modo de exclusão ou não) e
chamará os métodos apropriados da view.

Execute a aplicação, entre no modo exclusão, gire a tela e perceba que o



estado da aplicação agora estará consistente.

Desfazendo a exclusão com a SnackBar
A funcionalidade de remover hotéis foi implementada, mas não foi solicitada
nenhuma confirmação do usuário para excluir as informações. Isso é normal
e até recomendado, pois não é interessante ficar interrompendo o usuário com
mensagens para ações tão corriqueiras.

Como não foi exibida uma mensagem de confirmação, uma alternativa é
permitir que o usuário desfaça a ação realizada. Para esse tipo de ação, o
componente SnackBar é bem adequado, pois ele tem o propósito parecido com
o Toast, que é exibir uma mensagem para o usuário na parte inferior da tela,
entretanto a Snackbar fornece a possibilidade de “fechá-la” deslizando-o para a
direita e, opcionalmente, permite adicionar uma ação na qual o usuário
poderá selecionar.

A Snackbar está disponível na biblioteca de design que já foi adicionada por
conta do TextInputLayout utilizado na tela de cadastro.

Adicione duas strings ao res/values/strings.xml que serão usadas nessa
ação:
<string name="message_hotels_deleted">%d itens excluídos.</string>
<string name="undo">Desfazer</string>

Em seguida, adicione a lógica de desfazer a exclusão dos itens da lista
implementando as seguintes mudanças na classe HotelListPresenter:
class HotelListPresenter /* nada muda aqui */ {
    ...
    private val deletedItems = mutableListOf<Hotel>()
    fun deleteSelected(callback: (List<Hotel>)->Unit) {
        repository.remove(*selectedItems.toTypedArray())
        deletedItems.clear()
        deletedItems.addAll(selectedItems)
        refresh()
        callback(selectedItems)
        hideDeleteMode()
        view.showMessageHotelsDeleted(deletedItems.size)
    }
    fun undoDelete() {
        if (deletedItems.isNotEmpty()) {
            for (hotel in deletedItems) {
                repository.save(hotel)



            }
            searchHotels(lastTerm)
        }
    }
}

O atributo deletedItems foi criado para armazenar os hotéis que foram
excluídos no método deleteSelected(). Esse atributo é usado no método undoDelete()
que salva novamente no repositório os itens excluídos. Perceba que quando
os hotéis selecionados são excluídos, o método showMessageHotelsDeleted() da
view é chamado. Defina esse método na interface HotelListView como a seguir:
interface HotelListView {
    ...
    fun showMessageHotelsDeleted(count: Int)
}

Por fim, a classe HotelListFragment deve implementar esse método como a
seguir:
override fun showMessageHotelsDeleted(count: Int) {
    Snackbar.make(listView,
        getString(R.string.message_hotels_deleted, count),
        Snackbar.LENGTH_LONG)
        .setAction(R.string.undo) {
            presenter.undoDelete()
        }
        .show()
}

Ao clicar na ação de excluir, o método deleteSelected() do presenter é chamado,
os itens selecionados são excluídos do repositório e são armazenados no
atributo deletedItems. Feito isso, o método showMessageHotelsDeleted(Int) é invocado e
então a SnackBar é exibida, informando a quantidade de itens excluídos. No
método setAction(OnClickListener), o método undo() do presenter é invocado para
desfazer a exclusão. Ao desfazer a ação de excluir, os itens excluídos são
adicionados novamente ao repositório. Execute a aplicação, exclua alguns
itens, e desfaça a ação utilizando a SnackBar. O resultado deve ficar similar ao
da Figura 8.12.



Figura 8.12 – SnackBar para desfazer a exclusão dos itens.
A duração da SnackBar pode ser LENGTH_LONG e LENGTH_SHORT como no Toast,

mas também é possível utilizar o valor LENGTH_INDEFINITE que fará com que a
SanckBar fique visível até que o usuário a remova, deslizando para o lado.
Também pode-se definir a cor do texto do botão de ação por meio do método
setActionTextColor(int).

Você deve ter percebido que, ao desfazer a ação, os itens não voltam na
mesma ordem em que foram inseridos. Para resolver esse problema, deixe os
itens da lista ordenados pelo nome do hotel. Para isso, altere o método search()
do MemoryRepository para ficar como no código a seguir:
override fun search(term: String, callback: (List<Hotel>) -> Unit) {
    val resultList =
            if (term.isEmpty()) hotelsList
            else hotelsList.filter {
                it.name.toUpperCase().contains(term.toUpperCase())
            }
    callback(resultList.sortedBy { it.name })
}

O método sortBy permite ordenar os elementos de uma lista. Execute a
aplicação novamente e a ação de desfazer deve estar funcionando
corretamente.



Floating Action Button
O Floating Action Button, ou simplesmente FAB como é costumeiramente
chamado, é um botão redondo utilizado para representar a ação principal de
uma tela. Ele foi introduzido junto com o Material Design no Android 5
Lollipop e pode ser apresentado em dois tamanhos: normal com 56 dp, ou
mini, com 40 dp. Independente do tamanho, o ícone interno deve ter 24 dp de
largura/altura. Uma recomendação é que o FAB seja utilizado para ações
positivas, como criar, adicionar aos favoritos, compartilhar, navegar etc., e
não para ações destrutivas (como excluir) ou ações não intuitivas que são
mais comumente encontradas na action bar.

Esse componente será utilizado nesse aplicativo para substituir a ação de
adicionar um novo hotel que está na toolbar. Abra o arquivo
res/layout/activity_hotel.xml e faça as seguintes alterações:
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <fragment android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:name="dominando.android.fragments.HotelListFragment"
        android:id="@+id/fragmentList"/>
    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/fabAdd"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        android:tint="@android:color/white"
        app:srcCompat="@drawable/ic_add"
        app:fabSize="normal"
        app:borderWidth="0dp"
        android:layout_gravity="bottom|end"/>
</FrameLayout>

Perceba que foi utilizado o ícone chamado ic_add. Adicione-o clicando
com o botão direito sobre a pasta res/drawable e selecione New > Vector
Asset, em seguida, clique Clip art, selecione a imagem do ícone “add”. Por
fim, escolha a cor branca (#FFFFFF) para o ícone.

A seguir estão listadas algumas propriedades importantes do FAB:
• fabSize – determina o tamanho do botão. Pode assumir os valores normal e



mini;
• backgroundTint – determina a cor do botão; por padrão, o FAB terá a cor

colorAccent definida no estilo da aplicação;
• borderWidth – define uma borda para o botão;
• tintColor – cor do ícone do botão;
• rippleColor – atribui uma cor para o efeito de ripple ao pressionar o botão;
• srcCompat – define o ícone exibido dentro do botão;
• layout_anchor – recebe o id do componente no qual o botão deverá ficar

ancorado;
• layout_anchorGravity – indica a direção da ancoragem do FAB em relação ao

outro componente (left, right, bottom, top).
Lembre-se de adicionar o FAB ao layout para tablets. Altere o arquivo

res/layout-sw600dp/activity_main.xml:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal">
    <fragment
        android:id="@+id/fragmentList"
        android:name="dominando.android.fragments.HotelListFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:baselineAligned="false"/>
    <FrameLayout
        android:id="@+id/details"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="2">
        <com.google.android.material.floatingactionbutton.FloatingActionButton
            android:id="@+id/fabAdd"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="bottom|end"
            android:layout_margin="16dp"
            android:tint="@android:color/white"
            app:srcCompat="@drawable/ic_add"
            app:borderWidth="0dp"
            app:fabSize="normal" />



    </FrameLayout>
</LinearLayout>

Adicione o código a seguir à classe HotelActivity:
// import do Kotlin extensions
import kotlinx.android.synthetic.main.activity_hotel.*
// No onCreate
fabAdd.setOnClickListener {
    listFragment.hideDeleteMode()
    HotelFormFragment.newInstance().open(supportFragmentManager)
}

Remova a ação de adicionar do método onOptionsItemSelected(MenuItem) e do
arquivo res/menu/hotel.xml. Execute a aplicação, e teremos um resultado
semelhante à Figura 8.13.

Figura 8.13 – Floating Action Button.

Coordinator Layout
O CoordinatorLayout é mais um importante componente da biblioteca do Material
Design, e, segundo a própria documentação, ele é um FrameLayout com “super-
poderes”, pois coordena animações em componentes que estão definidos
dentro dele. Com a adição do FAB à HotelActivity, foi gerado um pequeno



problema visual: ao excluir itens da lista, a SnackBar é exibida sobre o FAB, e
isso não é desejado.

Para resolver esse problema, será utilizado o CoordinatorLayout. Seu uso é
muitíssimo simples, basta substituir o FrameLayout que foi utilizado no arquivo
res/layout/activity_hotel.xml pelo CoordinatorLayout:
<androidx.coordinatorlayout.widget.CoordinatorLayout ...>
    <fragment .../>
    <androidx.constraintlayout.widget.ConstraintLayout ... />
</androidx.coordinatorlayout.widget.CoordinatorLayout>

Pronto! Só será preciso fazer essa alteração no layout para smartphones. No
layout para tablets há mais espaço, então o problema com a SnackBar não
acontece. Teste a aplicação novamente e perceberá que o problema foi
resolvido.

O último detalhe é que, com o CoordinatorLayout, a função de deslizar para
remover a SnackBar funcionará automaticamente. Outras funcionalidades desse
componente serão abordadas no Capítulo 30.

Ação de compartilhamento
É evidente a presença das redes sociais na vida das pessoas e o
compartilhamento de informações por esse meio já faz parte do cotidiano. No
Android, o recurso de compartilhamento nas aplicações pode ser adicionado
usando a action bar. Com um simples clique, o usuário poderá compartilhar
informações nas redes sociais por meio dos aplicativos disponíveis no
aparelho ou até mesmo enviá-las via email ou mensagem de texto.

Para exemplificar seu uso, será adicionada uma opção onde o usuário possa
compartilhar sua avaliação de determinado hotel. Crie o arquivo
res/menu/hotel_details.xml e deixe-o como a seguir:
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto" >
    <item android:id="@+id/action_share"
        android:title="@string/action_share"
        app:showAsAction="ifRoom"
        app:actionProviderClass="androidx.appcompat.widget.ShareActionProvider"
        />
</menu>

Adicione as seguintes strings no res/values/strings.xml:
<string name="action_share">Compartilhar</string>



<string name="share_text">Me hospedei no %1$s e o classifiquei em %2$.1f estrelas</string>
Por fim, vá até o HotelDetailsFragment e faça as seguintes modificações:

// Adicione esse atributo. Atenção ao nome do pacote!
// androidx.appcompat.widget.ShareActionProvider
private var shareActionProvider : ShareActionProvider? = null
 
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setHasOptionsMenu(true)
}
override fun onCreateOptionsMenu(menu: Menu?, inflater: MenuInflater?) {
    super.onCreateOptionsMenu(menu, inflater)
    inflater?.inflate(R.menu.hotel_details, menu)
    val shareItem = menu?.findItem(R.id.action_share)
    shareActionProvider = MenuItemCompat.getActionProvider(shareItem) as? ShareActionProvider
    setShareIntent()
}
private fun setShareIntent() {
    val text = getString(R.string.share_text, hotel?.name, hotel?.rating)
    shareActionProvider?.setShareIntent(Intent(Intent.ACTION_SEND).apply {
        addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT)
        type = "text/plain"
        putExtra(Intent.EXTRA_TEXT, text)
    })
}

Os fragments por padrão não possuem opções de menu, por isso, no
onCreate(Bundle) o menu foi habilitado para esse fragment por meio do método
setHasOptionsMenu(Boolean). Já a classe ShareActionProvider é a responsável por
retornar à lista de aplicativos capaz de tratar determinada Intent de
compartilhamento.

Execute a aplicação e clique em um hotel. Será adicionado um ícone de
compartilhar na action bar. Ao clicar na opção de compartilhar a lista de
aplicativos instalados no aparelho será exibida, conforme podemos observar
na Figura 8.14.

É possível escolher qualquer aplicativo. Ao escolher o Twitter, teremos
algo parecido com a Figura 8.15.



Figura 8.14 – Ação de compartilhamento na ActionBar.

Figura 8.15 – Compartilhando informação com o Twitter.
Esse foi mais um longo capítulo em que estudamos os principais conceitos



envolvidos com fragments e action bar. Esse exemplo não terminou aqui, ele
continuará sendo evoluído durante todo o livro.

1 É possível redimensionar a tela de um emulador do Genymotion. Basta, antes de executá-lo, escolher
as propriedades do emulador e alterar o tamanho de tela da maneira qu desejar.



CAPÍTULO 9
Modos de navegação

No capítulo anterior foi mostrado como utilizar os Fragments e como
adicionar ações na Action Bar inclusive com a SearchView e com ações
contextuais. Porém, à medida que o aplicativo cresce, novos fluxos
navegacionais são criados para realizar suas funcionalidades. Neste capítulo
será demonstrado como implementar algumas formas de navegação mais
utilizadas e em quais cenários elas devem ser utilizadas.

Tipos de navegação
Um ponto importante ao iniciar o desenvolvimento de um aplicativo é definir
como será o seu fluxo navegacional. No Android, três opções são muito
comuns: tabs, bottom tabs e drawer.

As tabs (ou abas) são utilizadas normalmente para agrupar conteúdos
igualmente importantes, como, por exemplo, categorias de notícias de um
jornal. As abas podem ser utilizadas em qualquer parte da aplicação e
permitem alternar rapidamente entre elas fazendo o gesto de swipe ou
clicando na própria aba. Entretanto, as tabs não devem ser utilizadas como
“carrossel” ou paginação de informações. Também não é recomendável
utilizá-las se o conteúdo de alguma aba suportar gestos de swipe, pois esse
gesto é utilizado para realizar a troca de abas e isso comprometeria a
usabilidade.

As bottom tabs (barra com abas na parte inferior) devem ser utilizadas para
proporcionar uma navegação rápida entre conteúdos não relacionados da
aplicação. Devem ser utilizadas na tela principal e não devem exibir menos
que três opções e não mais que cinco. Se a aplicação possuir mais de cinco
fluxos principais, devem-se colocar os fluxos principais nas bottom tabs e as
demais no drawer, ou utilizar apenas o drawer.

O drawer é um menu lateral que pode ser acionado ao clicar no ícone à



esquerda da action bar (normalmente chamado de “hambúrguer”) ou
deslizando para a direita a partir da extremidade esquerda da tela. Ao clicar
em uma opção do drawer, um fragment pode ser exibido na própria activity
ou uma nova activity pode ser exibida. Ao usar fragments, podemos dizer que
ele está no “primeiro nível de navegação”. Se precisar aprofundar na
navegação, devemos criar outro nível usando uma nova activity, e nela
podemos iniciar um novo fluxo navegacional.

O exemplo deste capítulo demonstrará a utilização de todos esses tipos de
navegação. A Figura 9.1 mostra como ficará o fluxo de telas da aplicação.

Figura 9.1 – Fluxo navegacional da aplicação.
A activity principal terá um menu lateral, com três opções: “Abas”,

“Bottom” e “View Pager”. Ao clicar em qualquer uma delas, será exibido um
fragment com o texto da opção selecionada e um botão que, ao ser clicado,
iniciará uma nova activity. A primeira opção demonstrará a navegação com
abas, a segunda, com bottom tabs, e na última mostraremos o ViewPager, que
será similar à de abas, mas independente da action bar.

Toolbar



A partir da versão Lollipop, a ActionBar dá lugar à Toolbar como local para
centralização de ações da tela do seu aplicativo. Ela é mais fácil de trabalhar,
pois, além de poder ser associada a uma ActionBar, também pode ser declarada
dentro de um arquivo de layout e posicionada da maneira que preferir:
<androidx.appcompat.widget.Toolbar
   android:id="@+id/toolbar"
   android:layout_width="match_parent"
   android:layout_height="?attr/actionBarSize"
   android:background="?attr/colorPrimary"
   android:elevation="4dp"
   android:theme="@style/ThemeOverlay.AppCompat.ActionBar"
   app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/>

Podem-se utilizar a Toolbar e a ActionBar na mesma tela de forma
independente, mas para utilizar a Toolbar no lugar da ActionBar deve-se
desabilitar esta última. A maneira mais simples de fazer isso é alterar o tema
da aplicação no res/values/styles.xml:
<style name="TemaBase" parent="@style/Theme.AppCompat.Light.NoActionBar">
</style>

Utilizando o tema com a terminação NoActionBar, a ActionBar é desabilitada e
para que a Toolbar fique em seu lugar é preciso instanciá-la na activity e
invocar o método setSupportActionBar(Toolbar).

Feita essa ligação, todas as ações que forem carregadas para a ActionBar serão
atribuídas à Toolbar. Ou seja, podemos carregar os arquivos de menu
normalmente e tratar suas ações como se fossem a ActionBar.

Também é possível trabalhar com a Toolbar de forma avulsa, isto é, sem
ligação com a ActionBar, colocando-a em qualquer local do layout. E para
associar opções de menu basta fazer algo como mostrado no código a seguir:
toolbar.inflateMenu(R.menu.my_menu)
toolbar.setOnMenuItemClickListener { menuItem ->
    // Tratar opções de menu aqui...
    true // return true se a opção foi tratada
}

Nesse exemplo, um arquivo de menu é carregado por meio do método
inflateMenu(int) para tratar as respectivas opções, basta utilizar o método
setOnMenuItemClickListener(OnMenuItemClickListener). A Toolbar suporta os mesmos
itens de menu da ActionBar, como a SearchView vista no capítulo anterior.



DrawerLayout e NavigationView
Inicie um novo projeto e adicione as seguintes linhas ao arquivo
res/values/strings.xml:

Application Name Navegacao
Package Name dominando.android.navegacao
Activity Name MainActivity

<string name="option_tab">Abas</string>
<string name="option_bottom">Bottom</string>
<string name="option_pager">View Pager</string>
<string name="tab_favorites">Favoritos</string>
<string name="tab_schedule">Agendamentos</string>
<string name="tab_people">Pessoas</string>
<string-array name="sections">
    <item>Seção 1</item>
    <item>Seção 2</item>
    <item>Seção 3</item>
</string-array>

Em seguida, crie o arquivo res/values/arrays.xml e deixe-o como a seguir:
<resources>
    <array name="bg_colors">
        <item>#FFCDD2</item>
        <item>#B2DFDB</item>
        <item>#BBDEFB</item>
    </array>
    <array name="text_colors">
        <item>#F44336</item>
        <item>#4CAF50</item>
        <item>#03A9F4</item>
    </array>
</resources>

Foram declarados alguns textos referentes às três formas de navegação que
serão exibidas como opções no menu lateral. Os títulos dos fragments que
farão parte das telas do segundo nível de navegação estão no array sections, e
suas cores de background e de texto estão nos arrays bg_colors e text_colors
respectivamente.

Mais alguns ajustes devem ser feitos no projeto. Como será utilizada a
Toolbar, é necessário desabilitar a ActionBar; altere o arquivo
res/values/styles.xml e deixe-o como a seguir:
<resources>



    <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>
    <style name="MainTheme" parent="AppTheme">
        <item name="android:windowTranslucentStatus">true</item>
    </style>
</resources>

Desabilitamos a ActionBar utilizando o tema Theme.AppCompat.Light.NoActionBar.
Perceba que o tema AppTheme herda do tema da API de compatibilidade, e o
tema MainTheme está herdando de AppTheme. A propriedade
android:windowTranslucentStatus foi habilitada, pois a recomendação do Material
Design é que a barra de status fique transparente e que o menu lateral fique
visível através dela.

No AndroidManifest.xml faça a seguinte mudança:
<manifest ...>
 
    <application ...
        android:theme="@style/AppTheme">
        <activity
            android:name=".MainActivity"
            android:theme="@style/MainTheme" ...>

Certifique-se de que a aplicação esteja usando o AppTheme e que a MainActivity
use o MainTheme.

A Toolbar faz parte da biblioteca do Material Design, então é preciso
adicionar a dependência no build.gradle:
dependencies {
   ...
   implementation 'com.google.android.material:material:1.0.0'
}

Como a Toolbar será utilizada em mais de uma activity, então é interessante
declará-la em um arquivo separado e depois apenas referenciá-la por meio da
tag <include>. Crie o arquivo res/layout/toolbar.xml e deixe-o da seguinte
forma:
<androidx.appcompat.widget.Toolbar
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/toolbar"
    android:layout_width="match_parent"



    android:layout_height="?attr/actionBarSize"
    android:background="?attr/colorPrimary"
    app:popupTheme="@style/ThemeOverlay.AppCompat"
    app:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" />

Há alguns detalhes interessantes nesse arquivo: foi utilizada a propriedade
app:theme apontando para o estilo ThemeOverlay.AppCompat.ActionBar para que o
texto e os ícones fiquem brancos; o app:popupTheme é usado para pop-ups
criados a partir da Toolbar como o overflow menu; e a cor de background é
definida usando o atributo colorPrimary do estilo que definimos (por isso o uso
do ?attr).

Para criar o menu lateral, deve-se utilizar o componente DrawerLayout, uma
ViewGroup que deve conter dois filhos: um será exibido como o menu lateral e
outro será o conteúdo principal da tela (LinearLayout, RelativeLayout etc.). Até o
lançamento da biblioteca do Material Design, uma ListView era utilizada para o
menu lateral, onde cada linha servia como uma opção de menu. Essa opção
funciona muito bem; o problema é que, para seguir as recomendações do
Material Design, tínhamos de criar um adapter, um selector, definir o
espaçamento, e assim por diante.

Esse trabalho foi minimizado com o componente NavigationView da biblioteca
de design, que já exibe os itens com o visual recomendado. Além disso, a
montagem e o tratamento dos itens são feitos com os arquivos de menu, que é
um padrão já consolidado no Android desde as primeiras versões.

Primeiramente crie o arquivo de layout res/layout/content_main.xml, no
qual será definido o conteúdo da tela, e deixe-o como a seguir:
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:theme="@style/ThemeOverlay.AppCompat.Light">
        <include layout="@layout/toolbar" />
    </com.google.android.material.appbar.AppBarLayout>
    <FrameLayout
        android:id="@+id/content"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />



</androidx.coordinatorlayout.widget.CoordinatorLayout>
Neste arquivo de layout poderia ter sido utilizado apenas a Toolbar, mas

como mencionado, o menu lateral deve ser exibido por baixo da barra de
status do aparelho (onde fica o relógio, sinal e nível bateria), mas o conteúdo
da tela não deve ocupar esta área. Neste cenário, o CoordinatorLayout juntamente
com o AppBarLayout resolvem esse problema para nós. O FrameLayout, por sua
vez, exibirá um fragment que será o conteúdo principal da tela e carregado
programaticamente.

Faça as seguintes mudanças no arquivo de layout
res/layout/activity_main.xml como mostrado a seguir:
<androidx.drawerlayout.widget.DrawerLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/drawerLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true"
    tools:context=".MainActivity">
    <include layout="@layout/content_main"/>
    <com.google.android.material.navigation.NavigationView
        android:id="@+id/navigationView"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_gravity="start"
        android:fitsSystemWindows="true"
        app:headerLayout="@layout/menu_header"
        app:menu="@menu/main" />
</androidx.drawerlayout.widget.DrawerLayout>

Este arquivo de layout contém um DrawerLayout com dois elementos: um
NavigationView e um <include> para o arquivo de layout
res/layout/content_main.xml e que exibirá o conteúdo da tela em si. No
NavigationView serão exibidas as opções de menu que podemos selecionar, e
essas opções estão definidas no arquivo res/menu/main.xml e que foi
referenciado na propriedade app:menu. Crie este arquivo e deixe-o como a
seguir:
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    tools:context=".MainActivity">
        <group android:checkableBehavior="single">



            <item
                android:id="@+id/action_tab"
                android:checked="true"
                android:icon="@android:drawable/ic_menu_add"
                android:title="@string/option_tab" />
            <item
                android:id="@+id/action_bottom"
                android:icon="@android:drawable/ic_menu_edit"
                android:title="@string/option_bottom" />
            <item
                android:id="@+id/action_pager"
                android:icon="@android:drawable/ic_menu_delete"
                android:title="@string/option_pager" />
        </group>
</menu>

O único detalhe novo nesse arquivo de menu é a possibilidade de escolher
apenas uma das opções como se fosse um RadioGroup. Isso é feito com a tag
<group> e sua propriedade checkableBehavior. Perceba que estamos utilizando
ícones já existentes no Android. Fique à vontade para criar os ícones que
desejar.

Outro detalhe no NavigationView é que ele também está referenciando um
arquivo de cabeçalho com a propriedade app:headerLayout. Crie o arquivo
res/layout/menu_header.xml e deixe-o como a seguir:
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="150dp"
    android:background="?attr/colorAccent"
    android:padding="16dp">
    <TextView
        android:id="@+id/textView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="start|bottom"
        android:text="@string/app_name"
        android:textColor="@android:color/white"
        android:textSize="24sp" />
</FrameLayout>

Esse arquivo é opcional e não tem nada que já não tenha sido visto antes.
Implemente agora a MainActivity que deve ficar como a seguir:
import android.os.Bundle
import android.view.MenuItem
import androidx.appcompat.app.ActionBarDrawerToggle



import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.GravityCompat
import kotlinx.android.synthetic.main.activity_main.*
import kotlinx.android.synthetic.main.toolbar.*
 
class MainActivity : AppCompatActivity() {
 
    private val drawerToggle: ActionBarDrawerToggle by lazy {
        ActionBarDrawerToggle(this,
                drawerLayout, toolbar, R.string.app_name, R.string.app_name)
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        setSupportActionBar(toolbar)
        drawerLayout.addDrawerListener(drawerToggle)
        drawerToggle.syncState()
        navigationView.setNavigationItemSelectedListener { menuItem ->
            selectMenuOption(menuItem)
            true
        }
        if (savedInstanceState == null) {
            selectMenuOption(navigationView.menu.findItem(R.id.action_tab))
        }
    }
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            android.R.id.home -> {
                drawerLayout.openDrawer(GravityCompat.START)
                return true
            }
        }
        return super.onOptionsItemSelected(item)
    }
    private fun selectMenuOption(menuItem: MenuItem) {
        menuItem.isChecked = true
        drawerLayout.closeDrawers()
    }
}

O atributo drawerToggle do tipo ActionBarDrawerToggle servirá para controlar a
abertura e o fechamento do menu lateral. Ele também é o responsável por
colocar o ícone que fica na Toolbar, popularmente conhecido por
“hambúrguer”.



No método onCreate(Bundle) foi definida a Toolbar como ActionBar dessa activity
utilizando o método setSupportActionBar(Toolbar). O drawerToggle foi inicializado
utilizando o delegate lazy e no construtor foi passado como parâmetro a
activity, o drawerLayout, a Toolbar e os textos para serem utilizados quando o
menu estiver aberto e fechado respectivamente (usados para acessibilidade).
A opção de tabs foi selecionada por padrão caso a activity não esteja sendo
recriada.

Após ser inicializado, o drawerToggle é associado ao drawerLayout usando o
método addDrawerListener(DrawerListener) e o método syncState() é invocado. Então,
um listener para detectar a opção de menu selecionada é definido para o
NavigationView ao invocar o método
setNavigationItemSelectedListener(OnNavigationItemSelectedListener). Com o objeto
MenuItem, o método selectMenuOption(MenuItem) é chamado. E por agora apenas
marcará a opção como selecionada e fechará o menu lateral.

Execute a aplicação, e você obterá um resultado semelhante ao da Figura
9.2.

Figura 9.2 – Menu lateral em execução.

Fragments do primeiro nível



Terminado o menu principal, o fragment de primeiro nível de navegação deve
ser criado e chamado de FirsLevelFragment. Antes, crie o arquivo de layout
res/layout/fragment_first_level.xml e deixe-o da seguinte forma:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical">
    <TextView
        android:id="@+id/textView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="24sp" />
    <Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@android:string/ok" />
</LinearLayout>

Nada a comentar nesse arquivo, pois ele contém apenas um TextView e Button.
Agora crie a classe FirstLevelFragment:
import android.content.Intent
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import kotlinx.android.synthetic.main.fragment_first_level.*
 
class FirstLevelFragment : Fragment() {
    private var navigationType: String? = null
    private var actions = mutableMapOf<String, Class<*>>()
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        actions.put(getString(R.string.option_tab), TabsActivity::class.java)
        actions.put(getString(R.string.option_bottom), BottomNavActivity::class.java)
        actions.put(getString(R.string.option_pager), PagerActivity::class.java)
    }
    override fun onCreateView(inflater: LayoutInflater,
                              container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_first_level, container, false)
    }



    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        navigationType = arguments?.getString(EXTRA_TYPE)
        button.setOnClickListener {
            val key = navigationType
            val clazz = actions[key]
            startActivity(Intent(activity, clazz))
        }
        textView.text = navigationType
    }
    companion object {
        private const val EXTRA_TYPE = "tipoNavegacao"
        fun newInstance(type: String): FirstLevelFragment {
            val params = Bundle()
            params.putString(EXTRA_TYPE, type)
            val f = FirstLevelFragment()
            f.arguments = params
            return f
        }
    }
}

Esse fragment será usado para todas as opções do menu lateral. Entretanto,
em uma aplicação real, normalmente cada opção do menu seria um fragment
diferente. É importante ressaltar que nesse primeiro nível é possível ter várias
opções de menu, mas, se for necessário detalhar mais a informação que
estamos exibindo, é recomendado criar uma nova activity (ou um novo
fragment se estiver em um tablet e tivermos espaço disponível).

O FirstLevelFragment exibirá um TextView com o texto da opção selecionada no
menu, e um Button, que ao ser clicado exibirá uma nova activity para cada tipo
de navegação que será exemplificada (criaremos a seguir), e cada uma delas
está mapeada no atributo actions.

Agora faça o seguinte ajuste no método selectMenuOption(MenuItem) da
MainActivity:
private fun selectMenuOption(menuItem: MenuItem) {
    menuItem.isChecked = true
    drawerLayout.closeDrawers()
    val title = menuItem.title.toString()
    if (supportFragmentManager.findFragmentByTag(title) == null) {
        val firstLevelFragment = FirstLevelFragment.newInstance(title)
        supportFragmentManager
                .beginTransaction()



                .replace(R.id.content, firstLevelFragment, title)
                .commit();
    }
}

A navegação no primeiro nível é baseada no título da opção de menu. Para
que o fragment não seja adicionado se ele já estiver na tela, o método
findFragmentByTag(String) da classe FragmentManager foi utilizado. Se esse método
retornar nulo, é porque não foi adicionado nenhum fragment com a tag igual
ao título da opção de menu; nesse caso, o fragment é adicionado à tela, por
meio do método replace(int,Fragment, String). Note que o primeiro parâmetro desse
método é o id do FrameLayout declarado no res/layout/content_main.xml e o
último parâmetro é a tag que estamos usando na busca.

Se quiser testar como a aplicação está atualmente, comente o método
onCreate(Bundle) da classe FirstLevelFragment e execute a aplicação. O resultado
deve estar conforme a Figura 9.3.

Figura 9.3 – Aplicação com o fragment de primeiro nível.

Abas usando TabLayout
Nesta seção será definida a navegação com abas. Antes do Lollipop, as abas



eram criadas com a ActionBar, mas com o lançamento da biblioteca do Material
Design ela passou a ser implementada com a classe TabLayout, pois assim
como a Toolbar, ela traz mais flexibilidade uma vez que pode ser adicionada
em qualquer parte do arquivo de layout.

Crie uma nova activity chamada TabsActivity e modifique seu arquivo de
layout res/layout/activity_tabs.xml para que fique como a seguir:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    <include layout="@layout/toolbar"/>
    <com.google.android.material.tabs.TabLayout
        android:id="@+id/tabLayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="?attr/colorPrimary"
        app:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
        app:tabMode="fixed"
        app:tabGravity="fill" />
    <androidx.viewpager.widget.ViewPager
        android:id="@+id/viewPager"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
</LinearLayout>

Além do <include> da Toolbar, o arquivo de layout possui apenas mais dois
componentes: O TabLayout e o ViewPager.

O TabLayout exibe o título das abas e tem duas propriedades interessantes:
tabMode e tabGravity. Quando todas as abas couberem na tela, pode-se definir a
propriedade tabMode como fixed, então a largura da tela é dividida pelo número
de abas, mas quando as abas não couberem na tela é melhor utilizar o valor
scrolled, e dessa forma será possível fazer um scroll horizontal pelas abas. Na
propriedade tabGravity é possível indicar o alinhamento das abas e pode
assumir o valor center para que as abas fiquem centralizadas ou fill para que
ocupem toda a tela.

O ViewPager exibirá o conteúdo de cada aba e permite alternar entre as abas
deslizando para os lados.

Agora deixe a TabsActivity como a seguir:



import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_tabs.*
import kotlinx.android.synthetic.main.toolbar.*
 
class TabsActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_tabs)
        setSupportActionBar(toolbar)
        val pagerAdapter = TabsPagerAdapter(this, supportFragmentManager)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        viewPager.adapter = pagerAdapter
        tabLayout.setupWithViewPager(viewPager)
    }
}

No método onCreate(Bundle) criamos uma instância da classe TabsPagerAdapter,
que é responsável por criar o fragment de cada aba e definir seu respectivo
título:
import android.content.Context
import android.content.res.TypedArray
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager
import androidx.fragment.app.FragmentPagerAdapter
 
class TabsPagerAdapter(ctx: Context, fm: FragmentManager) : FragmentPagerAdapter(fm) {
    private val tabTitles: Array<String> = ctx.resources.getStringArray(R.array.sections)
    private val bgColors: TypedArray = ctx.resources.obtainTypedArray(R.array.bg_colors)
    private val textColors: TypedArray = ctx.resources.obtainTypedArray(R.array.text_colors)
 
    override fun getItem(position: Int): Fragment {
        return SecondLevelFragment.newInstance(
                tabTitles[position],
                bgColors.getColor(position, 0),
                textColors.getColor(position, 0))
    }
    override fun getCount(): Int {
        return 3
    }
    override fun getPageTitle(position: Int): CharSequence {
        return tabTitles[position]
    }
}



Essa classe herda de FragmentPageAdapter e será usada pelo ViewPager da
TabsActivity para determinar quantas abas serão exibidas e criar o fragment de
cada uma. O atributo tabTitles armazena os títulos definidos no arquivo
res/values/strings.xml enquanto bgColors e textColors armazenam as cores de
background e do texto declarados no res/values/arrays.xml.

No método getItem(int), um fragment referente à posição passada como
parâmetro é retornado. Aqui, é criada uma instância da classe
SecondLevelFragment que será criada a seguir. O método getCount() informa a
quantidade de páginas que devem ser criadas; em nosso caso, teremos três
páginas fixas. Por fim, temos o método getPageTitle(int), que retornará o título da
aba de acordo com a posição correspondente.

Voltando ao método onCreate(Bundle) da TabActivity, o tabLayout é inicializado
utilizando as informações do TabsPagerAdapter por meio do método
setupWithViewPager(ViewPager).

Antes de implementar a classe SecondLevelFragment, crie seu arquivo de layout
res/layout/fragment_second_level.xml e deixe-o como a seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center">
    <TextView
        android:id="@+id/textView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
</LinearLayout>

Nada a comentar aqui, então crie a classe SecondLevelFragment, que usará esse
arquivo e deverá ficar como a seguir:
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import kotlinx.android.synthetic.main.fragment_second_level.*
 
class SecondLevelFragment : Fragment() {
    override fun onCreateView(inflater: LayoutInflater,
                              container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(
                R.layout.fragment_second_level, container, false)



    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        arguments?.getString(EXTRA_TEXT)?.let {
            textView.text = it
        }
        arguments?.getInt(EXTRA_TEXT_COLOR)?.let {
            textView.setTextColor(it)
        }
        arguments?.getInt(EXTRA_BG_COLOR)?.let {
            view.setBackgroundColor(it)
        }
    }
    companion object {
        private const val EXTRA_TEXT = "texto"
        private const val EXTRA_BG_COLOR = "corBg"
        private const val EXTRA_TEXT_COLOR = "corTexto"
 
        fun newInstance(
                text: String, background: Int, textColor: Int): SecondLevelFragment {
            val params = Bundle()
            params.putString(EXTRA_TEXT, text)
            params.putInt(EXTRA_BG_COLOR, background)
            params.putInt(EXTRA_TEXT_COLOR, textColor)
            val slf = SecondLevelFragment()
            slf.arguments = params
            return slf
        }
    }
}

Não temos nada de diferente nesse fragment. Ele recebe no método
construtor newInstance(String,Int,Int) o texto que será exibido no TextView, a cor do
texto e a cor de background. Enfim, nada que já não tenhamos feito antes.

Para habilitar o botão de voltar na Toolbar, altere a declaração no
AndroidManifest.xml:
<activity ...
    android:name=".MainActivity"
    android:launchMode="singleTop"
    android:theme="@style/MainTheme">
            ...
<activity
    android:name=".TabsActivity"
    android:parentActivityName=".MainActivity"/>



Do jeito que a aplicação se encontra, descomente o método onCreate(Bundle) da
classe FirstLevelFragment (deixe comentadas as linhas que chamam as activities
que ainda não criamos) e execute a aplicação. Selecione a opção Abas e
clique no botão OK. Você terá um resultado similar ao da Figura 9.4.

Podemos alternar entre as abas clicando no título de uma aba ou deslizando
horizontalmente.

Figura 9.4 – Navegação com Abas com o TabLayout.

Bottom Navigation
Para implementar a navegação com abas na parte inferior na tela, deve-se
utilizar o componente BottomNavigationView que também faz parte da biblioteca
de design. Crie a BottomNavActivity e modifique seu arquivo de layout
res/layout/activity_bottom_nav para ficar como a seguir:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/rootView"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">



    <include layout="@layout/toolbar"/>
    <FrameLayout
        android:id="@+id/container"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />
    <com.google.android.material.bottomnavigation.BottomNavigationView
        android:id="@+id/bottomNavigation"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:itemBackground="@color/colorPrimary"
        app:itemIconTint="@drawable/selector_bottom_nav"
        app:itemTextColor="@drawable/selector_bottom_nav"
        app:menu="@menu/bottom_navigation" />
</LinearLayout>

A cor de background da BottomNavigationView é definida na propriedade
app:itemBackground. As cores dos ícones e do texto são atribuídas
respectivamente com as propriedades app:itemIconTint e app:itemTextColor. Perceba
que o selector selector_bottom_nav.xml está sendo utilizado e deve ser
adicionado à pasta res/drawable e deve ficar da seguinte forma:
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_checked="true" android:color="@android:color/white" />
    <item android:color="@android:color/darker_gray" />
</selector>

As opções que serão exibidas nas abas estão definidas no arquivo de menu
res/menu/bottom_navigation.xml. Crie esse novo arquivo e deixe-o como a
seguir:
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
        android:id="@+id/action_favorites"
        android:icon="@drawable/ic_favorite"
        android:title="@string/tab_favorites"
        app:showAsAction="ifRoom" />
    <item
        android:id="@+id/action_clock"
        android:icon="@drawable/ic_access_time"
        android:title="@string/tab_schedule"
        app:showAsAction="ifRoom" />
    <item
        android:id="@+id/action_people"
        android:icon="@drawable/ic_people"



        android:title="@string/tab_people"
        app:showAsAction="ifRoom" />
</menu>

Perceba que um ícone é definido para cada opção de menu. Crie cada um
deles clicando com o botão direito na pasta res/drawable e selecionando a
opção New > Vector Asset.

Feito isso, modifique a classe BottomNavActivity como a seguir:
import android.content.res.TypedArray
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_bottom_nav.*
import kotlinx.android.synthetic.main.toolbar.*
 
class BottomNavActivity : AppCompatActivity() {
 
    private val tabTitles: Array<String> by lazy {
        resources.getStringArray(R.array.sections)
    }
    private val bgColors: TypedArray by lazy {
        resources.obtainTypedArray(R.array.bg_colors)
    }
    private val textColors: TypedArray by lazy {
        resources.obtainTypedArray(R.array.text_colors)
    }
    private val tabIds = listOf(
            R.id.action_favorites, R.id.action_clock, R.id.action_people
    )
    private var currentTabIndex: Int = 0
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_bottom_nav)
        setSupportActionBar(toolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        currentTabIndex = savedInstanceState?.getInt(TAB_SELECTED) ?: 0
        showFragment(currentTabIndex)
        bottomNavigation.setOnNavigationItemSelectedListener { item ->
            val index = tabIds.indexOf(item.itemId)
            showFragment(index)
            true
        }
    }
    override fun onSaveInstanceState(outState: Bundle?) {
        super.onSaveInstanceState(outState)



        outState?.putInt(TAB_SELECTED, currentTabIndex)
    }
    private fun showFragment(position: Int) {
        val oldTag = "aba_$currentTabIndex"
        val newTag = "aba_$position"
        currentTabIndex = position
        val transaction = supportFragmentManager.beginTransaction()
        val oldFragment = supportFragmentManager.findFragmentByTag(oldTag)
        if (oldFragment != null) {
            transaction.hide(oldFragment)
        }
        var fragment = supportFragmentManager.findFragmentByTag(newTag)
        if (fragment == null) {
            fragment = SecondLevelFragment.newInstance(
                    tabTitles[position],
                    bgColors.getColor(position, 0),
                    textColors.getColor(position, 0))
            transaction.add(R.id.container, fragment, newTag)
        }
        rootView.setBackgroundColor(bgColors.getColor(currentTabIndex, 0))
        transaction.show(fragment).commit()
    }
    companion object {
        const val TAB_SELECTED = "tabSelected"
    }
}

A lista de títulos, cores de texto e de background são carregadas como
atributos. No onCreate(Bundle) o fragment referente à aba selecionada é exibido
no método showFragment(Int). O atributo currentTabIndex mantém o índice da aba
selecionada para que essa informação não seja perdida quando a tela for
rotacionada.

Para alternarmos entre as abas, devemos atribuir o listener para o
bottomNavigation por meio do método
setOnNavigationItemSelectedListener(OnNavigationItemSelectedListener). Estamos usando
instâncias diferentes do mesmo fragment para as três abas, mas esse método
seria o local ideal para carregar o fragment de acordo com a aba selecionada.
Perceba que no método showFragment(Int) o fragment atual é ocultado, então é
verificado se o novo fragment já foi adicionado anteriormente, em caso
positivo, apenas o exibimos, caso contrário ele é criado e adicionado. Essa
abordagem mantém o estado dos fragments, pois se fosse usado o
replace(Int,Fragment,String) o fragment antigo seria destruído. Outra curiosidade



nesse método é que a cor de background é atribuída à rootView, pois quando o
aparelho está em landscape a BottomNavigationView não ocupa toda a largura da
tela, então fizemos essa mudança por questões estéticas.

Ajuste a declaração da BottomNavActivity no AndroidManifest.xml como a seguir:
<activity
    android:name=".BottomNavActivity"
    android:parentActivityName=".MainActivity" />

Descomente a linha referente a essa activity no método onCreate(Bundle) da
classe FirstLevelFragment. Em seguida, execute a aplicação, selecione a opção
Bottom e clique no botão OK. O resultado deve ficar similar ao da Figura
9.5.

Figura 9.5 – Navegação com Bottom Navigation.

ViewPager
O ViewPager por si só não é uma forma de navegação propriamente dita, mas
eu costumo dar essa menção honrosa a esse componente. Já vimos o
ViewPager junto com o TabLayout, mas ele pode ser usado separadamente e em
qualquer lugar da tela. Para exemplificar seu uso, crie a activity PagerActivity,
cujo arquivo de layout res/layout/activity_pager.xml deve ficar desta forma:



<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    <include layout="@layout/toolbar" />
    <androidx.viewpager.widget.ViewPager
        android:id="@+id/viewPager"
        android:layout_width="match_parent"
        android:layout_height="match_parent">
        <androidx.viewpager.widget.PagerTabStrip
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" />
    </androidx.viewpager.widget.ViewPager>
</LinearLayout>

Diferentemente do que foi feito na TabsActivity, o ViewPager foi utilizado sem o
TabLayout, em vez disso, foi colocado um PagerTabStrip dentro dele, que fará
papel semelhante ao do TabLayout, mas com um visual diferente. Agora deixe a
PagerActivity como a seguir:
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_pager.*
import kotlinx.android.synthetic.main.toolbar.*
 
class PagerActivity : AppCompatActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_pager)
        setSupportActionBar(toolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        val tabsPagerAdapter = TabsPagerAdapter(this, supportFragmentManager)
        viewPager.adapter = tabsPagerAdapter
    }
}

Assim como nas demais activities, adicione o up button à parte superior da
tela:
<activity
    android:name=".PagerActivity"
    android:parentActivityName=".MainActivity" >
</activity>

Este exemplo está finalizado. Descomente todo o método onCreate(Bundle) da
classe FirstFragment e execute a aplicação. Selecione a opção do ViewPager e



clique em OK. O resultado ficará conforme o da Figura 9.6.
Conhecidas as técnicas de navegação, cabe a você escolher qual é a melhor

opção que se adéqua ao seu aplicativo.

Figura 9.6 – Navegação usando ViewPager.

Empilhando Fragments
Cada nova activity que é executada fica empilhada, e à medida que clicamos
na tecla back, a activity do topo da pilha é destruída e a que está abaixo dela é
exibida. É possível obter o mesmo comportamento com os fragments,
bastando para isso utilizar o método addToBackStack(String) do objeto
FragmentTransaction. Inclusive podemos associar uma animação de transição
usando o método setTransition(int).

A título de demonstração, abra a MainActivity e deixe o método selectMenuOption
(MenuItem) desta forma:
private fun selectMenuOption(menuItem: MenuItem) {
    menuItem.isChecked = true
    drawerLayout.closeDrawers()
    val title = menuItem.title.toString()
    val fragment = FirstLevelFragment.newInstance(title)
    val transaction = supportFragmentManager
            .beginTransaction()



            .replace(R.id.content, fragment, title)
            .setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN)
    if (content.childCount > 0) { // não adicionamos o primeiro fragment na backstack
        transaction.addToBackStack(null)
    }
    transaction.commit()
}

Execute a aplicação, selecione algumas vezes as opções do menu lateral.
Perceba que, ao pressionar a tecla Back, o fragment anterior será exibido, até
chegar ao primeiro fragment da pilha, onde se ao clicar na tecla Back
novamente a aplicação é encerrada.

Ao adicionar o FirstLevelFragment usando o método replace(int,Fragment,String), caso
ainda não haja nenhum fragment adicionado, esse será o elemento-raiz e ele
não deve ser adicionado à back stack, enquanto os demais devem ser
adicionados e ficarão empilhados.

Navigation API
A Navigation API faz parte do Jetpack e visa a facilitar a navegação em
aplicações Android apresentando um conceito diferente do que foi utilizado
em aplicativos Android desde o seu lançamento. Com ela, em vez de termos
uma activity por tela, temos uma activity por fluxo navegacional e um
fragment por tela. Assim, cada activity é responsável por controlar a
navegação entre dois ou mais fragments.

Cada navegação especifica um destino, que representa a próxima tela que
será exibida, e o conjunto desses destinos é chamado de grafo de navegação.
Esse grafo é definido em um arquivo XML localizado na pasta
res/navigation, no qual é possível definir visualmente as ações de navegação
que cada tela possuirá, inclusive definindo os parâmetros que pode receber.
Cada destino navegacional pode ser: uma activity, um fragment ou subgrafo
de navegação.

Application Name NavigationAPI
Package Name dominando.android.navigation
Activity Name MainActivity

Para checar como funciona esse recurso na prática, crie um novo projeto e,
em seguida, um fragment chamado HomeFragment, em que o arquivo de layout
res/layout/fragment_home.xml deverá ficar da seguinte forma:



<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/rootLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <TextView
        android:id="@+id/txtTitle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginBottom="16dp"
        android:text="HOME"
        android:textSize="32sp"
        android:textStyle="bold"
        app:layout_constraintBottom_toTopOf="@+id/btnGo"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_chainStyle="packed" />
    <Button
        android:id="@+id/btnGo"
        style="@style/Widget.AppCompat.Button.Colored"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="GO!"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/txtTitle" />
</androidx.constraintlayout.widget.ConstraintLayout>

Nada de especial nesse arquivo. Temos apenas um TextView e um botão que
exibirá uma nova tela ao ser clicado. Crie a classe HomeFragment e deixe-a
como a seguir:
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
 
class HomeFragment: Fragment() {
    override fun onCreateView(inflater: LayoutInflater,
                              container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_home, container, false)



    }
}

Essa classe não possui nada que já não tenhamos visto.
Adicione a classe CompleteFragment que será chamada pela HomeFragment, mas

antes defina o seu arquivo de layout em res/layout/fragment_complete.xml
deixando-o como a seguir:
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <TextView
        android:id="@+id/txtMessage"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:text="Complete"/>
</FrameLayout>

Em seguida, crie a classe CompleteFragment:
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
 
class CompleteFragment: Fragment() {
    override fun onCreateView(inflater: LayoutInflater,
                              container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_complete, container, false)
    }
}

Após criar esses dois fragments, certifique-se de adicionar a dependência da
biblioteca de navigation no build.gradle:
dependencies {
    def nav_version = "1.0.0-beta01"
    implementation "android.arch.navigation:navigation-fragment:$nav_version"
    implementation "android.arch.navigation:navigation-ui:$nav_version"
    ...
}

A Navigation API faz parte do Jetpack, mas como podemos reparar,
durante a escrita desse livro essa biblioteca encontrava-se em versão alpha.



Provavelmente quando você estiver lendo esse livro essa dependência já terá
mudado para androidx.navigation ou algo similar.

A MainActivity deve conter um NavigationHostFragment que controlará o fluxo
navegacional da aplicação e é onde os fragments serão empilhados. Abra o
arquivo de layout res/layout/activity_main.xml e deixe-o como a seguir:
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">
    <fragment
        android:id="@+id/navHostFragment"
        android:name="androidx.navigation.fragment.NavHostFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:navGraph="@navigation/main_graph"
        app:defaultNavHost="true" />
</FrameLayout>

A tag fragment está apontando para a classe NavHostFragment, onde é definido
que esse é o fluxo padrão do aplicativo por meio da propriedade
app:defaultNavHost. Na propriedade app:navGraph é definido qual o arquivo que
especifica o grafo de navegação.

No momento da escrita deste livro, o editor visual de navegação só estava
disponível para o Android Studio 3.3. Entretanto, o exemplo deve funcionar
corretamente na versão 3.2 do Android Studio, porém, sem a facilidade do
editor visual.

Crie o diretório res/navigation e, em seguida, clique com o botão direito
sobre ele e selecione a opção New > Navigation resource file. Nomeie o
arquivo como main_graph.xml e ao abri-lo, podemos adicionar o fluxo de
telas clicando no botão New destination como mostra a Figura 9.7.



Figura 9.7 – Editor visual de navegação do Android Studio.
Como podemos observar, nessa opção é possível criar um novo fragment ou

utilizar um existente. Selecione o HomeFragment e no editor visual ele será
exibido como na Figura 9.8.



Figura 9.8 – Editor visual de navegação com a navegação inicial.
Podemos observar algumas informações interessantes. No lado esquerdo,

temos a indicação do host que é a MainActivity e logo abaixo a homeFragment.
Perceba que no editor visual, esse fragment está com o ícone de uma casa
indicando que é o ponto de partida da navegação. Ainda no editor visual, no
lado direito do fragment temos uma alça em forma de círculo onde devemos
arrastar para criar uma conexão para um novo destino.

Ao clicar na aba Text localizada na parte inferior do editor visual, podemos
visualizar o XML que está sendo gerado. Como se pode perceber, o layout do
fragment não está sendo exibido. Para corrigir esse problema, basta fazer a
seguinte mudança:
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main_graph"
    app:startDestination="@id/homeFragment">
    <fragment
        android:id="@+id/homeFragment"
        android:name="dominando.android.navigationapi.HomeFragment"
        android:label="Home"
        tools:layout="@layout/fragment_home" />
</navigation>

Esse arquivo inicia com a tag <navigation> em que é definido o seu id para
main_graph. Em seguida, na propriedade app:startDestination, definimos que o
homeFragment é o ponto de partida da navegação. Dentro a tag <navigation>, temos
uma declaração normal de um fragment, onde é definido o nome da classe
com o atributo android:name, o título na propriedade android:label e o respectivo
arquivo de layout com a propriedade tools:layout. É importante enfatizar aqui
que as propriedades do namespace tools são utilizadas apenas em tempo de
projeto e não são obrigatórias, mas deixam o processo de desenvolvimento
mais amigável com informações importantes no editor visual.

Retorne ao editor visual e adicione o CompleteFragment, e, em seguida, no
XML, adicione a propriedade tools:layout apontando para @layout/fragment_complete.
Por fim, crie a conexão entre o HomeFragment e o CompleteFragment arrastando a
alça à direita do primeiro em direção ao segundo como mostra a Figura 9.9.



Figura 9.9 – Navegação entre dois fragments no editor visual.
O resultado no XML ficará como a seguir:

<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main_graph"
    app:startDestination="@id/homeFragment">
    <fragment
        android:id="@+id/homeFragment"
        android:name="dominando.android.navigationapi.HomeFragment"
        android:label="HomeFragment"
        tools:layout="@layout/fragment_home" >
        <action
            android:id="@+id/action_homeFragment_to_completeFragment"
            app:destination="@id/completeFragment" />
    </fragment>
    <fragment
        android:id="@+id/completeFragment"
        android:name="dominando.android.navigationapi.CompleteFragment"
        android:label="Complete"
        tools:layout="@layout/fragment_complete"/>
</navigation>

Perceba que foi criada uma <action> no HomeFragment para o CompleteFragment
com o id action_homeFragment_to_completeFragment. Obviamente isso pode ser



modificado, mas esse padrão deixa claro o que a ação realizará.
Configurada a navegação, faça a implementação do código para utilizá-la.

Abra a classe HomeFragment e faça as seguintes mudanças:
import androidx.navigation.Navigation
import kotlinx.android.synthetic.main.fragment_home.*
 
class HomeFragment: Fragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        btnGo.setOnClickListener(
                Navigation.createNavigateOnClickListener(
                        R.id.action_homeFragment_to_completeFragment
                )
        )
    }
}

Ao chamar o método createNavigateOnClickListener(int) da classe Navigation estamos
atribuindo o evento de clique do botão que fará com que a tela seja exibida.
Perceba que essa chamada abstrai para o desenvolvedor o uso das classes
FragmentManager e FragmentTransaction deixando o código bem mais simples.

Você pode estar se perguntando: “E se a navegação não for feita em um
clique de botão?”. Neste caso, você pode utilizar uma forma mais genérica,
que inclusive é mais recomendada. Altere o evento de clique do botão para
ficar como a seguir:
btnGo.setOnClickListener {
    Navigation.findNavController(requireActivity(), R.id.navHostFragment)
            .navigate(R.id.action_homeFragment_to_completeFragment)
}

A instância de NavController é obtida por meio do método
findNavController(Activity, Int) da classe Navigation e, em seguida, o método navigate(Int)
é chamado passando como parâmetro o id da ação a ser executada.

Execute a aplicação, clique no botão e a segunda tela será exibida. Ao clicar
na tecla de voltar, a tela principal será exibida novamente. Entretanto, a barra
de título não exibe o título da janela atual o que causa um comportamento
estranho. Para resolver esse problema, vá até a MainActivity e faça o seguinte
ajuste:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle



import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.navigation.ui.NavigationUI
 
class MainActivity : AppCompatActivity() {
    private val navController: NavController by lazy {
        Navigation.findNavController(this, R.id.navHostFragment)
    }
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        NavigationUI.setupActionBarWithNavController(this, navController)
    }
    override fun onSupportNavigateUp(): Boolean {
        return navController.navigateUp()
    }
}

Foi declarado um atributo do tipo NavController, que é inicializado utilizando
o método findNavController(Activity,int), em que o segundo parâmetro é o id do
NavHostFragment que declaramos no arquivo de layout da activity. Para
tratarmos a mudança na barra de título, o método
setupActionBarWithNavController(Activity, NavController) da classe NavigationUI foi
utilizado. Por fim, para tratar o up button, o método onSupportNavigateUp() da
activity foi sobrescrito apenas retornando a chamada ao método navigateUp() do
NavController.

Execute a aplicação novamente e o fluxo de navegação continuará
funcionando, mas agora a barra de título será atualizada e o up button será
exibido na segunda tela como mostra a Figura 9.10.



Figura 9.10 – Up button com barra de título.
A Navigation API também facilita a passagem de parâmetros entre

fragments, pois evita termos que criar o “factory method” newInstance() em cada
tela em que precisarmos passar parâmetros.

Demonstraremos esse recurso adicionando dois parâmetros ao
CompleteFragment. No editor visual selecione o CompleteFragment e na janela de
propriedades clique no botão de “+” da seção Arguments. O nome do
primeiro parâmetro será “full_name” do tipo String e o segundo será “age” do
tipo Integer. Perceba que esses parâmetros estarão declarados no XML na tag
<argument>:
<navigation ...>
    <fragment...>
    <fragment
        android:id="@+id/completeFragment"
        android:name="dominando.android.navigationapi.CompleteFragment"
        android:label="Complete"
        tools:layout="@layout/fragment_complete">
        <argument
            android:name="full_name"
            app:argType="string" />
        <argument
            android:name="age"
            app:argType="integer" />



    </fragment>
</navigation>

Para passar esses parâmetros, basta fazer o seguinte ajuste na HomeFragment:
class HomeFragment: Fragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        btnGo.setOnClickListener {
            val args = Bundle().apply {
                putString("full_name", "Nelson Glauber")
                putInt("age", 34)
            }
            Navigation.findNavController(requireActivity(), R.id.navHostFragment)
                    .navigate(R.id.action_homeFragment_to_completeFragment, args)
        }
    }
}

Apenas atribuímos os parâmetros especificados nas tags <argument> para o
objeto Bundle e o passamos como segundo parâmetro do método
navigate(int,Bundle). Para ler esses parâmetros, vá até a CompleteFragment e faça a
seguinte implementação:
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import kotlinx.android.synthetic.main.fragment_complete.*
class CompleteFragment: Fragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        arguments?.run {
            val fullName = getString("full_name")
            val age = getInt("age")
            txtMessage.text = "$fullName - $age"
        }
    }
}

KOTLINxJAVA: O bloco run é bem similar ao let, a diferença é que dentro do
bloco run, this é o objeto que chamou o método. No let, o objeto que chamou o
método é passado como parâmetro do lambda (que por padrão é it). Ambos os



métodos retornam a última linha do bloco.

Como podemos observar, a leitura dos parâmetros é feita normalmente
utilizando a propriedade arguments. Execute a aplicação e verifique se os
parâmetros estão sendo exibidos corretamente na segunda tela.

A Navigation API, além de apresentar um novo paradigma de navegação,
traz também uma boa abstração sobre a API de fragments, deixando o código
mais organizado e menos propenso a erros, uma vez que ela gerencia as
transações de exibição e ocultação dos fragments.

Utilizar a Navigation API pode ser particularmente útil em aplicações com
fluxos de telas mais profundos ou na implementação de deep links (que não é
abordado neste livro).

BottomSheet
O componente BottomSheet também não é realmente uma forma de navegação,
mas traz uma forma alternativa de exibir determinado conteúdo. Ele serve
basicamente para exibir informações que aparecem na parte inferior onde o
usuário pode fazer um gesto para cima para visualizar o restante do conteúdo.

Application Name BottomSheet
Package Name dominando.android.bottomsheet
Activity Name MainActivity

O BottomSheet faz parte da biblioteca de componentes do Material Design.
Para compreender melhor seu funcionamento, crie um novo projeto no
Android Studio e adicione a seguinte dependência no build.gradle:
dependencies {
    implementation 'com.google.android.material:material:1.0.0'
}

Crie o arquivo res/layout/layout_bottom_sheet.xml que será exibido na
BottomSheet e deixe-o como a seguir:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/layoutBottomSheet"
    android:layout_width="match_parent"
    android:layout_height="340dp"
    android:background="#009688"
    android:clickable="true"



    android:focusable="true"
    android:orientation="vertical"
    app:behavior_hideable="true"
    app:behavior_peekHeight="80dp"
    app:layout_behavior="com.google.android.material.bottomsheet.BottomSheetBehavior">
    <TextView
        android:layout_width="match_parent"
        android:layout_height="80dp"
        android:background="#004D40"
        android:gravity="center"
        android:text="Peek Area"
        android:textColor="@android:color/white" />
    <TextView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center"
        android:text="Conteúdo"
        android:textColor="@android:color/white" />
</LinearLayout>

No elemento-raiz do arquivo de layout estão as propriedades relativas ao
BottomSheet. A primeira delas é a behavior_hideable, que indica se a BottomSheet pode
ser ocultada arrastando-a para baixo. Em seguida, temos a propriedade
behavior_peekHeight, na qual é definida a altura da área que ficará visível para ser
arrastada pelo usuário. A propriedade layout_behavior determina que o
comportamento desse layout é o de um BottomSheet. Outro detalhe importante
nesse arquivo são os atributos clickable e focusable. Se eles não forem
adicionados, ao tocarmos na BottomSheet ela não interceptará o toque e esse
toque será capturado pela view atrás da BottomSheet.

Faça agora um ajuste no arquivo de layout da MainActivity para que o
BottomSheet seja exibido. Abra o arquivo res/layout/activity_main.xml e deixe-o
como a seguir:
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center"



        android:orientation="vertical">
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:text="Conteúdo"
            android:textSize="32sp" />
        <Button android:id="@+id/btnBottomSheet"
            style="@style/Widget.AppCompat.Button.Colored"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Show BottomSheet" />
        <Button android:id="@+id/btnBottomSheetDialog"
            style="@style/Widget.AppCompat.Button.Colored"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Show BottomSheetDialog" />
    </LinearLayout>
    <include layout="@layout/layout_bottom_sheet" />
</androidx.coordinatorlayout.widget.CoordinatorLayout>

Para exibirmos o conteúdo do BottomSheet, devemos simplesmente colocá-lo
dentro de um CoordinatorLayout. O LinearLayout representa o conteúdo principal da
tela, enquanto o conteúdo do BottomSheet foi adicionado pela tag <include>.
Poderíamos também colocar o conteúdo da tela em um arquivo separado, mas
vamos deixar dessa forma para o exemplo ficar mais simples.

Execute a aplicação e o BottomSheet já estará funcionando corretamente e, ao
arrastá-la para cima, teremos algo similar ao mostrado na Figura 9.11.



Figura 9.11 – BottomSheet expandido.
Como definimos a propriedade behavior_hideable como true, se deslizarmos para

baixo, o BottomSheet desaparece e não é possível exibi-lo novamente. Para
resolver esse problema, no evento de clique do botão exibiremos o BottomSheet
novamente. Faça os ajustes na MainActivity como mostrado a seguir:
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.google.android.material.bottomsheet.BottomSheetBehavior
import kotlinx.android.synthetic.main.activity_main.*
import kotlinx.android.synthetic.main.layout_bottom_sheet.*
 
class MainActivity : AppCompatActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
 
        btnBottomSheet.setOnClickListener {
            val behavior = BottomSheetBehavior.from(layoutBottomSheet)
            if (behavior.state == BottomSheetBehavior.STATE_HIDDEN
                    || behavior.state == BottomSheetBehavior.STATE_EXPANDED) {
                behavior.state = BottomSheetBehavior.STATE_COLLAPSED
            } else if (behavior.state == BottomSheetBehavior.STATE_COLLAPSED) {



                behavior.state = BottomSheetBehavior.STATE_EXPANDED
            }
        }
    }
}

Com a classe BottomSheetBehavior referência do comportamento do LinearLayout
que declaramos no arquivo res/layout/layout_bottom_sheet.xml é obtida por
meio do método from(View). Com esse objeto, o estado atual do BottomSheet é
verificado. Se ele estiver oculto (STATE_HIDDEN) ou expandido
(STATE_EXPANDED) será deixado no estado reduzido (STATE_COLLAPSED), dessa
forma ele será exibido caso ele não esteja mais sendo mostrado.

Ainda com o objeto BottomSheetBehavior é possível definir em tempo de
execução a área de “pegada” (peek area) usando a propriedade peekHeight, e se
o BottomSheet pode ser ocultado ou não utilizando isHideable:
behavior.peekHeight = 200
behavior.isHideable = false

Também é possível atribuir um listener para detectar as mudanças de estado
e de tamanho do BottomSheet:
behavior.setBottomSheetCallback(object: BottomSheetBehavior.BottomSheetCallback() {
    override fun onSlide(view: View, slideOffset: Float) {
    }
    override fun onStateChanged(view: View, newState: Int) {
    }
})

No método onSlide(View,Float) o parâmetro slideOffset indica a variação de
quanto a BottomSheet foi deslizada para cima ou para baixo. No entanto, no
método onStateChanged(View,Int) o feedback da mudança de estado é recebido por
meio do parâmetro newState.

BottomSheetDialog
O BottomSheet é bastante útil sendo parte integrante do layout para exibir
informações adicionais, mas ele pode ser utilizado como um DialogFragment
para requisitar alguma ação importante do usuário.

Para vermos esse conceito na prática, crie o arquivo
res/layout/layout_dialog.xml e deixe-o da seguinte forma:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"



    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp">
    <TextView
        android:id="@+id/textView"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Esse aqui é o texto"
        android:textSize="24sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <Button
        android:id="@+id/btnCancel"
        style="@style/Widget.AppCompat.Button.Borderless.Colored"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="Cancelar"
        app:layout_constraintEnd_toStartOf="@+id/btnConfirm"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/textView" />
    <Button
        android:id="@+id/btnConfirm"
        style="@style/Widget.AppCompat.Button.Colored"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Confirmar"
        app:layout_constraintBottom_toBottomOf="@+id/btnCancel"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toEndOf="@+id/btnCancel"
        app:layout_constraintTop_toTopOf="@+id/btnCancel" />
</androidx.constraintlayout.widget.ConstraintLayout>

Este é um arquivo de layout simples com apenas um TextView e dois botões.
Crie agora a classe BottomDialog que deve ficar da seguinte forma:
import android.app.Dialog
import android.view.LayoutInflater
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import kotlinx.android.synthetic.main.layout_dialog.view.*
 
class BottomDialog: BottomSheetDialogFragment() {
    override fun setupDialog(dialog: Dialog, style: Int) {
        super.setupDialog(dialog, style)
        val view = LayoutInflater.from(requireContext())



                .inflate(R.layout.layout_dialog, null)
        view.btnConfirm.setOnClickListener { dialog.dismiss() }
        view.btnCancel.setOnClickListener { dialog.dismiss() }
        dialog.setContentView(view)
    }
}

A classe que herda de BottomSheetDialogFragment é uma subclasse de
DialogFragment e no método setupDialog(Dialog,Int) o arquivo de layout é carregado e
a view é atribuída ao dialog por meio do método setContentView(View). No
evento de clique de cada botão o comportamento é apenas fechar o dialog
invocando o método dismiss().

Para chamar esse dialog, vá até a MainActivity e faça a seguinte
implementação para o evento de clique do segundo botão:
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        btnBottomSheetDialog.setOnClickListener {
            val dialog = BottomDialog()
            dialog.show(supportFragmentManager, "tag")
        }
    }
}

O dialog é exibido como um DialogFragment convencional invocando o
método show(FragmentManager,String). O resultado deve ficar conforme a Figura
9.12.



Figura 9.12 – BottomSheetDialogFragment.



CAPÍTULO 10
Persistência de dados

O Android disponibiliza algumas formas de persistir informações e cada uma
tem seu propósito específico. Neste capítulo será demonstrado como salvar e
recuperar pequenas informações utilizando Shared Preferences. Em seguida,
como ler e escrever no sistema de arquivos interno e externo do aparelho.
Como utilizar o SQLite, um leve e poderoso banco de dados para dispositivos
móveis que já vem embutido no sistema operacional. E para finalizar, será
explicado como acessar informações usando Content Providers.

Shared Preferences
É muito comum armazenar configurações simples nos aplicativos, para que o
usuário não tenha que defini-las toda vez que executá-los. No Android, isso
pode ser feito com a classe SharedPreferences, na qual as informações são salvas
no formato “chave/valor” para serem recuperadas posteriormente. A sintaxe
básica para sua utilização é a seguinte:
// Obtém a instância da SharedPreferences
val pref = getSharedPreferences("configuracoes", 0)
// Salva dois valores nas preferências
val editor = pref.edit()
editor.putString("musica", "Piano Bar")
editor.putBoolean("som", true)
editor.commit()
// Recuperando os valores
val musica = pref.getString("musica", null)
val som = pref.getBoolean("som", false)

Ao salvar os valores supracitados, eles serão armazenados em um arquivo
chamado configuracoes.xml no diretório
/data/data/pacote.da.sua.app/shared_prefs do aparelho. Os valores “Piano
Bar” e true serão armazenados para as configurações “música” e “som”



respectivamente, e estarão nesse arquivo mesmo que o usuário feche a
aplicação. Entretanto, esses dados podem ser apagados pelo usuário
acessando o menu Configurações > Aplicativos > [Sua app] >
Armazenamento1, no qual será exibida a tela da Figura 10.1, e ao clicar no
botão Limpar dados as configurações serão excluídas.

Figura 10.1 – Limpando dados do aplicativo.
É importante ressaltar que esses valores não podem ser acessados por outras

aplicações (a partir da API Level 17) ou pelo usuário, a não ser que o
aparelho seja “rooteado”.

Lendo e escrevendo arquivos
Nas próximas duas seções será demonstrado como ler e escrever informações
de arquivos texto na memória interna e externa do aparelho. Em ambos os
casos será utilizado o conteúdo digitado um EditText para preencher um
arquivo texto. Ao carregar o conteúdo do arquivo, ele será exibido em um
TextView. Crie um novo projeto e altere o res/layout/activity_main.xml para
ficar como a seguir.

Application Name Persistencia
Package Name dominando.android.persistencia



Activity Name MainActivity

<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp">
    <EditText
        android:id="@+id/edtText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <RadioGroup
        android:id="@+id/rgType"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/edtText">
        <RadioButton
            android:id="@+id/rbInternal"
            android:checked="true"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Memória Interna" />
        <RadioButton
            android:id="@+id/rbExternalPriv"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Memória Externa (Privado)" />
        <RadioButton
            android:id="@+id/rbExternalPublic"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Memória Externa (Pública)" />
    </RadioGroup>
    <Button
        android:id="@+id/btnSave"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Salvar"
        app:layout_constraintBaseline_toBaselineOf="@+id/btnRead"
        app:layout_constraintEnd_toStartOf="@+id/btnRead"
        app:layout_constraintHorizontal_chainStyle="spread"



        app:layout_constraintStart_toStartOf="parent" />
    <Button
        android:id="@+id/btnRead"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="Ler"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toEndOf="@+id/btnSave"
        app:layout_constraintTop_toBottomOf="@+id/rgType" />
    <TextView
        android:id="@+id/txtText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:textAppearance="?android:attr/textAppearanceLarge"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/btnSave" />
</androidx.constraintlayout.widget.ConstraintLayout>

O resultado ficará conforme a Figura 10.2.

Figura 10.2 – Arquivo de layout do exemplo de persistência.
O objetivo desse exemplo é mostrar as três formas de persistência nos



sistemas de arquivos que o Android disponibiliza. Ao clicar no botão Salvar,
o conteúdo do EditText será salvo em um arquivo *.txt e no botão Ler será
aberto esse mesmo arquivo e seu conteúdo exibido no TextView.

Agora adicione a lógica da tela na MainActivity:
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        btnRead.setOnClickListener {
            btnReadClick()
        }
        btnSave.setOnClickListener {
            btnSaveClick()
        }
    }
    private fun btnReadClick() {
        val type = rgType.checkedRadioButtonId
        when (type) {
            R.id.rbInternal -> loadFromInternal()
            R.id.rbExternalPriv -> loadFromExternal(true)
            R.id.rbExternalPublic -> loadFromExternal(false)
        }
    }
    private fun btnSaveClick() {
        val type = rgType.checkedRadioButtonId
        when (type) {
            R.id.rbInternal -> saveToInternal()
            R.id.rbExternalPriv -> saveToExternal(true)
            R.id.rbExternalPublic -> saveToExternal(false)
        }
    }
    private fun saveToInternal() {}
    private fun loadFromInternal() {}
    private fun saveToExternal(privateDir: Boolean) {}
    private fun loadFromExternal(privateDir: Boolean) {}
}

O código da classe é bem simples. Os eventos de clique dos botões que vão
ler e escrever o arquivo foram definidos no método onCreate(Bundle). Nesses
eventos é verificado qual RadioButton do RadioGroup está selecionado e então é



realizada a operação correspondente. Os métodos saveToInternal(),
loadFromInternal(), saveToExternal (Boolean) e loadFromExternal(Boolean) serão explicados e
implementados nas próximas seções.

Para ler e escrever o conteúdo, foram utilizadas as classes FilesInputStream e
FileOutputStream respectivamente do Java. Adicione os métodos a seguir na
MainActivity:
private fun save(fos : FileOutputStream) {
    val lines = TextUtils.split(edtText.text.toString(), "\n")
    val writer = PrintWriter(fos)
    for (line in lines) {
        writer.println(line)
    }
    writer.flush()
    writer.close()
    fos.close()
}
private fun load(fis : FileInputStream) {
    val reader = BufferedReader(InputStreamReader(fis))
    val sb = StringBuilder()
    do {
        val line = reader.readLine() ?: break
        if (sb.isNotEmpty()) sb.append('\n')
        sb.append(line)
    } while (true)
    reader.close()
    fis.close()
    txtText.text = sb.toString()
}

No método save(FileOutputStream) foi usada a chamada TextUtil.split(String, String)
para quebrar o texto do edtText em linhas usando o \n. Em seguida, um objeto
PrintWriter é criado para escrever cada uma das linhas no arquivo usando o
método writeln(String). Ao terminar o processo, os dados pendentes são enviados
e o fluxo (stream) é fechado usando flush() e close().

Para ler o conteúdo criado anteriormente e exibir no txtText, o método
load(FileInpuStream) foi usado. O arquivo é lido linha a linha, e quando a
chamada reader.readLine() for nula, é porque o fim do arquivo foi alcançado.

Vejamos agora como obter os objetos FileInputStream e FileOutputStream para
salvar a informação no cartão de memória ou na memória interna.



Arquivos na memória interna
É possível ler e gravar arquivos na memória interna do aparelho que ficam
armazenados no diretório /data/data/pacote.da.sua.app/files onde não são
acessíveis ao usuário (exceto se o aparelho for “rooteado”2). Analisemos o
método a seguir:
private fun saveToInternal() {
    try {
        val fos = openFileOutput("arquivo.txt", Context.MODE_PRIVATE)
        save(fos)
    } catch (e : Exception) {
        Log.e("NGVL", "Erro ao salvar o arquivo", e)
    }
}

O método openFileOutput(String,int) retorna um objeto FileOutputStream que permite
salvar o arquivo na memória interna. Em seguida, o método save(FileOutpuStream)
que foi criado na seção anterior é chamado. Agora observe o método que lê
esse conteúdo:
private fun loadFromInternal() {
    try {
        val fis = openFileInput("arquivo.txt")
        load(fis)
    } catch (e: Exception) {
        Log.e("NGVL", "Erro ao carregar o arquivo", e)
    }
}

Para ler o arquivo da memória interna foi utilizado o método
openFileInput(String) que retorna um objeto FileInputStream. Este é passado para o
método load(FileInputStream) criado na seção anterior. Lembrando que, assim
como na Shared Preferences, o usuário pode apagar esse arquivo indo nas
configurações do aparelho.

Execute a aplicação e tente salvar um texto na memória interna, feche o
aplicativo e tente ler o conteúdo.

Arquivos no cartão de memória
Todo aparelho tem uma memória externa que pode ser removível ou não. Os
arquivos salvos nesse local podem ser acessados por qualquer aplicativo ou
pelo próprio usuário. Para salvar arquivos no cartão de memória, a primeira



coisa a ser feita é adicionar a permissão no AndroidManifest.xml:
<manifest>
    <!-- Leitura -->
    <uses-permission
        android:name="android.permission.READ_EXTERNAL_STORAGE"/>
    <!-- Escrita -->
    <uses-permission
        android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    ...
</manifest>

Em seguida, é preciso checar se o cartão de memória está disponível, pois
ele pode ter sido removido, estar indisponível, ou, ainda, não estar pronto.
Para isso, é utilizado o método getExternalStorageState() da classe Environment:
val state = Environment.getExternalStorageState()
if (Environment.MEDIA_MOUNTED == state) {
    // Está tudo certo! Podemos ler e escrever
} else if (Environment.MEDIA_MOUNTED_READ_ONLY == state) {
    // Aqui só podemos ler
} else {
    // Outros estados...
}

Ao salvar arquivos no cartão de memória, é possível compartilhá-los com
outras aplicações ou não. Para usar o diretório compartilhado, deve ser
chamado o método getExternalStoragePublicDirectory(String) da classe Environment:
// Arquivo em /sdcard/DCIM
val directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM)

O diretório DCIM é onde normalmente ficam as fotos e os vídeos no
aparelho. Ao empregar a constante DIRECTORY_DCIM será usado o diretório-
raiz, mas pode-se utilizar algum de seus subdiretórios, tais como:
DIRECTORY_PODCASTS, DIRECTORY_RINGTONES, DIRECTORY_ALARMS,
DIRECTORY_NOTIFICATIONS, DIRECTORY_PICTURES, DIRECTORY_MOVIES ou
DIRECTORY_DOWNLOADS.

Já para usar o diretório privado no cartão de memória, deve-se utilizar o
método getExternalFilesDir(String). Pode-se passar como parâmetro para essa
função null ou qualquer um dos diretórios citados anteriormente (menos o
DCIM):
// Arquivo em /sdcard/Android/data/<package_name>/files/
val meuDir = getExternalFilesDir(null)

Vale salientar que o código anterior criará um diretório com o nome do



pacote da aplicação na pasta Android, que está na raiz do cartão de memória.
Outro detalhe importante é que os arquivos desse diretório serão excluídos
caso a aplicação seja desinstalada.

Implemente agora os métodos que estão faltando na MainActivity:
private fun getExternalDir(privateDir : Boolean) =
        // SDCard/Android/data/pacote.da.app/files
        if (privateDir) getExternalFilesDir(null)
        // SDCard/DCIM
        else Environment.getExternalStorageDirectory()
 
fun saveToExternal(privateDir: Boolean) {
    val state = Environment.getExternalStorageState()
    if (Environment.MEDIA_MOUNTED == state) {
        val myDir = getExternalDir(privateDir)
        try {
            if (myDir?.exists() == false) {
                myDir.mkdir()
            }
            val txtFile = File(myDir, "arquivo.txt")
            if (!txtFile.exists()) {
                txtFile.createNewFile()
            }
            val fos = FileOutputStream(txtFile)
            save(fos)
        } catch (e : IOException) {
            Log.d("NGVL", "Erro ao salvar arquivo", e)
        }
    } else {
        Log.e("NGVL", "Não é possível escrever no SD Card")
    }
}
fun loadFromExternal(privateDir: Boolean) {
    val state = Environment.getExternalStorageState()
    if (Environment.MEDIA_MOUNTED == state ||
            Environment.MEDIA_MOUNTED_READ_ONLY == state) {
        val myDir = getExternalDir(privateDir)
        if (myDir?.exists() == true) {
            val txtFile = File(myDir, "arquivo.txt")
            if (txtFile.exists()) {
                try {
                    txtFile.createNewFile()
                    val fis = FileInputStream(txtFile)
                    load(fis)
                } catch (e : IOException) {



                    Log.d("NGVL", "Erro ao carregar arquivo", e)
                }
            }
        }
    } else {
        Log.e("NGVL", "SD Card indisponível")
    }
}

No método saveToExternal(Boolean) é verificado se o cartão de memória está
montado e pronto para escrita; se estiver, o diretório onde o arquivo será
salvo é obtido com a chamada ao método getExternalDir(boolean).

Depois de obter o diretório onde será salvo o arquivo, é checado se ele
existe usando o método exists(); caso não exista, ele será criado usando a
chamada mkdir(). Em seguida, um objeto File é criado e averiguado se existe;
caso não exista, ele será criado usando creatNewFile(). Por fim, o objeto
FileOutpuStream é instanciado e passado para o método save(FileOutpuStream).

Para ler o conteúdo do arquivo, o método loadFromExternal(boolean) é utilizado.
Nele é averiguado se o cartão de memória está montado ao menos para
leitura, e, em seguida, é checado se o diretório e o arquivo a ser lido existem.
Em caso positivo, o objeto FileInputStream é instanciado e passado para o
método load(FileInputStream).

Permissões no Android 6.0 Marshmallow
Até o Android Lollipop todas as permissões que a aplicação necessitava eram
exibidas para o usuário antes de instalar a aplicação no aparelho pelo Google
Play. Entretanto, a partir do Android Marshmallow (API Level 23), o usuário
pode habilitar ou desabilitar o acesso de um aplicativo a determinado recurso
do dispositivo simplesmente acessando as configurações do sistema.

Ao executar a aplicação criada na seção anterior em um aparelho com
Android 6, ela não vai funcionar, pois o acesso a qualquer permissão listada
na Tabela 10.1 é negada por padrão. Essa tabela apresenta as principais
permissões do aplicativo que o usuário pode gerenciar (caso o aplicativo
necessite).

Isso é possível observar ao acessar as configurações do aparelho, entrar na
opção Apps e selecionar a aplicação que foi criada; será exibida a tela da
Figura 10.3. Ao clicar na opção Permissions, a tela da Figura 10.4 será



apresentada.

Figura 10.3 – Detalhes do aplicativo nas configurações do aparelho.

Figura 10.4 – Permissões utilizadas pelo aplicativo de persistência.



Tabela 10.1 – Permissões que podem ser habilitadas ou desabilitadas
pelo usuário

Permissão Descrição
READ_CALENDAR Ler ou escrever dados na aplicação de calendário.
WRITE_CALENDAR
CAMERA Acessar a câmera do aparelho (Capítulo 25).
READ_CONTACTS Ler ou escrever dados na aplicação de contatos (Capítulo 22).
WRITE_CONTACTS
ACCESS_FINE_LOCATION Acessar a localização do aparelho (Capítulo 19).
ACCESS_COARSE_LOCATION
RECORD_AUDIO Acessar o microfone do aparelho (Capítulo 25).
READ_PHONE_STATE Ler o estado do aparelho ou realizar uma ligação.
READ_PHONE_NUMBERS
CALL_PHONE
ANSWER_PHONE_CALLS
READ_CALL_LOG
WRITE_CALL_LOG
ADD_VOICE_MAIL
USE_SIP
PROCESS_OUTGOING_CALLS
BODY_SENSORS Sensores para mensurar dados do corpo (como batimentos cardíacos).
SEND_SMS Enviar ou receber SMS (Capítulo 22).
RECEIVE_SMS
READ_SMS
RECEIVE_WAP_PUSH
RECEIVE_MMS
READ_EXTERNAL_STORAGE Ler ou escrever no sistema de arquivos do aparelho.
WRITE_EXTERNAL_STORAGE

Dessa forma, para salvar os arquivos na pasta pública, devem-se fazer
algumas modificações no aplicativo. Adicione o seguinte código à MainActivity:
private fun checkStoragePermission(permission: String, requestCode: Int): Boolean {
    if (ActivityCompat.checkSelfPermission(this, permission)
            != PackageManager.PERMISSION_GRANTED) {
        if (ActivityCompat.shouldShowRequestPermissionRationale(this, permission)) {
            Toast.makeText(this, R.string.message_permission_requested,
                Toast.LENGTH_SHORT).show()
        }
        ActivityCompat.requestPermissions(this, arrayOf(permission), requestCode)
        return false
    }
    return true
}
override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>,
                                        grantResults: IntArray) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults)
    when (requestCode) {



        RC_STORAGE_PERMISSION -> {
            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(this, R.string.permission_granted,
                    Toast.LENGTH_SHORT).show()
            } else {
                Toast.makeText(this, R.string.permission_denied,
                    Toast.LENGTH_SHORT).show()
            }
        }
    }
}
companion object {
    val RC_STORAGE_PERMISSION = 0
}

O método checkStoragePermission(String,int) verificará se o aplicativo já possui a
permissão; caso tenha, ele retornará true, caso contrário, false. Quem realiza
essa checagem de fato é o método checkSelfPermission(Activity,String), que retorna
PERMISSION_GRANTED caso a permissão para aquele recurso esteja concedida,
ou PERMISSION_DENIED caso esteja negada. Neste exemplo, se a permissão não
está habilitada, o método shouldShowRequestPermissionRationale(Activity,String) é
chamado. Esse método deve ser usado caso o usuário já tenha concedido essa
permissão e depois a revogou. Esse é um bom momento para explicar ao
usuário que essa permissão é importante e deve ser concedida. Aqui, foi
usado apenas um Toast, mas se deve utilizar uma activity de ajuda, por
exemplo, para explicar o propósito dessa permissão.

Por fim, o método requestPermissions(Activity,Array<String>, Int) exibirá uma
mensagem solicitando a permissão em formato de um dialog. O resultado é
tratado no método onRequestPermissionsResult(int,Array<String>,IntArray).

Perceba que foi utilizada a classe ActivityCompat para ter suporte a versões
anteriores ao Marshmallow. Em versões anteriores ao Android 6, o método
checkSelfPermission(Activity, String) sempre retorna true se a permissão estiver
declarada no AndroidManifest.xml.

Adicione as strings utilizadas no res/values/strings.xml:
<string name="message_permission_requested">Você tem q habilitar essa permissão para ler ou salvar

o arquivo.</string>
<string name="permission_granted">Permissão concedida</string>
<string name="permission_denied">Permissão negada</string>

Agora faça a seguinte mudança no método saveToExternal(Boolean) e
loadFromExternal(Boolean) da MainActivity.



fun saveToExternal(privateDir : Boolean) {
    val hasPermission = checkStoragePermission(
            android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
            RC_STORAGE_PERMISSION)
    if (!hasPermission){
        return
    }
    // O restante do código permanece igual
}
fun loadFromExternal(privateDir: Boolean) {
    val hasPermission = checkStoragePermission(
            android.Manifest.permission.READ_EXTERNAL_STORAGE,
            RC_STORAGE_PERMISSION)
    if (!hasPermission){
        return
    }
    // O restante do código permanece igual
}

O método checkStoragePermission(String,int) é chamado passando como parâmetro
a permissão WRITE_EXTERNAL_STORAGE; caso ele ainda não tenha permissão, a
execução do método é encerrada.

Execute a aplicação em um aparelho ou emulador com Android 6.0 ou
superior; ao tentar salvar no cartão de memória, você verá uma mensagem
similar à da Figura 10.5.

O novo mecanismo de permissões foi uma grande mudança do Android
Marshmallow, por isso é necessário ficar atento para adaptar os aplicativos
para essa versão e posteriores. Os exemplos do livro estarão prontos para
executar a partir do Lollipop e posteriores (o que inclui o Android
Marshmallow).



Figura 10.5 – Solicitando permissão de acesso ao cartão de memória.

Dica de biblioteca: Permission Dispatcher
No decorrer do livro são apresentadas as maneiras de utilizar nativamente os
recursos da plataforma, mas serão mostradas algumas formas mais simples de
utilizar esses recursos por meio de bibliotecas. Para facilitar o tratamento de
permissões pode-se utilizar a biblioteca Permission Dispatcher
(https://github.com/permissions-dispatcher/PermissionsDispatcher).

Adicione a dependência dessa biblioteca no build.gradle:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'
 
dependencies {
    ...
    implementation ("com.github.hotchemi:permissionsdispatcher:4.1.0")
    kapt "com.github.hotchemi:permissionsdispatcher-processor:4.1.0"
}

Perceba que mais uma vez foi utilizado o kapt, pois a biblioteca gerará o
código que solicita as permissões em tempo de compilação. Agora faça as



seguintes mudanças na MainActivity:
import permissions.dispatcher.NeedsPermission
import permissions.dispatcher.OnPermissionDenied
import permissions.dispatcher.RuntimePermissions
 
@RuntimePermissions
class MainActivity : AppCompatActivity() {
    ...
    override fun onRequestPermissionsResult(requestCode: Int,
                                            permissions: Array<String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        onRequestPermissionsResult(requestCode, grantResults)
    }
    @OnPermissionDenied(android.Manifest.permission.WRITE_EXTERNAL_STORAGE)
     fun showDeniedForExternal() {
        Toast.makeText(this, R.string.permission_denied, Toast.LENGTH_SHORT).show()
    }
    private fun btnReadClick() {
        val type = rgType.checkedRadioButtonId
        when (type) {
            R.id.rbInternal -> loadFromInternal()
            R.id.rbExternalPriv -> loadFromExternalWithPermissionCheck(true)
            R.id.rbExternalPublic -> loadFromExternalWithPermissionCheck(false)
        }
    }
    private fun btnSaveClick() {
        val type = rgType.checkedRadioButtonId
        when (type) {
            R.id.rbInternal -> saveToInternal()
            R.id.rbExternalPriv -> saveToExternalWithPermissionCheck(true)
            R.id.rbExternalPublic -> saveToExternalWithPermissionCheck(false)
        }
    }
    @NeedsPermission(android.Manifest.permission.WRITE_EXTERNAL_STORAGE)
    fun saveToExternal(privateDir : Boolean) {
        // Apague as linhas a seguir. O restante do método permanece igual
        // val hasPermission = checkStoragePermission(
        // android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
        // RC_STORAGE_PERMISSION)
        // if (!hasPermission){
        // return
        // }
        ...
    }



    @NeedsPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE)
    fun loadFromExternal(privateDir: Boolean) {
        // Apague as linhas a seguir. O restante do método permanece igual
        // val hasPermission = checkStoragePermission(
        // android.Manifest.permission.READ_EXTERNAL_STORAGE,
        // RC_STORAGE_PERMISSION)
        // if (!hasPermission){
        // return
        // }
        ....
    }
    // Pode remover o companion object e o método checkStoragePermission

A MainActivity agora possui uma anotação @RunTimePermissions que registrará
essa classe para tratar permissões, servidor como canal de comunicação entre
nosso aplicativo e a biblioteca.

Os métodos que precisam de permissão estão anotados com @NeedsPermission
e recebem como parâmetro a permissão necessária (neste exemplo,
READ_EXTERNAL_STORAGE e WRITE_EXTERNAL_STORAGE). Isso fará com que
seja gerado um novo método com o final “WithPermissionCheck” que foi
utilizado no evento de clique dos botões de ler e salvar.

Desinstale a aplicação ou desabilite as permissões do aplicativo e execute a
aplicação novamente. Você verá que tudo funcionará normalmente, mas de
maneira mais simples com essa biblioteca.

Telas de preferências com PreferenceFragment
Muitas vezes o usuário acha um aplicativo melhor que o outro pelo simples
fato de poder configurá-lo da maneira que desejar. Nesta seção será
apresentado como criar facilmente telas de configuração para o aplicativo em
um padrão ao qual o usuário já está acostumado por meio da classe
PreferenceFragment.

A primeira coisa que deve ser feita para utilizar esse recurso é definir um
arquivo XML que determinará como essa tela será exibida. Porém, em vez de
um arquivo de layout, deve ser utilizado um “arquivo de tela de
preferências”, que inicia com a tag <PreferenceScreen> e pode conter
<EditTextPreference>, <CheckBoxPreference>, <SwitchPreference> e <ListPreference>.

Adicione a pasta res/xml e, em seguida, crie o arquivo app_preferences.xml
deixando-o como a seguir:



<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
    <EditTextPreference
        android:title="@string/title_city"
        android:key="@string/pref_city"
        android:defaultValue="@string/pref_city_default"
        android:inputType="text"
        android:singleLine="true"/>
    <SwitchPreference
        android:title="@string/title_messages"
        android:summary="@string/summary_messages"
        android:key="@string/pref_messages"/>
    <ListPreference
        android:title="@string/title_social_network"
        android:key="@string/pref_social_network"
        android:entries="@array/social_networks"
        android:entryValues="@array/social_networks_values"
        android:defaultValue="@string/pref_social_network_default"/>
</PreferenceScreen>

O EditTextPreference serve para salvar textos ou números de digitação livre;
neste exemplo é informado que o conteúdo será um texto por meio da
propriedade android:inputType. A propriedade android:title define o título que
aparecerá para o usuário. A propriedade android:key é a chave que será usada
para armazenar esse valor na SharedPreferences, cujo valor-padrão é determinado
pela propriedade android:defaultValue. O componente SwitchPreference salva apenas
valores do tipo booleano, e, além das propriedades que já foram
mencionadas, foi definida a propriedade android:summary, que representa o texto
que fica logo abaixo do título da preferência.

A ListPreference contém duas listas, android:entry e android:entryValues, sendo que a
primeira será exibida para o usuário e a segunda são os respectivos valores.
Sendo assim, ambas as listas devem ter a mesma quantidade de elementos.
As referências às strings que foram utilizadas devem ser adicionadas ao
arquivo res/values/strings.xml:
<string name="pref_city" translatable="false">city</string>
<string name="pref_messages" translatable="false">mensagens</string>
<string name="pref_social_network" translatable="false">rede_social</string>
<string name="title_city">Cidade</string>
<string name="pref_city_default">Recife</string>
<string name="title_messages">Receber mensagens</string>
<string name="summary_messages">Aplicação deve receber mensagens</string>
<string name="title_social_network">Rede social</string>
<string name="pref_social_network_default">gplus</string>



<string-array name="social_networks">
    <item>Google +</item>
    <item>Facebook</item>
    <item>Twitter</item>
    <item>LinkedIn</item>
</string-array>
<string-array name="social_networks_values">
    <item>gplus</item>
    <item>fb</item>
    <item>twitter</item>
    <item>linkedin</item>
</string-array>

Perceba que algumas strings foram marcadas como android:translatable="false"
para indicar que elas não precisam ser traduzidas. Isso é apenas uma boa
prática que pode evitar erros na aplicação, principalmente se o trabalho de
tradução for feito por outra empresa.

Definido o arquivo de preferências, implemente a classe que irá utilizá-lo.
Adicione a dependência da biblioteca de compatibilidade para as telas de
preferências no build.gradle:
dependencies {
    ...
    implementation 'androidx.preference:preference:1.0.0'
}

Agora crie a classe ConfigFragment para utilizar o arquivo de preferências que
foi definido anteriormente:
import android.os.Bundle
import androidx.preference.*
 
class ConfigFragment : PreferenceFragmentCompat(), Preference.OnPreferenceChangeListener {
    private lateinit var editPrefCity: EditTextPreference
    private lateinit var listPrefSocialNetworks: ListPreference
 
    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
        setPreferencesFromResource(R.xml.app_preferences, null)
        editPrefCity = findPreference(getString(R.string.pref_city)) as EditTextPreference
        listPrefSocialNetworks = findPreference(getString(R.string.pref_social_network)) as

ListPreference
        fillSummary(editPrefCity)
        fillSummary(listPrefSocialNetworks)
    }
    private fun fillSummary(preference: Preference) {
        preference.onPreferenceChangeListener = this



        val pref = PreferenceManager.getDefaultSharedPreferences(activity)
        val value = pref.getString(preference.key, "")
        onPreferenceChange(preference, value)
    }
    override fun onPreferenceChange(
            preference: Preference, newValue: Any): Boolean {
        val stringValue = newValue.toString()
        if (preference == listPrefSocialNetworks) {
            val index = listPrefSocialNetworks.findIndexOfValue(stringValue)
            if (index >= 0) {
                listPrefSocialNetworks.summary = listPrefSocialNetworks.entries[index]
            }
        } else if (preference == editPrefCity) {
            editPrefCity.summary = stringValue
        }
        return true
    }
}

A classe herda de PreferenceFragmentCompat e no método onCreatePreferences(Bundle,
String) a função setPreferencesFromResource(Int,String) é chamada passando como
parâmetro o arquivo de preferências que foi criado anteriormente e uma
string que representa o nome do arquivo de preferências. Só isso seria o
suficiente, e a classe estaria perfeitamente funcional, mas foi utilizada uma
lógica adicional para atualizar o sumário das preferências de cidade e rede
social quando elas tiverem seu valor modificado.

Para implementar essa lógica, é obtida a referência do EditTextPreference e do
ListPreference que foi adicionado ao arquivo de preferências. Em seguida, o
método fillSummary(Preference) é chamado duas vezes – uma para cada
preferência que precisa ter o sumário atualizado. Na primeira linha do
fillSummary(Preference), por meio do método
setOnPreferenceChangeListener(OnPreferenceChangeListener) é informado que, quando o
valor dessa preferência mudar, essa classe (this) será chamada. Quando isso
acontecer, o método onPreferenceChange(Preference,Object) será invocado e nele será
atualizado o sumário da preferência com seu respectivo valor. No caso da
lista, é necessário obter o título do respectivo valor que foi atribuído.

Se outra classe precisar ouvir os eventos da mudança de preferência, basta
usar o código a seguir:
val pref = PreferenceManager.getDefaultSharedPreferences(this)
pref.registerOnSharedPreferenceChangeListener { sharedPreferences, key ->
    // O parâmetro key é a preferência modificada



}
Nesse exemplo, foram atualizados os sumários quando o fragment é criado

e quando as preferências são alteradas.
Adicione uma nova activity chamada ConfigActivity ao projeto e deixe o seu

arquivo de layout como a seguir:
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <fragment
        android:id="@+id/fragmentConfig"
        android:name="dominando.android.persistencia.ConfigFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
</FrameLayout>

Como é possível observar, o arquivo de layout contém apenas a declaração
do fragment criado anteriormente. O código da ConfigActivity pode ficar o mais
simples possível:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
 
class ConfigActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_config)
    }
}

Será adicionada uma forma de chamar essa activity a partir da MainActivity.
Primeiro, adicione dois botões ao arquivo de layout
res/layout/activity_main.xml:
//Coloque logo abaixo do txtText
<Button
    android:id="@+id/btnOpenPref"
    android:text="Abrir Preferências"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    app:layout_constraintBaseline_toBaselineOf="@+id/btnReadPref"
    app:layout_constraintEnd_toStartOf="@+id/btnReadPref"
    app:layout_constraintHorizontal_chainStyle="spread"
    app:layout_constraintStart_toStartOf="parent" />
<Button
    android:id="@+id/btnReadPref"



    android:text="Ler Preferências"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toEndOf="@+id/btnOpenPref"
    app:layout_constraintTop_toBottomOf="@+id/txtText"/>

Adicione no onCreate(Bundle) da MainActivity os métodos que serão disparados
ao clicar nos botões:
// Atenção ao import!
import androidx.preference.PreferenceManager
 
// No onCreate
btnOpenPref.setOnClickListener {
    startActivity(Intent(this, ConfigActivity::class.java))
}
btnReadPref.setOnClickListener {
    readPrefs()
}
// Adicione o método readPrefs abaixo do onCreate
private fun readPrefs() {
    val prefs = PreferenceManager.getDefaultSharedPreferences(this)
    val city = prefs.getString(
            getString(R.string.pref_city),
            getString(R.string.pref_city_default))
    val socialNetwork = prefs.getString(
            getString(R.string.pref_social_network),
            getString(R.string.pref_social_network_default))
    val messages = prefs.getBoolean(
            getString(R.string.pref_messages), false)
    val msg = String.format("%s = %s\n%s = %s\n%s = %s",
    getString(R.string.title_city), city,
    getString(R.string.title_social_network), socialNetwork,
    getString(R.string.title_messages), messages.toString())
    Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()
}

A instância da SharedPreferences foi obtida por meio do método
getDefaultSharedPreferences(Context) da classe PreferenceManager. Em seguida, os
valores das preferências são lidos por meio das strings que foram definidas
no res/values/strings.xml. Isso é uma boa prática, pois evita confusão e erros
de digitação no nome da preferência. Execute a aplicação e teste a tela de
preferências; ela deve ficar similar à da Figura 10.6.



Figura 10.6 – Tela de preferências em execução.
As preferências e os arquivos são muito úteis em diversos cenários. Na

próxima seção será visto como persistir informações no banco de dados
relacional SQLite.

Banco de dados SQLite
O SQLite, de acordo com o seu site (www.sqlite.org), é “uma biblioteca que
implementa um banco de dados transacional, autocontido, sem necessidade
de servidor e nem de configurações”. Falando um pouco sobre cada item da
sua definição:

• suporte a transações é um recurso importantíssimo que permite executar
um conjunto de operações e só efetivá-las no banco se todas forem bem-
sucedidas. Caso alguma falhe, é possível desfazer o que já foi executado.
Isso garante a atomicidade do processo, ou seja, ou todas a operações são
realizadas, ou nenhuma;

• autocontido, por ser mínima a sua dependência do sistema operacional,
limitada apenas a algumas poucas funções de bibliotecas da linguagem C;

• trabalha localmente, então o aplicativo acessa diretamente o sistema de



arquivos, ao contrário da maioria dos bancos de dados que ficam em
servidores nos quais a aplicação se comunica via TCP/IP;

• não precisa ser instalado ou configurado, pois já vem incluído no sistema
operacional, então é só usá-lo.

O SQLite possui diversos recursos existentes em SGDBs, tais como: tabelas
com chaves primárias e estrangeiras, views, índices, suporte a transações e
triggers. Enfim, temos à disposição os principais recursos de um banco de
dados relacional.

Utilizando o SQLite na aplicação de hotéis
Para usar o SQLite podem-se utilizar as classes do pacote
android.database.sqlite, e ao criar um banco de dados ele será salvo na
memória interna do aparelho no diretório
/data/data/pacote.da.app/databases, não sendo acessível ao usuário. Para
exemplificar o seu uso, será criada uma camada de persistência para o
aplicativo de hotéis iniciado no Capítulo 8, de modo que eles fiquem salvos
ao sair da aplicação.

Application Name SQLite
Package Name dominando.android.hotel
Activity Name HotelActivity

Faça uma cópia do diretório do projeto Fragments, altere-o para SQLite.
Em seguida, apague o arquivo Fragments.iml e os diretórios build e
app/build. Agora selecione a opção Open Android Studio Project na tela de
boas-vindas do Android Studio e selecione a pasta SQLite. Renomeie o
pacote do projeto para dominando.android.hotel clicando com o botão direito
sobre ele e escolhendo a opção Refactor > Rename.... Selecione a opção
Rename package, defina o nome do pacote como “hotel” e clique em
Refactor. Será exibida uma janela no canto inferior, então clique em Do
refactor para confirmar a alteração.

Feito isso, verifique se o atributo applicationId do arquivo build.gradle e a
propriedade package no AndroidManifest.xml estão com o valor
dominando.android.hotel.

Aproveitando que foi feito esse refactoring, para facilitar a manutenção do
projeto, organize as classes do projeto em pacotes como mostra a Figura 10.7.
Crie cada um dos pacotes clicando com o botão direito sobre o pacote



principal e selecionando a opção New > Package. Em seguida, mova as
classes para os respectivos pacotes.

Feita essa modificação, abra os fragments e as activities e certifique-se de
que o import para o arquivo de layout correspondente esteja declarado
corretamente:
import kotlinx.android.synthetic.main.arquivo_de_layout.*

Agora, renomeie o título da aplicação no arquivo res/values/strings.xml:
<string name="app_name">Hotéis</string>

Execute a aplicação para se certificar de que a aplicação continua
funcionando após o refactoring.

Figura 10.7 – Estrutura de pacotes da aplicação.

Definindo o banco de dados da aplicação
Por questão de organização, a primeira coisa a ser feita é criar um arquivo
chamado DBConstants.kt no pacote repository.sqlite, que conterá apenas as
constantes com o nome da tabela, dos campos e do banco de dados:
package dominando.android.hotel.repository.sqlite
 
const val DATABASE_NAME = "dbHotel"



const val DATABASE_VERSION = 1
const val TABLE_HOTEL = "hotel"
const val COLUMN_ID = "_id"
const val COLUMN_NAME = "name"
const val COLUMN_ADDRESS = "address"
const val COLUMN_RATING = "rating"

KOTLINxJAVA: É permitido declarar constantes e funções “soltas” em um
arquivo Kotlin, sem necessariamente ter uma classe.

O modo recomendado para criar um banco de dados SQLite no Android é
definir uma classe que herde de SQLiteOpenHelper. Ela será responsável por criar
o banco de dados caso ele não exista e atualizá-lo (se necessário) em novas
versões da aplicação. Crie a classe HotelSqlHelper e deixe-a como a seguir:
import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
 
class HotelSqlHelper(context: Context) :
        SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {
    
    override fun onCreate(sqLiteDatabase: SQLiteDatabase) {
        sqLiteDatabase.execSQL(
                "CREATE TABLE $TABLE_HOTEL (" +
                        "$COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT," +
                        "$COLUMN_NAME TEXT NOT NULL, " +
                        "$COLUMN_ADDRESS TEXT, " +
                        "$COLUMN_RATING REAL)")
    }
 
    override fun onUpgrade(sqLiteDatabase: SQLiteDatabase,
                           oldVersion: Int, newVersion: Int) {
        // Para as próximas versões
    }
}

Essa classe herda de SQLiteOpenHelper e no construtor recebe apenas um
objeto Context, mas o construtor da superclasse requer, além desse objeto, o
nome e a versão do banco. A versão do banco é muito importante, pois se
deve definir o valor da primeira versão (1 por exemplo) e ir incrementando
esse valor à medida que alterações forem realizadas na estrutura do banco de
dados (como a adição de um novo campo, tabela, índice etc.). Perceba que a



versão do banco e do aplicativo são coisas distintas.
Quando essa classe for utilizada em qualquer ponto da aplicação, caso o

banco não exista, o método onCreate(SQLiteDatabase) será chamado, e então o
banco de dados será criado, assim como a tabela de hotéis. Caso o banco já
exista, mas com uma versão inferior ao valor da constante
DATABASE_VERSION, o método onUpgrade(SQLiteDatabase) será invocado.

Para entender melhor esse conceito de versão do banco, digamos que a
primeira versão do aplicativo foi lançada, e nela a versão do banco era 1.
Entretanto, na versão 5 do seu aplicativo, sentiu-se a necessidade de uma
nova coluna na tabela. Nesse cenário, seria necessário definir o valor da
constante DATABASE_VERSION para 2 e deixar o script da criação da tabela no
onCreate(SQLiteDatabse) já com a nova coluna. Dessa forma, quem baixar
diretamente a versão 5 do aplicativo usará o script atualizado com a nova
coluna. No método onUpgrade(SQLiteDatabse) ficaria apenas o script que adiciona
a nova coluna na tabela; assim o usuário que já tenha feito o download das
versões 1 a 4 terá o seu banco de dados atualizado e não perderá as
informações existentes.

O objeto SQLiteDatabase permite executar os comandos SQL (Structured
Query Language) no banco de dados. Ao chamar o método execSQL(String), a
instrução SQL é executada para criar a tabela de hotéis. Note que, para cada
campo, foi informado o seu tipo logo após o seu nome. O SQLite suporta os
tipos de dados listados na Tabela 10.2.

Tabela 10.2 – Tipos de dados do SQLite
Tipo Descrição

INTEGER Inteiro sinalizado, usando 8, 16, 24, 32, 48 ou 64 bits, conforme a necessidade.
REAL Ponto flutuante de 64 bits.
TEXT Textos em UTF-8, UTF-16BE ou UTF-16LE.
BLOB Arrays de bytes.

Como se pode observar, o SQLite é bem minimalista, e você pode pensar
que existem algumas lacunas como valores booleanos e datas. O primeiro
pode ser representado por um inteiro com 0 e 1, por exemplo. Já as datas
podem ser armazenadas como inteiros usando os milissegundos, ou, ainda,
como strings. O SQLite possui uma série de funções para manipulação de
data e hora que podem ser consultadas na documentação oficial disponível
em http://www.sqlite.org.



Crie a classe SQLiteRepository que realizará as operações de pesquisar, inserir,
atualizar e excluir registros no banco de dados e será utilizada pelas telas da
aplicação:
import android.content.ContentValues
import android.content.Context
import android.database.Cursor
import android.database.sqlite.SQLiteDatabase
import dominando.android.hotel.model.Hotel
import dominando.android.hotel.repository.HotelRepository
import java.util.ArrayList
 
class SQLiteRepository(ctx: Context): HotelRepository {
    private val helper: HotelSqlHelper = HotelSqlHelper(ctx)
 
    private fun insert(hotel: Hotel) {
        val db = helper.writableDatabase
        val cv = ContentValues().apply {
            put(COLUMN_NAME, hotel.name)
            put(COLUMN_ADDRESS, hotel.address)
            put(COLUMN_RATING, hotel.rating)
        }
        val id = db.insert(TABLE_HOTEL, null, cv)
        if (id != -1L) {
            hotel.id = id
        }
        db.close()
    }
    private fun update(hotel: Hotel) {
        val db = helper.writableDatabase
        val cv = ContentValues().apply {
            put(COLUMN_ID, hotel.id)
            put(COLUMN_NAME, hotel.name)
            put(COLUMN_ADDRESS, hotel.address)
            put(COLUMN_RATING, hotel.rating)
        }
        db.insertWithOnConflict(
                TABLE_HOTEL,
                null,
                cv,
                SQLiteDatabase.CONFLICT_REPLACE)
        db.close()
    }
    override fun save(hotel: Hotel) {
        if (hotel.id == 0L) {



            insert(hotel)
        } else {
            update(hotel)
        }
    }
    override fun remove(vararg hotels: Hotel) {
        val db = helper.writableDatabase
        for (hotel in hotels) {
            db.delete(
                    TABLE_HOTEL,
                    "$COLUMN_ID = ?",
                    arrayOf(hotel.id.toString()))
        }
        db.close()
    }
    override fun hotelById(id: Long, callback: (Hotel?)->Unit) {
        val sql = "SELECT * FROM $TABLE_HOTEL WHERE $COLUMN_ID = ?"
        val db = helper.readableDatabase
        val cursor = db.rawQuery(sql, arrayOf(id.toString()))
        val hotel = if (cursor.moveToNext()) hotelFromCursor(cursor) else null
        callback(hotel)
    }
    override fun search(term: String, callback: (List<Hotel>)->Unit) {
        var sql = "SELECT * FROM $TABLE_HOTEL"
        var args: Array<String>? = null
        if (term.isNotEmpty()) {
            sql += " WHERE $COLUMN_NAME LIKE ?"
            args = arrayOf("%$term%")
        }
        sql += " ORDER BY $COLUMN_NAME"
        val db = helper.readableDatabase
        val cursor = db.rawQuery(sql, args)
        val hotels = ArrayList<Hotel>()
        while (cursor.moveToNext()) {
            val hotel = hotelFromCursor(cursor)
            hotels.add(hotel)
        }
        cursor.close()
        db.close()
        callback(hotels)
    }
    private fun hotelFromCursor(cursor: Cursor): Hotel {
        val id = cursor.getLong(
                cursor.getColumnIndex(COLUMN_ID))
        val name = cursor.getString(



                cursor.getColumnIndex(COLUMN_NAME))
        val address = cursor.getString(
                cursor.getColumnIndex(COLUMN_ADDRESS))
        val rating = cursor.getFloat(
                cursor.getColumnIndex(COLUMN_RATING))
        return Hotel(id, name, address, rating)
    }
}

A classe implementa a interface HotelRepository que foi criada no Capítulo 8.
Ela inicia com um construtor que recebe um objeto Context como parâmetro, e
com ele é criada uma instância do HotelSqlHelper. Nesse momento, caso seja
feita uma chamada às propriedades writableDatabase ou readableDatabase – das quais
falaremos logo na sequência –, se o banco de dados não existir, ele será
criado e o método onCreate(SQLiteDatabase) da classe HotelSqlHelper será chamado.
Por meio do atributo helper uma referência da classe SQLiteDatabse pode ser
obtida, e com ela é possível inserir, alterar, excluir e obter os registros do
banco de dados.

No início do método insert(Hotel) uma instância do SQLiteDatabase é obtida por
meio da propriedade writableDatabase do helper. Em seguida, é declarado um
objeto ContentValues onde são adicionados os valores para cada coluna da tabela
usando o respectivo atributo do objeto hotel. Para inserir o registro na tabela o
método insert(String, String, ContentValues) é chamado passando como parâmetro o
nome da tabela e os valores que serão inseridos. Esse método retornará o
valor -1 caso ocorra algum problema, mas, se tudo correr bem, o id do
registro que foi incluído será retornado (uma vez que o campo ID foi
declarado como autoincremento), e nesse caso o id do objeto hotel que foi
passado como parâmetro é atualizado para que ele fique consistente com o
que está salvo no banco.

Os métodos insert(Hotel) e update(Hotel) estão privados, pois estão abstraídos
pelo save(Hotel). Nele, é verificado se o id do hotel é igual a zero; nesse caso,
este é um objeto novo e deve ser inserido; caso o hotel já tenha um
identificador, ele será atualizado.

No método update(Hotel) é feito algo similar ao método anterior, a diferença é
que foi utilizado o método insertWithOnConflict(String, String, ContentValues, int), pois
quando desfazemos uma exclusão passamos os objetos hotel com id para o
método save(Hotel), e nesse cenário ele tentaria atualizar um registro que já foi
excluído. Com o insertWithOnConflict(String, String, ContentValues, int) o SQLite tenta



inserir, e caso viole alguma regra do banco, o último parâmetro determinará a
ação que ele tomará. Com a constante SQLiteDatabase.CONFLICT_REPLACE se o
registro já existir ao tentar inseri-lo, ele será atualizado, que é exatamente o
comportamento desejado nesse exemplo.

Na verdade, se não fosse esse requisito de desfazer a exclusão, o método
update(Hotel) deveria estar como a seguir:
private fun update(hotel: Hotel) {
    val db = helper.writableDatabase
    val cv = ContentValues().apply {
        put(COLUMN_NAME, hotel.name)
        put(COLUMN_ADDRESS, hotel.address)
        put(COLUMN_RATING, hotel.rating)
    }
    db.update(TABLE_HOTEL, cv, "$COLUMN_ID = ?", arrayOf(hotel.id.toString()))
    db.close()
}

O método update(String, ContentValues, String, String[]) recebe como parâmetro: o
nome da tabela; um ContentValues com as colunas que serão atualizadas e os
seus respectivos valores; a cláusula where do SQL; e os argumentos da
cláusula WHERE. Neste exemplo está sendo usada a condição "_id = ?", onde a
“?” será substituída pelo valor correspondente do array de strings passado no
último parâmetro (que contém apenas o id do objeto hotel). Se for necessário,
por exemplo, alterar todos os hotéis cujos ids estivessem entre 1 e 10, poderia
ser utilizada a condição "_id >= ? and _id <= ?" e passar um array com as Strings
“1” e “10”.

O método remove(Hotel) excluirá um hotel do banco de dados ao invocar o
método delete(String, String, String[]), que recebe como parâmetro o nome da tabela,
a cláusula where e os argumentos da cláusula where. Aqui o hotel está sendo
excluído baseado no seu id.

Para realizar a pesquisa por hotéis, foi definido o método search(String), que
retorna via callback a lista de objetos Hotel. O método rawQuery(String, String)
retorna um objeto do tipo Cursor por meio do qual é possível navegar entre os
registros retornados pela consulta, e então ler o valor de cada coluna. Nesse
método, é passada a instrução SQL no primeiro parâmetro e os argumentos
da cláusula WHERE no segundo. Se for informado algum filtro, a condição
LIKE do SQL será usada para buscarmos hotel pelo nome; caso contrário,
todos os hotéis serão retornados.



Para navegar pelos registros retornados pela busca, é feita uma iteração pelo
cursor chamando o método moveToNext(); enquanto ele retornar true é sinal de
que ainda não foi alcançado o final dos registros retornados. Para ler cada
coluna, é necessário saber o tipo de dados, então utilizam-se os métodos
getLong(Int), getString(Int), getInt(Int) ou getFloat(Int). Note que para ler a informação é
preciso passar o índice da coluna no cursor que pode ser obtido pelo método
getColumnIndex(String) passando o nome da coluna. De posse dos valores, o
objeto hotel é criado e adicionado na lista que será retornada. Para finalizar, o
cursor é fechado e a lista de hotéis devidamente preenchida é retornada.

O método hotelById(Long, (Hotel)->Unit) é bem similar ao de busca pelo nome. A
única diferença é que a busca é feita pelo id em vez do nome; e é retornado
apenas um objeto no lugar de uma lista.

Observe que em todos os métodos, após realizar a operação desejada, o
banco de dados é fechado usando o método close() do objeto SQLiteDatabase,
evitando problemas com várias instâncias do banco abertas ao mesmo tempo.

Injeção de dependência com Koin
Até agora apenas a persistência em memória foi implementada pelo objeto
MemoryRepository. Ao clicar com o botão direito sobre esse objeto e selecionar a
opção Find Usages, nota-se que ela está sendo utilizada por três classes:
HotelListFragment, HotelDetailsFragment e HotelFormFragment. Graças à arquitetura
baseada na interface HotelRepository, para utilizar a persistência no SQLite
implementada na seção anterior, basta substituir a referência à MemoryRepository
pela classe SQLiteRepository nestes três locais.

A princípio, esta parece ser uma boa solução, pois o aplicativo de hotéis
possui apenas três referências ao repositório. Imagine se a aplicação tivesse
dezenas ou até centenas de telas e fosse preciso modificar o mecanismo de
persistência novamente. Teria que ser modificado em todos esses lugares.

Além desse problema, existe também um erro conceitual na abordagem
atual. A aplicação está isolando as camadas em Model, View e Presenter, mas
a View está acessando diretamente uma implementação real do model (neste
exemplo, o MemoryRepository). Lembre-se: no MVP, a View conversa apenas
com o Presenter, e este último é que deve acessar o Model.

Nesse contexto é que se encaixa a injeção de dependência, em que ao invés
de instanciar diretamente as dependências que a classe necessita, essas



dependências serão criadas e fornecidas a partir de um único local de forma
eficiente e padronizada. Para essa tarefa será utilizado o Koin
(https://github.com/InsertKoinIO/koin), uma biblioteca leve para injeção de
dependências.

Para utilizá-la, adicione a dependência no build.gradle:
dependencies {
    ...
    implementation 'org.koin:koin-android:1.0.0'
    implementation 'org.koin:koin-androidx-scope:1.0.0'
}

Crie o pacote di (de Dependency Injection) e dentro dele crie o arquivo
AndroidModule.kt e deixe-o como a seguir:
package dominando.android.hotel.di
 
import dominando.android.hotel.details.HotelDetailsPresenter
import dominando.android.hotel.details.HotelDetailsView
import dominando.android.hotel.form.HotelFormPresenter
import dominando.android.hotel.form.HotelFormView
import dominando.android.hotel.list.HotelListPresenter
import dominando.android.hotel.list.HotelListView
import dominando.android.hotel.repository.HotelRepository
import dominando.android.hotel.repository.sqlite.SQLiteRepository
import org.koin.dsl.module.module
 
val androidModule = module {
    single { this }
    single {
        SQLiteRepository(ctx = get()) as HotelRepository
    }
    factory { (view: HotelListView) ->
        HotelListPresenter(
                view,
                repository = get()
        )
    }
    factory { (view: HotelDetailsView) ->
        HotelDetailsPresenter(
                view,
                repository = get()
        )
    }
    factory { (view: HotelFormView) ->



        HotelFormPresenter(
                view,
                repository = get()
        )
    }
}

Foi criado um módulo do Koin com a função module que é responsável por
criar instâncias para a aplicação. Neste arquivo, além do repositório estão
sendo criados todos os presenters da aplicação. Em aplicativos maiores
devem-se criar mais módulos para organizar melhor as dependências.

O método single é utilizado para criar instâncias únicas, como é o caso do
repositório. Para criar múltiplas instâncias, deve-se utilizar o método factory,
como foi feito para os presenters, em que deve ser criada uma nova instância
para cada fragment que é exibido. Perceba que para criar o presenter é
necessária a sua respectiva view, por esta razão foi utilizado o parâmetro
params.

Note que foram utilizados os “named parameters” do Kotlin para facilitar a
legibilidade, deixando claro quais parâmetros estão sendo passados.

Uma vez que o módulo do Koin foi criado, ele deve ser iniciado tão logo a
aplicação seja aberta. Crie a classe HotelApp no pacote-raiz do projeto e deixe-a
como a seguir:
import android.app.Application
import dominando.android.hotel.di.androidModule
import org.koin.android.ext.android.startKoin
import org.koin.standalone.StandAloneContext.stopKoin
 
class HotelApp : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin(this, listOf(androidModule))
    }
    override fun onTerminate() {
        super.onTerminate()
        stopKoin()
    }
}

Ao iniciar a aplicação, antes de qualquer activity, o sistema operacional cria
uma instância do objeto Application. Por essa razão, foi criada a classe HotelApp
para inicializar o grafo de dependências do Koin por meio da chamada



startKoin(Context, List<Module>), passando como parâmetro a própria aplicação (que
herda de Context) e a lista de módulos. Aqui só foi declarado um único
módulo, mas se houvessem mais, eles deveriam ser passados como
parâmetro. Para evitar qualquer problema de memória, o módulo do Koin é
desalocado no método onTerminate().

Referencie a classe HotelApp na tag application do AndroidManifest.xml:
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="dominando.android.hotel">
    <application
        android:name=".HotelApp" ...

Feito isso, será informado em cada fragment que o Koin será responsável
por criar os presenters. Ao buscar por referências à interface HotelRepository,
notará que ela é usada pelos três presenters: HotelListPresenter, HotelDetailsPresenter e
HotelFormPresenter, e essas classes são utilizadas, respectivamente, em
HotelListFragment, HotelDetailsFragment e HotelFormFragment. Abra essas classes e faça
as seguintes mudanças:
// Certifique-se de utilizar esse import
import org.koin.android.ext.android.inject
import org.koin.core.parameter.parametersOf
 
class HotelListFragment : ListFragment() /* interfaces ... */ {
    private val presenter: HotelListPresenter by inject { parametersOf(this) }
    ...
class HotelDetailsFragment : Fragment(), HotelDetailsView {
    private val presenter: HotelDetailsPresenter by inject { parametersOf(this) }
     ...
class HotelFormFragment : DialogFragment(), HotelFormView {
    private val presenter: HotelFormPresenter by inject { parametersOf(this) }
    ...

Pronto! Com essa modificação os fragments não terão mais a
responsabilidade de criar os presenters nem o repositório. O maior benefício
dessa abordagem é deixar o código desacoplado e muito mais fácil de manter,
pois existe um local centralizado onde as instâncias dos serviços internos da
aplicação são criados. Desta forma, se o construtor de algum dos presenters
ou do repositório for alterado, só é preciso modificar um único local. E isso é
muito importante, principalmente em projetos maiores.

Execute a aplicação3, adicione alguns hotéis e depois feche a aplicação. Em
seguida, execute novamente e você verá que os dados permanecem lá.



Editando hotéis cadastrados
Até agora a aplicação insere, remove e lista os registros, entretanto não é
possível alterar um hotel existente. Chegou a hora de permitir a edição desses
registros. Adicione a seguinte ação no arquivo de menu
res/menu/hotel_details.xml para editar um hotel cadastrado:
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    ...
    <item
        android:id="@+id/action_edit"
        android:icon="@android:drawable/ic_menu_edit"
        android:title="@string/action_edit"
        app:showAsAction="always|withText" />
</menu>

Adicione a string action_edit no res/values/strings.xml:
<string name="action_edit">Editar</string>

Na classe HotelDetailsFragment será implementado o comportamento dessa
opção de menu que será exibir a tela de cadastro passando como parâmetro o
id do hotel selecionado:
override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    if (item?.itemId == R.id.action_edit) {
        HotelFormFragment
                .newInstance(hotel?.id ?: 0)
                .open(requireFragmentManager())
    }
    return super.onOptionsItemSelected(item)
}

Ao editar um registro, a HotelDetailsActivity deve atualizar o fragment com os
novos dados do hotel recém-modificados. Para tratar esse comportamento, é
necessário que a activity de detalhes implemente a interface OnHotelSavedListener
e seu respectivo método:
class HotelDetailsActivity : AppCompatActivity(), HotelFormFragment.OnHotelSavedListener {
    ...
    override fun onHotelSaved(hotel: Hotel) {
        setResult(RESULT_OK)
        showHotelDetailsFragment()
    }
    ...
}



Uma vez que a atualização foi feita na activity de detalhes, deve-se
informar a HotelActivity para atualizar o fragment de listagem. Por isso, no
método anterior foi chamado o método setResult(int), para que a HotelDetailsActivity
seja chamada utilizando startActivityForResult(Intent,int). Assim, só atualizaremos a
listagem se for necessário. Altere o método open() da HotelDetailsActivity:
fun open(activity: Activity, hotelId: Long) {
    activity.startActivityForResult(
            Intent(activity, HotelDetailsActivity::class.java).apply {
                putExtra(EXTRA_HOTEL_ID, hotelId)
            }, 0)
}

Em seguida, faça as seguintes mudanças na HotelActivity:
class HotelActivity ... {
    ...
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == 0 && resultCode == Activity.RESULT_OK) {
            listFragment.search(lastSearchTerm)
        }
    }
    override fun onHotelSaved(hotel: Hotel) {
        listFragment.search(lastSearchTerm)
        val detailsFragment = supportFragmentManager
            .findFragmentByTag(HotelDetailsFragment.TAG_DETAILS) as? HotelDetailsFragment
        if (detailsFragment != null && hotel.id == hotelIdSelected) {
            showDetailsFragment(hotelIdSelected)
        }
    }

No método onHotelSaved(Hotel) é tratado o caso da alteração de dados na
versão para tablets. Nesse cenário, é preciso checar se o hotel atualizado é o
mesmo que foi clicado. Em caso positivo, o fragment de detalhes deve ser
atualizado com os novos dados.

Execute a aplicação e agora será possível editar os hotéis cadastrados.

Criando um Adapter para a tela de listagem
Nesta seção será criado um adapter customizado para a tela de listagem. O
novo adapter utilizará para cada linha da lista o arquivo de layout
res/layout/item_hotel.xml definido a seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"



    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/selector_list_item"
    android:padding="8dp">
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceLarge"
        android:text="@null"
        android:id="@+id/txtName"/>
    <RatingBar
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/rtbRating"
        android:isIndicator="true"
        android:layout_gravity="end"
        android:progressTint="@color/colorAccent"
        style="?android:attr/ratingBarStyleSmall"/>
</LinearLayout>

Foi utilizado o estilo ?android:attr/ratingBarStyleSmall para a RatingBar aparecer
menor. Também foi usada a propriedade android:isIndicator para não permitir que
o usuário altere o valor do componente. Outro detalhe é que foi atribuído o
selector @drawable/selector_list_item como background, isso é necessário para que
a linha fique destacada ao fazer a seleção múltipla para exclusão.

Adicione o arquivo selector_list_item.xml na pasta res/drawable e deixe-o
como a seguir:
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_activated="true">
        <color android:color="@color/colorAccent" />
    </item>
</selector>

Agora crie uma nova classe chamada HotelAdapter no pacote list e deixe-a
como a seguir:
import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.RatingBar
import android.widget.TextView



import dominando.android.hotel.R
import dominando.android.hotel.model.Hotel
import kotlinx.android.synthetic.main.item_hotel.view.*
 
class HotelAdapter(context: Context, hotels: List<Hotel>):
        ArrayAdapter<Hotel>(context, 0, hotels) {
 
    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        val hotel = getItem(position)
        val viewHolder = if (convertView == null) {
            val view = LayoutInflater.from(parent?.context)
                    .inflate(R.layout.item_hotel, parent, false)
            val holder = ViewHolder(view)
            view.tag = holder
            holder
        } else {
            convertView.tag as ViewHolder
        }
        viewHolder.txtName.text = hotel?.name
        viewHolder.rtbRating.rating = hotel?.rating ?: 0f
        return viewHolder.view
    }
    class ViewHolder(val view: View) {
        val txtName: TextView = view.txtName
        val rtbRating: RatingBar = view.rtbRating
    }
}

Essa classe herda de ArrayAdapter, que é uma subclasse de BaseAdapter, mas que
já implementa os métodos getItem(int) e getCount() baseado na lista passada no
construtor. Vá até o método showHotels(List<Hotel>) da classe HotelListFragment e
substitua o antigo adapter pelo HotelAdapter:
override fun showHotels(hotels: List<Hotel>) {
    val adapter = HotelAdapter(requireContext(), hotels)
    listAdapter = adapter
}

Execute a aplicação e a tela de listagem ficará com um visual similar ao da
Figura 10.8.



Figura 10.8 – Adapter customizado para a tela de listagem de hotéis.

Content Provider
Um content provider, como o próprio nome diz, é um provedor de conteúdo
que permite compartilhar informações com outras aplicações. Essas
informações normalmente são dados do banco de dados SQLite (mas nada
impede que venham de outra fonte). As vantagens de utilizar esse mecanismo
são:

• permite compartilhar dados de forma padronizada entre aplicativos;
• uma interface-padrão de persistência de dados, independentemente de ser

com SQLite ou outra forma de armazenamento;
• se for necessário alterar a forma de persistir os dados, é preciso apenas

alterar o provider internamente;
• é o mecanismo-padrão de compartilhamento de dados da aplicação com

outros componentes do sistema e com outras aplicações.
Será adicionado um ContentProvider ao nosso aplicativo de hotéis apenas para

fins didáticos. Faça uma cópia do projeto SQLite e renomeie para Provider, em
seguida, apague o arquivo SQLite.iml e os diretórios build e app/build. Por



fim, abra o projeto do diretório Provider no Android Studio.
Application Name Provider
Package Name dominando.android.hotel
Activity Name HotelActivity

Para acessar os dados de um content provider, é recomendado utilizar a
classe LoaderManager, que faz a busca em segundo plano, ou seja, em outra
thread. Isso é uma boa prática, uma vez que caso haja um grande volume de
dados, a busca pode demorar alguns segundos e a aplicação pode aparentar
estar travada. Para exibir o resultado da busca deve-se utilizar um CursorAdapter,
que é similar a um ArrayAdapter, mas em vez de usar uma lista de objetos,
utiliza-se um Cursor como fonte de dados. Essa abordagem será utilizada no
Capítulo 22 sobre Contatos e SMS, mas por enquanto será criado um
repositório que acessa um Content Provider diretamente.

Crie um novo ContentProvider clicando com o botão direito no pacote
repository.sqlite e selecione New > Other > Content Provider. Será exibida a
tela da Figura 10.9.

Figura 10.9 – Criando um ContentProvider no Android Studio.
No campo Class Name, digite HotelProvider. No campo URI Authorities,

deve-se informar o endereço pelo qual o provider será acessado. Insira o
valor dominando.android.hotel. Logo abaixo estão dois checkboxes; no primeiro,



deve-se indicar se o provider ficará acessível para outras aplicações o
acessarem, enquanto no segundo é informado se o provider poderá ser
instanciado pelo sistema. Deixe ambos marcados e clique em Finish para que
o provider seja criado.

Em seguida, faça os ajustes para que a classe HotelProvider fique da seguinte
forma:
import android.content.ContentProvider
import android.content.ContentResolver
import android.content.ContentValues
import android.content.UriMatcher
import android.database.Cursor
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteQueryBuilder
import android.net.Uri
 
class HotelProvider : ContentProvider() {
 
    private lateinit var helper: HotelSqlHelper
 
    override fun onCreate(): Boolean {
        helper = HotelSqlHelper(context)
        return true
    }
    override fun getType(uri: Uri): String? {
        val uriType = sUriMatcher.match(uri)
        return when (uriType) {
            TYPE_HOTEL_DIR ->
                return "${ContentResolver.CURSOR_DIR_BASE_TYPE}/dominando.android.hotel"
            TYPE_HOTEL_ITEM ->
                return "${ContentResolver.CURSOR_ITEM_BASE_TYPE}/dominando.android.hotel"
            else -> null
        }
    }
    override fun insert(uri: Uri, values: ContentValues?): Uri? {
        val uriType = sUriMatcher.match(uri)
        val sqlDB = helper.writableDatabase
        val id: Long
        when (uriType) {
            TYPE_HOTEL_DIR ->
                id = sqlDB.insertWithOnConflict(
                        TABLE_HOTEL,
                        null,
                        values,



                        SQLiteDatabase.CONFLICT_REPLACE)
            else ->
                throw IllegalArgumentException("URI não suportada: $uri")
        }
        context.contentResolver.notifyChange(uri, null)
        return Uri.withAppendedPath(CONTENT_URI, id.toString())
    }
    override fun update(uri: Uri, values: ContentValues?, selection: String?,
                        selectionArgs: Array<String>?): Int {
        val uriType = sUriMatcher.match(uri)
        val sqlDB = helper.writableDatabase
        val rowsAffected = when (uriType) {
            TYPE_HOTEL_DIR ->
                sqlDB.update(
                        TABLE_HOTEL,
                        values,
                        selection,
                        selectionArgs)
            TYPE_HOTEL_ITEM -> {
                val id = uri.lastPathSegment
                sqlDB.update(
                        TABLE_HOTEL,
                        values,
                        "$COLUMN_ID= ?",
                        arrayOf(id))
            }
            else -> throw IllegalArgumentException(
                    "URI não suportada: $uri")
        }
        context.contentResolver.notifyChange(uri, null)
        return rowsAffected
    }
    override fun delete(uri: Uri, selection: String?, selectionArgs: Array<String>?): Int {
        val uriType = sUriMatcher.match(uri)
        val sqlDB = helper.writableDatabase
        val rowsDeleted = when (uriType) {
            TYPE_HOTEL_DIR ->
                sqlDB.delete(
                        TABLE_HOTEL, selection, selectionArgs)
            TYPE_HOTEL_ITEM -> {
                val id = uri.lastPathSegment
                sqlDB.delete(
                        TABLE_HOTEL, "$COLUMN_ID = ?", arrayOf(id))
            }
            else -> throw IllegalArgumentException(



                    "URI não suportada: $uri")
        }
        context.contentResolver.notifyChange(uri, null)
        return rowsDeleted
    }
    override fun query(uri: Uri, projection: Array<String>?, selection: String?,
                       selectionArgs: Array<String>?, sortOrder: String?): Cursor? {
        val uriType = sUriMatcher.match(uri)
        val db = helper.writableDatabase
        val queryBuilder = SQLiteQueryBuilder()
        queryBuilder.tables = TABLE_HOTEL
        val cursor: Cursor
        when (uriType) {
            TYPE_HOTEL_DIR ->
                cursor = queryBuilder.query(
                        db, projection, selection,
                        selectionArgs, null, null, sortOrder)
            TYPE_HOTEL_ITEM -> {
                queryBuilder.appendWhere("$COLUMN_ID = ?")
                cursor = queryBuilder.query(db, projection, selection,
                        arrayOf(uri.lastPathSegment),
                        null, null, null)
            }
            else -> throw IllegalArgumentException("URI não suportada: $uri")
        }
        cursor.setNotificationUri(context.contentResolver, uri)
        return cursor
    }
 
    companion object {
        private const val AUTHORITY = "dominando.android.hotel"
        private const val PATH = "hotels"
        private const val TYPE_HOTEL_DIR = 1
        private const val TYPE_HOTEL_ITEM = 2
        val CONTENT_URI: Uri = Uri.parse("content://$AUTHORITY/$PATH")
        private val sUriMatcher: UriMatcher = UriMatcher(UriMatcher.NO_MATCH)
        init {
            sUriMatcher.addURI(AUTHORITY, PATH, TYPE_HOTEL_DIR)
            sUriMatcher.addURI(AUTHORITY, "$PATH/#", TYPE_HOTEL_ITEM)
        }
    }
}

Essa classe herda de ContentProvider e, ao final, é declarada a constante
AUTHORITY, que deve ter o mesmo valor da propriedade android:authorities da



tag <provider> do AndroidManifest.xml:
<provider
    android:name=".repository.sqlite.HotelProvider"
    android:authorities="dominando.android.hotel"
    android:enabled="true"
    android:exported="true" />

É a authority que define o endereço do provider. Dessa forma, qualquer
requisição que for feita para content://dominando.android.hotel chamará o
provider. Porém, não faz sentido tratar uma requisição para
content://dominando.android.hotel/blablabla, por essa razão é preciso definir
os endereços que serão tratados pelo provider. Nesse exemplo, a classe
HotelProvider só responde por dois tipos de endereços:
content://dominando.android.hotel/hotels (que aqui é representada pela
constante TYPE_HOTEL_DIR) ou content://dominando.android.hotel/hotels/ID,
onde “ID” é o id do hotel que deve ser carregado (chamado de
TYPE_HOTEL_ITEM).

Para fazer essa validação é utilizado um objeto do tipo UriMatcher, que serve
justamente para checar se a Uri informada se enquadra em um desses dois
tipos. Dessa forma, para cada operação que for realizada no provider, é
verificado primeiramente se a Uri requisitada é do tipo TYPE_HOTEL_DIR ou
TYPE_HOTEL_ITEM.

No onCreate() é instanciado o HotelSqlHelper que dará acesso ao banco de dados
para realizar as operações de incluir, alterar, excluir e consultar.

É uma boa prática retornar qual o MIME Type dos dados que esse provider
trabalha no método getType(Uri). Se ele retornasse imagens PNG, por exemplo,
deveria ser retornado “image/png”. Porém, neste exemplo é retornada a
informação de um ou vários hotéis; por definição, deve-se utilizar
vnd.android.cursor.dir/<tipo> (ContentResolver.CURSOR_DIR_BASE_TYPE) para
quando o provider retornar vários registros e vnd.android.cursor.item/<tipo>
(ContentResolver.CURSOR_ITEM_BASE_TYPE) para quando retornar apenas um.

Em seguida, temos os quatro principais métodos que iniciam checando que
tipo de Uri foi passada: TYPE_HOTEL_DIR ou TYPE_HOTEL_ITEM. Se for passado
um id no final da Uri, é sinal de que se trata de um hotel específico; do
contrário, será uma operação que pode afetar todos os dados. Nos quatro
métodos, após obter a informação do tipo da Uri, a instância do SQLiteDatabase é
obtida a partir do atributo helper:



• insert(Uri, ContentValues) – antes de inserir um registro não sabemos o seu
identificador, logo, aqui só suportamos o TYPE_HOTEL_DIR (que não usa o
id). Então, nesse método, o objeto ContentValues recebido como parâmetro é
repassado para inser um novo registro no banco de dados. Essa operação
retornará o id do registro inserido, então o método Uri.withAppendedPath(Uri,
String) é chamado para que o endereço referente ao registro inserido possa
ser recuperado por meio do próprio provider pelo método query(Uri, String[],
String, String[], String). Perceba que foi usado o método insertWithOnConflict
(String,String, ContentValues,int), que fará com que o registro atual seja
atualizado caso haja algum problema de duplicidade;

• update(Uri, ContentValues, String, String[]) – é possível alterar um hotel específico
ou uma série de hotéis. Se o tipo da operação for TYPE_HOTEL_DIR, a
atualização é simplesmente executada com os parâmetros informados. Se
um id for passado na Uri, apenas o hotel com esse id será atualizado. Em
ambos os casos, é retornada a quantidade de linhas atualizadas;

• delete(Uri, String, String[]) – nesse método é feito algo bem similar ao método
anterior, mas para excluir um ou vários hotéis dependendo da Uri
informada;

• query(Uri, String[], String, String[], String) – nesse método, diferentemente do foi
feito no SQLiteRepository, em que foi usado o rawQuery(String, String[]), aqui é
utilizada a classe SQLiteQueryBuilder, na qual é possível montar a consulta
dinamicamente de uma forma mais elegante. Primeiro, é informado o
nome da tabela usando o método setTables(String); em seguida, é verificado
se é uma busca apenas pelo ID ou geral. No caso de busca pelo ID, essa
condição é adicionada na cláusula where com o método appendWhere(String).
Em ambos os casos é utilizado o método query(SQLiteDataBase, String[], String,
String[], String, String, String), que recebe como parâmetro o objeto SQLiteDatabase,
as colunas da tabela que serão retornadas, a cláusula where, os argumentos
da cláusula where, o agrupamento (group by do SQL), condição do group by
(having do SQL) e a ordenação (order by do SQL). Ao final, o objeto Cursor
obtido na consulta é retornado.

A parte mais interessante desses métodos é que nos três primeiros é gerada
uma notificação para informar que a operação foi efetuada usando o método
notifyChange(uri, null) do objeto ContentResolver obtido por meio da propriedade
contentResolver. Isso serve para notificar todos os cursores que estejam



apontando para uma dada Uri. Já ao realizar a busca, o objeto Cursor é
registrado para que ele receba as notificações sobre mudanças realizadas nos
dados do provider usando o método setNotificationUri(ContentResolver, Uri).

Agora finalmente o provider será usado. Para minimizar o impacto na
interface gráfica, todo o acesso ao provider ficará na classe ProviderRepository,
que deve ficar desta forma:
import android.content.ContentValues
import android.content.Context
import android.database.Cursor
import android.net.Uri
import dominando.android.hotel.model.Hotel
import dominando.android.hotel.repository.HotelRepository
 
class ProviderRepository(val ctx: Context) : HotelRepository {
 
    override fun save(hotel: Hotel) {
        val uri = ctx.contentResolver.insert(
                HotelProvider.CONTENT_URI,
                getValues(hotel))
        val id = uri?.lastPathSegment?.toLong() ?: -1
        if (id != -1L) {
            hotel.id = id
        }
    }
    private fun getValues(hotel: Hotel): ContentValues {
        val cv = ContentValues()
        if (hotel.id > 0) {
            cv.put(COLUMN_ID, hotel.id)
        }
        cv.put(COLUMN_NAME, hotel.name)
        cv.put(COLUMN_ADDRESS, hotel.address)
        cv.put(COLUMN_RATING, hotel.rating)
        return cv
    }
    override fun remove(vararg hotels: Hotel) {
        hotels.forEach { hotel ->
            val uri = Uri.withAppendedPath(
                    HotelProvider.CONTENT_URI, hotel.id.toString())
            ctx.contentResolver.delete(uri, null, null)
        }
    }
    override fun hotelById(id: Long, callback: (Hotel?) -> Unit) {
        val cursor = ctx.contentResolver.query(



                Uri.withAppendedPath(HotelProvider.CONTENT_URI, id.toString()),
                null, null, null, null)
        var hotel: Hotel? = null
        if (cursor?.moveToNext() == true) {
            hotel = hotelFromCursor(cursor)
        }
        cursor?.close()
        callback(hotel)
    }
    override fun search(term: String, callback: (List<Hotel>) -> Unit) {
        var where: String? = null
        var whereArgs: Array<String>? = null
        if (term.isNotEmpty()) {
            where = "$COLUMN_NAME LIKE ?"
            whereArgs = arrayOf("%$term%")
        }
        val cursor = ctx.contentResolver.query(
                HotelProvider.CONTENT_URI,
                null,
                where,
                whereArgs,
                COLUMN_NAME)
        val hotels = mutableListOf<Hotel>()
        while (cursor?.moveToNext() == true) {
            hotels.add(hotelFromCursor(cursor))
        }
        cursor?.close()
        callback(hotels)
    }
    private fun hotelFromCursor(cursor: Cursor): Hotel {
        val id = cursor.getLong(
                cursor.getColumnIndex(COLUMN_ID))
        val name = cursor.getString(
                cursor.getColumnIndex(COLUMN_NAME))
        val address = cursor.getString(
                cursor.getColumnIndex(COLUMN_ADDRESS))
        val rating = cursor.getFloat(
                cursor.getColumnIndex(COLUMN_RATING))
        return Hotel(id, name, address, rating)
    }
}

Foi substituído o acesso direto ao banco de dados pelo uso do provider.
Para acessá-lo, deve-se usar a propriedade contentResolver da classe Context e
passar a Uri com o endereço do provider que foi definido na constante



CONTENT_URI. Perceba que nos métodos remove(Hotel) e hotelById(Long) foi criada
a Uri com o id do hotel no final usando withAppendedPath(Uri, String). Isso fará com
que o provider reconheça essa requisição como do tipo TYPE_HOTEL_ITEM e
colocará automaticamente a condição para buscar ou excluir o hotel correto
baseado no id.

Para utilizar o novo repositório, altere o módulo do arquivo
AndroidModule.kt:
package dominando.android.hotel.di
// imports...
val androidModule = module {
    single { this }
    single {
        // Em vez de SQLiteRepository(ctx = get()) as HotelRepository
        ProviderRepository(ctx = get()) as HotelRepository
    }
    ...
}

Execute a aplicação, cadastre alguns hotéis e a aplicação deve continuar
funcionando da mesma forma.

Autobackup dos dados
Imagine que o usuário inseriu diversas informações localmente no
dispositivo. Então ele compra um novo aparelho, instala o seu aplicativo e os
dados não estão lá! Resolver esse problema é a motivação do recurso de auto
backup introduzido no Android Marshmallow. Com ele, os dados do
aplicativo são salvos automaticamente (até o limite de 25 MB). Esse backup é
feito a cada 24 horas quando o dispositivo estiver carregando a bateria,
conectado a uma rede Wi-Fi e o usuário não estiver utilizando.

Para habilitar o backup automático, basta adicionar a propriedade
android:allowBackup à tag application do AndroidManifest.xml:
<manifest … >
    <application
        android:allowBackup="true" ...>

Entretanto, nem sempre faz sentido realizar o backup de todos os arquivos
do aplicativo. Nesse caso, é possível incluir ou excluir arquivos do processo
de backup definindo um arquivo na pasta res/xml e o referenciando no
AndroidManifest.xml:



<manifest … >
    <application
        android:allowBackup="true"
        android:fullBackupContent="@xml/config_backup" ...>

No arquivo res/xml/config_backup.xml é possível definir os arquivos a
serem ignorados no backup por meio da tag <exclude>, como mostrado a
seguir:
<full-backup-content>
    <exclude domain="files" path="arquivo.txt "/>
</full-backup-content>

Com essa declaração, estaríamos fazendo o backup de todos os arquivos da
aplicação, exceto do arquivo arquivo.txt.

É possível definir o comportamento inverso utilizando a tag <include>:
<full-backup-content>
    <include domain="database" path="dbHotel "/>
</full-backup-content>

Nesse caso, seria feito apenas o backup do arquivo dbHotel.
Perceba que está sendo usada a propriedade domain, que pode ser: file para

arquivos na memória interna; database para bancos de dados SQLite; sharefpref
para SharedPreferences; external para arquivos na memória externa; e root para o
diretório-raiz da aplicação.

Lembrando que esse recurso está disponível apenas a partir do Android
Marshmallow (API Level 23). Para versões anteriores, você deve utilizar o
Android Backup Service (que não abordaremos aqui).

Terminamos mais um capítulo adicionando informações importantíssimas à
nossa caixa de ferramentas. A persistência de dados é presença garantida na
grande maioria das aplicações Android, e dominar esse recurso é importante
em diversos cenários.

1 Esse caminho pode variar de acordo com o fabricante e a versão do Android.
2 O termo “rootear” significa ter acesso ao usuário root, ou seja, ser o administrador do aparelho. Por

padrão, os fabricantes não dão esse privilégio ao usuário. Porém, existem ferramentas que permitem
habilitar o usuário root no aparelho, dando acesso total ao sistema.

3 Caso você tenha renomeado a aplicação e esteja vendo a aplicação Fragments em vez da atual
SQLite, abra o arquivo app.iml do projeto e substitua qualquer referência ao diretório antigo.



CAPÍTULO 11
Android Architecture Components

O exemplo desenvolvido no capítulo anterior está totalmente funcional, e
permite inserir, alterar, excluir e buscar informações no banco de dados.
Como foi possível perceber, foi necessário escrever uma boa quantidade de
código referente à criação do banco de dados (com o SQLiteOpenHelper),
mapeamento de objetos para dados e vice-versa (Hotel para ContentValues e de
Cursor para List<Hotel>), e para poder sincronizar os dados com a interface
gráfica algumas interfaces tiveram que ser definidas (OnHotelSavedListener e
OnHotelDeletedListener).

Nesse cenário, aparecem os Architecture Components, um conjunto de
APIs existentes no Jetpack que fornece uma padronização na arquitetura de
aplicativos Android, tornando-os mais robustos, organizados e menos
propensos a erros. Neste capítulo será feita uma breve introdução a esses
componentes e como eles podem nos ajudar a estruturar melhor nossos
aplicativos.

Lifecycle
O ciclo de vida de uma activity foi explicado no Capítulo 3 juntamente com
os métodos que são chamados pelo sistema operacional de acordo com cada
mudança de estado. Entretanto, se outra classe precisar ser notificada de
quando esses eventos aconteçam, a activity terá que chamar os métodos dessa
classe. Com a API de Lifecycle uma classe pode observar os eventos do ciclo
de vida de uma activity. Desta forma, ela poderá tratar esses eventos
internamente e a activity não precisará invocá-la diretamente.

A API de Lifecycle possui três componentes principais: Lifecycle,
LifecycleOwner e LifecycleObserver. O Lifecycle é o ciclo de vida propriamente dito.
Uma classe que implemente a interface LifecycleOwner deve possuir um Lifecycle,
e as classes AppCompatActivity e Fragment implementam esta interface. O



LifecycleObserver, como o próprio nome indica, ficará observando os eventos do
ciclo de vida e será notificado sobre as mudanças de estado que o interessar.
Veja o exemplo a seguir:
class MainActivity : AppCompatActivity() {
    val meuListener = MeuListener()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(meuListener)
    }
}
class MeuListener : LifecycleObserver {
    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    fun iniciar(){ /* faça alguma coisa no onStart */ }
 
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    fun parar() { /* faça alguma coisa no onStop */ }
}

A classe MeuListener implementa a interface LifecycleObserver que não exige que
seja implementado nenhum método. Entretanto, perceba que ela possui dois
métodos anotados com @OnLifecycleEvent, um para o evento de ON_START e o
outro para o evento ON_STOP. Isso quer dizer que esses métodos serão
invocados quando o onStart() e o onStop() da activity ou fragment que essa classe
estiver observando forem disparados. Neste exemplo, a MainActivity é uma
AppCompatActivity (que indiretamente implementa a interface LifecycleOwner e
possui um Lifecycle) onde no método onCreate(Bundle), por meio da propriedade
lifecycle, está sendo registrado o MeuListener como observador do ciclo de vida.

Para utilizar essa biblioteca, basta adicionar a dependência no build.gradle:
dependencies {
    implementation "androidx.lifecycle:lifecycle-common:2.0.0"
}

ViewModel
A classe ViewModel foi projetada para manter os dados da UI durante mudança
de configurações. Como foi explicado desde o Capítulo 3, quando a tela do
aparelho é girada, a activity atual é destruída e seus dados são perdidos. Por
essa razão, deve-se sempre salvar o estado da activity ou fragment.

Um uso muito interessante do ViewModel que será visto no próximo capítulo
é o caso de haver algum processamento assíncrono, onde uma tarefa é



iniciada em paralelo, e antes que essa tarefa seja concluída, o aparelho é
rotacionado. Se mantivermos no ViewModel o objeto responsável por essa
tarefa, não teremos problemas.

Além disso, a classe ViewModel permite tirar um pouco das responsabilidades
da tela evitando que elas fiquem enormes e difíceis de manter. Também é
possível compartilhar um ViewModel entre activities e fragments.

Vejamos um exemplo simples de um ViewModel:
class MeuViewModel : ViewModel() {
    // Armazene qualquer coisa aqui...
    var valor = 1
}
class MainActivity : AppCompatActivity() {
    val viewModel : MeuViewModel by lazy {
        ViewModelProviders.of(this).get(MeuViewModel::class.java)
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        Log.d("NGVL", "valor ${viewModel.valor++}")
    }
}

A classe MeuViewModel herda de ViewModel e deve armazenar o estado da sua
tela. Aqui é armazenada apenas uma variável chamada valor. A MainActivity
obtém a instância do MeuViewModel por meio da classe ViewModelProviders, e de
posse desse objeto podemos obter as informações necessárias para remontar a
tela. Nesse exemplo, cada vez que a tela for girada, a variável valor é
incrementada.

Se o ViewModel precisar receber parâmetros no construtor, é necessário criar
uma subclasse de ViewModelProvider.Factory como no exemplo a seguir:
class MeuViewModel(val repo: Repositorio) : ViewModel() {
    // Armazene qualquer coisa aqui...
}
class MeuViewModelFactory(
        private val repositorio: Repositorio
) : ViewModelProvider.Factory {
    override fun <T : ViewModel?> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(MeuViewModel::class.java)) {
            return MeuViewModel(repositorio) as T
        }
        throw IllegalArgumentException("View Model inválido")



    }
}

A biblioteca necessita que essa classe seja criada para poder reconstruir o
ViewModel após uma mudança de configuração. É preciso implementar o
método create(Class) que retornará uma instância do MeuViewModel. Entretanto,
isso só é feito se a classe passada como parâmetro for compatível, e essa
checagem é realizada utilizando a função isAssignableFrom(Class). Para obter a
instância do MeuViewModel na activity é necessário passar a instância de
MeuViewModelFactory:
class MinhaActivity : AppCompatActivity() {
    val meuViewModel: MeuViewModel by lazy {
        ViewModelProviders.of(this, MeuViewModelFactory(MeuRepositorio()))
                .get(MeuViewModel::class.java)
    }
    ...
}

Para utilizar a biblioteca, são necessários os seguintes ajustes no
build.gradle:
apply plugin: 'kotlin-kapt'
...
dependencies {
    implementation 'androidx.lifecycle:lifecycle-extensions:2.0.0' // ViewModelProviders
    implementation 'androidx.lifecycle:lifecycle-viewmodel:2.0.0' // ViewModel
    kapt 'androidx.lifecycle:lifecycle-compiler:2.0.0'
}

Além dos plugins do Android, Kotlin e Kotlin Extensions, é preciso aplicar
o plugin do kapt.

É importante deixar claro que, ao salvar o estado da activity, mesmo que ela
seja destruída pelo sistema operacional, o estado é persistido e posteriormente
recuperado quando a activity for recriada. Entretanto, isso não acontece com
o ViewModel. Se o sistema destruir a aplicação quando ela estiver em
background, o viewmodel também será desalocado.

LiveData
O LiveData permite armazenar dados observáveis e notificar os observadores
quando esses dados forem modificados. Um LiveData normalmente está
associado a um Lifecycle, e, dessa forma, ele só notificará os observadores
quando a activity ou fragment estiverem no estado de started (após o onStart())



ou resumed (após o onResume()) e com isso estarão sincronizados com os seus
ciclos de vida. O LiveData também pode não estar associado a um Lifecycle, e,
nesse caso, ele estará sempre ativo notificando os observadores.

Observe o exemplo a seguir:
class MeuViewModel : ViewModel() {
    private val valor = MutableLiveData<Int>()
 
    fun getValor(): LiveData<Int> = valor
    fun atualizarValor(v: Int) {
        valor.value = v
    }
}
 
class MainActivity : AppCompatActivity() {
    val viewModel : MeuViewModel by lazy {
        ViewModelProviders.of(this).get(MeuViewModel::class.java)
    }
    var x = 0
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        viewModel.getValor().observe(this, Observer { valor ->
            if (valor != null) {
                Log.d("NGVL", "valor $valor")
            }
        })
        button.setOnClickListener { viewModel.atualizarValor(++x) }
    }
}

A classe MeuViewModel possui um atributo do tipo MutableLiveData<Int>. Isso
indica que o atributo valor pode ser modificado. Logo em seguida definimos
um método que retorna um LiveData<Int> (que não permite mudança) de modo
que seu valor não seja alterado externamente ao ViewModel. Por meio do
LiveData, quem se registrar para observar mudanças nesse objeto receberá uma
notificação quando isso acontecer.

No método onCreate(Bundle) da MainActivity é registrado um
androidx.lifecycle.Observer para das mudanças do atributo valor do ViewModel por
meio do método observe(LifecycleOwner, Observer). No primeiro parâmetro é
passado this (já que a activitiy é um LifecycleOwner) e, no segundo, o objeto
Observer que será chamado quando a mudança ocorrer. É nesse método que a



interface gráfica deve ser atualizada com os novos dados vindos do view
model.

No evento de clique do botão (mas poderia ser em qualquer outro ou lugar)
o atributo valor é atualizado por meio da função atualizarValor(Int). Quando o
atributo valor é modificado, o Observer que foi registrado é chamado
automaticamente.

Para utilizar o Live Data é preciso apenas adicionar a seguinte dependência
no build.gradle:
dependencies {
    implementation "androidx.lifecycle:lifecycle-livedata:2.0.0"
}

Com esse recurso, a UI ficará ciente de modificações em valores dentro do
view model e poderá reagir apropriadamente a esses eventos.

Room
O Room é um ORM (Object Relational Mapper) que provê uma camada de
abstração sobre o SQLite e que simplifica o uso do banco de dados bem
como o mapeamento entre os objetos. Os principais componentes do Room
são:

• Entity – uma entidade é uma classe que armazena informações de uma
linha da tabela do banco de dados e deve ser anotada com @Entity;

• DAO – é uma interface anotada com @Dao responsável por definir os
métodos que realizarão as operações de inserir, alterar, excluir e obter
dados do banco de dados;

• Database – é responsável por criar o banco de dados, manter a lista de
entidades que serão persistidas, fornecer os DAOs e manter a versão do
banco de dados. Ela deve possuir a anotação @Database.

Como visto anteriormente, o LiveData mantém os dados de uma classe
observáveis. Trabalhando em conjunto com o Room, pode-se observar um
objeto (ou uma lista de objetos) retornado a partir de uma consulta ao banco
de dados, e caso algum registro tenha sido inserido, alterado ou excluído a
lista será atualizada automaticamente.

Refatorando o projeto de hotéis para Architecture



Components
O projeto de hotéis sofrerá uma refatoração para utilizar os AAC (Android
Architecture Components). Faça uma cópia do projeto Provider criado no
capítulo anterior, renomeie para ArchComponents, apague o arquivo Provider.iml
e os diretórios build e app/build e, em seguida, abra o projeto no Android
Studio.

Application Name ArchComponents
Package Name dominando.android.hotel
Activity Name HotelActivity

Aproveitando que será iniciado esse refactoring no projeto, faremos uma
melhoria na declaração de dependências do projeto. Uma vez que já existe
uma boa quantidade de bibliotecas adicionadas ao projeto, é uma prática
comum colocar suas respectivas versões em constantes, pois isso facilita a
manutenção ao precisar atualizar a versão de uma biblioteca.

Abra o arquivo build.gradle do projeto e faça as seguintes mudanças:
buildscript {
    ext {
        appcompat_version = '1.0.2'
        constraintlayout_version = '1.1.3'
        espresso_version = '3.1.1'
        gradle_version = '3.3.1'
        junit_version = '4.2'
        koin_version = '1.0.0'
        kotlin_version = '1.3.20'
        lifecycle_version = '2.0.0'
        materialdesign_version = '1.0.0'
        room_version = '2.0.0'
        testrunner_version = '1.1.0'
    }
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath "com.android.tools.build:gradle:$gradle_version"
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}
// Restante do arquivo não mudou...



Foram declaradas no bloco ext as versões de todas as bibliotecas utilizadas
até agora. Essas constantes serão visíveis para os demais scripts de build do
projeto (que no nosso caso é apenas o do módulo app).

Ajuste agora as dependências no build.gradle do módulo para utilizar as
constantes que foram declaradas:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'
 
android { ... }
 
dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
    implementation "androidx.appcompat:appcompat:$appcompat_version"
    implementation "androidx.constraintlayout:constraintlayout:$constraintlayout_version"
    implementation "com.google.android.material:material:$materialdesign_version"
    implementation "org.koin:koin-android:$koin_version"
    implementation "org.koin:koin-androidx-scope:$koin_version"
    implementation "org.koin:koin-androidx-viewmodel:$koin_version"
 
    implementation "androidx.lifecycle:lifecycle-extensions:$lifecycle_version"
    kapt "androidx.lifecycle:lifecycle-compiler:$lifecycle_version"
    implementation "androidx.room:room-runtime:$room_version"
    kapt "androidx.room:room-compiler:$room_version"
 
    testImplementation "junit:junit:$junit_version"
    androidTestImplementation "androidx.test.ext:junit:$testrunner_version"
    androidTestImplementation "androidx.test.espresso:espresso-core:$espresso_version"
}

Pronto! Agora todas as dependências do projeto estão utilizando as
respectivas constantes. Em destaque estão as dependências dos AAC que
ainda não tinham sido adicionadas. Também foi adicionada a dependência do
Koin para trabalhar com View Models que será vista mais adiante.

Por serem parte integrante do Jetpack, as dependências do Lifecycle, Live
Data e View Model estão no pacote androidx.lifecycle e a do Room no pacote
androidx.room. Perceba que foi utilizado o kapt mais uma vez, pois algumas
classes são geradas em tempo de compilação como as do Room que fazem o
acesso ao banco de dados. Por isso, lembre-se de aplicar o plugin no início do
build.gradle.



Room
O Room será utilizado no repositório do aplicativo, e a primeira etapa para
utilizá-lo é definir as entidades que serão persistidas no banco de dados. No
aplicativo de hotéis, haverá apenas a classe Hotel, que deve passar pelas
seguintes mudanças:
import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey
import dominando.android.hotel.repository.sqlite.COLUMN_ID
import dominando.android.hotel.repository.sqlite.TABLE_HOTEL
 
@Entity(tableName = TABLE_HOTEL)
data class Hotel(
        @PrimaryKey(autoGenerate = true)
        @ColumnInfo(name = COLUMN_ID)
        var id: Long = 0,
        var name: String = "",
        var address: String = "",
        var rating: Float = 0.0F
)

A classe recebeu a anotação @Entity que indica que os objetos dessa classe
serão persistidos. Por padrão, o nome da tabela terá o mesmo da classe, mas
pode-se utilizar o atributo tableName para definir um nome diferente. O atributo
id é chave primária, então foi adicionada a anotação @PrimaryKey, e como ele
deve ser gerado automaticamente, a propriedade autoGenerate foi definida para
true. Por padrão, o nome dos campos da tabela serão os mesmos nomes dos
atributos da classe, caso queira alterar isso, utilize a anotação @ColumnInfo.
Como o nome do atributo é “id” e o nome da coluna é “_id” essa anotação foi
utilizada.

Para organizar melhor o projeto, crie um pacote chamado repository.room, no
qual ficarão localizadas as classes de persistência relativas ao Room. Em
seguida, adicione a interface HotelDao, que permitirá realizar as operações no
banco de dados:
import androidx.lifecycle.LiveData
import androidx.room.*
import dominando.android.hotel.model.Hotel
import dominando.android.hotel.repository.sqlite.*
 
@Dao



interface HotelDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insert(hotel: Hotel): Long
    @Update
    fun update(hotel: Hotel): Int
    @Delete
    fun delete(vararg hotels: Hotel): Int
    @Query("SELECT * FROM $TABLE_HOTEL WHERE $COLUMN_ID = :id")
    fun hotelById(id: Long): LiveData<Hotel>
    @Query("""SELECT * FROM $TABLE_HOTEL
            WHERE $COLUMN_NAME LIKE :query ORDER BY $COLUMN_NAME""")
    fun search(query: String): LiveData<List<Hotel>>
}

A interface está anotada com @Dao e os métodos de inserir, atualizar, excluir
e listar estão anotados respectivamente com @Insert, @Update, @Delete e @Query.
O método insert(Hotel) possui em sua anotação a propriedade onConflict definida
como REPLACE, indicando que caso haja um conflito no momento da inserção
o registro será substituído. Perceba que esse método retorna um Long, que é o
id do registro que acabou de ser inserido. No método delete(Hotel...) foi utilizado
um vararg para indicar que é possível excluir vários registros de uma única
vez.

Porém, a parte mais interessante são os métodos hotelById(Long) e search(String),
em que o parâmetro é passado automaticamente para a instrução SQL que
será executada. Perceba também que eles retornam um LiveData que permitirá
com que a atualização da UI seja feita automaticamente.

O último passo para utilizar o Room é definir uma classe que herde de
RoomDatabase como a classe HotelDatabase apresentada a seguir:
import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import dominando.android.hotel.model.Hotel
import dominando.android.hotel.repository.sqlite.*
 
@Database(entities = [Hotel::class], version = DATABASE_VERSION)
abstract class HotelDatabase : RoomDatabase() {
 
    abstract fun hotelDao(): HotelDao
 
    companion object {



        private var instance: HotelDatabase? = null
 
        fun getDatabase(context: Context): HotelDatabase {
            if (instance == null) {
                instance = Room.databaseBuilder(
                        context.applicationContext,
                        HotelDatabase::class.java,
                        DATABASE_NAME)
                        .allowMainThreadQueries()
                        .build()
            }
            return instance as HotelDatabase
        }
        fun destroyInstance() {
            instance = null
        }
    }
}

Na anotação @Database é necessário informar: a lista de entidades que serão
persistidas por meio da propriedade entities; e a versão do banco, na
propriedade version. Perceba que essa é uma classe abstrata, pois assim como a
interface DAO, a implementação será gerada em tempo de compilação.

O método getDatabase(Context) serve para centralizar a criação de instâncias do
banco. Nele o banco é inicializado por meio do método Room.databaseBuilder
onde são passados: o contexto; a referência à classe HotelDatabase; e o nome do
banco. Note que foi utilizado o método allowMainThreadQueries(), o que não é
recomendado, pois as operações com o banco de dados devem ser realizadas
em uma thread separada, mas isto não está sendo feito aqui para simplificar o
exemplo. Threads e processamentos assíncronos serão abordados no próximo
capítulo.

Essa classe também deve prover um método para cada DAO que a
aplicação necessitar. Neste exemplo, existe apenas o HotelDao que é retornado
no método hotelDao().

Agora faça as seguintes mudanças na interface HotelRepository:
import androidx.lifecycle.LiveData
import dominando.android.hotel.model.Hotel
 
interface HotelRepository {
    fun save(hotel: Hotel)
    fun remove(vararg hotels: Hotel)



    fun hotelById(id: Long): LiveData<Hotel>
    fun search(term: String): LiveData<List<Hotel>>
}

A interface de HotelRepository agora utiliza LiveData ao invés dos callbacks que
foram usados anteriormente. Essa mudança, além de facilitar bastante o
trabalho como será visto mais adiante, deixará nosso aplicativo mais robusto
e confiável.

Após essa mudança, o projeto começará a apresentar erros, mas não se
preocupe, pois eles serão corrigidos um por um até o final do capítulo.

Primeiramente será implementada a nova interface HotelRepository que utiliza
LiveData. Crie a classe RoomRepository no pacote repository.room e deixe-a como a
seguir:
import androidx.lifecycle.LiveData
import dominando.android.hotel.model.Hotel
import dominando.android.hotel.repository.HotelRepository
 
class RoomRepository(
        database: HotelDatabase
) : HotelRepository {
    private val hotelDao = database.hotelDao()
 
    override fun save(hotel: Hotel) {
        if (hotel.id == 0L) {
            val id = hotelDao.insert(hotel)
            hotel.id = id
        } else {
            hotelDao.update(hotel)
        }
    }
    override fun remove(vararg hotels: Hotel) {
        hotelDao.delete(*hotels)
    }
    override fun hotelById(id: Long): LiveData<Hotel> {
        return hotelDao.hotelById(id)
    }
    override fun search(term: String): LiveData<List<Hotel>> {
        return hotelDao.search(term)
    }
}

Como se pode observar, essa classe é bem direta. Ela basicamente delega o
trabalho para os respectivos métodos na interface HotelDao, exceto pelo método



save(Hotel), que faz a checagem para inserir ou alterar o hotel. Então por que ela
foi criada? É uma boa prática do desenvolvimento de software não depender
de implementações concretas (como o DAO). Em vez disso deve-se depender
de uma interface, pois isso facilita futuras mudanças e os testes que serão
abordados no Capítulo 31.

View Models
O aplicativo de hotéis seguirá o padrão MVVM (Model View View-Model) e
terá um ViewModel para as telas de listagem, detalhes e cadastro de hotéis e que
vão substituir os presenters. Inicie essa migração pela tela de detalhes que é a
mais simples. Adicione a classe HotelDetailsViewModel ao pacote details e deixe-a
da seguinte forma:
import androidx.lifecycle.LiveData
import androidx.lifecycle.ViewModel
import dominando.android.hotel.model.Hotel
import dominando.android.hotel.repository.HotelRepository
 
class HotelDetailsViewModel(
        private val repository: HotelRepository
) : ViewModel() {
    fun loadHotelDetails(id: Long): LiveData<Hotel> {
        return repository.hotelById(id)
    }
}

Essa classe herda de ViewModel e possui como atributo o HotelRepository que
será usado para fazer a busca do hotel pelo id retornar um LiveData<Hotel>.
Desta forma, a tela de detalhes receberá a notificação de quando o hotel for
alterado.

Agora faça as seguintes mudanças na classe HotelDetailsFragment:
import androidx.lifecycle.Observer
    import org.koin.androidx.viewmodel.ext.android.viewModel
class HotelDetailsFragment : Fragment { // Não implementa HotelDetailsView
    // Substitua o atributo presenter pelo viewModel
    private val viewModel: HotelDetailsViewModel by viewModel()
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val id = arguments?.getLong(EXTRA_HOTEL_ID, -1) ?: -1
        viewModel.loadHotelDetails(id).observe(viewLifecycleOwner, Observer { hotel ->



            if (hotel != null) {
                showHotelDetails(hotel)
            } else {
                activity?.supportFragmentManager
                        ?.beginTransaction()
                        ?.remove(this)
                        ?.commit()
                errorHotelNotFound()
            }
        })
    }
    private fun showHotelDetails(hotel: Hotel) { ... }
    private fun errorHotelNotFound() { ... }
    ...
}

A classe não implementa mais a interface HotelDetailsView, por isso os
métodos showHotelDetails(Hotel) e errorHotelNotFound() não são mais override. Apague
a instância do presenter e substitua pelo viewModel. No onViewCreated() o método
loadHotelDetails(id) está sendo registrado um Observer para que a UI seja atualizada
quando os dados do hotel forem modificados. Essa parte é bem interessante,
pois quando o registro for excluído, esse Observer será chamado com o objeto
null e, nesse caso, o fragment deve ser removido da tela. Isso será
particularmente útil na versão para tablets.

Como as atualizações do hotel serão recebidas automaticamente via LiveData,
a HotelDetailsActivity não precisa mais ouvir o evento de quando um hotel é
salvo:
class HotelDetailsActivity : AppCompatActivity() { // não implementa mais OnHotelSavedListener
    // Remova o método onHotelSaved(hotel: Hotel)
}

Faça agora as modificações referentes à tela de cadastro de hotéis,
começando pela implementação da classe HotelFormViewModel no pacote form
que deve ficar como a seguir:
import androidx.lifecycle.LiveData
import androidx.lifecycle.ViewModel
import dominando.android.hotel.model.Hotel
import dominando.android.hotel.repository.HotelRepository
 
class HotelFormViewModel(
        private val repository: HotelRepository
) : ViewModel() {



    private val validator by lazy { HotelValidator() }
 
    fun loadHotel(id: Long): LiveData<Hotel> {
        return repository.hotelById(id)
    }
    fun saveHotel(hotel: Hotel): Boolean {
        return validator.validate(hotel)
                .also { validated ->
                    if (validated) repository.save(hotel)
                }
    }
}

Essa classe é bem similar à tela de detalhes. Além do método loadHotel(Long)
idêntico ao do view model anterior, ela possui o saveHotel(Hotel) para salvar o
hotel passado como parâmetro. Perceba que foi utilizada a classe HotelValidator
para verificar se o Hotel é válido antes de incluí-lo.

A próxima etapa será realizar as modificações na classe HotelFormFragment:
import org.koin.androidx.viewmodel.ext.android.viewModel
import androidx.lifecycle.Observer
 
class HotelFormFragment : DialogFragment() { // Não implementa mais HotelFormView
    // Substitua o presenter pelo viewModel
    private val viewModel: HotelFormViewModel by viewModel()
    private var hotel: Hotel? = null
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val hotelId = arguments?.getLong(EXTRA_HOTEL_ID, 0) ?: -1
        // Ao invés do presenter.loadHotel(...)
        if (hotelId > 0) {
            viewModel.loadHotel(hotelId).observe(viewLifecycleOwner, Observer { hotel ->
                this.hotel = hotel
                showHotel(hotel)
            })
        }
        // Restante do método não mudou
    }
    private fun showHotel(hotel: Hotel) { ... }
    private fun errorSaveHotel() { ... }
    private fun errorInvalidHotel() { ... }
    private fun handleKeyboardEvent(actionId: Int): Boolean {
        if (EditorInfo.IME_ACTION_DONE == actionId) {
            saveHotel()



            return true
        }
        return false
    }
    private fun saveHotel() {
        val hotel = this.hotel ?: Hotel()
        val hotelId = arguments?.getLong(EXTRA_HOTEL_ID, 0) ?: 0
        hotel.id = hotelId
        hotel.name = edtName.text.toString()
        hotel.address = edtAddress.text.toString()
        hotel.rating = rtbRating.rating
        try {
            if (viewModel.saveHotel(hotel)) {
                dialog.dismiss()
            } else {
                errorInvalidHotel()
            }
        } catch (e: Exception) {
            errorSaveHotel()
        }
    }
    // Remover a interface OnHotelSavedListener
    // Demais métodos não mudaram...
}

A classe não implementa mais a interface HotelFormView, consequentemente
os métodos showHotel(Hotel) e errorSaveHotel() e errorInvalidHotel() deixam de ser
override. O presenter foi removido e substituído pelo viewModel. Como as
atualizações na UI serão feitas automaticamente, não é mais preciso invocar a
interface OnHotelSavedListener no método handleKeyboardEvent(int), então a interface
também pode ser removida. O método saveHotel() usa o viewModel para salvar os
dados e deixa de retornar o hotel salvo.

Entretanto, sem sombra de dúvida o maior impacto foi na tela de listagem.
Observe como ficou a implementação do view model dessa tela, mas
primeiro adicione a classe SingleLiveEvent listada a seguir no pacote common e
deixe-a como a seguir:
import androidx.annotation.MainThread
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Observer
import java.util.concurrent.atomic.AtomicBoolean
 
class SingleLiveEvent<T> : MutableLiveData<T>() {



 
    private val pending = AtomicBoolean(false)
 
    @MainThread
    override fun observe(owner: LifecycleOwner, observer: Observer<in T>) {
        super.observe(owner, Observer { t ->
            if (pending.compareAndSet(true, false)) {
                observer.onChanged(t)
            }
        })
    }
    @MainThread
    override fun setValue(t: T?) {
        pending.set(true)
        super.setValue(t)
    }
    @MainThread
    fun call() {
        value = null
    }
}

Essa classe será utilizada pela tela de listagem para disparar eventos. Ela
será útil porque as classes LiveData e MutableLiveData disparam o evento assim
que o Observer se registra, e essa classe só dispara o evento nas mudanças
subsequentes ao registro no objeto.

Essa classe foi copiada do projeto de exemplo do Google e convertida para
Kotlin. O código original encontra-se aqui
(https://github.com/googlesamples/android-architecture/).

Crie a classe HotelListViewModel e deixe-a como a seguir:
import androidx.lifecycle.LiveData
import androidx.lifecycle.*
import dominando.android.hotel.common.SingleLiveEvent
import dominando.android.hotel.model.Hotel
import dominando.android.hotel.repository.HotelRepository
 
class HotelListViewModel(
        private val repository: HotelRepository
) : ViewModel() {
    var hotelIdSelected: Long = -1
    private val searchTerm = MutableLiveData<String>()
    private val hotels = Transformations.switchMap(searchTerm) { term ->
        repository.search("%$term%")



    }
    private val inDeleteMode = MutableLiveData<Boolean>().apply {
        value = false
    }
    private val selectedItems = mutableListOf<Hotel>()
    private val selectionCount = MutableLiveData<Int>()
    private val selectedHotels = MutableLiveData<List<Hotel>>().apply {
        value = selectedItems
    }
    private val deletedItems = mutableListOf<Hotel>()
    private val showDeletedMessage = SingleLiveEvent<Int>()
    private val showDetailsCommand = SingleLiveEvent<Hotel>()
    fun isInDeleteMode(): LiveData<Boolean> = inDeleteMode
 
    fun getSearchTerm(): LiveData<String>? = searchTerm
 
    fun getHotels(): LiveData<List<Hotel>>? = hotels
 
    fun selectionCount(): LiveData<Int> = selectionCount
 
    fun selectedHotels(): LiveData<List<Hotel>> = selectedHotels
 
    fun showDeletedMessage(): LiveData<Int> = showDeletedMessage
 
    fun showDetailsCommand(): LiveData<Hotel> = showDetailsCommand
 
    fun selectHotel(hotel: Hotel) {
        if (inDeleteMode.value == true) {
            toggleHotelSelected(hotel)
            if (selectedItems.size == 0) {
                inDeleteMode.value = false
            } else {
                selectionCount.value = selectedItems.size
                selectedHotels.value = selectedItems
            }
        } else {
            showDetailsCommand.value = hotel
        }
    }
    private fun toggleHotelSelected(hotel: Hotel) {
        val existing = selectedItems.find { it.id == hotel.id }
        if (existing == null) {
            selectedItems.add(hotel)
        } else {
            selectedItems.removeAll { it.id == hotel.id }



        }
    }
    fun search(term: String = "") {
        searchTerm.value = term
    }
    fun setInDeleteMode(deleteMode: Boolean) {
        if (!deleteMode) {
            selectionCount.value = 0
            selectedItems.clear()
            selectedHotels.value = selectedItems
            showDeletedMessage.value = selectedItems.size
        }
        inDeleteMode.value = deleteMode
    }
 
    fun deleteSelected() {
        repository.remove(*selectedItems.toTypedArray())
        deletedItems.clear()
        deletedItems.addAll(selectedItems)
        setInDeleteMode(false)
        showDeletedMessage.value = deletedItems.size
    }
    fun undoDelete() {
        if (deletedItems.isNotEmpty()) {
            for (hotel in deletedItems) {
                hotel.id = 0L
                repository.save(hotel)
            }
        }
    }
}

A abordagem do MVVM (Model View View-Model) é diferente do MVP
(Model View Presenter). No MVVM, diferentemente do presenter, o view-
model não se comunica com a view. Ao invés disso, o view-model expõe
dados observáveis que a view registra para observar e reagir às mudanças
desses dados. Neste exemplo, o mecanismo utilizado para expor os dados
observáveis é o Live Data. O view-model expõe objetos do tipo LiveData e a
view reagirá às mudanças utilizando os novos valores desses atributos.

Perceba que a classe HotelListView possui uma série de atributos privados do
tipo MutableLiveData (ou SingleLiveEvent que é subclasse de MutableLiveData) e
métodos públicos que retornam esses atributos como LiveData. A razão de
fazer isso é simples: encapsulamento. Não é recomendado que um atributo



seja modificado diretamente fora da classe, então internamente é usado um
MutableLiveData (que pode ser modificado) e externamente é exposto para a
view um LiveData (que não pode ser alterado). Assim como os outros view-
models mostrados aqui, ele herda de ViewModel e possui uma referência para o
HotelRepository.

As propriedades lastSearchTerm e hotelIdSelected substituirão os atributos de
mesmo nome da HotelActivity (como será mostrado logo a seguir). O atributo
hotels é um LiveData que expõe o resultado da última busca realizada. Perceba
que foi utilizado o método switchMap(LiveData) da classe Transformations para que
quando o termo a ser pesquisado (searchTerm) for modificado no método
search(String), uma nova busca seja realizada e a lista de hotéis será atualizada.
O atributo inDeleteMode indica se a tela encontra-se no modo de exclusão, já as
propriedades selectionCount e selectedHotels representam, respectivamente, a
quantidade e quais hotéis foram selecionados para exclusão. As duas outras
propriedades são utilizadas para eventos: showDeleteMessage exibirá o SnackBar
informando quantos itens foram excluídos, enquanto showDetailsCommand
mostrará os detalhes do Hotel quando um item for selecionado.

As funções dessa classe são bem similares ao que existe no presenter, a
diferença é que agora os atributos são modificados internamente em vez de
interagir com a view. No método selectHotel(Hotel) é verificado se a tela
encontra-se em modo de exclusão, em caso positivo, a lista e a quantidade de
itens selecionados é atualizada, caso contrário, o atributo showDetailsCommand é
modificado indicando que os detalhes do hotel devem ser exibidos.

No método search(String), quando o atributo searchTerm é atualizado,
automaticamente o switchMap é invocado para realizar a busca e atualizar a
listagem de hotéis.

O método deleteSelected() exclui os registros, e armazena os itens excluídos na
lista deletedItems para que seja possível desfazer a exclusão, caso seja
necessário. Por fim, o método undoDelete() desfaz a exclusão dos registros.

Faça os seguintes ajustes na classe HotelListFragment para utilizar o view-
model:
import androidx.lifecycle.Observer
import org.koin.androidx.viewmodel.ext.android.sharedViewModel
// Demais imports...
 
class HotelListFragment : ListFragment(),



        AdapterView.OnItemLongClickListener,
        ActionMode.Callback { // Não implementa mais HotelListView
    // Substituir o presenter pelo viewModel
    private val viewModel: HotelListViewModel by sharedViewModel()
 
    // Os outros atributos não mudaram
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        listView.onItemLongClickListener = this
        viewModel.showDetailsCommand().observe(viewLifecycleOwner, Observer { hotel ->
            if (hotel != null) {
                showHotelDetails(hotel)
            }
        })
        viewModel.isInDeleteMode().observe(viewLifecycleOwner, Observer { deleteMode ->
            if (deleteMode == true) {
                showDeleteMode()
            } else {
                hideDeleteMode()
            }
        })
        viewModel.selectedHotels().observe(viewLifecycleOwner, Observer { hotels ->
            if (hotels != null) {
                showSelectedHotels(hotels)
            }
        })
        viewModel.selectionCount().observe(viewLifecycleOwner, Observer { count ->
            if (count != null) {
                updateSelectionCountText(count)
            }
        })
        viewModel.showDeletedMessage().observe(viewLifecycleOwner, Observer { count ->
            if (count != null && count > 0) {
                showMessageHotelsDeleted(count)
            }
        })
        viewModel.getHotels()?.observe(viewLifecycleOwner, Observer { hotels ->
            if (hotels != null) {
                showHotels(hotels)
            }
        })
        if (viewModel.getHotels()?.value == null) {
            search()
        }
    }



    private fun showHotels(hotels: List<Hotel>) { ... }
    private fun showHotelDetails(hotel: Hotel) { ... }
    private fun showDeleteMode() { ... }
    fun hideDeleteMode() { ... } // é publico
    private fun updateSelectionCountText(count: Int) { ... }
    private fun showSelectedHotels(hotels: List<Hotel>) { ... }
 
    override fun onListItemClick(l: ListView?, v: View?, position: Int, id: Long) {
        super.onListItemClick(l, v, position, id)
        val hotel = l?.getItemAtPosition(position) as Hotel
        viewModel.selectHotel(hotel)
    }
 
    fun search(text: String = "") {
        viewModel.search(text)
    }
   // O método clearSearch foi removido
 
    override fun onItemLongClick(parent: AdapterView<*>?, view: View?,
                                 position: Int, id: Long): Boolean {
        val consumed = (actionMode == null)
        if (consumed) {
            val hotel = parent?.getItemAtPosition(position) as Hotel
            viewModel.setInDeleteMode(true)
            viewModel.selectHotel(hotel)
        }
        return consumed
    }
    override fun onActionItemClicked(mode: ActionMode?, item: MenuItem?): Boolean {
        if (item?.itemId == R.id.action_delete) {
            viewModel.deleteSelected()
            return true
        }
        return false
    }
    // Os métodos onCreateActionMode e onPrepareActionMode não mudaram
    override fun onDestroyActionMode(mode: ActionMode?) {
        actionMode = null
        viewModel.setInDeleteMode(false)
    }
    private fun showMessageHotelsDeleted(count: Int) {
        Snackbar.make(listView,
                getString(R.string.message_hotels_deleted, count),
                Snackbar.LENGTH_LONG)
                .setAction(R.string.undo) {



                    viewModel.undoDelete()
                }
                .show()
    }
    // Remover a interface OnHotelDeletedListener
    // A interface OnHotelClickListener não mudou
}

A classe não implementa mais a interface HotelListView como foi feito nos
demais fragments e mais uma vez o presenter foi substituído pelo viewModel.

No método onActivityCreated() foi onde ocorreram as maiores mudanças, pois é
o local onde foram registrados um Observer para cada atributo disponibilizado
pelo view-model, e cada Observer chama o método apropriado para atualizar a
interface gráfica. Os demais métodos sofreram poucas mudanças,
basicamente as relativas à substituição do presenter pelo view-model e o
override dos métodos da interface HotelListView.

Porém, um detalhe importantíssimo dessa classe é como a instância do
viewModel está sendo obtida. Foi utilizado o método sharedViewModel() do Koin,
pois o HotelListViewModel será compartilhado com a HotelActivity. Como o
HotelListFragment está contido na HotelActivity eles podem compartilhar o mesmo
viewModel, isso ajudará a manter o sincronismo dos dados com a interface
gráfica.

Sendo assim, faça as mudanças necessárias na classe HotelActivity:
import org.koin.androidx.viewmodel.ext.android.viewModel
class HotelActivity : AppCompatActivity(),
        HotelListFragment.OnHotelClickListener,
        HotelListFragment.OnHotelDeletedListener,
        SearchView.OnQueryTextListener,
        MenuItem.OnActionExpandListener
        // Não implementa mais HotelSavedListener nem OnHotelDeletedListener
{
    private val viewModel: HotelListViewModel by viewModel()
    // Os atributos hotelIdSelected e lastSearchTerm foram removidos, pois estão no viewmodel
    ...
    // Os métodos onSaveInstance e onRestoreInstanceState foram removidos
    // Os métodos onActivityResult, onHotelsDeleted e onHotelSaved foram removidos
    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        // O restante o método não mudou... apenas as linhas a seguir
        if (viewModel.getSearchTerm()?.value?.isNotEmpty() == true) {
            Handler().post {
                val query = viewModel.getSearchTerm()?.value
                ...



            }
        }
        return true
    }
    override fun onHotelClick(hotel: Hotel) {
        if (isTablet()) {
            viewModel.hotelIdSelected = hotel.id
            showDetailsFragment(hotel.id)
        } else {
            showDetailsActivity(hotel.id)
        }
    }
    override fun onQueryTextChange(newText: String?): Boolean {
        listFragment.search(newText ?: "")
        return true
    }
    override fun onMenuItemActionCollapse(item: MenuItem?): Boolean {
        // lastSearchTerm = "" // << remover
        listFragment.search()
        return true
    }
   ...
    // O companion object pode ser removido
}

A classe não implementa mais as interfaces OnHotelSavedListener e
OnHotelDeletedListener, pois as atualizações são feitas automaticamente pelo
LiveData. Consequentemente, os métodos onHotelSaved(Hotel) e onHotelDeleted foram
removidos. Outra mudança foi a remoção do método onActivityResult(int,int,Intent)
que era utilizado apenas para atualizar a listagem de hotéis em caso de
alteração na tela de detalhes, e como isso também é feito pelo LiveData esse
método não é mais necessário. Os métodos para salvar e recuperar o estado
da activity foram removidos. Ou seja, o trabalho da activity ficou muito mais
simples.

O último ajuste que precisa ser feito é na injeção de dependência para
realizar a criação dos view-models e do novo repositório. Abra o arquivo
AndroidModule.kt e deixe-o como a seguir:
package dominando.android.hotel.di
import dominando.android.hotel.details.HotelDetailsViewModel
import dominando.android.hotel.form.HotelFormViewModel
import dominando.android.hotel.list.HotelListViewModel
import dominando.android.hotel.repository.HotelRepository



import dominando.android.hotel.repository.room.HotelDatabase
import dominando.android.hotel.repository.room.RoomRepository
import org.koin.androidx.viewmodel.ext.koin.viewModel
import org.koin.dsl.module.module
 
val androidModule = module {
    single { this }
    single {
        RoomRepository(HotelDatabase.getDatabase(context = get()))as HotelRepository
    }
    viewModel {
        HotelListViewModel(repository = get())
    }
    viewModel {
        HotelDetailsViewModel(repository = get())
    }
    viewModel {
        HotelFormViewModel(repository = get())
    }
}

Está sendo retornada uma instância de RoomRepository em vez do
ProviderRepository. Como você deve ter notado, a criação dos presenters foi
removida e foram colocados os view-models em seu lugar. Foi utilizada a
função viewModel do Koin para instanciar os view-models, mas foi mencionado
na seção sobre view-model que era necessário uma classe que herdasse de
ViewModelProvider.Factory para passar parâmetros para um view-model. Isso não
foi necessário, pois o Kotlin realiza esse trabalho automaticamente.

Para finalizar este grande refactoring de MVP para MVVM, remova a
declaração do content provider do AndroidManifest.xml (tag <provider>) e
exclua as seguintes classes do projeto, pois elas não serão mais necessárias:

• os presenters: HotelDetailsPresenter, HotelFormPresenter e HotelListPresenter;
• as views: HotelDetailsView, HotelFormView e HotelListView;
• os repositórios: MemoryRepository, SQLiteRepository e ProviderRepository;
• demais classes: HotelSqlHelper e HotelProvider.
Finalmente! A mudança foi concluída e agora é possível testar o aplicativo

novamente. Desinstale a versão anterior do aplicativo de hotéis do aparelho e
execute o projeto novamente a partir do Android Studio. Tudo deve estar
funcionando como anteriormente, mas agora a estrutura do projeto deve estar
similar ao da Figura 11.1.



Figura 11.1 – Estrutura do projeto de hotéis em MVVM.
Você pode estar se perguntando por que foi implementada a versão do

aplicativo em MVP, já que foram removidas todas as classes referentes a esse
padrão. A principal razão foi demonstrar ambas as práticas para que você
conheça as duas técnicas, pois ambas são amplamente utilizadas. Outro
motivo é que nada impede que você utilize uma mescla desses dois padrões.
Por exemplo, o padrão MVP pode ser utilizado e os dados serem persistidos
no Room e a atualização automática da UI seja feita com Live Data.

Faça um comparativo entre os dois projetos e você perceberá que o código
ficou muito mais simples com o MVVM graças à ajuda das bibliotecas do
AAC. Entretanto, essas atualizações automáticas podem deixar o processo de
debug da aplicação mais complexo devido ao fato de os eventos poderem



acontecer a qualquer momento de forma assíncrona e não ordenada. Porém,
sem sombra de dúvida essa técnica é bastante útil para garantir aplicações
tenham uma interface gráfica em perfeito sincronismo com os dados.

Esse foi um capítulo longo com a adaptação do exemplo para o uso dos
Architecture Components e do padrão MVVM, e esse conhecimento será
bastante útil para os próximos capítulos.



CAPÍTULO 12
Acesso à web – Parte I

A internet é um lugar fantástico, onde as informações estão à nossa
disposição para serem consumidas quando e onde for necessário. E dar a
possibilidade ao usuário de acessar informação em seu dispositivo móvel
torna as coisas ainda mais interessantes. Neste capítulo veremos os conceitos
básicos de como fazer as aplicações se comunicarem com servidores web,
recebendo informações baseadas no protocolo HTTP. Veremos como acessar
web services REST e ler arquivos no formato JSON.

Conectando à rede
Antes de estabelecer conexão com a internet, é preciso adicionar duas
permissões no AndroidManifest.xml, como listado a seguir:
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>

A primeira é a principal e deve ser adicionada sempre que a aplicação
precisar acessar a internet, já a segunda é necessária quando é preciso checar
se há conexão disponível, conforme listado no código a seguir:
val cm = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    val nets = cm.allNetworks
    nets.forEach {
        val info = cm.getNetworkInfo(it)
        val connected = if (info.isConnected) "conectada" else "desconectada"
        Log.d("NGVL", "${info.extraInfo} $connected")
    }
} else {
    val nets = cm.allNetworkInfo
    nets.forEach {
        val connected = if (it.isConnected) "conectada" else "desconectada"
        Log.d("NGVL", "${it.typeName} $connected") } }

O ConnectivityManager é um serviço do sistema que provê informações sobre as



conexões do aparelho. Cada conexão é representada por um objeto da classe
NetworkInfo obtido por meio da propriedade allNetworks para Android
Marshmallow (API Level 23) ou superior, ou allNetworkInfo para versões
anteriores. Com esse objeto é possível checar se existe conectividade usando
a propriedade isConnected. Dessa forma, é possível, por exemplo, sugerir ao
usuário que, caso o arquivo a ser baixado seja grande demais, ele faça o
download usando uma rede Wi-Fi.

Para simplesmente saber se há algum tipo de conexão ativa, pode-se usar
activeNetworkInfo conforme a seguir:
val cm = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
val info = cm.activeNetworkInfo
if (info != null && info.isConnected) {
    // Conectado
} else {
    // Sem conexão
}

Uma vez obtida a informação sobre a conectividade do aparelho, deve-se
proceder o estabelecimento da conexão. O Android contém duas APIs para
essa tarefa: HTTPClient da Apache e HttpURLConnection do próprio Java. O Google
recomenda utilizar a segunda opção para aplicações voltadas para Android
2.3 ou versão superior. Falaremos dela mais adiante neste capítulo.

Cada um na sua thread
Ao executarmos qualquer aplicação Android, ela contém um processo com
uma linha de execução principal conhecida como main thread ou UI thread.
Nela são tratadas todas as interações do usuário com os componentes de
interface gráfica. Por isso, todo o código executado nessa thread não deve
demorar a responder, pois, se isso acontecer, a aplicação aparentará não estar
respondendo, ou, na linguagem mais popular, “travada”. Quando isso
acontece, o sistema operacional exibe a mensagem Application not
responding, que dá ao usuário a possibilidade de fechar a aplicação ou
aguardar até que ela termine a tarefa. A Figura 12.1 mostra a mensagem de
ANR sendo exibida no aparelho.

Até o Android 2.3 era possível (apesar de não recomendado) estabelecer
uma conexão com um servidor na UI thread; entretanto, ao tentar fazer isso
em uma versão posterior, a exceção NetworkOnMainThreadException será disparada.



Para resolver esse problema, é possível utilizar a classe java.lang.Thread do
próprio Java para realizar a comunicação, no entanto existe outra restrição
que deve ficar clara: não é possível atualizar componentes de UI em outra
thread. Entretanto, normalmente se faz o download de informações da
internet justamente para exibi-las na tela… E agora, o que fazer?

Figura 12.1 – Mensagem de “Application not responding” (ANR).

Tarefas assíncronas
Como mencionado na seção anterior, as operações de rede devem ser feitas
em uma thread separada. Porém, essa outra thread não pode atualizar a
interface gráfica, ou seja, ela não deve alterar o conteúdo de qualquer
componente visual. Para contornar esse problema, existe a classe AsyncTask,
que permite implementar o código que será executado antes, durante e depois
da execução da tarefa que será realizada assincronamente. Observe o código a
seguir:
class MinhaTask : AsyncTask<String, Unit, List<String>>() {
    override fun onPreExecute() {
        super.onPreExecute()
    }
    override fun doInBackground(vararg params: String?): List<String> {
        return emptyList()
    }
 
    override fun onPostExecute(result: List<String>?) {
        super.onPostExecute(result)
    }
}

A classe MinhaTask herda de AsyncTask e deve obrigatoriamente implementar o
método doInBackground(<T>...), que será executado em paralelo, ou seja, em uma
thread separada. É nesse método que se deve estabelecer a conexão com o
servidor e realizar a transferência de dados.



Perceba que na declaração da classe são usados três valores genéricos: String,
Unit e List<String>. O primeiro e o terceiro tipo definem, respectivamente, o tipo
do parâmetro de entrada e o retorno do método doInBackground(). O segundo tipo
da definição da classe deve ser utilizado para implementar um indicativo de
progresso (que poderia ser Int, por exemplo) da tarefa que está sendo realizada
em background, e nesse caso teríamos chamar o método publishProgress() dentro
do doInBackground() para fornecer o progresso (25% por exemplo) e
implementar o método onProgressUpdate() para exibir essa informação na
interface gráfica.

O método onPreExecute() é chamado antes da execução em background ser
realizada, e nele pode-se atualizar a interface gráfica, ou seja, é um bom
momento para exibir um indicador de progresso informando que os dados
estão sendo obtidos do servidor. Já o onPostExecute() é executado após a
execução em background, e aqui pode-se (ou deve-se) atualizar a interface
gráfica com os dados obtidos. Note que o tipo do parâmetro desse método é o
mesmo do retorno do método doInBackground().

Caso a AsyncTask esteja em execução, é possível cancelá-la chamando o
método cancel(boolean), passando true se você desejar interromper a thread, ou
false caso contrário. Ao chamar o método cancel(boolean), o método onCanceled()
será chamado em vez do onPostExecute().

Para executar uma AsyncTask é necessário chamar o método execute().

Estabelecendo a conexão
Para realizar a comunicação com o servidor, pode-se utilizar a classe
HttpURLConnection do pacote java.net, e após estabelecer a conexão; devem-se
utilizar os objetos InputStream para ler e OutputStream para escrever qualquer tipo
de dado no servidor, conforme a necessidade. Analise o código a seguir:
private fun downloadString(enderecoWeb: String): List<String>? {
    val SEGUNDOS = 1000
    try {
        val url = URL(enderecoWeb)
        val conexao = url.openConnection() as HttpURLConnection
        conexao.readTimeout = 10 * SEGUNDOS
        conexao.connectTimeout = 15 * SEGUNDOS
        conexao.requestMethod = "GET"
        conexao.doInput = true
        conexao.doOutput = false



        conexao.connect()
        val resposta = conexao.responseCode
        if (resposta == HttpURLConnection.HTTP_OK) {
            val input = conexao.inputStream
            val strings = ArrayList<String>()
            val reader = BufferedReader(InputStreamReader(input))
            var s: String? = null
            while (true) {
                s = reader.readLine()
                if (s == null) break
                else strings.add(s)
            }
            return strings
        }
    } catch (e: Exception) {
        e.printStackTrace()
    }
    return null
}

O método downloadStrings(String) recebe como parâmetro um endereço da web
para um arquivo *.txt com múltiplas linhas, então o arquivo é lido e uma lista
de strings é retornada, onde cada item da lista será uma linha do arquivo.

Um objeto URL do pacote java.net foi criado com o endereço passado como
parâmetro, e com esse objeto a conexão é obtida por meio do método
openConnection(). Em seguida, são configurados alguns parâmetros da conexão
como os timeouts de leitura e de conexão nas propriedades readTimeout e
connectionTimeout. Assim, caso o servidor demore a responder, uma exceção será
lançada. Logo depois, é definido que será realizada uma requisição do
utilizando o método GET1 do protocolo HTTP ao utilizar a propriedade
requestMethod, e nas linhas seguintes, com doInput e doOutput é indicado que será
feita apenas fazer leitura nessa conexão, ou seja, não será enviado nenhum
parâmetro no corpo da requisição, como é feito ao usar o método POST. E,
finalmente, a conexão é estabelecida com o servidor usando o método
connect().

O protocolo HTTP define códigos para a resposta de uma requisição. Por
exemplo, quando uma requisição for bem-sucedida, será retornado o código
200; caso o endereço não exista, o servidor devolverá 404, ou, ainda, se
ocorrer algum erro no servidor, o valor 500 será obtido. Sabendo disso, antes
de ler o conteúdo da resposta do servidor, é checado se o código de resposta é



igual a 200 para saber se a requisição foi bem-sucedida. Isso está sendo feito
por meio da instrução responseCode == HTTP_OK.

Se tudo der certo, a resposta do servidor começa a ser lida usando um
InputStream que foi obtido do objeto HttpUrlConnection. É importante ressaltar que,
para qualquer conteúdo que for lido, tudo será muito similar ao que foi feito
aqui, o que vai mudar é em que os bytes lidos serão transformados: XML,
JSON, imagens, arquivos de texto etc. Nas próximas seções será visto como
ler outros tipos de conteúdo.

JSON
JSON (JavaScript Object Notation) é um formato para troca de dados, leve e
de fácil leitura e escrita. Ele é formatado em texto plano e tem apenas três
elementos básicos: objetos, propriedades e arrays. Os objetos são delimitados
por chaves “{ }”, as propriedades são conjuntos de chave/valor separados por
“:” e os arrays são listas delimitadas por colchetes “[ ]”. Um exemplo de
arquivo JSON pode ser visto a seguir:
{
  "produtos": [
    {
      "codigo": 1,
      "descricao": "Arroz",
      "preco": 2.50
    },
    {
      "codigo": 2,
      "descricao": "Feijão",
      "preco": 4.50
    }
  ]
}

Esse arquivo possui um objeto cuja propriedade produtos armazena um array
de objetos. Cada objeto dessa lista tem três propriedades: codigo, descricao e
preco.

Para ler o conteúdo de um arquivo JSON, utilizam-se as classes JSONObject,
nas quais é possível obter o valor de cada propriedade definida no objeto, e a
lista de objetos é representada pela classe JSONArray. A Tabela 12.1 exibe os
principais métodos da classe JSONObject.



Tabela 12.1 – Principais métodos da classe JSONObject
Método Descrição

getBoolean(String) Retorna um valor boolean associado a uma propriedade.
getDouble(String) Retorna um valor double associado a uma propriedade.
getInt(String) Retorna um valor int associado a uma propriedade.
getJSONArray(String) Retorna um JSONArray associado a uma propriedade.
getJSONObject(String) Retorna um JSONObject associado a uma propriedade.
getLong(String) Retorna um valor long associado a uma propriedade.

Ao chamar qualquer um dos métodos listados na tabela anterior, caso a
propriedade não exista, uma exceção é levantada. Nesses casos, pode-se usar
o método isNull(String) para checar se a propriedade existe ou usar os mesmos
métodos descritos anteriormente, mas que começam com “opt”. Por exemplo,
para obter o valor de uma propriedade opcional do tipo string, pode-se usar o
método optString(String), se for int, optInt(String), e assim por diante.

Lendo um JSON assincronamente via HTTP
Para pôr em prática todos os conceitos vistos nas seções anteriores criaremos
um aplicativo que consumirá um arquivo JSON com alguns dos livros da
Novatec Editora. Crie um novo projeto com os dados a seguir e mãos à obra!

Application Name HTTP
Package Name dominando.android.http
Activity Name MainActivity

O arquivo que será lido está disponível no endereço
https://raw.githubusercontent.com/nglauber/dominando_android3/master/livros_novatec.json
e tem o seguinte formato:
{
  "novatec": [
    {
      "categoria": "Banco de dados",
      "livros": [
        {
          "titulo": "NoSQL Essencial",
          "autor": "Pramod J. Sadalage / Martin Fowler",
          "ano": 2013,
          "paginas": 216,
          "capa": "https://s3.novatec.com.br/capas/9788575223383.jpg"
        },



        {
          "titulo": "Fundamentos de Bancos de Dados com C#",
          "autor": "Michael Schmalz",
          "ano": 2012,
          "paginas": 120,
          "capa": "https://s3.novatec.com.br/capas/9788575223154.jpg"
        }
      ]
    },
   ...
  ]
}

Como é possível observar, o JSON tem uma leitura muito fácil e pode ser
entendido simplesmente como: a Novatec publica livros de várias categorias,
e cada um deles tem um título, um autor (ou mais de um), ano de publicação,
quantidade de páginas e um link para a imagem de capa. É possível
materializar esse conceito no projeto criando a classe Book e deixando-a desta
forma:
data class Book (
        var title: String = "",
        var category: String = "",
        var author: String = "",
        var year: Int = 0,
        var pages: Int = 0,
        var coverUrl: String = ""
) {
    override fun toString() = title
}

A classe Book é bem simples, e não possui nada que já não tenha sido visto.
Para poder acessar a web e checar se há conexão disponível, adicione as

permissões ao AndroidManifest.xml:
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>

Em seguida, crie a classe BookHttp que será uma classe utilitária responsável
por estabelecer a conexão com o servidor, fazer o download do JSON e
retornar uma lista de objetos Book.
import android.content.Context
import android.net.ConnectivityManager
import org.json.JSONException
import org.json.JSONObject
import java.io.ByteArrayOutputStream



import java.io.IOException
import java.io.InputStream
import java.net.HttpURLConnection
import java.net.URL
import java.nio.charset.Charset
 
object BookHttp {
    val BOOK_JSON_URL = "https://raw.githubusercontent.com/nglauber/" +
            "dominando_android3/master/livros_novatec.json"
 
    @Throws(IOException::class)
    private fun connect(urlAddress: String): HttpURLConnection {
        val second = 1000
        val url = URL(urlAddress)
        val connection = (url.openConnection() as HttpURLConnection).apply {
            readTimeout = 10 * second
            connectTimeout = 15 * second
            requestMethod = "GET"
            doInput = true
            doOutput = false
        }
        connection.connect()
        return connection
    }
    fun hasConnection(ctx: Context): Boolean {
        val cm = ctx.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val info = cm.activeNetworkInfo
        return info != null && info.isConnected
    }
 
    fun loadBooks(): List<Book>? {
        try {
            val connection = connect(BOOK_JSON_URL)
            val responseCode = connection.responseCode
            if (responseCode == HttpURLConnection.HTTP_OK) {
                val inputStream = connection.inputStream
                val json = JSONObject(streamToString(inputStream))
                return readBooksFromJson(json)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return null
    }
    @Throws(JSONException::class)



    fun readBooksFromJson(json: JSONObject): List<Book> {
        val booksList = mutableListOf<Book>()
        var currentCategory: String
        val jsonNovatec = json.getJSONArray("novatec")
        for (i in 0 until jsonNovatec.length()) {
            val jsonCategory = jsonNovatec.getJSONObject(i)
            currentCategory = jsonCategory.getString("categoria")
            val jsonBooks = jsonCategory.getJSONArray("livros")
            for (j in 0 until jsonBooks.length()) {
                val jsonBook = jsonBooks.getJSONObject(j)
                val book = Book(
                        jsonBook.getString("titulo"),
                        currentCategory,
                        jsonBook.getString("autor"),
                        jsonBook.getInt("ano"),
                        jsonBook.getInt("paginas"),
                        jsonBook.getString("capa")
                )
                booksList.add(book)
            }
        }
        return booksList
    }
    @Throws(IOException::class)
    private fun streamToString(inputStream: InputStream): String {
        val buffer = ByteArray(1024)
        // O bigBuffer vai armazenar todos os bytes lidos
        val bigBuffer = ByteArrayOutputStream()
        // Precisamos saber quantos bytes foram lidos
        var bytesRead: Int
        // Vamos lendo de 1KB por vez...
        while (true) {
            bytesRead = inputStream.read(buffer)
            if (bytesRead == -1) break
            // Copiando a quantidade de bytes lidos do buffer para o bigBuffer
            bigBuffer.write(buffer, 0, bytesRead)
        }
        return String(bigBuffer.toByteArray(), Charset.forName("UTF-8"))
    }
}

Os dois primeiros métodos dessa classe utilizam os conceitos explicados
nas seções anteriores. No método connect(String), a conexão com o servidor é
estabelecida e o objeto HttpUrlConnection é retornado. Para checar se há conexão
com a internet, foi utilizado o método hasConnection(Context).



No método loadBooks(), é feita a tentativa de conectar ao servidor; se a
requisição for bem-sucedida (responseCode igual a HttpURLConnection.HTTP_OK), o
objeto InputStream é obtido para ler os bytes do arquivo JSON que será
representado por um objeto da classe JSONObject. A classe JSONObject contém
alguns construtores, e um deles recebe uma String. Para criar uma String a partir
de um InputStream, foi criado o método streamToString(InputStream) que está todo
comentado, mas que em resumo lê os bytes vindos da conexão e os converte
em uma String.

Voltando ao método loadBooks(), ao obter o JSONObject, o método
readBooksFromJson (JSONObject) é invocado para que seja feita a leitura do arquivo
JSON e instanciados os objetos Book para serem retornados. Nesse método é
criado um ArrayList que conterá a lista de livros que serão retornados ao final.
Em seguida, por meio da chamada json.getJSONArray("novatec"), é obtido o
JSONArray que conterá todas as categorias de livros disponíveis. Perceba que
“novatec” é uma propriedade do objeto-raiz do documento JSON.

De posse desse objeto, um laço for foi utilizado para percorrer todas as
categorias. Cada categoria é um JSONObject com as propriedades “categoria” e
“livros”, sendo que a primeira é uma string simples contendo o nome da
categoria, enquanto a segunda é um JSONArray com os livros daquela
categoria, e para obtê-los foi feita a chamada getJSONArray("livros").

Em seguida, a categoria atual é armazenada numa variável temporária
chamada currentCategory, pois a informação da categoria deve ser informada
para cada objeto Book. O objeto jsonBooks é um JSONArray com a lista dos livros
de cada categoria, então com ele é feito um outro for para obter cada livro da
categoria atual.

Cada livro do array jsonBooks é obtido usando o método getJSONObject(int) e
armazenado na variável jsonBook, e com ela é lida cada propriedade do livro.
Por fim, uma instância da classe Book é criada e adicionada à booksList.

Implemente agora o fragment que listará os livros. Crie o arquivo de layout
res/layout/fragment_books_list.xml e deixe-o assim:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ListView
        android:id="@+id/listView"



        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"/>
    <ProgressBar
        android:id="@+id/progressBar"
        style="?android:attr/progressBarStyle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <TextView
        android:id="@+id/txtMessage"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/progressBar" />
</androidx.constraintlayout.widget.ConstraintLayout>

Adicione no res/values/strings.xml as strings que serão usadas a seguir:
<string name="error_no_connection">Sem conexão</string>
<string name="error_load_books">Falha ao obter lista de livros</string>
<string name="message_progress">Baixando informações dos livros…</string>

Adicione a classe BooksListFragment e deixe-a desta forma:
import android.os.AsyncTask
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import androidx.fragment.app.Fragment
import kotlinx.android.synthetic.main.fragment_books_list.*
 
class BooksListFragment : Fragment() {
    private var asyncTask: BooksDownloadTask? = null
    private val booksList = mutableListOf<Book>()
    private var adapter: ArrayAdapter<Book>? = null
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)



        retainInstance = true
    }
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_books_list, container, false)
    }
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        adapter = ArrayAdapter(requireContext(), android.R.layout.simple_list_item_1, booksList)
        listView.emptyView = txtMessage
        listView.adapter = adapter
        if (booksList.isNotEmpty()) {
            showProgress(false)
        } else {
            if (asyncTask == null) {
                if (BookHttp.hasConnection(requireContext())) {
                    startDownloadJson()
                } else {
                    progressBar.visibility = View.GONE
                    txtMessage.setText(R.string.error_no_connection)
                }
            } else if (asyncTask?.status == AsyncTask.Status.RUNNING) {
                showProgress(true)
            }
        }
    }
    private fun showProgress(show: Boolean) {
        if (show) {
            txtMessage.setText(R.string.message_progress)
        }
        txtMessage.visibility = if (show) View.VISIBLE else View.GONE
        progressBar.visibility = if (show) View.VISIBLE else View.GONE
    }
    private fun startDownloadJson() {
        if (asyncTask?.status != AsyncTask.Status.RUNNING) {
            asyncTask = BooksDownloadTask()
            asyncTask?.execute()
        }
    }
    private fun updateBookList(result: List<Book>?) {
        if (result != null) {
            booksList.clear()
            booksList.addAll(result)
        } else {
            txtMessage.setText(R.string.error_load_books)



        }
        adapter?.notifyDataSetChanged()
        asyncTask = null
    }
 
    inner class BooksDownloadTask : AsyncTask<Void, Void, List<Book>?>() {
        override fun onPreExecute() {
            super.onPreExecute()
            showProgress(true)
        }
        override fun doInBackground(vararg strings: Void): List<Book>? {
            return BookHttp.loadBooks()
        }
        override fun onPostExecute(livros: List<Book>?) {
            super.onPostExecute(livros)
            showProgress(false)
            updateBookList(livros)
        }
    }
}

Como a maioria da lógica ficou em BookHttp, a classe BooksListFragment ficou
bem simples. Ela é uma subclasse de Fragment onde foi definido o atributo
asyncTask que será responsável por realizar a requisição em uma thread
separada e, ao concluir a tarefa, atualiza a interface gráfica. O atributo
booksList armazena os objetos Books que serão retornados após a leitura do
JSON vindo do servidor.

No método onCreate(Bundle), a propriedade retainInstanceState recebeu o valor true
para indicar que a instância desse fragment deve ser retida mesmo quando a
activity for rotacionada. Esse detalhe é importantíssimo, pois ao girar o
aparelho não é desejado que os dados do fragment sejam destruídos e tenham
que ser baixados novamente, desperdiçando bateria e consumindo dados da
rede desnecessariamente.

O arquivo de layout é carregado no onCreateView(LayoutInflater, ViewGroup, Bundle)
e no método onActivityCreated(Bundle) é definida a propriedade emptyView para que
o txtMessage seja exibido se a listView estiver vazia.

No método onActivityCreated(Bundle) está a lógica principal da tela.
Primeiramente é verificado se a lista de livros não está vazia. Nesse caso,
simplesmente é ocultada a view de progresso, pois os dados já foram
carregados. Caso contrário (a lista esteja vazia), é verificado se a asyncTask é



igual a null, nesse caso, o download dos dados não foi iniciado, então se deve
baixar a lista de livros do servidor. Porém, antes, é verificado se há conexão
disponível, se houver, o processo de download deve continuar invocando o
método startDownloadJson(). Caso não haja conexão, o txtMessage é atualizado
informando que não há conexão.

Você pode estar se perguntando “quando asyncTask não será null?”. Apesar de
estar mantendo a instância do fragment, ao girar a tela do aparelho, a activity
que possui esse fragment será recriada e, consequentemente, o método
onActivityCreated(Bundle) será chamado novamente. Se isso acontecer, enquanto o
download estiver sendo realizado, asyncTask já terá sido inicializada e estará
em execução, ou seja, seu status será igual a RUNNING. Nesse cenário, será
chamado apenas o método showProgress(boolean) para exibir uma ProgressView
indicando que o processamento ainda está ocorrendo.

Falando no método showProgress(boolean), ele faz com que uma barra de
progresso seja exibida com uma mensagem. O método startDownloadJson() que
aparece em seguida inicializa a asyncTask e a executa por meio do método
execute().

A classe interna BooksDownloadTask fará com que o download do JSON seja
feito em uma thread separada, mas, antes de isso acontecer, o método
onPreExecute() é chamado para exibir a barra de progresso. No
doInBackground(<T>...) apenas é chamado o método loadBooks() da classe BookHttp.
E, para finalizar, no onPostExecute(<T>), a barra de progresso é ocultada e o
método updateBookList(List<Book>) é chamado.

Se a lista de livros retornada for diferente de null, o atributo bookList é
atualizado com a lista passada por parâmetro. Caso a lista seja nula, uma
mensagem de erro é exibida. Ao final, a asyncTask é removida da memória
atribuindo um valor null.

O último passo é usar esse fragment na MainActivity, então declare-o no
res/layout/activity_main.xml como no código a seguir:
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/container"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <fragment android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:name="dominando.android.http.BooksListFragment"
        android:id="@+id/listFragment"/>



</FrameLayout>
O código da MainActivity é exibido a seguir:

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}

Execute a aplicação e você deverá obter um resultado similar ao da Figura
12.2 enquanto os dados estiverem sendo carregados, e quando a operação
tiver sido concluída a tela da Figura 12.3 é exibida.

Foi apresentado um exemplo funcional que lê um JSON da internet de
forma assíncrona e tratando casos de erro como problemas na leitura do
arquivo e falta de conexão. Entretanto, esse exemplo está listando apenas os
títulos dos livros. Como fazer para exibir também a capa do livro?

Figura 12.2 – Barra de progresso.



Figura 12.3 – Listagem de livros obtida usando AsyncTask.

Dica de biblioteca: Carregando imagens da web
No exemplo anterior foram listados apenas os títulos dos livros usando um
ArrayAdapter. Chegou a hora de deixar a listagem mais atraente com mais
informações sobre o livro, como: o ano de publicação, o nome do autor, a
quantidade de páginas e a imagem de capa.

Ao analisar o JSON, foi lido na seção anterior que é possível notar que o
JSON possui apenas a URL onde se encontra a imagem de capa do livro.
Infelizmente a API padrão do Android não possui um componente que
carregue uma imagem da web passando apenas sua URL. Sendo assim,
desenvolvedores ao redor do mundo implementaram diversas bibliotecas para
resolver essa demanda. As mais populares são:

• Glide – https://github.com/bumptech/glide
• Picasso – http://square.github.io/picasso
• Fresco – http://frescolib.org
Todas possuem diversos recursos relacionados ao carregamento de imagens

como: cache, transformação, animação após o carregamento etc. Neste



exemplo será utilizado o Glide devido à sua popularidade na comunidade de
desenvolvimento e também à facilidade de uso. Para incluí-lo ao projeto,
basta adicionar a seguinte linha na seção dependencies do arquivo
app/build.gradle:
apply plugin: 'kotlin-kapt' // Lembre-se de aplicar o plugin do kapt
...
dependencies {
    ...
    implementation 'com.github.bumptech.glide:glide:4.8.0'
    kapt 'com.github.bumptech.glide:compiler:4.8.0'
}

Inserida a dependência, criaremos um adapter customizado que exibirá
todas as informações do livro. Crie o arquivo de layout
res/layout/item_book.xml e deixe-o desta forma:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">
    <ImageView
        android:id="@+id/imgCover"
        android:layout_width="60dp"
        android:layout_height="80dp"
        android:layout_marginStart="8dp"
        android:layout_marginTop="8dp"
        android:layout_marginBottom="8dp"
        android:scaleType="centerCrop"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <TextView
        android:id="@+id/txtTitle"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginStart="8dp"
        android:layout_marginEnd="8dp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toEndOf="@+id/imgCover"
        app:layout_constraintTop_toTopOf="@+id/imgCover"
        tools:text="Titulo" />
    <TextView



        android:id="@+id/txtAuthors"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginEnd="8dp"
        android:textStyle="italic"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="@+id/txtTitle"
        app:layout_constraintTop_toBottomOf="@+id/txtTitle"
        tools:text="Autores" />
    <TextView
        android:id="@+id/txtYear"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="12sp"
        app:layout_constraintBaseline_toBaselineOf="@+id/txtPages"
        app:layout_constraintEnd_toEndOf="@+id/txtTitle"
        app:layout_constraintHorizontal_bias="1.0"
        app:layout_constraintStart_toEndOf="@+id/txtPages"
        tools:text="Ano" />
    <TextView
        android:id="@+id/txtPages"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="12sp"
        app:layout_constraintStart_toStartOf="@+id/txtAuthors"
        app:layout_constraintTop_toBottomOf="@+id/txtAuthors"
        tools:text="Paginas" />
</androidx.constraintlayout.widget.ConstraintLayout>

Implemente o adapter que fará a exibição dos dados,; para tal, crie a classe
BookListAdapter e a deixe de acordo com a listagem a seguir:
import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ImageView
import android.widget.TextView
import com.bumptech.glide.Glide
import kotlinx.android.synthetic.main.item_book.view.*
 
class BookListAdapter(context: Context, books: List<Book>)
    : ArrayAdapter<Book>(context, 0, books) {
 
    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {



        val book = getItem(position)
        val holder: ViewHolder
        val view: View
        if (convertView == null) {
            view = LayoutInflater.from(context).inflate(
                    R.layout.item_book, parent, false)
            holder = ViewHolder(view)
            view.tag = holder
        } else {
            view = convertView
            holder = view.tag as ViewHolder
        }
        book?.let {
            Glide.with(context).load(book.coverUrl).into(holder.imgCapa)
            holder.txtTitulo.text = book.title
            holder.txtAutores.text = book.author
            holder.txtAno.text = book.year.toString()
            holder.txtPaginas.text = context.getString(R.string.n_paginas, book.pages)
        }
        return view
    }
    internal class ViewHolder(view: View) {
        var imgCapa: ImageView = view.imgCover
        var txtTitulo: TextView = view.txtTitle
        var txtAutores: TextView = view.txtAuthors
        var txtPaginas: TextView = view.txtPages
        var txtAno: TextView = view.txtYear
    }
}

Apesar de já ter sido explicado como funciona um adapter, vale a pena
revisarmos alguns conceitos aqui. A classe anterior herda de ArrayAdapter e no
método getView(int,View,ViewGroup) é montada cada linha que será exibida pela
ListView. Primeiramente, é obtido o objeto book, em seguida, a constante do
tipo ViewHolder é declarada para armazenar a referência dos componentes
declarados no arquivo de layout, e que serão exibidos na linha da lista.
Depois é checado se convertView é igual a null para saber se é preciso carregar o
arquivo de layout ou se é possível reusar uma view existente. No primeiro
caso, a variável convertView é inicializada com o arquivo de layout que é
carregado usando o método inflate(int, ViewGroup) da classe LayoutInflater. Em
seguida, o objeto holder é inicializado e as referências dos componentes do
arquivo de layout são armazenados nele, pois, como a convertView será



reaproveitada depois, não será necessário chamar o findViewById(int) nas
próximas vezes em que a view for requisitada. Porém, para que possam ser
recuperadas posteriormente, o objeto holder é armazenado no convertView usando
a propriedade tag.

Se convertView for diferente de null, é porque ela já foi inicializada
anteriormente, então agora só é preciso preenchê-la com os novos dados.
Porém, para isso, é preciso obter as referências dos componentes que estão no
ViewHolder que foi armazenado na tag do convertView, então é utilizada a
propriedade tag para obtê-lo.

De posse do holder, cada um dos componentes é preenchido com a
informação do livro. O título e o nome dos autores não têm muito mistério,
mas para preencher o ano de publicação foi usado o método
getString(int,Object...), onde esse int deve ser algum identificador da classe R.string,
ou seja, o id de alguma string definida no res/values/strings.xml:
<string name="n_paginas">%d páginas</string>

Finalmente, para exibir a imagem da capa do livro, foi utilizado o Glide
com a chamada a seguir:
Glide.with(context).load(book.coverUrl).into(holder.imgCover)

No método load(String) a URL da capa do livro foi passada como parâmetro e
em into(ImageView) foi indicada a ImageView onde a imagem será exibida.
Consulte a documentação no site do Glide para ter acesso a mais opções.
Agora substitua a inicialização do adapter pela classe BooksListFragment:
class BooksListFragment : Fragment() {
    ...
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        adapter = BookListAdapter(requireContext(), booksList)
        // Restante do método não mudou
    }
}

Execute a aplicação e teremos um resultado similar ao da Figura 12.4.



Figura 12.4 – Listagem de livros com capas.
O exemplo está completo e nas próximas seções veremos outra alternativa

para acessar recursos na web.

Dica de biblioteca: OkHttp
Foi visto como acessar um servidor web utilizando a classe HttpUrlConnection
que funciona muito bem, seu único inconveniente é no momento de ler a
resposta do servidor, em que é necessário ler byte a byte e transformar esses
bytes em alguma informação. A biblioteca OkHttp
(http://square.github.io/okhttp/) facilita esse trabalho, pois ao ler algum
conteúdo no formato texto (JSON, XML, HTML etc.), é possível obter esse
conteúdo automaticamente convertido para String. Outra vantagem do
OkHttp é que ele faz o cache de requisições repetidas e a compactação das
respostas utilizando GZIP, diminuindo o tempo de download:
val client = OkHttpClient.Builder()
        .readTimeout(5, TimeUnit.SECONDS)
        .connectTimeout(10, TimeUnit.SECONDS)
        .build()
val request = Request.Builder()
    .url("http://seusite.com/arquivo.json")



    .build()
val response = client.newCall(request).execute()
val json = response.body()?.string()

Neste exemplo, o objeto OkHttp é inicializado e, em seguida, são definidos os
timeouts de leitura e conexão com o servidor. Em seguida, é criado um objeto
Request apontando para a URL do servidor e, por meio do método
newCall(Request), a requisição é realizada. O retorno do método execute() é um
objeto Response, no qual se pode obter, por meio do método body() (que é o
corpo da resposta), o conteúdo do JSON.

Por padrão, as requisições são do tipo GET, mas também é possível realizar
requisições do tipo POST, PUT e DELETE:
val httpClient = OkHttpClient()
val mediaTypeJson = MediaType.parse("application/json; charset=utf-8")
val jsonReq = "{'nome':'Glauber', 'email':'nglaubervasc@gmail.com}"
val body = RequestBody.create(mediaTypeJson, jsonReq)
val postRequest = Request.Builder()
        .url("http://seuservidor.com/pessoas")
        .post(body)
        .build()
val postResponse = httpClient.newCall(postRequest).execute()

Neste exemplo um JSON é enviado para o servidor por meio de uma
requisição do tipo POST. É importante ressaltar que esse código deve ser
chamado fora da UI thread, em uma AsyncTask, por exemplo.

Utilizaremos a OkHttp no exemplo deste capítulo, por isso, adicione a
dependência ao build.gradle:
dependencies {
    ...
    implementation "com.squareup.okhttp3:okhttp:3.12.0"
}

Dica de Biblioteca: GSON
Foi visto que com a biblioteca OkHttp a resposta de uma requisição HTTP
pode ser lida mais facilmente. Essa resposta pode ser uma string que
representa um arquivo JSON retornado pelo servidor. Então esse arquivo
teria que ser lido e transformado em objetos Kotlin utilizando as classes
JSONObject e JSONArray, como foi demonstrado anteriormente. Entretanto, a
biblioteca GSON, do próprio Google, simplifica esse trabalho.

Vejamos como essa biblioteca funciona na prática. Adicione a dependência



do GSON ao build.gradle:
dependencies {
    ...
    implementation 'com.google.code.gson:gson:2.8.5'
}

Para que a conversão do arquivo JSON retornado pelo servidor seja feita
automaticamente para objetos Kotlin é necessário ter uma estrutura de classes
idêntica à do JSON. Então seria necessário criar mais duas classes no projeto:
Category e Publisher:
// Category.kt
import com.google.gson.annotations.SerializedName
 
data class Category(
        @SerializedName("categoria")
        var name: String = "",
        @SerializedName("livros")
        var books: List<Book> = emptyList()
)
 
// Publisher.kt
import com.google.gson.annotations.SerializedName
data class Publisher (
        @SerializedName("novatec")
        var categories: List<Category> = emptyList()
)

O JSON de livros possui um objeto com a propriedade “novatec” que é um
array de objetos. Cada objeto desse array é uma categoria, e cada categoria
que possui um nome e uma lista de livros.

Com as classes Publisher, Category e Book temos a mesma estrutura que no
arquivo JSON. Entretanto, no arquivo JSON o atributo chama-se novatec e na
classe Editora o nome do atributo é categories. Para que a leitura seja feita
corretamente, é utilizada a anotação @SerializedName(String), que fará essa
conversão de nomes. O mesmo foi feito para as propriedades name e books da
classe Category, que no arquivo JSON chamam-se, respectivamente,
“categoria” e “livros”.

Temos esse mesmo problema na classe Book, pois os seus atributos não
possuem o mesmo nome dos atributos utilizados no arquivo JSON. Por isso,
faça os seguintes ajustes:
import com.google.gson.annotations.SerializedName



data class Book(
        @SerializedName("titulo")
        var title: String = "",
        var category: String = "",
        @SerializedName("autor")
        var author: String = "",
        @SerializedName("ano")
        var year: Int = 0,
        @SerializedName("paginas")
        var pages: Int = 0,
        @SerializedName("capa")
        var coverUrl: String = ""
)

Utilizando a anotação @SerializedName indicamos para a biblioteca GSON os
nomes corretos dos atributos que devem ser atribuídos aos objetos dessa
classe.

OkHttp + GSON
Para demonstrar o uso das bibliotecas OkHttp e o GSON trabalhando juntas
no arquivo BookHttp, adicione o seguinte método:
import java.util.concurrent.TimeUnit
import okhttp3.Request
...
fun loadBooksGson(): List<Book>? {
    val client = OkHttpClient.Builder()
            .readTimeout(5, TimeUnit.SECONDS)
            .connectTimeout(10, TimeUnit.SECONDS)
            .build()
    val request = Request.Builder()
            .url(BOOK_JSON_URL)
            .build()
    try {
        val response = client.newCall(request).execute()
        val json = response.body()?.string()
        val gson = Gson()
        val publisher = gson.fromJson<Publisher>(json, Publisher::class.java)
        return publisher.categories
                .flatMap { category ->
                    category.books.forEach { book ->
                        book.category = category.name
                    }
                    category.books



                }
    } catch (e: Exception) {
        e.printStackTrace()
    }
    return null
}

A utilização do GSON se resume às duas linhas marcadas em negrito. Todo
o arquivo JSON foi convertido para um objeto Publisher. Lembrando que isso
só foi possível porque as estruturas no JSON e nas classes Kotlin são iguais.

O método flatMap itera sobre uma lista de elementos e cria uma nova lista
contendo todos itens acumulados. Neste exemplo, temos uma lista de
categorias, e via flatMap, é obtida a lista de livros de cada categoria e
convertida para uma grande lista de livros com os livros de todas as
categorias. Perceba que dentro das chaves do flatMap o it é a categoria atual.
Então foi utilizado um forEach para atribuir o nome da categoria de cada livro.
Após o forEach é retornado it.livros para seja acumulada à lista final que será
retornada.

Na classe BooksListFragment, no método doInBackground() da inner class
BooksDownloadTask, altere a chamada para o novo método.
override fun doInBackground(vararg strings: Void): List<Book>? {
    return BookHttp.loadBooksGson()
}

Execute a aplicação e os mesmos resultados obtidos anteriormente devem
ser exibidos.

Você pode estar se perguntando por que mostramos as duas formas de ler
um JSON. Primeiramente porque é importante saber como certas bibliotecas
funcionam. A outra razão é que nem sempre temos um arquivo JSON simples
como o que apresentamos, e pode ser interessante ler o JSON “manualmente”
para evitar classes desnecessárias, que teriam que ser criadas apenas para
satisfazer à necessidade da biblioteca. Esse foi o caso das classes Publisher e
Category, que não são utilizadas em nenhum outro ponto da aplicação.

Lendo arquivos XML
Apesar de o JSON ter se tornado um padrão para envio e leitura de
informações de um servidor web, podem ocorrer situações em que os
arquivos XML são a única opção. Dessa forma, será mostrado como ler uma



versão em XML do arquivo JSON que foi usado nas seções anteriores. Ele
tem o seguinte formato:
<?xml version="1.0" encoding="UTF-8"?>
<novatec>
   <categorias>
      <categoria>
         <categoria>Banco de dados</categoria>
         <livros>
            <livro>
               <ano>2013</ano>
               <autor>Pramod J. Sadalage / Martin Fowler</autor>
               <capa>http://novatec.com.br/figuras/capas/9788575223383.gif</capa>
               <paginas>216</paginas>
               <titulo>NoSQL Essencial</titulo>
            </livro>
            <livro>
               <ano>2012</ano>
               <autor>Michael Schmalz</autor>
               <capa>http://www.novatec.com.br/figuras/capas/9788575223154.gif</capa>
               <paginas>120</paginas>
               <titulo>Fundamentos de Bancos de Dados com C#</titulo>
            </livro>
         </livros>
      </categoria>
      ...

Existe uma infinidade de bibliotecas disponíveis no mercado para leitura de
arquivos XML, mas utilizaremos o XmlPullParser devido à sua simplicidade
e por ser nativo do Android, mas nada impede que você utilize o SAX
(Simple API for XML) ou o DOM (Document Object Model) do Java, que
também estão disponíveis na plataforma.

Com o XmlPullParser, o documento XML é lido sequencialmente um
elemento após outro. Cada elemento encontrado é um evento, e os principais
eventos são:

• START_DOCUMENT e END_DOCUMENT – determinam o começo e o fim do
documento;

• START_TAG e END_TAG – indicam a abertura e o fechamento de determinada
tag;

• TEXT – evento disparado quando um texto é encontrado dentro de uma tag.



Para navegar pelo documento XML, é utilizada a classe XmlPullParser. Com
ela pode-se obter o evento atual, invocando o método getEventType(), e ir para o
próximo evento, ou seja, para o próximo elemento do XML com o método
next(). Depois dessa breve introdução, adicione à classe BookHttp o código a
seguir:
val BOOKS_XML_URL = "https://raw.githubusercontent.com/nglauber/" +
        "dominando_android3/master/livros_novatec.xml"
@Throws(Exception::class)
private fun readBooksXml(inputStream: InputStream): List<Book> {
    val booksList = mutableListOf<Book>()
    var book: Book? = null
    var currentTag: String? = null
    var currentCategory: String = ""
    val factory = XmlPullParserFactory.newInstance()
    val xpp = factory.newPullParser()
    xpp.setInput(inputStream, "UTF-8")
    var eventType = xpp.eventType
    while (eventType != XmlPullParser.END_DOCUMENT) {
        when (eventType){
            XmlPullParser.START_TAG -> {
                currentTag = xpp.name
                if ("livro" == currentTag) {
                    book = Book()
                    book.category = currentCategory
                }
            }
            XmlPullParser.END_TAG -> {
                if ("livro" == xpp.name) {
                    booksList.add(book as Book)
                }
            }
            XmlPullParser.TEXT -> {
                if (!xpp.isWhitespace) {
                    val text = xpp.text
                    when (currentTag){
                        "titulo" -> book?.title = text
                        "paginas" -> book?.pages = text.toInt()
                        "capa" -> book?.coverUrl = text
                        "autor" -> book?.author = text
                        "ano" -> book?.year = text.toInt()
                        "categoria" -> currentCategory = text
                    }
                }



            }
        }
        eventType = xpp.next()
    }
    return booksList
}
fun readBooksXml(): List<Book>? {
    try {
        val connection = connect(BOOKS_XML_URL)
        val responseCode = connection.responseCode
        if (responseCode == HttpURLConnection.HTTP_OK) {
            val `is` = connection.inputStream
            return readBooksXml(`is`)
        }
    } catch (e: Exception) {
        e.printStackTrace()
    }
    return null
}

Foi definida uma constante para endereço do arquivo XML no servidor. Em
seguida, no método readBooksXml(InputStream) é declarada e inicializada uma lista
de objetos da classe Book que será retornada pelo método. Como o documento
XML será lido elemento por elemento, as variáveis currentTag e currentCaterory
armazenarão a tag a categoria de livro que está sendo lida.

Logo em seguida a leitura do XML é iniciada, na qual é obtida a instância
do XmlPullParser por meio da classe XmlPullParserFactory, sendo informado que os
dados virão do InputStream recebido como parâmetro por meio do método
setInput (InputStream, String). Então, na instrução while o documento será lido
enquanto o evento não for igual END_DOCUMENT.

KOTLINxJAVA: Em Kotlin, “is” é uma palavra reservada, por isso, para utilizá-
la como nome de variável ela deve estar entre acentos graves `is`.

Se o evento atual for START_TAG, a variável currentTag é atualizada e então é
checado se a tag de abertura que foi encontrada foi a tag <livro>. Nesse caso,
um novo objeto book é criado. Caso o evento seja o de END_TAG é porque a tag
de fechamento </livro> foi encontrada, então o livro é adicionado à lista de
livros.

Porém, boa parte do processamento acontece quando o evento TEXT ocorre.
Aqui verifica-se qual é a currentTag para preencher o atributo correto do objeto



book.
Para testar essa implementação, altere a classe BooksListFragment, no método

doInBackground() da inner class BooksDownloadTask conforme a seguir:
override fun doInBackground(vararg strings: Void): List<Book>? {
    return BookHttp.readBooksFromXml()
}

Execute a aplicação e teremos o mesmo resultado que tivemos
anteriormente ao lermos o arquivo JSON.

Coroutines
Desde o início deste capítulo foi enfatizado que todo processamento oneroso
em termos computacionais, como acesso à rede e leitura de arquivos deve ser
feito em uma thread separada. Com as coroutines é possível realizar tarefas
assíncronas sem necessariamente mudar o fluxo de código do aplicativo. As
coroutines simplificam a programação assíncrona abstraindo do programador
toda complexidade do uso de threads, fazendo com que o programa continue
síncrono, mas com algumas chamadas sendo feitas de forma assíncrona.

A Jetbrains define as coroutines como “lightweight threads” (threads
leves), entretanto elas não criam diversas threads para realizar o
processamento assíncrono, ao invés disso, é utilizado um pool com um
número limitado de threads que serão utilizadas pelas coroutines. Por essa
razão, é possível criar 100.000 coroutines, mas não seria possível criar esse
mesmo número de threads.

Recursos similares às coroutines já existem em outras linguagens, mas
finalmente o Kotlin trouxe esse benefício para o desenvolvimento Android.
Diferentemente de outros mecanismos existentes nas APIs nativas da
plataforma, as coroutines são processamentos que podem ser suspendidos
sem bloquear a thread atual. Vejamos o exemplo a seguir:
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import android.util.Log
import kotlinx.android.synthetic.main.activity_main.*
import kotlinx.coroutines.*
import kotlin.coroutines.CoroutineContext
 
class MainActivity : AppCompatActivity(), CoroutineScope {
    private lateinit var job: Job



 
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        job = Job()
        button1.setOnClickListener {
            carregarTarefasSequenciais()
        }
        button2.setOnClickListener {
            carregarTarefasParalelas()
        }
    }
    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
    }
    suspend fun tarefa1(): String {
        Log.d("NGVL", "tarefa1 -> INICIO ${Thread.currentThread().name}")
        delay(5000)
        Log.d("NGVL", "tarefa1 -> FIM")
        return "Tarefa1"
    }
    suspend fun tarefa2(): String {
        Log.d("NGVL", "tarefa2 -> INICIO ${Thread.currentThread().name}")
        delay(3000)
        Log.d("NGVL", "tarefa2 -> FIM")
        return "Tarefa2"
    }
    private fun carregarTarefasSequenciais() {
        launch {
            val a = withContext(Dispatchers.Default) { tarefa1() }
            val b = withContext(Dispatchers.IO) { tarefa2() }
            button1.text = "$a $b"
        }
    }
    private fun carregarTarefasParalelas() {
        launch {
            coroutineScope {
                val a = async(Dispatchers.IO) { tarefa1() }
                val b = async (Dispatchers.Default) { tarefa2() }
                button2.text = "${a.await()} ${b.await()}"
            }



        }
    }
}

KOTLINxJAVA: Em Kotlin é possível definir propriedades em interfaces como é
o caso da CoroutineScope na qual é preciso implementar a propriedade coroutineContext.

KOTLINxJAVA: A linguagem Kotlin permite que cada classe crie sua
implementação dos operadores matemáticos (+, -, /, * e %), de atribuição (=, +=, -=,
/=, *=, %=), incremento (++ e --), lógicos (<, <=, >= e >), entre outros. A classe
CoroutineContext (super classe de Job) sobrescreve o operador de soma para adicionar
um Job como “filho” dele.

A activity implementa a interface CoroutineScope que vai definir o escopo da
execução das coroutines e permitirá maior controle sobre elas. A única
implementação necessária dessa interface é a propriedade coroutineContext, em
que nesse exemplo foi definido o escopo da main thread, usando
Dispatchers.Main, juntamente com o atributo job que controlará todas as
coroutines-filhas, ou seja, nesse contexto. Perceba que o atributo job é
instanciado no onCreate(Bundle), e no onDestroy() todas as tarefas que estiverem
sendo executadas em background serão canceladas.

As funções tarefa1() e tarefa2() utilizam o modificador suspend que indica que
elas são funções que podem ser suspensas, ou seja, realizarão um
processamento assíncrono. Dentro dessas funções é simulada uma espera por
meio da função delay(Int,TimeUnit).

As funções marcadas como supend só podem ser chamadas por outras
funções suspensas ou por um Job, que é um abstração do Kotlin para uma
tarefa que possui um ciclo de vida e que pode ser cancelada. A maneira mais
simples de criar um Job é por meio do método launch.

Nessa classe foram utilizados dois tipos de execução em background:
paralelo e sequencial. Em carregarTarefasSequenciais(), as chamadas aos métodos
tarefa1() e tarefa2() é feita de forma sequencial, utilizando o método
withContext(CoroutineContext). O método tarefa1() demora 5 segundos para executar
(por conta do delay(5, TimeUnit.SECONDS)); e, em seguida, a tarefa2() gasta 3
segundos para executar. Desta forma, o tempo gasto seria de
aproximadamente 8 segundos.



Perceba que na primeira chamada foi utilizado o contexto Dispatchers.Default
que utiliza um pool de threads compartilhado. Já na segunda chamada foi
utilizado o Dispatchers.IO, que é mais recomendado para realizar operações de
entrada e saída de dados (mas aqui foi utilizado apenas para fins didáticos).
Ao observar o log é possível notar que está sendo impresso o nome da thread
em que a coroutine está executando.

A função async utilizada no método carregarTarefasParalelas() permite que os
processamentos ocorram em paralelo, ou seja, o métodos tarefa1() será
chamado e logo em seguida tarefa2() também iniciará sua execução. Entretanto,
a tarefa2() terminará primeiro (em 2 segundos), e aproximadamente 3 segundos
depois, tarefa1() finalizará seu trabalho, totalizando assim 5 segundos. O
método retorna async() retorna um objeto da classe Deferred que permite chamar
a função await() para aguardar a tarefa ser concluída e obter o resultado.
Entretanto, é preciso declarar um escopo para essas duas tarefas que
executarão assincronamente, por isso, todo o bloco de código está envolvido
pela função coroutineScope.

Em ambos os métodos, a constante s recebe a concatenação do retornos das
funções tarefa1() e tarefa2(). Note que foi utilizada uma estrutura try/catch, pois se
ocorrer algum problema no processamento assíncrono uma string de erro é
retornada.

Como é possível notar, o uso das coroutines é muito simples, por isso, ela
será utilizada para substituir a AsyncTask no exemplo deste capítulo. Adicione
essas dependências no build.gradle:
dependencies {
    ...
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1'
}

A primeira dependência é da biblioteca principal de coroutines, enquanto a
segunda permite utilizar o contexto de UI do Android.

A única classe que terá de ser modificada é a BooksListFragment que deve ficar
da seguinte forma:
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter



import androidx.fragment.app.Fragment
import kotlinx.android.synthetic.main.fragment_books_list.*
import kotlinx.coroutines.*
import kotlin.coroutines.CoroutineContext
 
class BooksListFragment : Fragment(), CoroutineScope {
    // O atributo asyncTask foi substituído pelo atributo downloadJob
    private lateinit var job: Job
    private var downloadJob: Job? = null
    // Demais atributos não mudaram
 
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        retainInstance = true
        job = Job()
    }
    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
    }
    // O método onCreateView não mudou
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        adapter = BookListAdapter(requireContext(), booksList)
        listView.emptyView = txtMessage
        listView.adapter = adapter
        if (booksList.isNotEmpty()) {
            showProgress(false)
        } else {
            if (downloadJob == null) {
                if (BookHttp.hasConnection(requireContext())) {
                    startDownloadJson()
                } else {
                    progressBar.visibility = View.GONE
                    txtMessage.setText(R.string.error_no_connection)
                }
            } else if (downloadJob?.isActive == true) {
                showProgress(true)
            }
        }
    }
    // Método showProgress não mudou



    private fun startDownloadJson() {
        downloadJob = launch {
            showProgress(true)
            val booksTask = withContext(Dispatchers.IO) {
                BookHttp.loadBooksGson()
            }
            updateBookList(booksTask)
            showProgress(false)
        }
    }
    private fun updateBookList(result: List<Book>?) {
        if (result != null) {
            booksList.clear()
            booksList.addAll(result)
        } else {
            txtMessage.setText(R.string.error_load_books)
        }
        adapter?.notifyDataSetChanged()
        downloadJob = null
    }
    // Remova a classe BooksDownloadTask
}

Com pouquíssimas modificações, a AsyncTask foi substituída pela coroutine.
O atributo job é inicializado no método onCreate(Bundle), e ao destruir o fragment
as tarefas do job são canceladas, e o processamento assíncrono é realizado
com a instrução withContext(Dispatchers.IO). Perceba que o método loadBooksGson()
não foi marcado como suspend. Isso não é necessário, pois o próprio método
withContext(CoroutineContext) faz isso automaticamente.

A discussão sobre HTTP não termina por aqui, ela continuará no Capítulo
14.

1 O protocolo HTTP suporta os métodos HEAD, OPTIONS, TRACE, CONNECT, GET, POST, PUT e
DELETE.



CAPÍTULO 13
Broadcast receiver

No Android é possível detectar quando eventos do sistema operacional
acontecem de uma maneira bem simples por meio dos broadcast receivers
(ou simplesmente receivers). Mudança do nível da bateria, inicialização do
sistema e falta de conectividade com a internet são alguns exemplos dos
eventos que podem ser capturados pelo aplicativo. Entretanto, também é
possível definir eventos customizados, dispará-los e tratá-los de forma
semelhante aos eventos de sistema.

Capturando eventos
Para capturar eventos, tanto do sistema operacional quanto do próprio
aplicativo, é necessário criar uma classe que herde android.content.BroadcastReceiver
e implementar o método onReceive(Context, Intent), que será chamado quando o
evento ocorrer. Em seguida, deve-se informar qual evento tratar, e para fazer
isso existem duas opções:

• registrar a classe com a tag <receiver> no AndroidManifest.xml e informar o
evento que se deseja detectar usando a tag <action> declarada em um <intet-
filter>. Neste caso, quando o evento ocorrer, o Android criará uma
instância do receiver e o executará automaticamente;

• utilizar o método registerReceiver(BroadcastReceiver, IntentFilter) da classe Context
(lembrando que Activity herda dessa classe). E, para desativá-lo, chamar o
método unregisterReceiver(BroadcastReceiver). Dessa forma, é possível controlar
quando o receiver ficará ouvindo determinado evento.

Um detalhe importante sobre a primeira abordagem é que não é necessário
que a aplicação esteja em execução para que o evento seja consumido, mas
obrigatoriamente o aplicativo deve ter sido executado ao menos uma vez.
Entretanto, por questões de desempenho, declarar receivers no
AndroidManifest.xml é um recurso que foi removido parcialmente no



Android 7.0 (API Level 24) e quase completamente a partir do Android 8.0
(API Level 26), restando apenas alguns poucos eventos que ainda podem ser
capturados desta maneira.

É importante salientar que um receiver não possui interface gráfica e tem
um tempo de vida muito curto. Se o método onReceive(Context,Intent) não concluir
sua execução em até dez segundos, o Android exibirá uma mensagem de
ANR (Application Not Responding) e dará a opção ao usuário de finalizar a
aplicação.

Declarando um broadcast receiver
Crie um novo projeto para ver na prática como utilizar os broadcast receivers.

Application Name Broadcast
Package Name dominando.android.broadcast
Activity Name MainActivity

O arquivo de layout res/layout/activity_main.xml só terá dois botões e um
TextView, como podemos observar a seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    android:orientation="vertical">
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="sendBroadcast"
        android:id="@+id/btnSend"/>
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="sendBroadcast(Local)"
        android:id="@+id/btnLocal"/>
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/txtMessage"/>
</LinearLayout>

Crie nova classe chamada EventReceiver, que deve ficar como listado a seguir:
import android.widget.Toast
import android.content.Intent



import android.content.BroadcastReceiver
import android.content.Context
class EventReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context?, intent: Intent?) {
        val action = intent?.action
        Toast.makeText(context, "Ação:\n$action", Toast.LENGTH_LONG).show()
    }
}

Como foi mencionado, quando o receiver for instanciado, o método onReceive
(Context,Intent) será chamado. Nesse exemplo apenas é exibido um Toast quando
o evento é recebido. Agora registre essa classe no AndroidManifest.xml:
<application ...>
    ...
    <receiver android:name=".EventReceiver">
        <intent-filter>
            <action android:name="dominando.android.broadcast.ACTION_EVENT"/>
            <category android:name="android.intent.category.DEFAULT"/>
        </intent-filter>
    </receiver>
</application>

O receiver é declarado com a tag <receiver> e o nome da classe na
propriedade android:name. Na tag <intent-filter>, são filtradas as intents que esse
receiver pode tratar. Neste exemplo, com a tag <action> foi configurado que
receiver será invocado quando a ação dominando.android.broadcast.ACTION_EVENT
for disparada. Utilizar o nome do pacote como prefixo da ação não é
obrigatório, mas é uma boa prática para evitar duplicidade de nomes. Outra
convenção é utilizar letras maiúsculas para o nome da ação.

Disparando um broadcast receiver implícito
Uma vez declarado, esse receiver pode ser invocado por qualquer aplicação
que dispare a ação ACTION_EVENT. Caso queira evitar isso, basta adicionar a
propriedade android:exported com o valor false à tag <receiver>.

Faça os seguintes ajustes na MainActivity que disparará esse broadcast:
import android.os.Bundle
import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {



    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        btnSend.setOnClickListener {
            sendImplicitBroadcast()
        }
    }
    private fun sendImplicitBroadcast() {
        val intent = Intent(ACTION_EVENT)
        sendBroadcast(intent)
    }
    companion object {
        private const val ACTION_EVENT = "dominando.android.broadcast.ACTION_EVENT"
    }
}

Execute a aplicação e, ao clicar no primeiro botão, caso a aplicação esteja
executando em um aparelho com Android Marshmallow (API Level 23) ou
inferior um Toast será exibido informando que a ação foi disparada.
Entretanto, a partir do Android Nougat (API Level 24), será exibida a
seguinte mensagem no Logcat:
W/BroadcastQueue: Background execution not allowed: receiving Intent {

act=dominando.android.broadcast.ACTION_EVENT flg=0x10 } to
dominando.android.broadcast/.EventReceiver
Como é possível observar no log, a execução de Broadcast Receivers não é

permitida em background. Uma alternativa que durante a escrita deste livro
ainda permitia esse tipo de execução está listada a seguir:
private fun sendImplicitBroadcast() {
    val intent = Intent(ACTION_EVENT)
    val matches = packageManager.queryBroadcastReceivers(intent, 0)
    for (resolveInfo in matches) {
        val explicit = Intent(intent)
        val componentName = ComponentName(
                resolveInfo.activityInfo.applicationInfo.packageName,
                resolveInfo.activityInfo.name
        )
        explicit.component = componentName
        sendBroadcast(explicit)
    }
}

Neste exemplo, basicamente uma intent implícita é convertida para uma
intent explícita. O package manager é um serviço do sistema que possui



informações sobre os componentes utilizados pela aplicação, tais como:
activities, services (que veremos mais adiante), broadcast receivers e content
providers. Foi utilizado o objeto packageManager para buscar por Broadcast
Receivers que respondam pela Intent que está sendo passada como parâmetro.
Essa busca retorna uma lista de ResolverInfo e, caso encontre algum resultado,
um objeto ComponentName é criado passando como parâmetro o pacote da
aplicação e o nome da classe. Finalmente, esse objeto é passado para uma
intent explícita usada para disparar o broadcast.

Esse método funciona inclusive para chamar esse broadcast a partir de outra
aplicação. O resultado deve ficar conforme a Figura 13.1.

Figura 13.1 – Broadcast implícito.
Criar os próprios broadcasts pode ser muito útil principalmente em

aplicativos maiores nos quais uma parte do sistema precisa notificar outra
parte não relacionada. Ou, ainda, quando é preciso que aplicativos diferentes
conversem entre si.

Broadcast receivers locais
Para enviar mensagens de broadcast dentro da própria aplicação, ou seja, sem



que outras aplicações sejam notificadas, é mais aconselhável utilizar a classe
LocalBroadcastManager.

Faça os seguintes ajustes na MainActivity destacados a seguir:
import android.content.*
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.localbroadcastmanager.content.LocalBroadcastManager
import kotlinx.android.synthetic.main.activity_main.*
class MainActivity : AppCompatActivity() {
    val receiver: InternalReceiver = InternalReceiver()
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        btnSend.setOnClickListener {
            sendImplicitBroadcast()
        }
        btnLocal.setOnClickListener {
            val intent = Intent(ACTION_EVENT)
            LocalBroadcastManager.getInstance(this)
                    .sendBroadcast(intent)
        }
    }
    override fun onResume() {
        super.onResume()
        val filterLocal = IntentFilter(ACTION_EVENT)
        LocalBroadcastManager.getInstance(this)
                .registerReceiver(receiver, filterLocal)
    }
    override fun onPause() {
        super.onPause()
        LocalBroadcastManager.getInstance(this)
                .unregisterReceiver(receiver)
    }
 
    inner class InternalReceiver : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            txtMessage.text = "Ação:\n${intent.action}"
        }
    }
    companion object {
        private const val ACTION_EVENT = "dominando.android.broadcast.ACTION_EVENT"
    }
}



Foi declarado um atributo da classe InternalReceiver que é um broadcast
receiver interno dessa activity. E por que não usar o anterior? Perceba que
esse receiver está acessando o TextView que está no arquivo de layout dessa
activity. Na classe EventReceiver isso não seria possível. Essa é outra
característica do broadcast receiver: declará-lo apenas para a tela em que ele
for utilizado.

No método onResume() é instanciado um objeto IntentFilter passando a
ACTION_EVENT como parâmetro. Esse objeto é necessário para registrar a ação
que será tratada pelo receiver. Perceba que está sendo feito em código o mesmo
que foi feito com a tag <intent-filter> no AndroidManifest.xml.

Em seguida, o receiver é registrado usando o método
registerReceiver(BroadcastReceiver,IntentFilter) da classe LocalBroadcastManager. No método
onPause() ele é desregistrado por meio do método
unregisterReceiver(BroadcastReceiver).

Para disparar o evento, o método sendBroadcast(Intent) foi usado como feito no
evento de clique do outro botão, mas dessa vez usando a classe
LocalBroadcastManager. Execute a aplicação e observe que o TextView exibirá a
ACTION_EVENT ao ser clicado.

Tratando eventos do sistema
O Android dispara mensagens de broadcast para avisar que algo ocorreu.
Mudança de nível de bateria, conexão de um fone de ouvido, instalação de
uma aplicação, acender ou apagar a tela são alguns dos exemplos dessas
mensagens. Uma lista completa dessas mensagens pode ser encontrada na
documentação do Android (que você pode baixar no Android Studio) no
arquivo ANROID_SDK_DIR/platforms/android-X/data/broadcast_actions.txt
(em que X é a API Level da documentação que você está visualizando).

Em diversos casos é importante executar alguma ação assim que o aparelho
é inicializado, e o Android dispara uma mensagem de broadcast quando isso
acontece, mas para esse caso é necessário declarar o receiver no
AndroidManifest.xml. Altere a declaração do EventReceiver desta forma:
<receiver android:name=".EventReceiver">
    <intent-filter>
        <action android:name="dominando.android.broadcast.ACTION_EVENT"/>
        <category android:name="android.intent.category.DEFAULT"/>
    </intent-filter>



    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED"/>
    </intent-filter>
</receiver>

A ação de detectar o boot do aparelho é uma das poucas ainda podem ser
declaradas no AndroidManifest.xml. Para detectar que a inicialização do
aparelho foi concluída, foi utilizada a ação BOOT_COMPLETED. Ela precisa da
permissão do usuário, então adicione também a permissão
RECEIVE_BOOT_COMPLETED:
<manifest ... >
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
    <application ...>

Para efeitos de teste, altere a classe EventReceiver para ficar conforme a
listagem a seguir:
class EventReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context?, intent: Intent?) {
        val action = intent?.action
        Toast.makeText(context, "Ação:\n$action", Toast.LENGTH_LONG).show()
        if (Intent.ACTION_BOOT_COMPLETED == action) {
            // Não faça isso na sua aplicação!
            // Isso vai irritar o usuário :)
            val it = Intent(context, MainActivity::class.java)
            it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            context?.startActivity(it)
        }
    }
}

Com essa mudança ao iniciar o aparelho, automaticamente a MainActivity será
executada. Compile e execute a aplicação e, em seguida, desligue o aparelho
(ou o emulador pressionando o botão de liga/desliga). Ligue-o novamente e
você perceberá que a activity principal será exibida assim que o aparelho
terminar de inicializar.

Declarando com permissões
Ao declarar um receiver no AndroidManifest.xml, ele será público e qualquer
outra aplicação poderá acessá-lo. Para evitar que isso aconteça, basta
adicionar a propriedade android:exported="false" à tag <receiver>. E se você quiser
realmente que somente outra aplicação sua (ou de alguma empresa parceira)



possa acessar? Podemos utilizar a propriedade android:permission:
<manifest …
    <permission android:name="dominando.android.broadcast.MESTRE_JEDI"/>
    <application …
        <receiver android:name=".EventReceiver"
            android:permission="dominando.android.broadcast.MESTRE_JEDI">
            ...

Com esta declaração, apenas os aplicativos que usarem essa permissão
poderão disparar esse broadcast receiver. É possível ser ainda mais detalhista
com essa tag <permission>, como, por exemplo, informar que apenas os
aplicativos assinados com a mesma chave possam acessar esse broadcast
receiver, mas não vamos nos estender nesse assunto.

A aplicação que quiser disparar esse broadcast deve adicionar a seguinte
declaração ao AndroidManifest.xml:
<manifest …
    <uses-permission android:name="dominando.android.broadcast.MESTRE_JEDI"/>

Caso qualquer aplicação tente invocar o broadcast sem permissão
simplesmente não funcionará, mas no Logcat aparecerá uma mensagem como
a seguir:
W/BroadcastQueue: Permission Denial: broadcasting Intent {

act=dominando.android.broadcast.ACTION_EVENT flg=0x10
cmp=dominando.android.broadcast/.EventReceiver } from dominando.android.http (pid=4938,
uid=10082) requires dominando.android.broadcast.MESTRE_JEDI due to receiver
dominando.android.broadcast/.EventReceiver

Detectando a presença de conectividade
No exemplo do capítulo anterior foi mostrado como acessar um servidor web
para obter informações e exibi-las para o usuário, mas se não houver
conexão, uma mensagem é exibida para o usuário informando sobre essa
situação. Imagine que o usuário tem acesso a uma rede Wi-Fi, mas
simplesmente esqueceu de ativar essa configuração no aparelho. Vendo a
mensagem exibida pelo seu aplicativo, ele acessa a barra de status do
aparelho (sem sair da aplicação) e ativa a configuração de Wi-Fi do aparelho.
O que o aplicativo faz? Nada! E isso não é bom, pois o usuário terá que
fechar e abrir a aplicação para tentar obter os dados novamente.

Podemos poupá-lo desse trabalho criando um broadcast receiver que
detecte a disponibilidade de conexão com a internet e baixe os dados



automaticamente. Abra o projeto do capítulo anterior e crie a classe
InternetFragment listada a seguir:
import android.app.PendingIntent
import android.net.ConnectivityManager
import android.content.Intent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.IntentFilter
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import android.os.Build
import androidx.fragment.app.Fragment
 
abstract class InternetFragment : Fragment() {
    private var receiver: ConnectionReceiver? = ConnectionReceiver()
    private val pit: PendingIntent by lazy {
        PendingIntent.getBroadcast(context,
                0, Intent(ACTION_CONNECTIVITY), 0)
    }
    abstract fun startDownload()
    override fun onResume() {
        super.onResume()
        registerForConnectivityChanges()
    }
    override fun onPause() {
        super.onPause()
        unregisterForConnectivityChanges()
    }
 
    private fun isMarshmallowOrLater() =
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.M
 
    private fun registerForConnectivityChanges() {
        if (isMarshmallowOrLater()) {
            val context = requireContext()
            val connectivityManager = context
                    .getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            val request = NetworkRequest.Builder()
                    .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                    .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
                    .build()
            connectivityManager.registerNetworkCallback(request, pit)
            val filter = IntentFilter(ACTION_CONNECTIVITY)
            context.registerReceiver(receiver, filter)



        } else {
            val filter = IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION)
            context?.registerReceiver(receiver, filter)
        }
    }
    private fun unregisterForConnectivityChanges() {
        if (isMarshmallowOrLater()) {
            val context = requireContext()
            val connectivityManager = context
                .getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            connectivityManager.unregisterNetworkCallback(pit)
        } else {
            context?.unregisterReceiver(receiver)
        }
    }
    internal inner class ConnectionReceiver : BroadcastReceiver() {
        private var first = true
        override fun onReceive(context: Context, intent: Intent) {
            var validAction = false
            if (isMarshmallowOrLater()) {
                if (intent.action == ACTION_CONNECTIVITY) {
                    validAction = true
                }
            } else {
                if (intent.action == ConnectivityManager.CONNECTIVITY_ACTION) {
                    if (first) {
                        first = false
                    } else {
                        validAction = true
                    }
                }
            }
            if (validAction && BookHttp.hasConnection(context)) {
                startDownload()
            }
        }
    }
    companion object {
        const val ACTION_CONNECTIVITY = "dominando.android.http.CONNECTION"
    }
}

A classe InternetFragment herda de Fragment, onde o atributo receiver é registrado
no onResume() para ouvir o evento de mudança de conectividade e
desregistrado no método onPause(). Para tratar o evento de mudança de



conectividade, foram implementadas duas abordagens.
A primeira abordagem é mais simples, pois só é preciso registrar o

broadcast para a ação CONNECTIVITY_ACTION criando uma instância de um
IntentFilter. Essa classe representa a tag <intent-filter> do AndroidManifest.xml.
Em seguida, o receiver é registrado para o evento definido usando o método
registerReceiver(BroadcastReceiver, IntentFilter) e o desregistrado utilizando o método
unregisterReceiver(BroadcastReceiver).

Entretanto, a primeira abordagem não funciona mais a partir do Android
Marshmallow (API Level 23), pois a ação CONNECTIVITY_ACTION foi marcada
como depreciada. A abordagem recomendada passa a ser a utilização da
classe ConnectivityManager para registrar uma PendingIntent (que como o próprio
nome diz, é uma intent pendente) para o ConnectionReceiver utilizando o método
registerNetworkCallback(NetworkRequest, PendingIntent). Perceba que foi utilizado um
objeto NetworkRequest que permite informar alguns recursos de rede que sejam
necessários. Neste exemplo, foi definido que é necessário uma rede com
acesso à internet (NET_CAPABILITY_INTERNET) e sem restrições de acesso
(NET_CAPABILITY_NOT_RESTRICTED). Como a ação CONNECTIVITY_ACTION está
depreciada, foi utilizada uma ação personalizada ACTION_CONNECTIVITY e o
broadcast receiver foi registrado para ouvir essa ação.

A classe interna ConnectionReceiver herda de BroadcastReceiver e implementa o
método onReceive(Context,Intent) como requer o Android. Assim, quando houver a
mudança de estado de conectividade, esse método será invocado.

Para alguns tipos de eventos, o método onReceive(Context, Intent) é chamado
imediatamente ao registrar um broadcast receiver, e o broadcast de
conectividade é um desses eventos. Então foi definido um atributo booleano
chamado first, que indica se é a primeira vez que o receiver está sendo
chamado; se for, a primeira chamada a esse receiver é ignorada. Se não for, é
verificado se o evento disparado foi o de mudança de conectividade (obtida
por meio da propriedade action da Intent). Em caso positivo, o método abstrato
startDownload() é chamado.

Para testar o código anterior, faça com que a classe BooksListFragment herde de
InternetFragment:
class BooksListFragment : InternetFragment(), CoroutineScope {
    ...
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)



        listView.emptyView = txtMessage
        if (booksList.isNotEmpty()) {
            showProgress(false)
            updateBookList(booksList)
        } else {
            startDownload()
        }
    }
    // O código desse método estava no bloco else do método acima
    override fun startDownload() {
        if (job == null) {
            if (BookHttp.hasConnection(requireContext())) {
                startDownloadJson()
            } else {
                progressBar.visibility = View.GONE
                txtMessage.setText(R.string.error_no_connection)
            }
        } else if (job?.isActive == true) {
            showProgress(true)
        }
    }
}

Feito isso, desabilite as conexões do aparelho (ou emulador) para testar a
nova funcionalidade. A maneira mais simples é selecionar a opção Modo
avião, que na maioria dos aparelhos fica localizada barra de notificações.
Depois é só clicar no ícone de um avião. A Figura 13.2 mostra a opção de
modo avião no Android Pie.



Figura 13.2 – Opção para habilitar o modo avião.
Habilite o modo avião e execute a aplicação. Deslize a barra de status para

baixo e desabilite o modo avião. Se tudo correr bem, a listagem de livros será
exibida automaticamente.

Como podemos ver, capturar eventos do sistema pode agregar muito aos
aplicativos e ajuda a tratar cenários especiais na aplicação.



CAPÍTULO 14
Acesso à web – Parte II

Após ter sido demonstrado como baixar informações de um servidor web por
meio de arquivos JSON e XML, nos aprofundaremos um pouco mais sobre
comunicação HTTP no Android implementando o acesso a um web service
simples que armazenará as informações da aplicação de hotéis.

Padrão REST
O REST (Representational State Transfer) tornou-se o padrão de web
services mais adotado mundialmente. Ele é baseado em recursos, em que um
recurso é qualquer entidade que possa ser endereçada, normalmente por um
id único. Em um blog, por exemplo, um recurso poderia ser um post, já em
um site vendas um produto ou um pedido também seriam bons exemplos de
recursos. Estes, em sua maioria, são representados computacionalmente por
documentos XML ou JSON.

Apesar de estar intimamente ligado ao protocolo HTTP, o padrão REST
pode usar qualquer tipo de protocolo de aplicação, mas sem sombra de
dúvida o HTTP é o mais adotado, e isso pode ser observado pela ampla
quantidade de APIs REST disponíveis na web. Empresas como Twitter,
Facebook e Google disponibilizam acesso aos seus recursos via APIs REST
que podem ser acessadas por clientes desktop, mobile e web.

O REST utiliza os próprios métodos HTTP para realizar as operações. Ao
realizar uma requisição do tipo GET, por exemplo, informações são obtidas do
servidor. Já em uma requisição POST um recurso seria incluído, no PUT seria
feita a alteração desse um registro, e a exclusão pelo método DELETE.

Web service REST com PHP
Tanto web services quanto a linguagem PHP (PHP Hypertext Preprocessor)
são assuntos para um livro inteiro, e não é intuito deste livro entrar em



detalhes em nenhum desses assuntos. Então faremos um serviço bem simples
que permita ao leitor testar as requisições feitas a partir de uma aplicação
Android.

Para executar um web service é preciso de um servidor web e uma
linguagem de programação que trate requisições HTTP. Neste exemplo será
usado o Apache Web Server (http://httpd.apache.org) que hospedará um web
service simples escrito em PHP (http://www.php.net) que persistirá os dados
em um banco de dados MariaDB (http://mariadb.com).

Se você nunca ouviu falar em nenhum dos softwares citados anteriormente,
não se desespere. Você pode baixá-los individualmente em seus respectivos
sites, mas uma opção mais simples é baixar o XAMPP
(http://www.apachefriends.org), que é um pacote que já instala Apache,
MariaDB, PHP e Perl na sua máquina. O “X” significa cross-platform, o que
quer dizer que funcionará sem problemas em Windows, Mac OS e Linux.
Faça o download e siga as instruções de instalação que são bem simples.

Uma vez instalado, execute o XAMPP e será exibida a tela da Figura 14.1.

Figura 14.1 – XAMPP em execução.
Em seguida, clique na aba Manage Services e verifique se os serviços do



Apache e o MySQL estão funcionando conforme a Figura 14.2. Caso não
estejam, selecione o serviço e clique em Start e o ícone do respectivo serviço
deverá ficar verde.

Feito isso, abra o navegador e digite o endereço exibido na Figura 14.1, por
exemplo http://192.168.64.2. Se tudo estiver certo, uma tela similar à Figura
14.3 deverá ser exibida.

Figura 14.2 – Status do Apache e MySQL no XAMPP.



Figura 14.3 – Servidor Apache em execução.
Para gerenciar o banco de dados no servidor pode-se utilizar a opção

phpMyAdmin. Lá é possível criar e visualizar a estrutura do banco de dados,
bem como os dados da tabela que será criada para o exemplo que será
desenvolvido neste capítulo.

Para abrir o diretório onde se encontra o XAMPP, selecione na aba
Welcome e clique no botão Open Application Folder. Vá até o diretório
htdocs, crie um diretório chamado hotel_service e adicione nele o arquivo
webservice.php listado a seguir1:
<?php
$servername = "127.0.0.1";
$username = "root";
$password = "";
$conn = new mysqli($servername, $username, $password);
if ($conn->connect_error) {
    die("Erro ao conectar com banco de dados: " . $conn->connect_error);
}
$sql = "CREATE DATABASE IF NOT EXISTS hotel_db";
if (!$conn->query($sql) === TRUE) {
    echo "Erro ao criar banco de dados: " . $conn->error;
}



$sql = "CREATE TABLE IF NOT EXISTS hotel_db.Hotel (
id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
user VARCHAR(200),
name VARCHAR(500) NOT NULL,
address VARCHAR(500) NOT NULL,
rating FLOAT(15,12),
photo_url VARCHAR(1000)
)";
if ($conn->query($sql) === FALSE) {
    echo "Erro ao criar tabela: " . $conn->error;
}
$httpMethod = $_SERVER['REQUEST_METHOD'];
if ($httpMethod == 'POST') {
    $stmt = $conn->prepare(
        "INSERT INTO hotel_db.Hotel (user, name, address, rating, photo_url)
         VALUES (?, ?, ?, ?, ?)");
    $segments = explode("/", parse_url($_SERVER["REQUEST_URI"], PHP_URL_PATH));
    $json = json_decode(file_get_contents('php://input'));
    $user = $segments[count($segments)-1];
    $name = $json->{'name'};
    $address = $json->{'address'};
    $rating = $json->{'rating'};
    $photourl = $json->{'photoUrl'};
    $stmt->bind_param("sssds", $user, $name, $address, $rating, $photourl);
    $stmt->execute();
    $stmt->close();
    $id = $conn->insert_id;
    $jsonResponse = array("id"=>(int)$id);
    echo json_encode($jsonResponse);
} else if ($httpMethod == 'GET') {
    $jsonArray = array();
    $sql = "SELECT id, user, name, address, rating, photo_url FROM hotel_db.Hotel ";
    $singleLine = false;
    $segments = explode("/", parse_url($_SERVER["REQUEST_URI"], PHP_URL_PATH));
    $id = $segments[count($segments)-1];
    $user = $segments[count($segments)-2];
    if (is_numeric($user)){
        $singleLine = true;
        $sql = $sql ." WHERE user = '". $user ."' AND id = ". $id;
    } else {
        $user = $id;
        $sql = $sql ." WHERE user = '". $user ."'";
    }
    $result = $conn->query($sql);
    if ($result && $result->num_rows > 0) {



        while($row = $result->fetch_assoc()) {
            $jsonLinha = array(
                "id" => $row["id"],
                "user" => $user,
                "name" => $row["name"],
                "address" => $row["address"],
                "rating" => (float)$row["rating"],
                "photoUrl" => $row["photo_url"]);
            $jsonArray[] = $jsonLinha;
            if ($singleLine){
                echo json_encode($jsonLinha);
                break;
            }
        }
    }
    if (!$singleLine) {
        echo json_encode($jsonArray);
    }
} else if ($httpMethod == 'PUT') {
    $stmt = $conn->prepare(
        "UPDATE hotel_db.Hotel SET user=?, name=?, address=?, rating=?, photo_url=? WHERE

id=?");
    $json = json_decode(file_get_contents('php://input'));
    $segments = explode("/", $_SERVER["REQUEST_URI"]);
    $id = $segments[count($segments)-1];
    $user = $segments[count($segments)-2];
    $name = $json->{'name'};
    $address = $json->{'address'};
    $rating = $json->{'rating'};
    $photourl = $json->{'photoUrl'};
    $stmt->bind_param("sssdsi", $user, $name, $address, $rating, $photourl, $id);
    $stmt->execute();
    $stmt->close();
    $jsonResponse = array("id"=>(int)$id);
    $image_path = "upload/" . $id ."___*";
    if ($photourl == NULL || $photourl == ""){
        $files = glob($image_path); //get all file names
        foreach($files as $file){
            if(is_file($file))
                unlink($file); //delete file
        }
    }
    echo json_encode($jsonResponse);
} else if ($httpMethod == 'DELETE') {
    $stmt = $conn->prepare("DELETE FROM hotel_db.Hotel WHERE id=? AND user=?");



    $segments = explode("/", $_SERVER["REQUEST_URI"]);
    $id = $segments[count($segments)-1];
    $user = $segments[count($segments)-2];
    $stmt->bind_param("is", $id, $user);
    $stmt->execute();
    $stmt->close();
    $jsonResponse = array("id"=>(int)$id);
    $image_path = "upload/" . $id ."___*";
    
    $files = glob($image_path); //get all file names
    foreach($files as $file){
        if(is_file($file))
            unlink($file); //delete file
    }
    echo json_encode($jsonResponse);
}
$conn->close();
?>

De maneira geral, esse script inicia tentando conectar-se ao MySQL. Em
seguida, o banco e a tabela são criados, caso não existam. Feito isso, é
verificado qual método HTTP está sendo utilizado para realizar a operação
correspondente no banco de dados. Se for feita uma requisição do tipo POST,
será efetuada uma operação de inclusão de um novo registro; se for usado o
PUT, um registro existente será atualizado; para excluir, o método DELETE é
utilizado e para listar os dados é feita uma requisição do tipo GET. Perceba
que todas as operações (exceto o GET) envolvem o recebimento de um JSON.

Os registros serão armazenados no banco de dados hotel_db na tabela Hotel.
Entretanto, é preciso saber como os dados serão enviados para o servidor e
como será o formato da resposta. A Tabela 14.1 apresenta essas informações.

Tabela 14.1 – Documentação do web service de hotéis
Método
HTTP Exemplo Retorno

POST webservice.php/<user> {"id": <novoId>}
{"name":"Hotel teste",
"address":"Rua Tal", "rating":
3.5
"photourl":"imagem.jpg"}

PUT webservice.php/<user>/<id> {"id": 1}
{"name":"Hotel teste",
"address":"Rua Tal", "rating":
3.5
"photourl":"imagem.jpg"}



DELETE /<user>/<id> {"id": 2}
GET /<user> [{"id":1, "name":"Hotel A",

"address":"Rua A","rating":3, "photourl":"" },
{"id":2, "name":"Hotel A",
"address":"Rua A","rating":4.5, "photourl":
"upload/2___imagem.jpg"]

/<user>/<id> {"id":1, "name":"Hotel A",
"address":"Rua A","rating":3, "photourl": ""}

Nas operações de inclusão, alteração e exclusão, um JSON com o id do
registro afetado é retornado. Para inserir, não é informado o id, pois ele será
gerado automaticamente pelo banco de dados do servidor. Na alteração é
necessário passar o id do hotel para atualizar o registro, e essa informação vai
na URL, da mesma forma que é feita na exclusão. Por fim, para obter os
registros, é feita uma requisição do tipo GET que retornará um array com os
hotéis cadastrados, ou apenas um hotel se for informado o respectivo id.

Perceba que para todas as requisições deve-se passar um user, que indicará a
qual usuário do aplicativo aquele hotel está associado. A tela de login será
implementada apenas no Capítulo 18, mas a aplicação já estará pronta para
essa mudança. Outro campo novo que foi apresentado aqui é o photo_url que
armazenará a URL da imagem referente ao hotel. Veremos como carregar a
imagem do aparelho a fazer o upload para o servidor ainda nesse capítulo.

Na próxima seção será implementado o acesso a esse webservice a partir da
aplicação de hotéis.

Preparando a aplicação para a web
Será dado continuidade ao projeto de cadastro de hotéis. Crie uma cópia do
projeto ArchComponents do Capítulo 11 e renomeie para WebService. Apague o
arquivo ArchComponents.iml e os diretórios build e app/build. Em seguida,
abra o projeto no Android Studio para começar os ajustes.

Application Name WebService
Package Name dominando.android.hotel
Activity Name HotelActivity

Uma vez que a aplicação acessará a internet, a primeira coisa que deve ser
feita é adicionar a respectiva permissão dentro da tag <manifest> no
AndroidManifest.xml:
<uses-permission android:name="android.permission.INTERNET"/>

Crie um novo pacote chamado http dentro do pacote repository onde serão



colocadas todas as classes relacionadas às requisições web. Em seguida,
adicione a classe IdResult listada a seguir:
data class IdResult(var id : Long)

Conforme foi explicado na seção anterior, ao inserir, atualizar ou excluir
um registro, um JSON contendo o id do hotel é retornado. A classe IdResult
representará esse tipo de retorno do web service.

Um grande trabalho que terá de ser realizado no aplicativo é manter os
dados locais sincronizados com os dados que ficarão armazenados no
servidor. Para representar o status atual do registro, adicione a interface Status
e deixe-a como a seguir:
interface Status {
    companion object {
        const val OK = 0
        const val INSERT = 1
        const val UPDATE = 2
        const val DELETE = 3
    }
}

Na classe Hotel, serão adicionados mais alguns atributos: photoUrl conterá a
URL da imagem que está armazenada no servidor (ou localmente, como
veremos adiante); status indicará o status do registro conforme as constantes da
interface Status; e o serverId representa o id do hotel no servidor.

Adicione ao arquivo DBConstants.kt as constantes referentes a essas novas
colunas:
const val COLUMN_PHOTO_URL = "photoUrl"
const val COLUMN_USER = "user"
const val COLUMN_STATUS = "status"
const val COLUMN_SERVER_ID = "serverId"

Em seguida, faça as seguintes mudanças na classe Hotel:
import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey
import dominando.android.hotel.repository.http.Status
import dominando.android.hotel.repository.sqlite.COLUMN_ID
import dominando.android.hotel.repository.sqlite.COLUMN_SERVER_ID
import dominando.android.hotel.repository.sqlite.TABLE_HOTEL
 
@Entity(tableName = TABLE_HOTEL,



        indices = [Index(COLUMN_SERVER_ID, unique = true)])
data class Hotel(
        @PrimaryKey(autoGenerate = true)
        @ColumnInfo(name = COLUMN_ID)
        var id: Long = 0,
        var name: String = "",
        var address: String = "",
        var rating: Float = 0.0F,
        var photoUrl: String = "",
        var serverId: Long? = null,
        var status: Int = Status.INSERT
)

Com essa abordagem, assim que um registro for inserido no banco de dados
local, ele ficará com o status INSERT. O mesmo acontecerá com a alteração e a
exclusão, que ficarão com o status UPDATE e DELETE, respectivamente.
Quando a operação for efetivada no servidor, o registro será atualizado para o
status OK.

Perceba que foi criado um índice único para o atributo serverId utilizando a
propriedade indices da @Entity. Nesse Index foi definida como true a propriedade
unique, o que impedirá que existam localmente dois registros com o mesmo id
do servidor.

Será necessário fazer algumas mudanças na parte de persistência para tratar
esses novos atributos. Comece pela interface HotelRepository:
interface HotelRepository {
    fun save(hotel: Hotel)
    fun insert(hotel: Hotel): Long
    fun update(hotel: Hotel)
    fun remove(vararg hotels: Hotel)
    fun hotelById(id: Long): LiveData<Hotel>
    fun search(term: String): LiveData<List<Hotel>>
    fun pending(): List<Hotel>
    fun hotelByServerId(serverId: Long): Hotel?
}

Os métodos adicionados serão utilizados durante o processo de
sincronização dos dados locais com o servidor. Os métodos insert(Hotel),
update(Hotel) e hotelByServerId(Long) são autoexplicativos. O método pending()
retornará os registros que estão pendentes de atualização com o servidor, ou
seja, aqueles em que o status esteja diferente de OK.

Com esses novos métodos e com os novos atributos na classe Hotel, a
interface HotelDao também deve sofrer algumas mudanças que são listadas a



seguir:
import dominando.android.hotel.repository.http.Status
import dominando.android.hotel.repository.sqlite.*
...
@Dao
interface HotelDao {
    // Os métodos insert, delete, update e hotelById não mudaram
    @Query("""SELECT * FROM $TABLE_HOTEL
            WHERE $COLUMN_STATUS != ${Status.DELETE}
            AND $COLUMN_NAME LIKE :query
            ORDER BY $COLUMN_NAME""")
    fun search(query : String): LiveData<List<Hotel>>
 
    @Query("""SELECT * FROM $TABLE_HOTEL
            WHERE $COLUMN_SERVER_ID = :serverId""")
    fun hotelByServerId(serverId : Long): Hotel?
 
    @Query("""SELECT * FROM $TABLE_HOTEL
            WHERE $COLUMN_STATUS != ${Status.OK}""")
    fun pending(): List<Hotel>
}

O método search(String) foi modificado para não exibir registros marcados
para exclusão no servidor. Já o método hotelByServerId(Long) faz algo bem
semelhante ao hotelById(Long), a diferença que ele retorna o próprio objeto Hotel,
pois o LiveData não será necessário. Por fim, o método pending() retorna os
registros que não estejam marcados com o status OK.

As alterações na classe HotelRoomRepository serão bem diretas como é possível
observar a seguir:
import dominando.android.hotel.repository.http.Status
...
class RoomRepository(
        database: HotelDatabase
) : HotelRepository {
    private val hotelDao = database.hotelDao()
    override fun save(hotel: Hotel) {
        if (hotel.id == 0L) {
            hotel.status = Status.INSERT
            val id = insert(hotel)
            hotel.id = id
        } else {
            hotel.status = Status.UPDATE
            update(hotel)



        }
    }
    override fun insert(hotel: Hotel): Long {
        return hotelDao.insert(hotel)
    }
    override fun update(hotel: Hotel) {
        hotelDao.update(hotel)
    }
    // Os métodos delete, hotelById e search não mudaram
    override fun hotelByServerId(serverId: Long): Hotel? {
        return hotelDao.hotelByServerId(serverId)
    }
    override fun pending(): List<Hotel> {
        return hotelDao.pending()
    }
}

No método save(Hotel) o status do objeto é alterado antes de realizar a
operação no banco de dados. Os outros métodos estão simplesmente
acessando respectivos métodos da classe HotelDao.

Outra mudança que deve ser realizada é na tela de listagem. A partir de
agora, ao excluir um hotel na tela de listagem, ele será, na verdade, marcado
para exclusão. E quando for feita a sincronização com o servidor, o registro
será realmente excluído. Para isso faça a seguinte mudança na classe
HotelListViewModel:
class HotelListViewModel(
        private val repository: HotelRepository
) : ViewModel() {
    ...
    fun deleteSelected() {
        selectedItems.forEach {
            it.status = Status.DELETE
            repository.update(it)
        }
        deletedItems.clear()
        deletedItems.addAll(selectedItems)
        setInDeleteMode(false)
        showDeletedMessage.value = deletedItems.size
    }
    ...
}

Apenas o método deleteSelected() foi afetado, onde o status de cada registro foi
selecionado de modo a marcá-lo para exclusão. Feito isso, serão definidas as



classes utilizadas para acessar o web service.

Dica de biblioteca: Retrofit
No Capítulo 12 foi demonstrado como acessar um servidor utilizando a classe
HttpUrlConnection, mas, em seguida, foi apresentada a biblioteca OkHttp que deixa
esse acesso mais simples. Foi visto também como ler um arquivo JSON
utilizando as classes JSONObject e JSONArray do próprio Android, mas que com a
biblioteca GSON a conversão de um JSON para um objeto Kotlin é feita
automaticamente.

O Retrofit é uma biblioteca amplamente utilizada pelos desenvolvedores e
que adiciona mais um nível de abstração na realização de requisições HTTP,
pois ela mapeia as chamadas HTTP em uma interface Kotlin, onde cada
método dessa interface representa um tipo de requisição que será feita ao
servidor. Definida essa interface, a biblioteca gerará toda a implementação de
requisições web para nós. Muito similar ao que foi feito com o Room.

O Retrofit será utilizado no projeto para facilitar o acesso ao webservice de
hotéis. Sendo assim, adicione a dependência do Retrofit no build.gradle:
dependencies {
    ...
    implementation "com.squareup.retrofit2:retrofit:$retrofit_version"
    implementation "com.squareup.retrofit2:converter-gson:$retrofit_version"
    implementation "com.squareup.okhttp3:logging-interceptor:$okhttp_version"
}

Lembre-se de adicionar as constantes retrofit_version e okhttp_version no
build.gradle do projeto:
buildscript {
    ext {
        // mantenha a ordem alfabética...
        okhttp_version = '3.12.0'
        retrofit_version = '2.5.0'
        ...
    }

Note que foram adicionadas outras duas dependências além da do Retrofit.
A primeira será responsável por converter a resposta do servidor utilizando a
biblioteca GSON. Entretanto, o Retrofit é flexível o suficiente para trabalhar
com outras bibliotecas que convertem os resultados em JSON para objetos
em memória como o Jackson (https://github.com/FasterXML/jackson) e o



Moshi (https://github.com/square/moshi). A outra dependência que foi
adicionada permite visualizar os logs das requisições HTTP, o que ajuda
bastante durante o desenvolvimento.

Definina agora a interface HotelHttpApi que mapeará as chamadas HTTP que
realizaremos para o webservice:
import dominando.android.hotel.model.Hotel
import retrofit2.Call
import retrofit2.http.*
 
interface HotelHttpApi {
    @GET("$WEB_SERVICE/{user}")
    fun listHotels(@Path("user") user: String): Call<List<Hotel>>
 
    @GET("$WEB_SERVICE/{user}/{hotelId}")
    fun hotelById(@Path("user") user: String,
                  @Path("hotelId") id: Long): Call<Hotel?>
 
    @POST("$WEB_SERVICE/{user}")
    fun insert(@Path("user") user: String,
               @Body hotel: Hotel): Call<IdResult>
 
    @PUT("$WEB_SERVICE/{user}/{hotelId}")
    fun update(@Path("user") user: String,
               @Path("hotelId") id: Long,
               @Body hotel: Hotel): Call<IdResult>
 
    @DELETE("$WEB_SERVICE/{user}/{hotelId}")
    fun delete(@Path("user") user: String,
               @Path("hotelId") id: Long): Call<IdResult>
 
    companion object {
        const val WEB_SERVICE = "webservice.php"
    }
}

Todos os métodos são anotados com @GET, @POST, @PUT e @DELETE de
acordo com a chamada HTTP que será realizada ao webservice de hotéis.
Perceba que é passado um parâmetro que identifica o usuário da aplicação.
Essa definitivamente não é a melhor estratégia de segurança, mas será
utilizada essa abordagem para simplificar o projeto.

O método listHotels(String) fará uma requisição do tipo GET para trazer todos
os hotéis cadastrados no servidor. A anotação @Path indica que o parâmetro



será passado como um segmento da URL, por exemplo:
http://<servidor>/webservice.php/nglauber onde “nglauber” é o usuário. O
retorno desse método é um objeto do tipo Call que permite realizar a
requisição, que pode ser de forma assíncrona ou assíncrona:
// Forma assíncrona
service.listHotels("algum_usuario").enqueue(
        object: Callback<List<Hotel>> {
            override fun onResponse(call: Call<List<Hotel>>?,
                                    response: Response<List<Hotel>>?) {
            }
            override fun onFailure(call: Call<List<Hotel>>?, t: Throwable?) {
            }
        }
)
// Forma síncrona
val response = service.listHotels("algum_usuario").execute()
if (response.isSuccessful) { /* sucesso */ } else { /* falha */ }

Será apresentado mais adiante como instanciar este serviço, uma vez que
ele é apenas uma interface. Para utilizá-lo na forma assíncrona, o método do
serviço é chamado (neste exemplo, o listHotels(String)) e, em seguida, o método
equeue(Callback). Se a requisição for bem-sucedida, o método
onResponse(Call,Response) será disparado, caso contrário, o onFailure(Call,Throwable).
Da maneira síncrona, simplesmente é chamado o método execute(), então a
resposta é obtida e assim é verificado se ela foi bem-sucedida por meio da
propriedade isSuccessful.

Voltando à explicação da API do webservice, o método hotelById(String,Long) é
bem similar ao listHotels(String), a única diferença é que ele adiciona mais um
parâmetro ao segmento: o id do hotel. Para salvar o hotel, o método
insert(String,Hotel) recebe um objeto Hotel que será convertido para JSON e será
enviado no corpo da requisição HTTP, e por essa razão, está anotado com
@Body. Os métodos update(String,Long,Hotel) e delete(String,Hotel) seguem a mesma
lógica.

Não foi utilizado nesse exemplo, mas a anotação @QueryString serve para
passar um parâmetro na URL, como, por exemplo:
http://<servidor>/webservice.php?nome=Glauber. Neste caso, está sendo
passado o parâmetro “nome” com o valor “Glauber”.



Acessando um web service
Feitos os devidos ajustes e definida a interface do Retrofit, deve-se criar a
classe que centralizará todas as operações relacionadas ao acesso ao web
service de hotéis. Adicione a classe HotelHttp ao projeto e deixe-a conforme a
seguir:
import dominando.android.hotel.repository.HotelRepository
 
class HotelHttp(private val service : HotelHttpApi,
                private val repository: HotelRepository,
                private val currentUser: String) {
 
    fun synchronizeWithServer() {
        if (currentUser.isBlank()){
            throw SecurityException("Usuário não autenticado")
        } else {
            sendPendingData()
            updateLocal()
        }
    }
    private fun sendPendingData() {
        val pendingHotels = repository.pending()
        pendingHotels.forEach { hotel ->
            when (hotel.status) {
                Status.INSERT -> {
                    val result = service.insert(currentUser, hotel).execute()
                    if (result.isSuccessful) {
                        hotel.serverId = result.body()?.id ?: 0
                        hotel.status = Status.OK
                        repository.update(hotel)
                    }
                }
                Status.DELETE -> {
                    val serverId = hotel.serverId ?: 0L
                    if (serverId != 0L) {
                        val result = service.delete(currentUser, serverId).execute()
                        if (result.isSuccessful) {
                            repository.remove(hotel)
                        }
                    } else {
                        repository.remove(hotel)
                    }
                }
                Status.UPDATE -> {



                    val result = if (hotel.serverId == 0L) {
                        service.insert(currentUser, hotel).execute()
                    } else {
                        service.update(currentUser, hotel.serverId ?: 0, hotel).execute()
                    }
                    if (result.isSuccessful) {
                        hotel.serverId = result?.body()?.id ?: 0
                        hotel.status = Status.OK
                        repository.update(hotel)
                    }
                }
            }
        }
    }
    private fun updateLocal() {
        val response = service.listHotels(currentUser).execute()
        if (response.isSuccessful) {
            val hotelsInServer = response.body()
                    ?.map { hotel ->
                        hotel.apply {
                            val id = hotel.id
                            hotel.serverId = id
                            hotel.id = 0
                        }
                    }
            hotelsInServer?.forEach { hotel ->
                hotel.status = Status.OK
                val localHotel = repository.hotelByServerId(hotel.serverId ?: 0)
                if (localHotel == null) {
                    repository.insert(hotel)
                } else {
                    hotel.id = localHotel.id
                    repository.update(hotel)
                }
            }
        }
    }
    companion object {
        const val BASE_URL = "http://192.168.64.2/hotel_service/"
    }
}

Foi declarada uma constante chamada BASE_URL no final da classe na qual é
definido o endereço do web service. Esse endereço deve ser o endereço IP da
sua máquina na rede local. Porém, caso esse web service esteja hospedado



em um servidor real na internet, o endereço apropriado deve ser utilizado.
No método synchronizeWithServer() os registros que estiverem pendentes (com

status diferente de OK) são enviados para o servidor por meio do método
sendPendingData(). Logo em seguida é feito o download dos dados do servidor
usando o método updateLocal() que atualiza o banco de dados local.

Para enviar ao servidor os registros locais, no início do método
sendPendingData() é feita uma busca pelos hotéis que tenham o status diferente de
OK no banco de dados local. Então essa lista é percorrida checando o status de
cada hotel:

• caso o status seja INSERT, o hotel será inserido no servidor invocando o
método insert(String,Hotel); em caso de sucesso, o status do registro e o id do
servidor são atualizados no banco de dados local;

• caso o status seja DELETE, é verificado primeiro se o hotel possui um id no
servidor. Caso tenha, o registro é excluído primeiramente no servidor com
o método delete(String,Hotel). Caso o hotel não possua um id de servidor, isso
significa que esse hotel foi incluído localmente, mas foi enviado para o
servidor, então ele só precisa ser excluído no banco de dados local;

• por fim, se o status for UPDATE, é checado se o hotel tem um id no
servidor; em caso positivo, atualizamos o registro no servidor por meio do
método update(String,Long,Hotel), senão inserimos no servidor com o método
insert(String,Hotel). Em ambos os casos, atualizaremos o registro local caso a
operação tenha sido realizada com sucesso no servidor.

No método updateLocal(), primeiramente é obtida a lista de hotéis cadastrada
no servidor invocando o método listHotels(String) do serviço web. Ao receber o
resultado, o id recebido é o do servidor, por isso foi utilizada a função map
para atribuir o id do servidor ao atributo serverId do objeto hotel e atribuir zero
ao id do hotel. Com isso, ao percorrer a lista, é verificado se no banco de
dados local existe um hotel com o serverId, em caso positivo, o registro é
atualizado e, caso contrário, é incluído.

Por fim, perceba que a referência para o HotelHttpApi é passada como
parâmetro no construtor. Como estamos utilizando o padrão de injeção de
dependências no projeto, devemos fornecer essas dependências no arquivo
AndroidModule.kt como apresentado a seguir:
import com.google.gson.GsonBuilder
import dominando.android.hotel.repository.http.HotelHttp



import dominando.android.hotel.repository.http.HotelHttpApi
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
 
val androidModule = module {
    ...
    single {
        val logging = HttpLoggingInterceptor()
        logging.level = HttpLoggingInterceptor.Level.BODY
        val httpClient = OkHttpClient.Builder()
        httpClient.addInterceptor(logging)
        val gson = GsonBuilder()
                .setLenient()
                .create()
        val retrofit = Retrofit.Builder()
                .baseUrl(HotelHttp.BASE_URL)
                .addConverterFactory(GsonConverterFactory.create(gson))
                .client(httpClient.build())
                .build()
        retrofit.create<HotelHttpApi>(HotelHttpApi::class.java)
    }
    factory {
        HotelHttp(service = get(),
                repository = get(),
                currentUser = "nglauber"
        )
    }
}

No bloco single o serviço é configurado indicando que será uma instância
única. Primeiramente foi criada uma instância de HttpLoggingInterceptor, que é
utilizada para exibir os logs das requisições feitas pelo Retrofit. Esse passo é
opcional, mas ajuda bastante, principalmente durante o desenvolvimento do
aplicativo. Foi instanciado também um objeto OkHttpClient que estabelecerá a
comunicação com o servidor. Perceba que o logging foi atribuído ao objeto
httpClient utilizando o método addInterceptor(Interceptor). Em seguida, também
inicializado um GsonBuilder que será utilizado para fazer as conversões de/para
JSON. A inicialização do serviço é feita pela classe Retrofit.Builder, onde é
passada a URL base do serviço, a instância do Gson e do OkHttpClient. Por fim,
com o método create(Class) a implementação da interface gerada pelo Retrofit é
criada. No bloco factory a classe HotelHttp é criada uma nova instância para ser



fornecida para quem for utilizá-la.
Note que está sendo informado um usuário fixo (“nglauber”), quando for

implementado o recurso de login do aplicativo no Capítulo 18 esse parâmetro
será substituído pelo usuário autenticado na aplicação.

Upload de arquivos
Um recurso muito interessante em uma aplicação mobile é o envio de
arquivos para um servidor web, em especial fotos tiradas pela câmera do
aparelho. Serviços como DropBox e Google Drive são exemplos clássicos
dessa abordagem. Será adicionado ao aplicativo de hotéis o recurso de
selecionar uma imagem da galeria de mídia do aparelho e enviá-la para o
servidor.

Um detalhe que o desenvolvedor mobile deve ter em mente é que quando
for preciso interagir com uma aplicação servidora, é necessário conhecer a
API web que está sendo disponibilizada. Nesse exemplo, será feita uma
requisição HTTP do tipo POST passando os campos id e hotel_photo; o primeiro
será o id do hotel no servidor, enquanto o segundo é o arquivo da foto.

Vá até o diretório onde está o web service e crie um subdiretório chamado
upload, onde ficarão as imagens que serão enviadas (lembre-se de adicionar
permissão de escrita nesse diretório). E no mesmo diretório onde encontra-se
o web service, adicione o arquivo upload.php listado a seguir:
<?php
if ($_FILES["hotel_photo"]["error"] > 0) {
    // Bad request
    http_response_code(400);
} else {
    $id = $_POST["id"];
    $image_path = "upload/" . $id ."___*";
    $files = glob($image_path); //obtendo todos os arquivos que começar com $image_path
    
    $file_destination = "upload/" . $id ."___". uniqid(rand(), true) .".jpg";
    move_uploaded_file(
        $_FILES["hotel_photo"]["tmp_name"],
        $file_destination);
    $servername = "localhost";
    $username = "root";
    $password = "";
    $conn = new mysqli($servername, $username, $password);



    if ($conn->connect_error) {
        die("Connection failed: " . $conn->connect_error);
    }
    $stmt = $conn->prepare(
        "UPDATE hotel_db.Hotel SET photo_url=? WHERE id=?");
    
    $stmt->bind_param("si", $file_destination, $id);
    $stmt->execute();
    $stmt->close();
    $jsonRetorno = array("id"=>(int)$id, "photoUrl"=> $file_destination);
    foreach($files as $file){
        if(is_file($file))
        unlink($file); //removendo os arquivos antigos daquele hotel (caso existam)
    }
    echo json_encode($jsonRetorno);
    http_response_code(200);
    $conn->close();
}
?>

Não é o objetivo entrar em detalhes da linguagem PHP, mas basicamente
esse script checa inicialmente se o arquivo enviado tem algum erro, e nesse
caso é retornado o código 400 para indicar uma requisição mal formada feita
pelo cliente.

Caso o arquivo esteja ok, uma variável chamada file_destination é declarada
para armazenar o caminho de onde o arquivo será salvo no servidor. Todos os
arquivos ficarão na pasta upload e o nome do arquivo será formado pelo id
do hotel no servidor concatenado com “___” e um valor aletório. Esse
formato facilita a alteração da imagem, já que antes de atualizar a tabela, são
excluídos todos os arquivos que comecem com o “id_do_hotel_no_servidor___”.

Perceba que não foi feita nenhuma validação de tamanho, extensão ou
formato do arquivo, mas obviamente isso deveria ser feito pelo
desenvolvedor backend PHP.

Será utilizada a biblioteca Glide para carregar e exibir a imagem do hotel,
por isso adicione as dependências no build.gradle do módulo app:
dependencies {
    ...
    implementation "com.github.bumptech.glide:glide:$glide_version"
    kapt "com.github.bumptech.glide:compiler:$glide_version"
}

Certifique-se de aplicar o plugin do kapt no início do arquivo e declarar a



constante glide_version no build.gradle do projeto: glide_version = '4.8.0'.
Serão feitas as modificações no aplicativo para adicionar o recurso de

upload de imagens, começando pela interface HotelHttpApi que terá um novo
método:
import okhttp3.MultipartBody
import okhttp3.RequestBody
 
interface HotelHttpApi {
    ...
    @Multipart
    @POST(UPLOAD)
    fun uploadPhoto(
            @Part("id") hotelId: RequestBody,
            @Part file: MultipartBody.Part
    ): Call<UploadResult>
 
    companion object {
        ...
        const val UPLOAD = "upload.php"
    }
}

Foi utilizada a anotação @Multipart para indicar que está sendo feita uma
requisição com várias partes, onde cada parte deve estar anotada com @Part. A
primeira parte é do tipo RequestBody que representa o corpo da requisição que é
o id do hotel, enquanto a segunda parte é o arquivo em si.

Como retorno do método, está sendo utilizada a classe UploadExecution que
armazena o id do registro que foi atualizado e o caminho da imagem no
servidor (ex.: upload/1___imagem.jpg). Adicione essa classe deixando-a no
pacote repository.http como a seguir:
sealed class UploadExecution
data class UploadResult(var id: Long, var photoUrl: String) : UploadExecution()
object NoUploadPerformed : UploadExecution()

Aqui foi criada uma sealed class chamada UploadExecution para determinar os
dois possíveis resultados da operação de upload: o sucesso com a classe
UploadResult e a falha com a NoUploadPerformed.

Agora serão feitas as mudanças na UI para poder selecionar a imagem
armazenada no aparelho, começando pelo arquivo de layout da tela de
cadastro. Faça as seguintes alterações no arquivo
res/layout/fragment_hotel_form.xml:



<ScrollView ...>
    <LinearLayout ...>
        ...
        <ImageView
            android:id="@+id/imgPhoto"
            android:background="@android:color/darker_gray"
            android:layout_width="200dp"
            android:layout_height="200dp"
            android:layout_gravity="center" />
    </LinearLayout>
</ScrollView>

O resultado deve ficar conforme a Figura 14.4.

Figura 14.4 – Tela de cadastro de hotéis.
Na tela de detalhes também será exibida a imagem do hotel. Modifique o

arquivo res/layout/fragment_hotel_details.xml de modo que fique como a
seguir:
<androidx.constraintlayout.widget.ConstraintLayout ... >
    <TextView
        android:id="@+id/txtName"
        app:layout_constraintBottom_toTopOf="@+id/imgPhoto"
        .../>
    <ImageView
        android:id="@+id/imgPhoto"
        android:layout_width="200dp"



        android:layout_height="0dp"
        android:layout_gravity="center"
        android:layout_marginEnd="8dp"
        android:layout_marginStart="8dp"
        android:layout_marginTop="8dp"
        android:background="@android:color/darker_gray"
        app:layout_constraintBottom_toTopOf="@+id/txtAddress"
        app:layout_constraintDimensionRatio="h,4:3"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintHeight_max="200dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/txtName" />
    <! -- apenas a propriedade abaixo mudou... -->
    <TextView
        android:id="@+id/txtAddress"
        app:layout_constraintTop_toBottomOf="@+id/imgPhoto" ... />
    <RatingBar
        android:id="@+id/rtbRating"... />
</androidx.constraintlayout.widget.ConstraintLayout>

Foram mostradas apenas as propriedades que foram modificadas. O
resultado deve ficar semelhante ao da Figura 14.5.

Figura 14.5 – Tela de detalhes do hotel.
Um ponto interessante a ressaltar nesse arquivo de layout é que está sendo

utilizado o recurso de aspect ratio do Constraint Layout, onde foi definido



que a imagem tem 200dp de altura e um aspecto de 4:3, e com isso a altura é
calculada automaticamente.

Uma pequena mudança na classe HotelFormViewModel é necessária. A
propriedade photoUrl será exposta como um LiveData para que a imagem do
hotel seja atualizada automaticamente na tela quando for selecionada:
class HotelFormViewModel: ViewModel() {
    val photoUrl = MutableLiveData<String>()
    ...
}

Na classe HotelFormFragment é onde terão as mudanças mais significativas
como podemos observar a seguir:
class HotelFormFragment : DialogFragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        ...
        if (hotelId > 0) {
            viewModel.loadHotel(hotelId).observe(viewLifecycleOwner, Observer { hotel ->
                this.hotel = hotel
                viewModel.photoUrl.value = hotel.photoUrl
                showHotel(hotel)
            })
        }
        viewModel.photoUrl.observe(viewLifecycleOwner, Observer { photoUrl ->
            photoUrl?.let {
                loadImage(it)
            }
        })
        imgPhoto.setOnClickListener {
            selectPhoto()
        }
    }
    private fun loadImage(url: String) {
        var imageUrl = url
        if (imageUrl.isNotEmpty()) {
            if (!imageUrl.contains("content://")) {
                imageUrl = HotelHttp.BASE_URL + url
            }
            Glide.with(imgPhoto.context).load(imageUrl).into(imgPhoto)
        }
    }
    private fun selectPhoto() {
        val intent = Intent(Intent.ACTION_OPEN_DOCUMENT)



        intent.addCategory(Intent.CATEGORY_OPENABLE)
        intent.addFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION)
        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        intent.type = "image/*"
        startActivityForResult(intent, REQUEST_GALLERY)
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (resultCode == Activity.RESULT_OK) {
            if (requestCode == REQUEST_GALLERY) {
                viewModel.photoUrl.value = data?.data.toString()
            }
        }
    }
    ...
    private fun saveHotel() {
        val hotel = this.hotel ?: Hotel()
        val hotelId = arguments?.getLong(EXTRA_HOTEL_ID, 0) ?: 0
        hotel.id = hotelId
        hotel.name = edtName.text.toString()
        hotel.address = edtAddress.text.toString()
        hotel.rating = rtbRating.rating
        hotel.photoUrl = viewModel.photoUrl.value ?: ""
        try {
            if (viewModel.saveHotel(hotel)) {
                dialog.dismiss()
            } else {
                errorInvalidHotel()
            }
        } catch (e: Exception) {
            errorSaveHotel()
        }
    }
    ...
    companion object {
        private const val REQUEST_GALLERY = 1
        ...
    }
}

Existem alguns pontos bem interessantes nesta classe. O método selectPhoto()
abrirá o aplicativo onde será possível selecionar fotos (normalmente a galeria
de mídia do aparelho). Após selecionar a foto, o método onActivityResult(int, int,
Intent) será disparado trazendo o caminho da imagem selecionada, o problema
é que esse caminho é um endereço para o content provider de mídias do



Android. Esse caminho será temporário até que o upload da imagem seja
feito para o servidor. No momento do updalod, será feita uma consulta para
obter o caminho real do arquivo. Com isso, além da permissão INTERNET que
já foi adicionada, será necessária a permissão READ_EXTERNAL_STORAGE para
acessar o provider de mídias (fotos, áudios e vídeos) no
AndroidManifest.xml:
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>

O último detalhe importante dessa classe é que o atributo photoUrl está sendo
atualizado antes de salvar o hotel no método saveHotel(Hotel).

Na HotelDetailsFragment apenas será exibida a imagem da mesma forma que foi
feito na tela de cadastro:
class HotelDetailsFragment : Fragment() {
    ....
    private fun showHotelDetails(hotel: Hotel) {
        this.hotel = hotel
        txtName.text = hotel.name
        txtAddress.text = hotel.address
        rtbRating.rating = hotel.rating
        var photoUrl = hotel.photoUrl
        if (photoUrl.isNotEmpty()) {
            if (!photoUrl.contains("content://")) {
                photoUrl = HotelHttp.BASE_URL + hotel.photoUrl
            }
            Glide.with(imgPhoto.context).load(photoUrl).into(imgPhoto)
        }
    }
    ...
}

Uma vez que o arquivo for selecionado, o caminho que será salvo no banco
será o da imagem local. No momento em que a sincronização estiver sendo
feita, o upload dessa imagem será realizado e o banco de dados local será
atualizado com a URL da imagem no servidor.

Essa lógica será abstraída em classes separadas. Para isso, crie o pacote
imagefiles dentro de repository e adicione a classe PictureToUpload:
import okhttp3.MediaType
import java.io.File
 
data class PictureToUpload(
        val imageFile: File,
        val fileType: MediaType



)
Essa classe foi definida apenas para abstrair a imagem que será enviada

para o servidor. Agora crie a interface FindHotelPicture:
import dominando.android.hotel.model.Hotel
 
interface FindHotelPicture {
    fun pictureFile(hotel: Hotel): PictureToUpload
}

Essa interface serve apenas para abstrair a conversão de um arquivo para
um objeto PictureToUpload que será usado para fazer o upload do arquivo.

Por fim, crie a implementação desta interface definindo a classe
ImageGalleryPictureFinder como a seguir:
import android.content.ContentResolver
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import dominando.android.hotel.model.Hotel
import okhttp3.MediaType
import java.io.File
import java.io.FileOutputStream
 
class ImageGalleryPictureFinder(
        private val uploadsDir: File,
        private val resolver: ContentResolver) : FindHotelPicture {
 
    override fun pictureFile(hotel: Hotel): PictureToUpload {
        val file = File(uploadsDir, "${hotel.id}.jpg")
        if (file.exists() && !file.delete())
            throw IllegalArgumentException("Cannot find picture for this hotel")
        else {
            val filePath = Uri.parse(hotel.photoUrl)
            saveImageFromUri(filePath, file)
            return PictureToUpload(
                    file,
                    MediaType.parse(resolver.getType(filePath))!!
            )
        }
    }
    private fun saveImageFromUri(origin: Uri, destination: File) {
        try {
            if (!destination.exists()) {
                destination.createNewFile()
            }



            val input = resolver.openInputStream(origin)
            val options = BitmapFactory.Options()
            options.inSampleSize = 4
            val bmp = BitmapFactory.decodeStream(input, null, options)
            val bytes = FileOutputStream(destination)
            bmp?.compress(Bitmap.CompressFormat.JPEG, 80, bytes)
        } catch (e: Exception) {
            throw IllegalStateException("Cannot process image file")
        }
    }
}

Para poder enviar um arquivo, é necessário o caminho real no sistema de
arquivos. Por essa razão, o método saveImageFromUri(Context,Uri,File) tenta carregar
a imagem a partir do content provider utilizando
contentResolver.openInputStream(Uri) e salva no sistema de arquivos
temporariamente. Perceba que a imagem é carregada com 80% da sua
qualidade original e com 25% do tamanho (inSampleSize = 4). Isso fará com que
o upload seja bem mais rápido. Obviamente, em um aplicativo real, devem-se
utilizar estratégias melhores de compressão de imagem.

Essa classe será utilizada na HotelHttp conforme a seguir:
class HotelHttp(private val service : HotelHttpApi,
                private val repository: HotelRepository,
                private val pictureFinder: FindHotelPicture,
                private val currentUser: String) {
    ...
    private fun sendPendingData() {
        val pendingHotels = repository.pending()
        pendingHotels.forEach { hotel ->
            when (hotel.status) {
                Status.INSERT -> {
                    val result = service.insert(currentUser, hotel).execute()
                    if (result.isSuccessful) {
                        hotel.serverId = result.body()?.id ?: 0
                        hotel.status = Status.OK
                        uploadHotelPhoto(hotel)
                        repository.update(hotel)
                    }
                }
                Status.DELETE -> {
                    val serverId = hotel.serverId ?: 0L
                    if (serverId != 0L) {
                        val result = service.delete(currentUser, serverId).execute()



                        if (result.isSuccessful) {
                            repository.remove(hotel)
                        }
                    } else {
                        repository.remove(hotel)
                    }
                }
                Status.UPDATE -> {
                    val result = if (hotel.serverId == 0L) {
                        service.insert(currentUser, hotel).execute()
                    } else {
                        service.update(currentUser, hotel.serverId ?: 0, hotel).execute()
                    }
                    if (result.isSuccessful) {
                        hotel.serverId = result.body()?.id ?: 0
                        hotel.status = Status.OK
                        uploadHotelPhoto(hotel)
                        repository.update(hotel)
                    }
                }
            }
        }
    }
    private fun uploadHotelPhoto(hotel: Hotel) {
        if (hotel.photoUrl.isNotEmpty() && hotel.photoUrl.startsWith("content:")) {
            val execution = uploadFile(hotel)
            when (execution) {
                is UploadResult -> {
                    Log.d("NGVL", "Upload efetuado com sucesso")
                }
                is NoUploadPerformed -> {
                    Log.e("NGVL", "Erro ao efetuar upload")
                }
            }
        }
    }
    private fun uploadFile(hotel: Hotel): UploadExecution? {
        return try {
            val (sourceFile, mediaType) = pictureFinder.pictureFile(hotel)
            val toUpload = RequestBody.create(mediaType, sourceFile)
 
            val body = MultipartBody.Part.createFormData("hotel_photo",
                sourceFile.name, toUpload)
            val description = RequestBody.create(MultipartBody.FORM,
                hotel.serverId.toString())



            val response = service.uploadPhoto(description, body).execute()
            if (response.isSuccessful) hotel.photoUrl =
                "$BASE_URL${response.body()?.photoUrl}"
            response.body()
                    ?.let { it }
                    ?: throw Throwable("Error at upload")
        } catch (error: Throwable) {
            NoUploadPerformed
        }
    }
    ...
}

No método sendPendingData(), após enviar os dados para o servidor, o upload
do arquivo é feito invocando o método uploadHotelPhoto(Hotel). Esse método
verifica se a propriedade photoUrl não está vazia e se inicia com “content:”, o que
indica que é o caminho de uma imagem local. Em caso positivo,
uploadFile(Hotel) é chamado.

No uploadFile(Hotel), após salvar a imagem no sistema de arquivos, cada parte
da requisição é criada. Primeiro, a parte do arquivo utilizando
MediaType.parse(String,File) onde é passado o mime type do arquivo (image/jpg
neste caso) e o arquivo em si. Essa parte estará no corpo da requisição que foi
instanciada utilizando MutipartBody.Part.createFormData(String,String,MultipartBody.Part).
Perceba que a primeira string que foi passada aqui deve ser a mesma que foi
definida no arquivo upload.php. Por fim, foi criada uma descrição para a
requisição e invocado o método uploadPhoto(RequestBody,MultipartBody.Part) do
serviço web. Se a solicitação for bem-sucedida, o atributo photoUrl do objeto
hotel é atualizado com a URL retornada pelo servidor.

Mais uma vez a classe HotelHttp está dependendo de outra classe, neste caso,
uma instância de FindHotelPicture. Essa dependência deve ser fornecida no
arquivo AndroidModule.kt:
val androidModule = module {
    ...
    factory {
        val context = get() as Context
        val resolver = context.contentResolver
        val uploadDir = context.externalCacheDir ?: context.cacheDir
        ImageGalleryPictureFinder(uploadDir, resolver) as FindHotelPicture
    }
    factory {
        HotelHttp(service = get(),



                repository = get(),
                pictureFinder = get(),
                currentUser = "nglauber"
        )
    }
}

A instância de ImageGalleryPictureFinder foi criada passando o diretório
temporário onde as imagens serão salvas e o objeto ContentResolver obtido por
meio do Context.

Apague a versão anterior da aplicação e execute-a novamente e já será
possível selecionar uma imagem da galeria de mídia do aparelho; entretanto,
o upload e a sincronia dos dados serão testadas no próximo capítulo
utilizando a classe HotelHttp a partir de um Service.

1 Se preferir, você pode baixar esse arquivo em https://github.com/nglauber/dominando_android3.



CAPÍTULO 15
Services

O Service é um componente do Android que permite realizar longas operações
em segundo plano sem uma interface gráfica associada, ou seja, ainda que o
usuário esteja em outro aplicativo ou não esteja usando o aparelho. Em um
serviço é possível, por exemplo, realizar operações de rede, escrever no
sistema de arquivos, acessar um content provider etc. Neste capítulo veremos
como declarar um serviço, entender seu ciclo de vida, iniciar e conectar-se a
ele.

Quando utilizar um serviço?
Um serviço deve ser utilizado quando é preciso executar algum código em
segundo plano mesmo que o usuário não esteja interagindo com a aplicação
ou mesmo com o aparelho.

Existem basicamente três tipos de serviços:
• Foreground – quando o serviço realiza alguma operação e ela é visível ao

usuário, normalmente por meio de uma notificação;
• Background – utilizado para realizar uma operação sem que o usuário

fique ciente. Entretanto, o Google estabeleceu uma série de limitações
para esse tipo de serviço a partir do Android Oreo (API Level 26);

• Bounded – é um serviço vinculado a uma activity, desta forma, ao encerrar a
activity o serviço é automaticamente destruído.

Para criar um serviço, basta definir uma classe que herde de Service e
implementar os seguintes métodos do seu ciclo de vida:

• onCreate() – chamado quando o serviço é criado;
• onStartCommand(Intent,int,int) – invocado sempre que o método startService(Intent) é

chamado;
• onBind(Intent) – retorna um objeto IBinder que estabelece um canal de



comunicação com uma activity; esse método deve obrigatoriamente ser
implementado (mesmo que retorne null). Ele é chamado quando essa
conexão é estabelecida ao invocar o método
bindService(Intent,ServiceConnection,int). Isso é particularmente útil quando se
deseja obter informações do serviço, e não apenas enviar comandos para
ele;

• onDestroy() – é invocado quando o serviço é destruído, e nele devem ser
liberados os recursos alocados.

Se um serviço é iniciado com a chamada ao método startService(Intent), ele
permanecerá ativo até que ele pare a si próprio chamando o método stopSelf()
ou que seja invocado o método stopService(Intent). Quando é realizada a conexão
como um serviço apenas por meio do método
bindService(Intent,ServiceConnection,int), o serviço só executará enquanto a activity
que o iniciou estiver ativa. A Figura 15.1 mostra o ciclo de vida de um
service.

Figura 15.1 – Ciclo de vida de um service. Original:
https://developer.android.com/guide/components/services.



Limitações no uso de serviços
A principal característica do serviço é executar em segundo plano sem que o
usuário fique ciente disso. Entretanto, essa sua característica pode gerar
grandes problemas de consumo de memória, bateria e processamento. Por
essa razão, a partir do Android 8 (API Level 26), o Google impôs algumas
limitações no uso de serviços em background, assim como fez com os
broadcast receivers.

Os serviços em foreground não tiveram nenhuma mudança significativa,
entretanto os serviços em background só poderão executar durante alguns
minutos após a aplicação ir para background. Quando esse tempo se esgotar,
o sistema encerrará o serviço como se o próprio serviço tivesse chamado o
método stopSelf().

Existem diversas formas para contornar essa nova limitação:
• ao invés de chamar startService() pode-se chamar startForegroundService() no

Android 8.0 (API 26), e a partir do Android Pie (API Level 28), deve ser
adicionada a permissão FOREGROUND_SERVICE;

• na grande maioria dos casos, é possível substituir um service por um
JobIntentService ou utilizar o WorkManager (que será visto no próximo capítulo);

• utilizar push notifications quando for necessário executar algo de acordo
com algum evento ocorrido no servidor (esse assunto será abordado no
Capítulo 18);

• postergar a execução para quando a aplicação entrar em foreground
novamente.

A intenção do Google com essas limitações é melhorar a performance do
sistema como um todo evitando processamentos desnecessários sem que haja
conhecimento do usuário.

Service versus IntentService
Para criar um serviço, existem duas opções: Service ou IntentService. A primeira é
a superclasse de todos os serviços e é preciso muita atenção ao usá-la, pois
todo o código é executado na thread principal. Dessa forma, se um código
demorar a executar, será exibida uma mensagem informando que a aplicação
não está respondendo (ANR – Application Not Responding). A opção aqui é
instanciar uma Thread para processar o código desejado:



class MeuServico : Service() {
    override fun onBind(intent: Intent): IBinder? {
        return null
    }
    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
        // Instancie e inicie uma Thread aqui...
        return super.onStartCommand(intent, flags, startId);
    }
}

Ao usar o IntentService, automaticamente uma nova thread é criada a cada
chamada feita ao service, e o código será processado no método
onHandleIntent(Intent). Caso sejam feitas várias chamadas a esse tipo de serviço,
elas serão enfileiradas e tratadas sequencialmente. Ao terminar todas as
requisições, o serviço é automaticamente finalizado:
class MeuServico : IntentService("minha_thread") {
    override fun onBind(intent: Intent): IBinder? {
        return null
    }
    override fun onHandleIntent(intent: Intent?) {
    }
}

Para ambos os tipos de serviço, é preciso declarar a respectiva classe no
AndroidManifest.xml:
<service android:name="pacote.da.app.MeuServico ">

Conhecidas as características básicas de um serviço, veremos como utilizá-
las na prática.

Utilizando a classe JobIntentService
No aplicativo de hotéis será utilizado um serviço para realizar a sincronização
de dados com o servidor. Para evitar problemas como as restrições de
serviços em background, será definida uma subclasse de JobIntentService, que
cria uma abstração sobre a API de serviços do Android.

Até o Android Nougat (API Level 24) essa classe invocará um IntentService
utilizando o método startService(Intent) para realizar o trabalho. No entanto, a
partir do Android Oreo (API Level 26) um JobIntentService é lançado com um
Job por meio do método enqueue(JobInfo,JobWorkItem) da classe JobScheduler.

No capítulo anterior foram criados todos os métodos que acessam o web
service de hotéis, mas eles não foram utilizados. Abra o projeto WebService e



crie uma nova classe chamada HotelIntentService e deixe-a da seguinte forma:
import android.content.Intent
import androidx.core.app.JobIntentService
import androidx.localbroadcastmanager.content.LocalBroadcastManager
import org.koin.android.ext.android.inject
 
class HotelIntentService: JobIntentService() {
 
    override fun onHandleWork(intent: Intent) {
        val hotelHttp: HotelHttp by inject()
        val it = Intent(ACTION_SYNC)
        val lbm = LocalBroadcastManager.getInstance(this)
        try {
            hotelHttp.synchronizeWithServer()
            it.putExtra(EXTRA_SUCCESS, true)
        } catch (e: Exception) {
            it.putExtra(EXTRA_SUCCESS, false)
            e.printStackTrace()
        } finally {
            lbm.sendBroadcast(it)
        }
    }
    companion object {
        const val ACTION_SYNC = "sync_hotels"
        const val EXTRA_SUCCESS = "success"
    }
}

Como toda a lógica da comunicação HTTP está encapsulada na classe
HotelHttp, o serviço ficou bem simples. A classe HotelIntentService herda de
JobIntentService e no método onHandleWork(Intent) apenas é chamado o método
synchronizeWithServer() da classe HotelHttp. Em seguida, um broadcast é disparado
informando o sucesso ou a falha da operação.

Lembre-se de adicionar a permissão ao AndroidManifest.xml e checar se a
declaração do serviço está desta forma:
<manifest ... >
    <application ... >
        ...
        <service
            android:name=".repository.http.HotelIntentService"
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:exported="false" />
    </application>



</manifest>
O próximo passo é fazer os ajustes na aplicação para utilizar o serviço. Para

chamar o serviço será utilizada uma abordagem bem comum, que é o gesto
de swipe-to-refresh. A ideia é fazer a sincronização com o servidor quando
puxarmos a lista de cima para baixo (como é feito nas aplicações do Gmail,
Twitter e Facebook). Isso pode ser feito com o componente SwipeRefreshLayout.
Crie o arquivo res/layout/fragment_list_hotel.xml e deixe-o conforme a
seguir:
<androidx.swiperefreshlayout.widget.SwipeRefreshLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/swipeRefresh"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ListView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@android:id/list"/>
</androidx.swiperefreshlayout.widget.SwipeRefreshLayout>

O SwipeRefreshLayout possui um ListView com o id @android:id/list, que é
obrigatório quando usa-se a classe ListFragment, que é o caso do HotelListFragment.
Faça as seguintes alterações nessa classe:
class HotelListFragment : ListFragment(),
        AdapterView.OnItemLongClickListener,
        ActionMode.Callback,
        SwipeRefreshLayout.OnRefreshListener {
 
    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        startSync()
    }
    override fun onAttach(context: Context?) {
        super.onAttach(context)
        LocalBroadcastManager.getInstance(requireContext())
          .registerReceiver(serviceReceiver, IntentFilter(HotelIntentService.ACTION_SYNC))
    }
    override fun onDetach() {
        super.onDetach()
        LocalBroadcastManager.getInstance(requireContext()).unregisterReceiver(serviceReceiver)
    }
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?): View? {



        return inflater.inflate(R.layout.fragment_list_hotel, container, false)
    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        swipeRefresh.setOnRefreshListener(this)
        swipeRefresh.setColorSchemeResources(
                R.color.colorPrimary,
                R.color.colorAccent,
                R.color.colorPrimaryDark)
    }
    override fun onRefresh() {
        startSync()
    }
    private fun startSync() {
        JobIntentService.enqueueWork(requireContext(),
                HotelIntentService::class.java, 0,
                Intent(context, HotelIntentService::class.java)
        )
    }
    private val serviceReceiver: BroadcastReceiver by lazy {
        object : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                swipeRefresh.isRefreshing = false
                if (!intent.getBooleanExtra(HotelIntentService.EXTRA_SUCCESS, false)) {
                    Toast.makeText(activity, R.string.error_sync,
                            Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
    ...
}

Essa classe implementa a interface OnRefreshListener para poder detectar
quando o gesto de swipe foi feito na lista. O serviceReceiver é criado para
receber o feedback do serviço e saber se a sincronização foi bem-sucedida ou
não. Estamos registrando esse broadcast receiver no onAttach(Context) e
desregistrando no onDetach(). No onCreateView(LayoutInflater,ViewGroup,Bundle)
estamos carregando o arquivo de layout e no onViewCreated(View,Bundle) é
definido listener do swiperefresh usando o método
setOnRefreshListener(OnRefreshListener) e o seu esquema de cores usando o método
setColorScheme(int...). Isso fará com que haja uma alternância dessas cores no
componente enquanto o processamento estiver sendo realizado.



O método onRefresh() é chamado quando o gesto de swipe é realizado. Ao
invocar o enqueue(Context,Class,Int,Intent) o serviço é iniciado para sincronizar os
dados. O texto usado para informar problemas ao sincronizar com o servidor
deve ser incluído no res/values/strings.xml:
<string name="error_sync">Erro ao sincronizar com o servidor.</string>

Lembre-se de que a comunicação com o servidor está sendo realizada em
texto plano e isso não é permitido por padrão a partir do Android Oreo. Por
essa razão, faça a seguinte mudança no AndroidManifest.xml:
<manifest ...>
    <application ...
        android:usesCleartextTraffic="true">

Abra o XAMPP, inicie o servidor Apache e o MySQL e execute a aplicação
Android. Adicione alguns registros1 e, em seguida, faça o gesto de swipe para
baixo. A sincronização com o servidor será feita e os dados aparecerão no
banco de dados no servidor. Para visualizar esses dados, utilize a ferramenta
phpMyAdmin que já vem com o XAMPP. Basta abrir o endereço
http://localhost:8080/phpMyAdmin e selecionar o banco hotel_db.

A aplicação já está utilizando o serviço e consegue sincronizar com os
dados vindos do servidor. Você perceberá que os novos dados serão exibidos
e salvos localmente.

A Figura 15.2 mostra nossa aplicação em execução ao utilizar o recurso de
swipe-to-refresh.



Figura 15.2 – Tela de listagem de hotéis com swipe-to-refresh.

Conectando-se a um serviço
O próximo exemplo demonstrará como criar um serviço e conectar-se a ele
por meio de um Binder. O aplicativo listará todos os arquivos de áudio do
aparelho, e ao selecionar um desses arquivos ele será reproduzido. Será
utilizado um serviço para que a música continue executando mesmo que o
usuário saia da aplicação. Crie um novo projeto e vamos lá.

Application Name MP3Service
Package Name dominando.android.mp3service
Activity Name Mp3Activity

A conexão com o serviço será estabelecida para obter informações sobre
ele. Para obter essas informações é preciso inicialmente criar uma interface
que definirá as ações que o serviço realizará, bem como as informações que
ele proverá. Adicione a interface Mp3Service e deixe-a desta forma:
interface Mp3Service {
    fun play(file: String)
    fun pause()
    fun stop()
    val currentSong: String?



    val totalTime: Int
    val elapsedTime: Int
}

O nome dos métodos já são bem explicativos, para tocar um arquivo de
áudio, será usado o método play(String) informando o caminho do arquivo no
cartão de memória. Para pausar e interromper a execução do áudio usaremos
os métodos pause() e stop() respectivamente. Perceba que estão sendo definidas
três propriedades na interface, currentSong, totalTime e ellapsedTime que retornarão
respectivamente o caminho do arquivo de música que está sendo executado
no momento, a duração total do arquivo e o tempo que já foi decorrido.

Para que um serviço possa estabelecer um canal de comunicação com uma
activity, ele deve retornar um objeto que implemente a interface
android.os.IBinder. A classe android.os.Binder implementa essa interface, então
vamos criar uma subclasse dela chamada Mp3Binder para que o nosso serviço
retorne uma instância dela:
import android.os.Binder
class Mp3Binder(val service: Mp3Service) : Binder()

Ao estabelecer a conexão com o serviço, uma instância do objeto Mp3Binder
será retornado, e com ele será obtida a instância de um Mp3Service que
permitirá chamar cada um dos métodos e propriedades que foram definidas
na interface.

Realize agora a implementação do Mp3ServiceImpl, que é o serviço
responsável por realizar na prática as operações de áudio. Crie um novo
serviço clicando com o botão direito sobre o pacote da aplicação e selecione a
opção New > Service > Service. Preencha o nome como Mp3ServiceImpl, clique
em Finish e deixe-o da seguinte forma:
import android.app.Service
import android.content.Intent
import android.media.MediaPlayer
import android.os.IBinder
import java.io.FileInputStream
 
class Mp3ServiceImpl : Service(), Mp3Service {
    private lateinit var mediaPlayer: MediaPlayer
    private var isPaused: Boolean = false
    private var currentFile: String? = null
 
    override fun onCreate() {
        super.onCreate()



        mediaPlayer = MediaPlayer()
    }
 
    override fun onBind(intent: Intent): IBinder? {
        return Mp3Binder(this)
    }
 
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        if (intent != null) {
            when (intent.getStringExtra(EXTRA_ACTION)) {
                ACTION_PLAY -> play(intent.getStringExtra(EXTRA_FILE))
                ACTION_PAUSE -> pause()
                ACTION_STOP -> stop()
            }
        }
        return super.onStartCommand(intent, flags, startId)
    }
 
    // Implementação da interface Mp3Service
    override fun play(file: String) {
        if (!mediaPlayer.isPlaying && !isPaused) {
            try {
                mediaPlayer.reset()
                val fis = FileInputStream(file)
                mediaPlayer.setDataSource(fis.fd)
                mediaPlayer.prepare()
                currentFile = file
            } catch (e: Exception) {
                e.printStackTrace()
                return
            }
        }
        isPaused = false
        mediaPlayer.start()
    }
 
    override fun pause() {
        if (mediaPlayer.isPlaying) {
            isPaused = true
            mediaPlayer.pause()
        }
    }
 
    override fun stop() {
        if (mediaPlayer.isPlaying || isPaused) {



            isPaused = false
            mediaPlayer.stop()
            mediaPlayer.reset()
        }
    }
    
    override var currentSong: String? = null
        get() = currentFile
 
    override var totalTime: Int = 0
        get() {
            return if (mediaPlayer.isPlaying || isPaused) {
                mediaPlayer.duration
            } else 0
        }
 
    override var elapsedTime: Int = 0
        get() {
            return if (mediaPlayer.isPlaying || isPaused) {
                mediaPlayer.currentPosition
            } else 0
        }
 
    companion object {
        val EXTRA_ACTION = "${Mp3ServiceImpl::class.java.`package`.name}.EXTRA_ACTION"
        val EXTRA_FILE = "${Mp3ServiceImpl::class.java.`package`.name}.EXTRA_FILE"
        val ACTION_PLAY = "${Mp3ServiceImpl::class.java.`package`.name}.ACTION_PLAY"
        val ACTION_PAUSE = "${Mp3ServiceImpl::class.java.`package`.name}.ACTION_PAUSE"
        val ACTION_STOP = "${Mp3ServiceImpl::class.java.`package`.name}.ACTION_STOP"
    }
}

A classe herda de Service e implementa a interface Mp3Service. No final da
classe foram declaradas algumas constantes que são usadas na Intent que
disparará esse serviço. Em seguida, foi definido um atributo do tipo
MediaPlayer, que é a classe responsável por executar arquivos de áudio e vídeo
no Android. Esse assunto será abordado novamente no Capítulo 25, mas é
importante conhecer um pouco do diagrama da Figura 15.3.



Figura 15.3 – Diagrama de estados da classe MediaPlayer. Fonte:
http://developer.android.com.

Ao criar um objeto MediaPlayer, ele se encontra no estado idle. Ao chamar o
método setDataSource(FileDescriptor) é definido o local da mídia que será
executada. Deve-se invocar o método prepare() para preparar o objeto para
execução. Feito isso, o player está pronto para tocar, então o método start()
deve ser chamado para iniciar a execução da música, alterando o estado do
mediaPlayer para started. Nesse estado é possível chamar os métodos pause() e
start() para pausar e tocar a música respectivamente, porém quando a música
terminar ou se for chamado o método stop(), o player mudará seu estado para
stopped. E uma vez nesse estado, é necessário invocar o método prepare()



novamente. Por fim, se o método reset() for chamado, ele voltará para o estado
de idle, e o release() inutilizará o objeto MediaPlayer.

Os atributos currentFile e isPaused indicam o caminho do arquivo que está
sendo executado no momento e se o áudio está em pausa.

Quando uma activity conecta-se a um serviço invocando o método bindService
(Intent), o onBind(Intent) é chamado, e nele é retornada uma instância do Mp3Binder.
Note que, para criar o binder, é preciso uma instância de Mp3Service; como o
Mp3ServiceImpl implementa essa interface, é passado this.

O método onStartCommand(Intent, int, int) é disparado sempre que é feita uma
chamada ao método startService(Intent). Nele checamos o parâmetro
EXTRA_ACTION, que indica qual operação com o áudio deve ser realizada:
tocar, pausar ou parar. De acordo com a ação, é chamado o método
correspondente: play(String), pause() ou stop().

Um detalhe importante aqui é o retorno do método onStartCommand(Intent,int,int),
que pode ser algum dos valores listados na Tabela 15.1.

Tabela 15.1 – Possíveis valores de retorno do método
onStartCommand(Intent, int, int)

Constante Propósito
START_STICKY É o retorno-padrão. Caso o processo do serviço seja finalizado, o sistema

tentará reiniciá-lo. Caso haja intents pendentes, elas serão entregues com a
intent apropriada ao método onStartCommand(Intent,int,int). Caso não haja
intents pendentes, o serviço será inicializado com uma intent nula.

START_NOT_STICKY Se o processo do serviço for finalizado e não houver intents pendentes, o
serviço será finalizado e não será recriado até que outra chamada seja feita a
ele.

START_REDELIVERY_INTENT Se o processo do serviço for finalizado, então a última intent será agendada
para ser executada quando o serviço for invocado novamente.

START_STICKY_COMPATIBILITY Versão de compatibilidade do START_STICKY (para as versões 1.5 e 1.6 do
(padrão) Android) que não garante que o serviço será chamado após ser finalizado.

O valor START_STICKY_COMPATIBILITY faz com que o serviço permaneça
ativo até que seja chamado o método stopService(Intent) de qualquer lugar da
aplicação, ou stopSelf() dentro do serviço.

Vamos falar agora da implementação dos métodos da interface Mp3Service.
No método play(String), é verificado se a música não está tocando nem pausada,
e nesse caso abrimos um FileInputStream para o caminho do arquivo passado
como parâmetro. Com esse objeto, o FileDescriptor é obtido por meio da
propriedade fd, que é passado como parâmetro para o método



setDataSource(FileDescriptor) do mediaPlayer. Em seguida, ao invocar o método
prepare(), o mediaPlayer é preparado para execução. Finalmente, o método start() é
chamado para iniciar a execução do áudio, e os atributos isPaused e currentFile
são atualizados.

O método pause() checa se o áudio está em execução com o isPlaying; se
estiver, o mediaPlayer é pausado e o atributo isPaused é atualizado. O método stop()
faz algo bem similar, mas é checado também se o áudio está pausado. Em
seguida, o mediaPlayer é interrompido (stop()) e reiniciado (reset()) para ser
utilizado para tocar outro áudio posteriormente. O caminho da música que
está atualmente em execução é obtido pela propriedade currentSong; já para
conseguir o tempo total do áudio temos totalTime, que recupera essa
informação com o mediaPlayer.duration, enquanto o tempo decorrido da execução
do áudio é retornado pela propriedade elapsedTime, que obtém essa informação
do mediaPlayer por meio da propriedade currentPosition. Certifique-se de que o
serviço está declarado no AndroidManifest.xml dentro da tag <application> como
a seguir:
<service
        android:name=".Mp3ServiceImpl"
        android:enabled="true"
        android:exported="true" >
</service>

Passaremos agora para a implementação da activity que acessará o serviço.
Altere o arquivo de layout res/layout/activity_mp3.xml e deixe-o conforme a
seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/linearLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <TextView
        android:id="@+id/txtSong"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        android:text="@null"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />



    <ProgressBar
        android:id="@+id/progressBar"
        style="?android:attr/progressBarStyleHorizontal"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/txtSong" />
    <TextView
        android:id="@+id/txtTime"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@null"
        app:layout_constraintEnd_toEndOf="@+id/progressBar"
        app:layout_constraintTop_toBottomOf="@+id/progressBar" />
    <Button
        android:id="@+id/btnPlay"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginStart="16dp"
        android:text="Play"
        app:layout_constraintEnd_toStartOf="@+id/btnPause"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/txtTime" />
    <Button
        android:id="@+id/btnPause"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Pause"
        app:layout_constraintEnd_toStartOf="@+id/btnStop"
        app:layout_constraintStart_toEndOf="@+id/btnPlay"
        app:layout_constraintTop_toTopOf="@+id/btnPlay" />
    <Button
        android:id="@+id/btnStop"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginEnd="16dp"
        android:text="Stop"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toEndOf="@+id/btnPause"
        app:layout_constraintTop_toTopOf="@+id/btnPause" />
    <ListView
        android:id="@+id/listView"
        android:layout_width="0dp"



        android:layout_height="0dp"
        android:layout_margin="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/btnPlay" />
</androidx.constraintlayout.widget.ConstraintLayout>

O txtSong exibirá o caminho do arquivo de áudio em execução, enquanto a
progressbar e o txtTime exibirão o tempo decorrido. Os botões btnPlay, btnPause e
btnStop servirão respectivamente para iniciar, pausar e parar a execução da
música. A listView exibirá a lista dos arquivos de áudio existentes no aparelho.

Agora deixe a Mp3Activity como a seguir:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.Manifest
import android.content.ComponentName
import android.content.ServiceConnection
import android.database.Cursor
import android.os.Handler
import android.os.IBinder
import android.provider.MediaStore
import android.view.View
import android.widget.AdapterView
import android.widget.SimpleCursorAdapter
import android.content.Intent
import android.content.pm.PackageManager
import android.text.format.DateUtils
import android.widget.Toast
import androidx.core.app.ActivityCompat
import androidx.loader.app.LoaderManager
import androidx.loader.content.CursorLoader
import androidx.loader.content.Loader
import kotlinx.android.synthetic.main.activity_mp3.*
 
class Mp3Activity : AppCompatActivity(),
        ServiceConnection,
        AdapterView.OnItemClickListener,
        LoaderManager.LoaderCallbacks<Cursor> {
 
    private var service: Mp3Service? = null
    private var music: String = ""
    private val columns = arrayOf(
            MediaStore.MediaColumns.DISPLAY_NAME,



            MediaStore.MediaColumns.DATA,
            MediaStore.MediaColumns._ID
    )
    private val adapter: SimpleCursorAdapter by lazy {
        SimpleCursorAdapter(
                this,
                android.R.layout.simple_list_item_2,
                null,
                columns,
                intArrayOf(android.R.id.text1, android.R.id.text2),
                0)
    }
    private lateinit var handler: Handler
    private lateinit var threadProgress: Runnable
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_mp3)
        handler = Handler()
        threadProgress = object : Thread() {
            override fun run() {
                updateScreen()
                if (service?.totalTime ?: 0 > service?.elapsedTime ?: 0) {
                    handler.postDelayed(this, 1000)
                }
            }
        }
        btnPlay.setOnClickListener { play() }
        btnPause.setOnClickListener { pause() }
        btnStop.setOnClickListener { stop() }
    }
    private fun updateScreen() {
        music = service?.currentSong ?: ""
        txtSong.text = music
        val elapsedTime = service?.elapsedTime ?: 0
        txtTime.text = DateUtils.formatElapsedTime(elapsedTime.toLong() / 1000)
        progressBar.max = service?.totalTime ?: 0
        progressBar.progress = elapsedTime
    }
    private fun play() {
        handler.removeCallbacks(threadProgress)
        if (music.isNotBlank()) {
            service?.play(music)
            handler.post(threadProgress)
        }



    }
    private fun pause() {
        service?.pause()
        handler.removeCallbacks(threadProgress)
    }
    private fun stop() {
        service?.stop()
        handler.removeCallbacks(threadProgress)
        progressBar.progress = 0
        txtTime.text = DateUtils.formatElapsedTime(0)
    }
    override fun onResume() {
        super.onResume()
        if (adapter.count == 0) {
            val permission = Manifest.permission.READ_EXTERNAL_STORAGE
            if (ActivityCompat.checkSelfPermission(this, permission) ==
                    PackageManager.PERMISSION_GRANTED) {
                LoaderManager.getInstance(this).initLoader(0, null, this)
            } else {
                ActivityCompat.requestPermissions(this, arrayOf(permission), 0)
            }
        }
        val intent = Intent(this, Mp3ServiceImpl::class.java)
        startService(intent)
        bindService(intent, this, 0)
    }
    override fun onRequestPermissionsResult(requestCode: Int,
            permissions: Array<out String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
            LoaderManager.getInstance(this).initLoader(0, null, this)
        } else {
            Toast.makeText(this, "Permissão negada.", Toast.LENGTH_SHORT).show()
            finish()
        }
    }
    override fun onPause() {
        super.onPause()
        unbindService(this)
        handler.removeCallbacks(threadProgress)
    }
    // ServiceConnection
    override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {
        service = (binder as Mp3Binder).service
        handler.post(threadProgress)



    }
    override fun onServiceDisconnected(name: ComponentName?) {
        service = null
    }
    // AdapterView.OnItemClickListener
    override fun onItemClick(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
        val cursor = parent?.getItemAtPosition(position) as? Cursor
        cursor?.let {
            music = cursor.getString(cursor.getColumnIndex(MediaStore.Files.FileColumns.DATA))
            stop()
            play()
        }
    }
    // LoaderManager.LoaderCallbacks<Cursor>
    override fun onCreateLoader(id: Int, args: Bundle?): Loader<Cursor> {
        return CursorLoader(this,
                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
                columns,
                MediaStore.Audio.AudioColumns.IS_MUSIC + " = 1",
                null,
                null
        )
    }
    override fun onLoadFinished(loader: Loader<Cursor>, data: Cursor?) {
        adapter.swapCursor(data)
        listView.adapter = adapter
        listView.onItemClickListener = this
    }
    override fun onLoaderReset(loader: Loader<Cursor>) {
        adapter.swapCursor(null)
    }
}

A activity implementa a interface ServiceConnection, que é necessária para
estabelecer a conexão com o serviço. Essa conexão é realizada no onResume()
por meio da chamada ao método bindService(Intent, ServiceConnection) e finalizada
no método onPause() ao invocar o método unbindService(ServiceConnection). Quando a
conexão com o serviço é estabelecida, o método
onServiceConnected(ComponentName,IBinder) é chamado, e nele a instância do
Mp3Service é obtida (que em tempo de execução é uma instância do
Mp3ServiceImpl) para realizar a comunicação com o serviço. Já o método
onServiceDisconnected(ComponentName) é chamado ao desconectar-se do serviço.

No onResume(), primeiramente é feita a verificação se a aplicação possui



permissão de acesso ao sistema de arquivos do aparelho. Caso possua, é
inicializada uma busca no content provider de mídia do aparelho para trazer
todas as músicas do dispositivo. Ao chamar o método
initLoader(Int,Bundle,LoaderCallbacks) da classe LoaderManager, a busca será iniciada no
método onCreateLoader(Int,Bundle) por meio da classe CursorLoader, onde é
informado que será feita uma busca por arquivos de áudio no cartão de
memória (MediaStore.Audio.Media.EXTERNAL_CONTENT_URI) e que sejam arquivos
de música. Quando a busca for concluída, o método onLoadFinished(Loader,Cursor)
será chamado, então foi usada uma instância da classe SimpleCursorAdapter do
próprio Android para exibir os resultados, em que cada linha mostrará o
nome da música e seu respectivo caminho no sistema de arquivos. Esses
valores estão armazenados nas colunas DISPLAY_NAME e DATA.

Para atualizar a duração da música é usada uma thread que é gerenciada por
um objeto Handler (que será explicada no próximo capítulo). Quando o botão
play for clicado, essa thread será executada e chamará o método post(Runnable)
do handler, mas perceba que dentro da threadProgress é feito o agendamento da
execução de uma nova instância dessa mesma thread para daqui a um
segundo, usando o método postDelayed(Runnable, long), fazendo uma espécie de
loop.

Adicione a permissão para ler o cartão de memória para que possamos listar
os arquivos de música:
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>

Execute a aplicação. O resultado pode ser observado na Figura 15.4.
Para tocar um áudio, clique em algum arquivo da lista. Em seguida, será

possível pausar ou parar a execução, ou ainda iniciar um novo áudio clicando
na lista novamente. Tente explorar alguns cenários como girar a tela e sair
pressionando back ou home e voltando para a aplicação.

Para testar essa aplicação, copie alguns arquivos de música (*.mp3, por
exemplo) para o cartão de memória do aparelho. Caso esteja testando no
emulador, você poderá fazer o upload de arquivos pela janela Device
Explorer do Android Studio (View > Tool Windows > Device File
Explorer), como mostra a Figura 15.5. Dependendo da versão do emulador,
pode ser que seja necessário ejetar o cartão de memória do emulador para que
seja feito um scan no sistema de arquivos de modo que o content provider de
áudio seja atualizado com os novos arquivos.



Figura 15.4 – Player de áudio que utiliza serviço em execução.

Figura 15.5 – Device File Explorer do Android Studio.
A aplicação deve estar funcionando bem, mas se o usuário iniciar um áudio

e sair da aplicação, pode ser um pouco inconveniente ter que voltar a ela para
poder pausar ou parar a música. O que podemos fazer para melhorar essa



experiência? No Capítulo 17 será visto como as notificações podem ajudar a
interagir com o aplicativo quando ele não estiver em foreground. Porém,
antes veremos como realizar agendamento de tarefas no Android.

1 Caso tenha problemas ao executar essa aplicação, desinstale a aplicação de hotel dos capítulos
anteriores, pois elas não têm as novas colunas que adicionamos.



CAPÍTULO 16
Agendamento de tarefas

Em alguns cenários é útil adiar a execução de uma determinada tarefa, ou,
ainda, executá-la periodicamente. A plataforma Android contém algumas
classes que permitem realizar o agendamento de tarefas. Neste capítulo será
apresentado como implementar esse comportamento por meio das classes
Handler e WorkManager.

Handler
Como foi visto no capítulo sobre HTTP, não é recomendado realizar longas
operações na UI Thread. Sendo assim, é preciso utilizar outra thread para
realizar o trabalho. Entretanto, aí surge um novo problema: essa nova thread
não pode atualizar a Main Thread. Para resolver esse problema, foi utilizada a
classe AsyncTask e posteriormente as coroutines. Porém, caso seja necessário
que uma tarefa fique executando por um longo período de tempo essas
abordagens não devem ser utilizadas; surge então a necessidade do uso da
classe Handler, que permite enviar e tratar mensagens vindas de outra thread
para serem executadas na UI Thread; indicar que determinada ação seja
executada repetidamente durante intervalos de tempo; ou que uma ação seja
executada em um momento específico.

A classe Handler já foi utilizada em alguns pontos no decorrer do livro. No
capítulo anterior, por exemplo, ela foi utilizada para atualizar a duração do
tempo decorrido da música que estava sendo executada.

Nesse capítulo serão vistos mais alguns detalhes sobre essa classe. Crie um
novo projeto para entender melhor o funcionamento do Handler.

Application Name Tasks
Package Name dominando.android.handler
Activity Name MainActivity

Altere o arquivo de layout res/layout/activity_main.xml deixando-o como a



seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".MainActivity"
    android:orientation="vertical">
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Start"
        android:id="@+id/btnStart" />
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/txtMessage"
        android:gravity="center"/>
</LinearLayout>

Nesse exemplo, ao clicar no botão, será iniciada uma Thread que enviará
mensagens para o Handler a cada 1 segundo. Ao receber essa mensagem, o
Handler atualizará o texto do TextView. Para isso faça as seguintes mudanças na
MainActivity:
import android.os.Bundle
import android.os.Handler
import android.os.Message
import androidx.appcompat.app.AppCompatActivity
import java.lang.ref.WeakReference
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    private val handler: MyHandler by lazy { MyHandler(this) }
    private var thread: MyThread? = null
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        btnStart.setOnClickListener {
            thread = MyThread(handler)
            thread?.start()
            btnStart.isEnabled = false
        }
    }



    override fun onPause() {
        super.onPause()
        handler.removeCallbacksAndMessages(null)
        thread?.interrupt()
    }
 
    private class MyThread(handler: Handler) : Thread() {
        private val handlerRef = WeakReference<Handler>(handler)
 
        override fun run() {
            super.run()
            handlerRef.get()?.let { handler ->
                for (i in 0 until 10) {
                    val message = Message()
                    message.what = MESSAGE_COUNT
                    message.arg1 = i
                    handler.sendMessage(message)
                    try {
                        Thread.sleep(1000)
                    } catch (e: InterruptedException) {
                        e.printStackTrace()
                    }
                }
                handler.sendEmptyMessage(MESSAGE_FINISH)
            }
        }
    }
 
    private class MyHandler(activity: MainActivity) : Handler() {
        val activityRef = WeakReference<MainActivity>(activity)
 
        override fun handleMessage(msg: Message) {
            super.handleMessage(msg)
            activityRef.get()?.let { activity ->
                if (msg.what == MESSAGE_COUNT) {
                    activity.txtMessage.text = "Contador: ${msg.arg1}"
                } else if (msg.what == MESSAGE_FINISH) {
                    activity.txtMessage.text = "Acabou!"
                    activity.btnStart.isEnabled = true
                }
            }
        }
    }
    companion object {
        private const val MESSAGE_COUNT = 1



        private const val MESSAGE_FINISH = 2
    }
}

Na classe MyThread foi utilizada uma estrutura for onde, a cada interação, uma
mensagem é enviada para o handler por meio do método sendMessage(Message).
Perceba que foi instanciado um objeto Message no qual são utilizadas as
propriedades what e arg1 que são do tipo int. A propriedade arg2, também do tipo
int, poderia ser utilizada, ou, ainda, obj, que permite passar qualquer objeto.
Outra opção seria passar um Bundle por meio da propriedade data. Ao terminar
o loop, uma mensagem que contém apenas o atributo what é enviada
utilizando o método sendEmptyMessage(int).

Essa classe está apenas fazendo um loop simples. Porém, imagine que ela
pudesse estar conectada por um socket a um servidor ou realizando outra
operação de I/O. A abordagem seria a mesma: enviar mensagens para a UI
thread por meio de um handler.

Já a classe MyHandler trata as mensagens vindas da MyThread. A cada
mensagem recebida, o método handleMessage(Message) será invocado, e nele o
texto do TextView é atualizado.

Um detalhe bem interessante de ambas as classes é que elas não estão
declaradas como inner class, o que quer dizer que ela não pertence à MainActivity,
e inclusive podem ser declaradas em arquivos separados se preferir. O
segundo detalhe é que foi utilizada WeakReference, que representa uma
referência fraca para um objeto, ou seja, se esse objeto não está sendo
referenciado em nenhum outro lugar, não é essa referência fraca que impedirá
que esse objeto seja coletado pelo Garbage Collector. Isso evita o vazamento
de memória (memory leaks), uma vez que a activity e o handler estão sendo
referenciados em outra thread. Deve-se fazer o mesmo ao utilizar uma
AsyncTask ou qualquer outra classe que utilize uma thread separada e possua
uma referência para a activity, fragment ou uma de suas views.

No método onPause() a thread é parada invocando o método interrupt() e
qualquer mensagem que esteja pendente para o Handler é cancelada por meio
do método removeCallbacksAndMessages().

Caso queira testar se o Handler é realmente necessário, tente alterar o texto do
TextView dentro do método run() da MyThread (lembre-se de colocá-la como inner
class MyThread). A aplicação fechará e a seguinte exceção será levantada:
Process: dominando.android.handler, PID: 18287



android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that
created a view hierarchy can touch its views.

    at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6891)
    at android.view.ViewRootImpl.invalidateChildInParent(ViewRootImpl.java:1083)
    at android.view.ViewGroup.invalidateChild(ViewGroup.java:5205)
    at android.view.View.invalidateInternal(View.java:13656)
    at android.view.View.invalidate(View.java:13620)
    at android.view.View.invalidate(View.java:13604)
    at android.widget.TextView.checkForRelayout(TextView.java:7355)
    at android.widget.TextView.setText(TextView.java:4480)
    at android.widget.TextView.setText(TextView.java:4337)
    at android.widget.TextView.setText(TextView.java:4312)
    at dominando.android.handler.MainActivity$MyThread.run(MainActivity.kt:35)

A mensagem de erro informa que apenas a thread que criou a view (no
caso, a UI thread) pode tocar, ou seja, alterar algo nas views.

Veja a seguir outro recurso interessante do Handler: a capacidade de agendar
a execução de tarefas:
import android.os.Bundle
import android.os.Handler
import androidx.appcompat.app.AppCompatActivity
import java.lang.ref.WeakReference
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    private lateinit var handler: Handler
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        handler = Handler()
        btnStart.setOnClickListener {
            btnStart.isEnabled = false
            handler.post(MyThread(this))
        }
    }
    override fun onPause() {
        super.onPause()
        handler.removeCallbacksAndMessages(null)
    }
    private class MyThread(activity: MainActivity) : Thread() {
        private val activityRef = WeakReference<MainActivity>(activity)
        private var count = 0
        override fun run() {
            super.run()



            activityRef.get()?.let { activity ->
                if (count < 10) {
                    count++
                    activity.txtMessage.text = "Contador: $count"
                    activity.handler.postDelayed(this, 1000)
                } else {
                    count = 0
                    activity.txtMessage.text = "Acabou!"
                    activity.btnStart.isEnabled = true
                }
            }
        }
    }
}

Em termos de funcionalidade, esse exemplo é igual ao anterior, mas a
implementação é bem diferente. O primeiro detalhe é que não é criada uma
subclasse de Handler. Ao clicar no botão, o método post(Runnable) do Handler é
invocado. Esse método faz com que o código do Runnable passado como
parâmetro seja executado na UI thread. Com certeza não faz muito sentido
esse método ser chamado na UI thread, mas se notarmos dentro da MyThread
está sendo utilizado o método postDelayed(Runnable,long) no qual é agendada a
execução de uma nova instância da MyThread para daqui a 1 segundo (ou seja,
1.000 milissegundos).

Além do postDelayed(Runnable, long), pode-se utilizar o método postAtTime(Runnable,
long) no qual se deve informar o momento exato em que se deseja que o
Runnable passado como parâmetro execute. É importante deixar claro que esse
método só será executado se a activity ainda estiver em execução.

Para agendar a execução de tarefas em background, é recomendado utilizar
a classe WorkManager que será vista ainda neste capítulo.

Agendamento de tarefas em background
O Android sempre possuiu um mecanismo para agendamento de tarefas em
background. Por meio da classe AlarmManager, é possível agendar que uma
activity, service ou broadcast receiver fosse executado periodicamente ou em
um momento específico.

Entretanto, se a tarefa a ser executada necessitasse de algum recurso ou
configuração do aparelho, como estar conectado a uma rede Wi-Fi ou o
aparelho estar conectado ao carregador, essa checagem tinha que ser feita



pelo desenvolvedor quando o alarme fosse disparado. Por essa razão, o
JobScheduler foi lançado no Android Lollipop (API Level 21) permitindo
agendar tarefas que são executadas apenas sob algumas condições.

Por possuir bibliotecas específicas para cada versão do Android, a
biblioteca Firebase JobDispatcher foi criada para abstrair essa complexidade para
o desenvolvedor. Basicamente, ela utiliza o AlarmManager para agendar tarefas
em aparelhos versões anteriores ao Lollipop e o JobScheduler para aparelhos
com Lollipop ou superior. O único pré-requisito é que o aparelho possua o
Google Play instalado.

WorkManager
O WorkManager é uma biblioteca de agendamento de tarefas assíncronas onde é
possível especificar a periodicidade e condições para que ela seja executada.
Ele faz parte do Jetpack e é compatível com o Android 4.0 (API Level 14) ou
superior. Internamente, o código executado pelo WorkManager é designado para
um JobScheduler, se o aparelho rodar Android Marshmallow (API Level 23) ou
superior; para o Firebase JobDispatcher, se o desenvolvedor adicionou a
dependência dessa biblioteca no build.gradle; ou para um AlarmManager em
último caso. Crie um novo projeto para entendermos melhor esse recurso.

Application Name Agendamento
Package Name dominando.android.agendamento
Activity Name MainActivity

Para utilizar o WorkManager, adicione as seguintes dependências no
build.gradle:
dependencies { ...
    implementation "android.arch.work:work-runtime:1.1.0-beta05"
    implementation "android.arch.work:work-firebase:1.0.0-alpha11"
}

O WorkManager faz parte do Jetpack, mas como podemos reparar, durante a
escrita desse livro essa biblioteca encontrava-se em versão beta.
Provavelmente quando você estiver lendo esse livro essa dependência já terá
mudado para androidx.work ou algo similar.

Para agendar uma tarefa primeiramente é preciso defini-la. Deve-se criar
uma classe que herde de Worker e implementar o método doWork(). Adicione a
classe MyWork e deixe-a como a seguir:



import android.content.Context
import androidx.work.Data
import androidx.work.Worker
import androidx.work.WorkerParameters
 
class MyWork (context: Context, workerParams: WorkerParameters)
    : Worker(context, workerParams) {
    override fun doWork(): Result {
        val firstName = inputData.getString(PARAM_FIRST_NAME)
        val outputData = Data.Builder()
                .putString(PARAM_NAME, "$firstName Glauber")
                .putInt(PARAM_AGE, 35)
                .putLong(PARAM_TIME, System.currentTimeMillis())
                .build()
        return Result.success(outputData)
    }
    companion object {
        const val PARAM_FIRST_NAME = "first_name"
        const val PARAM_NAME = "name"
        const val PARAM_AGE = "age"
        const val PARAM_TIME = "time"
    }
}

Temos alguns detalhes interessantes nessa classe. O primeiro é que um
Worker permite tanto receber parâmetros quanto retornar valores. Os
parâmetros são recebidos por meio da propriedade inputData. E para retornar
dados, basta criar um objeto da classe Data.Builder e passar como parâmetro
para o retorno do método. No nosso exemplo, utilizamos
Result.success(outputData). Tanto inputData quanto o outuputData armazenam os dados
no formato chave/valor onde o valor são tipos simples como: String, Int, Long,
Float, Double e Boolean.

O segundo detalhe é que o retorno do método doWork() deve ser Result.success()
para informar que o “trabalho” foi concluído corretamente, ou Result.failure()
caso algo dê errado. Existe ainda outro tipo de retorno: Result.retry(). Como o
próprio nome diz, ao retornar esse valor, o sistema tentará executar essa
classe novamente. Quando e como essa nova tentativa será realizada
dependerá de como o agendamento foi realizado baseado no método
setBackoffCriteria(BackoffPolicy,long,TimeUnit) da classe WorkRequest.Builder.

O agendamento de tarefas será apresentado a seguir, mas antes deixe o
arquivo de layout res/layout/activity_main.xml como segue:



<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp"
    tools:context=".MainActivity">
    <TextView
        android:id="@+id/txtStatus"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
    <TextView
        android:id="@+id/txtOutput"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
    <Button
        android:id="@+id/btnOneTime"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="One time" />
    <Button
        android:id="@+id/btnPeriodic"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Periodic" />
    <Button
        android:id="@+id/btnStop"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Stop" />
</LinearLayout>

Implementaremos agora o código da MainActivity no qual será feito o
agendamento da tarefa:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.lifecycle.Observer
import androidx.work.*
import kotlinx.android.synthetic.main.activity_main.*
import java.util.*
import java.util.concurrent.TimeUnit
 
class MainActivity : AppCompatActivity() {
 
    private val wm = WorkManager.getInstance()



    private var workId: UUID? = null
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        btnOneTime.setOnClickListener {
            val input = Data.Builder()
                    .putString(MyWork.PARAM_FIRST_NAME, "Nelson")
                    .build()
            val request = OneTimeWorkRequest.Builder(MyWork::class.java)
                    .setInputData(input)
                    .build()
            observeAndEnqueue(request)
        }
        btnPeriodic.setOnClickListener {
            val input = Data.Builder().putString(MyWork.PARAM_FIRST_NAME, "Nelson").build()
            val request = PeriodicWorkRequest.Builder(
                    MyWork::class.java, 5, TimeUnit.MINUTES)
                    .setInputData(input)
                    .build()
            observeAndEnqueue(request)
        }
        btnStop.setOnClickListener {
            workId?.let { uuid ->
                wm.cancelWorkById(uuid)
            }
            //wm.cancelAllWork()
        }
    }
    private fun observeAndEnqueue(request: WorkRequest) {
        wm.enqueue(request)
        workId = request.id
        wm.getWorkInfoByIdLiveData(request.id).observe(this, Observer { status ->
            txtStatus.text = when (status?.state) {
                WorkInfo.State.ENQUEUED -> "Enfileirado"
                WorkInfo.State.BLOCKED -> "Bloqueado"
                WorkInfo.State.CANCELLED -> "Cancelado"
                WorkInfo.State.RUNNING -> "Executando"
                WorkInfo.State.SUCCEEDED -> "Sucesso"
                WorkInfo.State.FAILED -> "Falhou"
                else -> "Indefinido"
            }
            txtOutput.text = status?.outputData?.run {
                """${getString(MyWork.PARAM_NAME)}
                   |${getInt(MyWork.PARAM_AGE, 0)}



                   |${getLong(MyWork.PARAM_TIME, 0)}""".trimMargin()
            }
        })
    }
}

Para obter a instância do WorkManager, basta invocar o método getInstance(). Ao
realizar o agendamento de uma tarefa, ele possui um identificador único do
tipo UUID. O atributo workId armazenará essa informação para que seja
possível cancelar a tarefa utilizando o método cancelWorkById(UUID) do
WorkManager. Se quiser cancelar todas as tarefas pendentes, pode-se chamar o
método cancelAllWork().

Foi visto na classe MyWork que é possível passar informações para o worker.
Isto é feito utilizando a classe Data.Builder.

É possível agendar tarefas com o WorkManager de duas formas: com o
OneTimeWorkRequest para que a tarefa seja executada apenas uma vez; ou de
forma periódica, utilizando PeriodicWorkRequest. Em ambos os casos a execução
acontece imediatamente após o agendamento, para definir um delay inicial,
isso só pode ser feito apenas a partir do Android M utilizando o método
setInitialDelay(Int,TimeUnit). Para o agendamento periódico, o intervalo mínimo é
de 5 minutos.

Com o WorkManager é possível acompanhar o status da execução da tarefa. O
método getWorkInfoByIdLiveData(UUID) retorna um LiveData<WorkInfo> e neste
exemplo ele foi utilizado para exibir o status em um TextView. Perceba que
existem vários estados e seus nomes já são bem autoexplicativos.

Um recurso muito interessante do WorkManager são as restrições que podem
ser definidas para que a tarefa seja executada. É possível definir, por
exemplo, que a tarefa só seja executada se o aparelho tiver acesso à internet.
Ou, ainda, que o aparelho esteja carregando a bateria. Isso pode ser feito por
meio da classe Constraints.Builder e os seus principais métodos estão listados na
Tabela 16.1.

Tabela 16.1 – Principais métodos da classe Constraints.Builder
Método Propósito

setRequireBatteryNotLow(boolean) Especifica se é necessário que o aparelho não esteja com o nível de bateria
baixo.

setRequiresCharging(boolean) Indica se é necessário que o aparelho esteja carregando a bateria.
setRequireNetworkType( Pode-se indicar o tipo de rede de que o Worker necessita. Pode ser
NetWorkType) NetworkType.NOT_REQUIRED, NetworkType.CONNECTED,



NetworkType.NOT_ROAMING, NetworkType.UNMETERED ou
NetworkType.UNMETERED.

setRequiresDeviceIdle(boolean) Define se o aparelho deve estar sem atividade no momento (idle). Disponível
apenas a partir do Android Marshmallow (API Level 23).

setRequiresStorageNotLow( Define se a tarefa deve ser executada se o aparelho estiver com a capacidade de
boolean) armazenamento baixa.

Para definir essas restrições, basta criar um objeto Constraints e adicionar a
requisição de agendamento utilizando o método setConstraints(Constraints) como a
seguir:
val constraints = Constraints.Builder()
        .setRequiredNetworkType(NetworkType.NOT_REQUIRED)
        .setRequiresBatteryNotLow(false)
        .setRequiresCharging(false)
        .setRequiresStorageNotLow(false)
        .build()
val request = OneTimeWorkRequest.Builder(MyWork::class.java)
        .setConstraints(constraints)
        .build()

Outro recurso muito interessante do WorkManager é o encadeamento de
chamadas. É possível definir que um worker seja executado após outro
worker terminar, ou, ainda, ter workers trabalhando em paralelo.

Vejamos este exemplo:
    class Worker1(context: Context, workerParams: WorkerParameters)
        : Worker(context, workerParams) {
        override fun doWork(): Result {
            Thread.sleep(2000)
            val outputData = Data.Builder()
                    .putString("title", "Dominando Android")
                    .build()
            return Result.success(outputData)
        }
    }
    class Worker2(context: Context, workerParams: WorkerParameters)
        : Worker(context, workerParams) {
        override fun doWork(): Result {
            Thread.sleep(1000)
            val outputData = Data.Builder()
                    .putString("subtitle", "com Kotlin")
                    .build()
            return Result.success(outputData)
        }
    }



    class Worker3(context: Context, workerParams: WorkerParameters)
        : Worker(context, workerParams) {
        override fun doWork(): Result {
            val s = inputData.run {
                getString("title") +" "+ getString("subtitle")
            }
            Log.d("NGVL", s)
            return Result.success()
        }
    }

A classe Worker1 retorna uma string com a chave title por meio do atributo
outputData. O Worker2 também retorna uma string, mas com a chave subtitle. O
Worker3, por sua vez, recebe esses valores como parâmetros por meio da
propriedade inputData. Assim, o agendamento dessas tarefas pode ser feito da
seguinte forma:
val request1 = OneTimeWorkRequest.Builder(Worker1::class.java).build()
val request2 = OneTimeWorkRequest.Builder(Worker2::class.java).build()
val request3 = OneTimeWorkRequest.Builder(Worker3::class.java).build()
wm.beginWith(listOf(request1, request2))
    .then(request3)
    .enqueue()

Com o método beginWith(WorkRequest) é definido que o Worker1 e o Worker2 serão
executados em paralelo, e quando ambos acabarem, o Worker3 será executado.
Dessa forma, será exibido no Logcat a seguinte mensagem:
dominando.android.agendamento D/NGVL: Dominando Android com Kotlin

Se quiser que outro worker execute antes, pode-se usar:
wm.beginWith(request0)
    .then(listOf(request1, request2))
    .then(request3)
    .enqueue()

Como foi possível observar, tanto o método beginWith(WorkRequest...) quanto o
método then(WorkRequest...) podem receber um ou vários objetos, e, nesses casos,
esses workers executariam em paralelo.

WorkManager no projeto de hotéis
No projeto de hotéis, foi utilizada a classe JobIntentService para realizar a
comunicação com o webservice. Quando o gesto de swipe de cima para baixo
é feito na tela de listagem, o serviço de sincronização é iniciado e a activity



fica aguardando a resposta por meio de um BroadcastReceiver.
Essa implementação funciona, mas além de não ser das mais elegantes, ela

ainda tem um problema: se a sincronização for iniciada e a tela for
rotacionada, a sincronização continua, mas sem nenhuma indicação para o
usuário. Para resolver esse problema, seria necessário obter o status do
serviço para saber se ele está em processo de sincronização ou não. Isso seria
possível, mas um pouco complicado de ser implementado. Como foi visto
anteriormente, o WorkManager permite saber o status atual da tarefa que está
sendo realizada.

Essa mudança será implementada no projeto de hotéis. Abra o projeto de
hotéis e adicione as dependências no build.gradle:
dependencies { ...
    implementation "android.arch.work:work-runtime:$workmanager_version"
    implementation "android.arch.work:work-firebase:$workmanager_fb_version"
}

Lembre-se de declarar as constantes workmanager_version = '1.0.0-beta05' e
workmanager_fb_version = '1.0.0-alpha11' no build.gradle do projeto.

Altere a classe HotelIntentService e deixe-a como a seguir:
import android.content.Context
import androidx.lifecycle.LiveData
import androidx.work.*
import org.koin.standalone.KoinComponent
import org.koin.standalone.inject
 
class HotelSyncWorker(context: Context, workerParams: WorkerParameters)
    : Worker(context, workerParams), KoinComponent {
    override fun doWork(): Result {
        val hotelHttp: HotelHttp by inject()
        return try {
            hotelHttp.synchronizeWithServer()
            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }
    companion object {
        fun start(): LiveData<WorkInfo> {
            val workManager = WorkManager.getInstance()
            val constraints = Constraints.Builder()
                    .setRequiredNetworkType(NetworkType.CONNECTED)



                    .build()
            val request = OneTimeWorkRequest.Builder(HotelSyncWorker::class.java)
                    .setConstraints(constraints)
                    .build()
            workManager.enqueue(request)
            return workManager.getWorkInfoByIdLiveData(request.id)
        }
    }
}

A classe foi renomeada para HotelSyncWorker. Como era de se esperar, a classe
herda de Worker, mas está implementando a interface KoinComponent (que não
requer nenhum método). Isso é necessário, pois quando uma dependência é
necessária em algum dos componentes do Android como Activity, Fragment
ou em um Service, basta usar o by inject() do Kotlin. Entretanto, quando é
preciso injetar a dependência em uma classe “normal”, é necessário
implementar essa interface.

O resto da implementação é bastante simples. A sincronização com o
servidor é realizada, se correr tudo bem, Result.success() é retornado, e
Result.failure() caso aconteça algum erro.

Também foi criado um método utilitário chamado start() onde a instância do
WorkManager é obtida para realizar o agendamento da sincronização. Uma
restrição foi estabelecida para que a sincronização só ocorra se o aparelho
tiver acesso à internet. Isso foi feito por meio da constante constraints. Por fim,
o agendamento é feito e um LiveData<WorkInfo> que representa o status da
requisição é retornado.

Remova a declaração do service do AndroidManifest.xml e faça as
seguintes mudanças na classe HotelListViewModel:
class HotelListViewModel(
        private val repository: HotelRepository
) : ViewModel() {
    var syncStatus: LiveData<WorkInfo>? = null
    ...
    fun startSync(): LiveData<WorkInfo>? {
        syncStatus = HotelSyncWorker.start()
        return syncStatus
    }
}

O atributo syncStatus foi adicionado para que o fragment possa observar a
mudança do status da sincronização com o servidor.



A última mudança necessária é na classe HotelListFragment:
import androidx.work.WorkInfo
import androidx.work.WorkInfo.State
class HotelListFragment : ListFragment(),
        AdapterView.OnItemLongClickListener,
        ActionMode.Callback,
        SwipeRefreshLayout.OnRefreshListener {
    // Remova o atributo serviceReceiver
    // Remova os métodos onAttach, onCreate e onDetach
    private val syncObserver = Observer<WorkInfo> {
        swipeRefresh.isRefreshing = (it.state == State.RUNNING
            || it.state == State.ENQUEUED)
    }
    private fun startSync() {
        viewModel.syncStatus?.removeObserver(syncObserver)
        viewModel.startSync()?.observe(viewLifecycleOwner, syncObserver)
    }
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        if (savedInstanceState == null) {
            startSync()
        } else {
            viewModel.syncStatus?.observe(viewLifecycleOwner, syncObserver)
        }
        ...
    }

As mudanças foram relativamente simples. O brocast receiver serviceReceiver
foi removido e como ele era registrado e desregistrado nos métodos onAttach()
e onDetach(), esses métodos também foram removidos.

O atributo syncObserver foi adicionado para receber as mudanças no status da
sincronização, exibindo e ocultando o indicador de progresso do
SwipeRefreshLayout de acordo com o status. Esse objeto é registrado no
onActivityCreated(Bundle) e no método onRefresh(), sendo que, neste último, o
método startSync() do viewModel é chamado para iniciar o processo de
sincronização.

Feitas essas modificações, execute a aplicação e ela deve continuar
funcionando da mesma forma que antes. Entretanto, corrigimos o problema
de rotacionar a tela durante o processo de sincronização.

Doze Mode



Com o intuito de melhorar o consumo da bateria, o Google introduziu o Doze
mode no Android 6.0. Um recurso do sistema operacional que restringe o
acesso à CPU e à rede enquanto o usuário não estiver utilizando o aparelho e
não estiver conectado a uma fonte de energia. Nesse momento o aparelho fica
com as seguintes restrições:

• o acesso à rede é interrompido;
• os alarmes agendados com o AlarmManager são adiados;
• o sistema não permite a execução de SyncAdapter e de JobScheduler.
Periodicamente, o Android sai do modo Doze por um breve período para

permitir que as aplicações executem suas tarefas que foram “bloqueadas”.
Tão logo o usuário mova o aparelho, ligue a tela ou conecte um carregador, o
Doze sai de cena e tudo volta ao normal.

Detectando aplicação em background
Vimos neste capítulo como agendar a execução de tarefas em background.
Entretanto, como saber se a aplicação está sendo utilizada no momento? Na
verdade, é possível descobrir se existe alguma activity do nosso aplicativo em
execução.

Quando foi apresentado o ciclo de vida de uma activity, foi visto que
quando ela é executada, os métodos onCreate(Bundle), onStart() e onResume() são
executados até que a activity se torne completamente visível. No entanto, os
métodos onPause(), onStop() e onDestroy() são chamados quando a activity é
destruída.

Podemos então ser notificados quando esses eventos acontecerem de uma
maneira geral dentro do aplicativo. Para isso, podemos fazer a seguinte
implementação:
import android.app.Activity
import android.app.Application
import android.os.Bundle
 
class MyApp : Application() {
    private val lifecycleCallback = LifecycleCallback()
    val inForeground = lifecycleCallback.activitiesStarted == 0
    
    override fun onCreate() {
        super.onCreate()



        registerActivityLifecycleCallbacks(lifecycleCallback)
    }
 
    inner class LifecycleCallback : Application.ActivityLifecycleCallbacks {
        var activitiesStarted = 0
        override fun onActivityStarted(activity: Activity?) {
            activitiesStarted++
        }
        override fun onActivityStopped(activity: Activity?) {
            activitiesStarted--
        }
        override fun onActivityPaused(activity: Activity?){}
        override fun onActivityResumed(activity: Activity?) {}
        override fun onActivityDestroyed(activity: Activity?) {}
        override fun onActivitySaveInstanceState(activity: Activity?, outState: Bundle?) {}
        override fun onActivityCreated(activity: Activity?, savedInstanceState: Bundle?) {}
    }
}

A classe MyApp herda de Application e nela foi registrado um listener para o
ciclo de vida de todas as activities da aplicação utilizando o método
registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks). Cada vez que uma activity é
iniciada (o onStart() é chamado) o atributo activitiesStarted é incrementado, e cada
vez que a activity é parada (o onStop() é chamado) o atributo é decrementado.
Com essa simples abordagem conseguimos, a partir de qualquer ponto do
aplicativo, saber se ele está em foreground ou em background simplesmente
usando:
val app = application as MyApp
if (app.inForeground) {
    // faça algo
}

Lembre-se de declarar a classe MyApp na tag <application> do
AndroidManifest.xml:
<application ...
    android:name=".MyApp"

O agendamento de tarefas é um recurso muito poderoso do Android, mas
como citamos anteriormente, devemos ter cuidado para não consumir bateria
e dados desnecessariamente.



CAPÍTULO 17
Notificações

As notificações permitem alertar o usuário que algum evento aconteceu
mesmo que ele não esteja utilizando a aplicação ou até mesmo o aparelho no
momento. Quando uma notificação é disparada, ela aparece na barra de status
do aparelho e pode ser visualizada ao deslizar essa barra para baixo. Ao clicar
em uma notificação, normalmente é exibida uma activity com mais detalhes
sobre o alerta que foi disparado. A correta utilização de notificações traz
diversos benefícios, como aumentar o engajamento do seu usuário, visto que
elas chamam a atenção e isso aumenta a possibilidade de o aplicativo ser
executado. Neste capítulo será visto como utilizar a API de notificações do
Android.

Atributos de uma notificação
As notificações estão presentes desde a primeira versão do Android, mas até
a versão 2.3 elas basicamente só exibiam um título, um texto de detalhe, o
ícone e a hora em que a notificação foi disparada, mas as notificações são tão
importantes que a cada nova versão do Android novos recursos são
adicionados. Por isso, para criar notificações compatíveis com todas as
versões do Android, deve-se utilizar a classe NotificationCompat.Builder da
biblioteca de compatibilidade, e ao invocar o método build() será criado um
objeto Notification. Caso a propriedade não exista na versão em que a aplicação
estiver executando, ela será simplesmente ignorada.

Para disparar uma notificação, deve-se chamar o método notify(int, Notification)
da classe NotificationManagerCompat. Embora seja opcional, na imensa maioria das
vezes, ao clicar em uma notificação, uma activity será iniciada, mas a partir
do Android 4.1 é possível incluir ações na notificação que podem disparar
outra activity ou realizar uma tarefa específica. Para ambos os casos, deve-se
criar um objeto da classe PendingIntent, que será disparado pelo usuário a partir



da notificação.
A Tabela 17.1 mostra as principais características que podem ser

adicionadas a uma notificação, o respectivo método da classe
NotificationCompat.Builder e a menor versão na qual o recurso está disponível.

Tabela 17.1 – Principais métodos da classe NotificationCompat.Builder



Como se pode observar, uma notificação deve conter minimamente o ícone
pequeno, o título e um texto de detalhamento. As demais informações são
opcionais.

Desabilitando notificações
A partir do Android 5 (Lollipop) o usuário pode desativar as notificações nas
configurações do aparelho. Essa opção está disponível nas configurações do
aparelho e podem ser diferentes dependendo da versão do Android ou do
fabricante do aparelho. Nessa tela é exibida uma lista dos aplicativos
instalados no aparelho; selecione qualquer aplicativo da lista e você notará
que é possível desabilitar as notificações do aplicativo como mostra a Figura
17.1.



Figura 17.1 – Desabilitando notificações.

Canais de notificação
Como vimos na seção anterior, a partir do Android Lollipop (API 21) o
usuário tem a opção de desabilitar as notificações de determinado aplicativo.
Entretanto, seria interessante que o usuário tivesse a opção de não receber
apenas alguns tipos de notificação do aplicativo. Por essa razão, foi
introduzido no Android Oreo (API 26) o recurso de canais de notificação,
onde é possível categorizar e agrupar as notificações do aplicativo, e desta
forma, desabilitar apenas alguns tipos de notificação.

Em um aplicativo de notícias, por exemplo, seria interessante criar um
canal para cada categoria de notícia. Assim, o usuário poderia desabilitar as
notificações sobre televisão, mas deixar habilitadas as notificações sobre
economia e tecnologia.

A partir do Android Oreo, ao deslizar a notificação para um dos lados, um
ícone de uma engrenagem é exibido. Ao clicar nesse ícone é possível
visualizar o canal ao qual essa notificação faz parte. Ao clicar no botão
Advanced, todos os canais de notificação do aplicativo são exibidos como
mostra a Figura 17.2.



A opção Allow notification dot permite exibir o badge no ícone do
aplicativo, que é uma bolinha que fica na parte superior direita.

Figura 17.2 – Canais de notificação no Android 8.

Criando notificações
Conhecidas as principais características de uma notificação, crie um novo
projeto para entender o funcionamento da API de notificações.

Application Name Notification
Package Name dominando.android.notification
Activity Name MainActivity

Adicione no res/values/strings.xml todas as strings que serão utilizadas no
projeto:
<resources>
    <string name="app_name">Meu App</string>
    <string name="notif_title">Dominando o Android</string>
    <string name="notif_text">Essa é uma notificação</string>
    <string name="notif_big_message">
        Esse é um exemplo notificação com um texto grande, mas que caberá devido ao estilo
    </string>
    <string name="notif_button_action">Ação</string>



    <string name="notif_reply_label">Responder</string>
    <string name="notif_reply_hint">Digite a mensagem</string>
    <string name="notif_reply_replied">Respondido!</string>
    <string name="notif_channel_name">Padrão</string>
    <string name="notif_channel_description">Canal padrão de notificações</string>
    <string name="notif_channel_urgent_name">Urgente</string>
    <string name="notif_big_inbox_title">Mensagens não lidas:</string>
    <string name="notif_big_inbox_message">Mensagem %1$d</string>
    <string name="notif_big_inbox_summary">Clique para exibir</string>
</resources>

Em seguida, deixe o arquivo de res/layout/activity_main.xml como a seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">
    <Button
        android:id="@+id/btnSimple"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Simples" />
    <Button
        android:id="@+id/btnTapAction"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Tap Action" />
    <Button
        android:id="@+id/btnBigText"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Big Text" />
    <Button
        android:id="@+id/btnActionButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Button Action" />
    <Button
        android:id="@+id/btnDirectReply"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Direct Reply" />
    <Button
        android:id="@+id/btnInbox"



        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Inbox" />
    <Button
        android:id="@+id/btnHeadsUp"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Heads up" />
</LinearLayout>

Adicione também dois ícones que serão utilizados no projeto clicando com
o botão direito sobre a pasta res/drawable e selecionando a opção New >
Vector Asset. Aqui foram utilizados os ícones “Favorite” (um coração) e
“Send” (uma seta para direita). Certifique-se de criar esse ícones na cor
branca. Isso é importante, pois o Android gerenciará a cor do ícone e do
background automaticamente, dependendo da versão por meio do método
setColor(int).

A lógica de criação das notificações estará centralizada no objeto
NotificationUtils que será criado logo adiante. Antes disso, faça as seguintes
mudanças na MainActivity:
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        btnSimple.setOnClickListener {
            NotificationUtils.notificationSimple(this)
        }
        btnTapAction.setOnClickListener {
            NotificationUtils.notificationWithTapAction(this)
        }
        btnBigText.setOnClickListener {
            NotificationUtils.notificationBigText(this)
        }
        btnActionButton.setOnClickListener {
            NotificationUtils.notificationWithButtonAction(this)
        }
        btnDirectReply.setOnClickListener {
            NotificationUtils.notificationAutoReply(this)



        }
        btnInbox.setOnClickListener {
            NotificationUtils.notificationInbox(this)
        }
        btnHeadsUp.setOnClickListener {
            NotificationUtils.notificationHeadsUp(this)
        }
    }
}

Nessa classe foram definidos apenas os eventos de clique dos botões, que
simplesmente chamam métodos da classe NotificationUtils que será criada na
próxima seção.

Notificação simples
A primeira notificação que será criada é a mais simples possível, com apenas
os elementos obrigatórios. Crie o objeto NotificationUtils e deixe como a seguir:
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.graphics.Color
import android.os.Build
import androidx.annotation.RequiresApi
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
 
object NotificationUtils {
    val CHANNEL_ID = "default"
 
    @RequiresApi(Build.VERSION_CODES.O)
    private fun createNotificationChannel(context: Context) {
        val notificationManager =
                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        val channelName = context.getString(R.string.notif_channel_name)
        val channelDescription = context.getString(R.string.notif_channel_description)
        val channel = NotificationChannel(
                CHANNEL_ID,
                channelName,
                NotificationManager.IMPORTANCE_DEFAULT).apply {
            description = channelDescription
            enableLights(true)
            lightColor = Color.GREEN



            enableVibration(true)
            vibrationPattern = longArrayOf(100, 200, 300, 400, 500, 400, 300, 200, 400)
        }
        notificationManager.createNotificationChannel(channel)
    }
 
    fun notificationSimple(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            createNotificationChannel(context)
        }
        val notificationBuilder = NotificationCompat.Builder(context, CHANNEL_ID)
                .setSmallIcon(R.drawable.ic_favorite)
                .setContentTitle(context.getString(R.string.notif_title))
                .setContentText(context.getString(R.string.notif_text))
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setColor(ActivityCompat.getColor(context, R.color.colorAccent))
                .setDefaults(Notification.DEFAULT_ALL)
        val notificationManager = NotificationManagerCompat.from(context)
        notificationManager.notify(1, notificationBuilder.build())
    }
}

A partir do Android 8, é obrigatória a criação de pelo menos um canal de
notificações. Para identificar esse canal, foi definida a constante CHANNEL_ID.
O método createNotificationChannel(Context) só será chamado se a aplicação estiver
sendo executada em aparelhos com Android Oreo (API 26) ou superior.
Nesse método o canal é criado por meio da classe NotificationChannel, passando
como parâmetro o id do canal, seu nome e importância (ver Tabela 17.2).

Em seguida, definem-se mais alguns atributos opcionais do canal, tais
como: descrição, cor do led do aparelho e vibração. Por fim, ao invocar o
método createNotificationChannel(NotificationChannel) da classe NotificationManager, o
canal será criado e, caso já exista, nada acontecerá.

A classe NotificationManager provê um série de métodos para gerenciar os
canais de notificação. É possível obter os canais do aplicativo por meio dos
métodos getNotificationChannel(String) ou getNotificationChannels(), em que no primeiro
você deve informar o id do canal que deseja obter, e o segundo retorna a lista
de todos os canais. Para excluir um canal, basta invocar o método
deleteNotificationChannel(String). Também é possível criar grupos de canais
declarando uma instância de NotificationChannelGroup passando um id e o nome
do grupo, e depois passar essa instância para o método
createNotificationChannelGroup(NotificationChannelGroup). Para associar o canal ao



grupo, basta passar o id do grupo ao criar o NotificationChannel por meio da
propriedade group.

Tabela 17.2 – Níveis de importância de um canal de notificações
Importância Propósito

IMPORTANCE_NONE Sem importância. A notificação não é exibida. O canal assume esse valor quando o
usuário desabilita as notificações desse canal.

IMPORTANCE_MIN Mínimo de importância. A notificação aparece na notification drawer, mas não na barra
de status. Não emite som.

IMPORTANCE_LOW Baixa importância. A notificação é exibida na barra de status e na notification drawer
mas não pode emitir som.

IMPORTANCE_DEFAULT Importância padrão. Mesmo que a anterior, mas pode emitir som.
IMPORTANCE_HIGH Importância alta. Mesma que a anterior, mas pode usar intents full screen.

O método createSimpleNotification(Context, String, int) dispara uma notificação com
os atributos obrigatórios: ícone, título e texto. Também são definidas uma cor
que será utilizada no ícone da notificação e das ações. Isso não é obrigatório,
mas, caso contrário, uma cor-padrão da plataforma será definida. Além disso,
a prioridade da notificação foi definida como padrão, a prioridade poderia
assumir um dos valores listados na Tabela 17.3.

Tabela 17.3 – Níveis de prioridade das notificações
Importância Propósito

PRIORITY_MIN Prioridade mínima. O sistema poderá exibir essa notificação menor ou no fim da lista de
notificações.

PRIORITY_LOW Prioridade baixa. O sistema poderá exibir essa notificação menor ou abaixo das notificações
com prioridade padrão.

PRIORITY_DEFAULT Prioridade padrão.
PRIORITY_HIGH Prioridade alta. O sistema poderá exibir essa notificação maior ou acima das notificações

com prioridade padrão.
PRIORITY_MAX Prioridade máxima. O sistema poderá exibir essa notificação maior ou no topo da lista de

notificações.

Com a classe NotificationManagerCompat a notificação é disparada utilizando o
método notify(int,Notification), onde o primeiro parâmetro é o id da notificação e o
segundo é a notificação em si. O id é muito importante, pois com ele
podemos cancelar uma notificação via código utilizando o método cancel(int)
do NotificationManagerCompat.

Se quiser executar a aplicação, comente os métodos inexistentes da
NotificationUtils que estão sendo chamados pela MainActivity. Ao clicar no botão
“Simples” a notificação será exibida conforme a Figura 17.3.



Figura 17.3 – Notificação Simples.

Ação de clicar na Notificação
No exemplo anterior, ao clicar na notificação que foi disparada, nada
acontece. Isso porque não foi definida a ação que deve ser realizada. Para
demonstrar esse comportamento, o botão btnTapAction chama o método
notificationWithTapAction(Context) da NotificationUtils:
object NotificationUtils {
    ...
    private fun getContentIntent(context: Context): PendingIntent? {
        val intent = Intent(context, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }
        return PendingIntent.getActivity(context, 0, intent, 0)
    }
 
    fun notificationWithTapAction(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            createNotificationChannel(context)
        }
        val notificationBuilder = NotificationCompat.Builder(context, CHANNEL_ID)
                .setSmallIcon(R.drawable.ic_favorite)



                .setContentTitle(context.getString(R.string.notif_title))
                .setContentText(context.getString(R.string.notif_text))
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setColor(ActivityCompat.getColor(context, R.color.colorAccent))
                .setDefaults(Notification.DEFAULT_ALL)
                .setContentIntent(getContentIntent(context))
                .setAutoCancel(true)
        val notificationManager = NotificationManagerCompat.from(context)
        notificationManager.notify(2, notificationBuilder.build())
    }
}

As únicas diferenças desse método para o que foi criado na seção anterior
são as chamadas aos métodos setContentIntent(PendingIntent) e setAutoCancel(boolean). O
segundo informa que a notificação deve ser removida automaticamente após
ser clicada. Já no primeiro método foi atribuída uma PendingIntent que será
executada quando a notificação for clicada. Perceba que é criada uma Intent
para a MainActivity.

Execute a aplicação e clique no botão btnTapAction e será exibida uma
notificação idêntica a da seção anterior, mas, ao clicar na notificação, a
MainActivity será exibida novamente e a notificação removida. A maneira mais
simples de corrigir esse problema é fazer a seguinte mudança no
AndroidManifest.xml:
<manifest ... >
    <application ...>
        <activity android:name=".MainActivity"
            android:launchMode="singleTop">

Com essa mudança, caso já exista uma instância da MainActivity sendo
executada, em vez de ser criada uma nova instância, o método
onNewIntent(Intent) será executado.

Assim, um cenário muito comum no uso de notificações é exibir a tela de
detalhes da aplicação em vez da tela principal. Por exemplo, ao clicar na
notificação de um email do Gmail, o conteúdo do email é exibido em vez da
tela principal. O mesmo acontece com o WhatsApp, ao clicar na notificação
de uma mensagem, o usuário é redirecionado automaticamente para a tela de
conversa. E em ambos os casos, ao clicar no botão de voltar, a tela principal
do aplicativo é exibida.

Esse comportamento será demonstrado neste exemplo. Crie uma nova
activity chamada DetailActivity e adicione apenas um TextView no seu arquivo de



layout res/layout/activity_detail.xml:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".DetailActivity">
 
    <TextView
        android:id="@+id/txtMessage"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

Agora, faça a seguinte mudança no AndroidManifest.xml:
<manifest ... >
    <application ...>
        <activity
            android:name=".DetailActivity"
            android:parentActivityName=".MainActivity" />

Foi configurado que a activity anterior à DetailActivity é a MainActivity. Isso será
importante para montar a pilha de activities ao clicar na notificação. A
DetailActivity é listada a seguir e apenas exibe o valor do parâmetro
EXTRA_MESSAGE passado via Intent:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import kotlinx.android.synthetic.main.activity_detail.*
 
class DetailActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_detail)
        txtMessage.text = intent.getStringExtra(EXTRA_MESSAGE)
    }
    companion object {
        const val EXTRA_MESSAGE = "message"
    }
}



Modifique o método getContentIntent(Context) da NotificationUtils para que fique
como a seguir:
import androidx.core.app.TaskStackBuilder
 
object NotificationUtils {
    ...
    private fun getContentIntent(context: Context): PendingIntent? {
        val detailsIntent = Intent(context, DetailActivity::class.java).apply {
            putExtra(DetailActivity.EXTRA_MESSAGE, "Via notificação")
        }
        return TaskStackBuilder.create(context)
                .addNextIntentWithParentStack(detailsIntent)
                .getPendingIntent(1, PendingIntent.FLAG_UPDATE_CURRENT)
    }
    ...
}

Nesse método, primeiramente foi definido um objeto Intent que iniciará a
classe DetailActivity. Em seguida, foi usada a classe TaskStackBuilder para controlar
a pilha de activities e garantir que, sempre que o usuário clicar na notificação,
a tela de detalhe será exibida, e ao pressionar a tecla back, o usuário será
redirecionado para a tela principal, mesmo que a aplicação esteja fechada. Ou
seja, ela faz com que nem a tela de lista nem a de detalhes sejam criadas
repetidamente ou fora de ordem.

Ao chamar o método addNextIntentParentStack(Class), a parent activity da activity
que estamos passando como parâmetro é adicionada à pilha. Por fim, o objeto
PendingIntent é obtido invocando o método getPendingIntent(int,int) onde é passado o
id da intenção e a FLAG_UPDATE_CURRENT indicando que, se já houver uma
PendingIntent para essa mesma activity (e com o mesmo id), ela deve ser
atualizada.

Execute a aplicação novamente e, ao clicar na notificação, a tela de detalhes
será exibida. E clicando no botão voltar, a tela principal da aplicação será
exibida.

Notificação com texto longo
Aplicativos de redes sociais ou de troca de mensagens exibem grandes
quantidades de texto. Por padrão, as notificações só exibem uma linha de
texto, mas existe um estilo especial de notificação para esse tipo de cenário.
Adicione o método notificationBigText(this) no objeto NotificationUtils e deixe-o como



a seguir:
object NotificationUtils {
    ...
    fun notificationBigText(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            createNotificationChannel(context)
        }
        val bigTextStyle = NotificationCompat
                .BigTextStyle()
                .bigText(context.getString(R.string.notif_big_message))
        val notificationBuilder = NotificationCompat.Builder(context, CHANNEL_ID)
                .setSmallIcon(R.drawable.ic_favorite)
                .setContentTitle(context.getString(R.string.notif_title))
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setColor(ActivityCompat.getColor(context, R.color.colorAccent))
                .setDefaults(Notification.DEFAULT_ALL)
                .setContentIntent(getContentIntent(context))
                .setAutoCancel(true)
                .setStyle(bigTextStyle)
        val notificationManager = NotificationManagerCompat.from(context)
        notificationManager.notify(3, notificationBuilder.build())
    }
}

Em vez de definirmos o texto da notificação diretamente, como foi feito
com o método setContentText(String), foi instanciado um BigTextStyle que foi
atribuído à notificação utilizando o método setStyle(Style). A notificação deve
ficar conforme a Figura 17.4.



Figura 17.4 – Notificação com texto em múltiplas linhas.

Notificações com botões de ação
Com mencionado, é possível incluir botões de ação em uma notificação.
Diferentemente do evento de clique na notificação, normalmente esses botões
realizam alguma ação em background. Por isso, crie a classe
NotificationActionReceiver apenas para demonstrar como tratar essas ações em
background:
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.widget.Toast
import androidx.core.app.NotificationManagerCompat
 
class NotificationActionReceiver: BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        Toast.makeText(context,
                intent.getStringExtra(EXTRA_MESSAGE),
                Toast.LENGTH_LONG).show()
        NotificationManagerCompat.from(context).cancelAll()
    }
    companion object {



        const val EXTRA_MESSAGE = "message"
    }
}

Essa classe exibe um Toast contendo o valor do parâmetro EXTRA_MESSAGE
passado via Intent, e, em seguida, remove da barra de notificações todas as
notificações da nossa aplicação chamando o método cancelAll() da classe
NotificationManagerCompat. Caso não deseje esse comportamento, basta passar o id
da notificação como parâmetro da Intent.

Certifique-se de declarar esta classe no AndroidManifest.xml:
<manifest ... >
    <application ...>
        <receiver android:name=".NotificationActionReceiver"/>

Feita a implementação do Broadcast Receiver que tratará a ação, adicione o
método a seguir no objeto NotificationUtils:
object NotificationUtils {
    ...
    fun notificationWithButtonAction(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            createNotificationChannel(context)
        }
        val actionIntent = Intent(context, NotificationActionReceiver::class.java).apply {
            putExtra(NotificationActionReceiver.EXTRA_MESSAGE, "Ação da notificação")
        }
        val pendingIntent = PendingIntent.getBroadcast(context, 0, actionIntent, 0)
        val notificationBuilder = NotificationCompat.Builder(context, CHANNEL_ID)
                .setSmallIcon(R.drawable.ic_favorite)
                .setContentTitle(context.getString(R.string.notif_title))
                .setContentText(context.getString(R.string.notif_text))
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setColor(ActivityCompat.getColor(context, R.color.colorAccent))
                .setDefaults(Notification.DEFAULT_ALL)
                .addAction(0, context.getString(R.string.notif_button_action),
                    pendingIntent)
                .setAutoCancel(true)
        val notificationManager = NotificationManagerCompat.from(context)
        notificationManager.notify(4, notificationBuilder.build())
    }
}

A única mudança que temos nesse método é a chamada ao método
addAction(Action) para adicionar a ação à notificação. Ao disparar essa
notificação ela ficará conforme a Figura 17.5.



Figura 17.5 – Notificação com botão de ação.

Notificações com digitação de texto
Outro recurso muito interessante adicionado ao Android 8 é a capacidade de
responder uma notificação com texto. Isso é muito utilizado em aplicativos
de mensagem e de redes sociais. Ele é adicionado como uma action,
semelhante ao que fizemos na seção anterior. Quando essa action for clicada,
ela se transformará em uma área na qual o usuário poderá digitar a mensagem
que desejar. Ao enviar a mensagem, a Intent que foi definida para a ação será
disparada. Após tratar a mensagem, a recomendação é que a notificação
anterior seja modificada para exibir um feedback para o usuário de que o
texto digitado foi tratado.

A classe ReplyReceiver será responsável por receber a mensagem digitada pelo
usuário. Crie essa classe e deixe-a como a seguir:
import android.content.BroadcastReceiver
mport android.content.Context
import android.content.Intent
import android.widget.Toast
import androidx.core.app.RemoteInput
 



class ReplyReceiver: BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val remoteInput = RemoteInput.getResultsFromIntent(intent)
        val message = remoteInput?.getCharSequence(EXTRA_TEXT_REPLY)
        if (message != null) {
            Toast.makeText(context, message, Toast.LENGTH_LONG).show()
        }
        val notificationId = intent.getIntExtra(EXTRA_NOTIFICATION_ID, -1)
        NotificationUtils.notificationReplied(context, notificationId)
    }
    companion object {
        const val EXTRA_TEXT_REPLY = "action_text_reply"
        const val EXTRA_NOTIFICATION_ID = "notif_id"
    }
}

O texto digitado pelo usuário está contido em um objeto Bundle que é obtido
ao invocar o método getResultsFromIntent(Intent) da classe RemoteInput. Após obter o
texto, o Toast é exibido. Em seguida, é chamado o método
notificationReplied(Context) do objeto NotificationUtils (que será criado logo a seguir),
de modo a fornecer um feedback ao usuário de que a mensagem foi tratada.

Certifique-se de declarar esta classe no AndroidManifest.xml:
<manifest ... >
    <application ...>
        <receiver android:name=".ReplyReceiver"/>

Agora adicione os métodos a seguir no objeto NotificationUtils:
object NotificationUtils {
    ...
    fun notificationAutoReply(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            createNotificationChannel(context)
        }
        val notificationId = 5
        val intent = Intent(context, ReplyReceiver::class.java).apply {
            putExtra(ReplyReceiver.EXTRA_NOTIFICATION_ID, notificationId)
        }
        val replyPendingIntent = PendingIntent.getBroadcast(
                context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT)
        // pacote androidx.core.app
        val remoteInput = RemoteInput.Builder(ReplyReceiver.EXTRA_TEXT_REPLY)
                .setLabel(context.getString(R.string.notif_reply_hint))
                .build()
        val action = NotificationCompat.Action.Builder(R.drawable.ic_send,



                context.getString(R.string.notif_reply_label), replyPendingIntent)
                .addRemoteInput(remoteInput)
                .build()
        val notificationBuilder = NotificationCompat.Builder(context, CHANNEL_ID)
                .setSmallIcon(R.drawable.ic_favorite)
                .setContentTitle(context.getString(R.string.notif_title))
                .setContentText(context.getString(R.string.notif_text))
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setColor(ActivityCompat.getColor(context, R.color.colorAccent))
                .setDefaults(Notification.DEFAULT_ALL)
                .addAction(action)
        val notificationManager = NotificationManagerCompat.from(context)
        notificationManager.notify(notificationId, notificationBuilder.build())
    }
    fun notificationReplied(context: Context, notificationId: Int) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            createNotificationChannel(context)
        }
        val timeout = 2000L
        val notificationBuilder = NotificationCompat.Builder(context, NotificationUtils.CHANNEL_ID)
                .setSmallIcon(R.drawable.ic_favorite)
                .setContentTitle(context.getString(R.string.notif_title))
                .setContentText(context.getString(R.string.notif_reply_replied))
                .setColor(ContextCompat.getColor(context, R.color.colorAccent))
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setDefaults(0)
                .setTimeoutAfter(timeout)
        val notificationManager = NotificationManagerCompat.from(context)
        notificationManager.notify(notificationId, notificationBuilder.build())
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
            Handler().postDelayed({ notificationManager.cancel(notificationId) }, timeout)
        }
    }
}

No método notificationAutoReply(Context) a notificação que nos dará a
possibilidade de digitar um texto é criada. Primeiramente é definida uma Intent
para a classe ReplyReceiver passando como parâmetro o id da notificação, pois
precisaremos atualizá-la e posteriormente removê-la. Em seguida, é
instanciado o objeto RemoteInput que representa o componente que permitirá
digitar na notificação. Note que é passada a constante EXTRA_TEXT_REPLY
definida na classe ReplyReceiver, pois ela representa a chave para obtermos o
texto digitado pelo usuário. Por fim, a ação é criada e a ação de responder é
adicionada a ela utilizando o método addRemoteInput(RemoteInput) da classe



NotificationCompat.Action.Builder.
O método notificationReplied(Context) tem um detalhe importante. Após exibir

essa notificação, não faz sentido ela continuar sendo exibida. Por isso,
utilizando o método setTimeoutAfter(long) foi definido um timeout de 2 segundos
para que ela seja excluída automaticamente.

Ao executar a aplicação e disparar essa notificação, ela deverá ficar similar
à Figura 17.6.

Entretanto, ao clicar na ação de responder, a notificação se transformará em
um espaço de digitação como pode ser observado na Figura 17.7.

E, finalmente, ao digitar uma mensagem e clicar no botão de enviar, a
notificação de feedback será exibida como na Figura 17.8.

Figura 17.6 – Notificação com ação de digitação.



Figura 17.7 – Digitando texto em uma notificação.

Figura 17.8 – Notificação de feeback de digitação.



Notificações agrupadas
É possível agrupar as notificações do mesmo tipo para evitar poluir a barra de
notificações do aparelho com mensagens do mesmo tipo. Um bom exemplo é
um aplicativo de emails, em que ao receber uma mensagem que ainda não foi
lida uma notificação é disparada e, ao ser clicada, o email em questão é
exibido. Assim, se houver mais de um email não lido, não se deve usar uma
notificação para cada mensagem, e sim utilizar um estilo de notificação
diferente. Crie o método a seguir no objeto NotificationUtils:
object NotificationUtils {
    ...
    fun notificationInbox(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            createNotificationChannel(context)
        }
        val number = 5
        val inboxStyle = NotificationCompat.InboxStyle()
        inboxStyle.setBigContentTitle(context.getString(R.string.notif_big_inbox_title))
        for (i in 1..number) {
            inboxStyle.addLine(context.getString(R.string.notif_big_inbox_message, i))
        }
        inboxStyle.setSummaryText(context.getString(R.string.notif_big_inbox_summary))
        val notificationBuilder = NotificationCompat.Builder(context, CHANNEL_ID)
                .setSmallIcon(R.drawable.ic_favorite)
                .setColor(ActivityCompat.getColor(context, R.color.colorAccent))
                .setContentTitle(context.getString(R.string.notif_title))
                .setContentText(context.getString(R.string.notif_text))
                .setDefaults(Notification.DEFAULT_ALL)
                .setNumber(number)
                .setStyle(inboxStyle)
        val nm = NotificationManagerCompat.from(context)
        nm.notify(8, notificationBuilder.build())
    }
}

Nesse método foi utilizado o estilo de notificação representado pela classe
NotificationCompat.InboxStyle, que permitirá que a notificação seja expandida
exibindo mais linhas (preferencialmente até cinco) de informações. O método
setSummary(String) exibe um texto na parte inferior da notificação em versões
antigas do Android, bem como o método setNumber(int), que exibe o número de
linhas que a notificação possui.

Execute a aplicação e a notificação deve ficar conforme a Figura 17.9.



Figura 17.9 – Notificação com itens agrupados.

Detectando a exclusão da Notificação
É possível detectar quando o usuário removeu uma notificação. Basta definir
a PendingIntent que será executada, passá-la como parâmetro para o método
setDeleteIntent(PendingIntent) do objeto NotificationCompat.Builder.

Crie a classe DeleteNotificationReceiver e deixe-a como segue:
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.widget.Toast
 
class DeleteNotificationReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        Toast.makeText(context, "Notificação excluída!", Toast.LENGTH_SHORT).show()
    }
}

Certifique-se de que esse broadcast receiver esteja declarado no
AndroidManifest.xml:
<manifest ... >
    <application ...>



        <receiver android:name=".DeleteNotificationReceiver"/>
Configure a notificação de modo que esse receiver seja chamado ao

excluirmos a notificação. Para isso, faça a seguinte mudança no método
notificationSimple(Context) do objeto NotificationUtils:
fun notificationSimple(context: Context) {
    ...
    val deletePit = PendingIntent.getBroadcast(
            context, 0,
            Intent(context, DeleteNotificationReceiver::class.java), 0)
    val notificationBuilder = NotificationCompat.Builder(context, CHANNEL_ID)
            .setDeleteIntent(deletePit)
            .setSmallIcon(R.drawable.ic_favorite)
            ...
    ...
}

A única mudança nesse método foi a declaração da PendingIntent apontando
para o broadcast receiver e sua atribuição à notificação por meio do método
setDeleteIntent(PendingIntent). Execute a aplicação novamente, clique no botão para
disparar a notificação simples. Ao excluir a notificação, o Toast declarado na
classe DeleteNotificationReceiver deve ser exibido.

Visibilidade das Notificações
Um detalhe significativo a partir do Lollipop é que as notificações aparecem
por padrão também na tela de bloqueio, conforme pode ser observado na
Figura 17.10.



Figura 17.10 – Tela de bloqueio com a notificação.
Dependendo da configuração do aparelho ou da versão do Android, o

conteúdo da notificação pode não ser exibido, mas isso pode ser configurado
por meio do método setVisibility(int), que pode assumir os seguintes valores:

• VISIBILITY_PUBLIC – a notificação e o seu conteúdo são exibidos na tela de
bloqueio;

• VISIBILITY_PRIVATE (padrão) – exibe a notificação na lockscreen, mas não
o seu conteúdo;

• VISIBILITY_SECRET – a notificação não aparecerá na tela de bloqueio.
Para configurar a visibilidade da notificação, basta utilizar o código a

seguir:
val notificationBuilder = NotificationCompat.Builder(context, CHANNEL_ID)
        ...
        .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)

Um detalhe importante é que é possível definir uma notificação para ser
exibida na tela de bloqueio e outra para ser exibida na barra de notificações.
Basta utilizar o método setPublicVersion(Notification) da classe
NotificationCompat.Builder.



Notificações Heads-up
Outra novidade do Android Lollipop foram as heads-up notifications.
Notificações que vieram para substituir as telas cheias que eram exibidas
repentinamente para o usuário (como o recebimento de chamada telefônica).
Esse tipo de notificação ocorre apenas quando a notificação chega e a tela do
aparelho está ativa. Para usufruir desse recurso, basta invocar o método
setFullScreenIntent(PendingIntent,boolean):
object NotificationUtils {
    ...
    val URGENT_ID = "urgent"
 
    @RequiresApi(Build.VERSION_CODES.O)
    private fun createNotificationUrgentChannel(context: Context) {
        val notificationManager =
                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        val channel = NotificationChannel(
                URGENT_ID,
                context.getString(R.string.notif_channel_urgent_name),
                NotificationManager.IMPORTANCE_HIGH)
        notificationManager.createNotificationChannel(channel)
    }
    fun notificationHeadsUp(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            createNotificationUrgentChannel(context)
        }
        val notificationBuilder = NotificationCompat.Builder(context, URGENT_ID)
                .setSmallIcon(R.drawable.ic_favorite)
                .setContentTitle(context.getString(R.string.notif_title))
                .setContentText(context.getString(R.string.notif_text))
                .setColor(ActivityCompat.getColor(context, R.color.colorAccent))
                .setDefaults(Notification.DEFAULT_ALL)
                .setAutoCancel(true)
                .setFullScreenIntent(getContentIntent(context), true)
        val notificationManager = NotificationManagerCompat.from(context)
        notificationManager.notify(1, notificationBuilder.build())
    }

As notificações desse tipo só são possíveis por canais de prioridade alta.
Por essa razão foi criado um novo canal no método
createNotificationUrgentChannel(Context). Fora esse detalhe, é uma notificação
idêntica às demais que criamos até aqui. Esse ajuste fará com que a sua
notificação fique de acordo com a Figura 17.11 ao ser disparada e a tela do



aparelho estiver ativa.

Figura 17.11 – Heads-up notification.
Para remover esse tipo de notificação basta deslizá-la para um dos lados.

Notificações customizadas
A barra de notificações permite que cada notificação possa exibir um arquivo
de layout completo, possibilitando inclusive a interação do usuário com os
componentes dessa notificação por meio da classe RemoteViews. Abra o
exemplo MP3Service do Capítulo 15, onde o music player que não permitia
pausar a música ao sair do aplicativo. Para resolver esse problema, será criada
uma notificação que exibirá a música em execução e os botões de play, pause
e stop. Crie o arquivo de layout res/layout/layout_notification.xml e deixe-o
como a seguir:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/white"
    android:padding="4dp"



    android:gravity="center_vertical">
    <TextView
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:id="@+id/txtMusic"
        android:ellipsize="marquee"
        android:textColor="@android:color/black"
        android:gravity="center_vertical"/>
    <ImageButton
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/btnPlay"
        android:src="@android:drawable/ic_media_play"/>
    <ImageButton
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/btnPause"
        android:src="@android:drawable/ic_media_pause" />
    <ImageButton
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/btnClose"
        android:src="@android:drawable/ic_menu_close_clear_cancel"/>
</LinearLayout>

Abra o arquivo Mp3ServiceImpl e faça as seguintes alterações:
class Mp3ServiceImpl : Service(), Mp3Service {
    // Os atributos não foram alterados
    // Os métodos não listados aqui não sofreram modificações
    override fun play(file: String) {
        // O restante do método permanece igual
        createNotification()
    }
    override fun stop() {
        // O restante do método permanece igual
        removeNotification()
    }
    private fun createNotification() {
        val channelId = "channel1"
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val notificationManager = getSystemService(
                    Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(
                    NotificationChannel(channelId,



                            getString(R.string.app_name),
                            NotificationManager.IMPORTANCE_LOW)
            )
        }
        val itPlay = Intent(this, Mp3ServiceImpl::class.java).apply {
            putExtra(EXTRA_ACTION, ACTION_PLAY)
            putExtra(EXTRA_FILE, currentFile)
        }
        val itPause = Intent(this, Mp3ServiceImpl::class.java).apply {
            putExtra(EXTRA_ACTION, ACTION_PAUSE)
        }
        val itStop = Intent(this, Mp3ServiceImpl::class.java).apply {
            putExtra(EXTRA_ACTION, ACTION_STOP)
        }
        val pitActivity = PendingIntent.getActivity(this, 0,
                Intent(this, Mp3Activity::class.java).apply {
                    addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)
                }, PendingIntent.FLAG_UPDATE_CURRENT
        )
        val pitPlay = PendingIntent.getService(this, 1, itPlay,
            PendingIntent.FLAG_UPDATE_CURRENT)
        val pitPause = PendingIntent.getService(this, 2, itPause, 0)
        val pitStop = PendingIntent.getService(this, 3, itStop, 0)
        val views = RemoteViews(packageName, R.layout.layout_notification)
        views.setOnClickPendingIntent(R.id.btnPlay, pitPlay)
        views.setOnClickPendingIntent(R.id.btnPause, pitPause)
        views.setOnClickPendingIntent(R.id.btnClose, pitStop)
        views.setOnClickPendingIntent(R.id.txtMusic, pitActivity)
        views.setTextViewText(R.id.txtMusic,
            currentFile?.substring((currentFile?.lastIndexOf(File.separator) ?: 0) + 1))
        val n = NotificationCompat.Builder(this, channelId)
                .setSmallIcon(R.mipmap.ic_launcher)
                .setContent(views)
                .setOngoing(true)
                .build()
        NotificationManagerCompat.from(this).notify(1, n)
    }
    private fun removeNotification() {
        NotificationManagerCompat.from(this).cancel(1)
    }
    ...
}

A mudança mais significativa foi a adição do método createNotification(). As
intents e pending intents são inicializadas para as ações dos botões. Em



seguida, o arquivo de layout da notificação é carregado utilizando a classe
RemoteViews. Toda a interação com as views da notificação devem ser feitas
com essa classe. O evento de clique dos botões é definido usando o método
setOnClickPendingIntent(int, PendingIntnt) e o texto do TextView com o método
setTextViewText(int, CharSequence).

Por fim, a view remota é atribuída à notificação com o método
setContent(RemoteViews) e para indicar que a notificação representa algo que está
acontecendo foi utilizado o setOngoing(boolean). Execute a aplicação e coloque
uma música para tocar. Você já perceberá que a notificação será disparada e
que não será possível excluí-la deslizando para o lado, isso porque foi
chamado o método setOngoing(true). Ao visualizar o notification drawer,
teremos algo similar à Figura 17.12.

Figura 17.12 – Notificação com layout customizado.
Agora podemos sair da nossa aplicação e controlar a execução da música

por meio da barra de notificações.
Como foi possível observar neste capítulo, as notificações, além de

ajudarem o usuário a lembrar-se de realizar determinada ação, aumentam o
engajamento do usuário com o aplicativo. E com uma API simples, mas
bastante sofisticada, você pode – e deve – utilizar a barra de notificações nos



seus aplicativos. Lembre-se sempre de seguir essas boas práticas em seus
aplicativos.



CAPÍTULO 18
APIs do Google

O Google disponibiliza diversas APIs interessantes para que aplicativos
Android possam interagir com os serviços da empresa. Neste capítulo serão
abordados alguns desses serviços, tais como: receber notificações de um
servidor web utilizando o Firebase Cloud Messaging (FCM); assitir a vídeos
com a YouTube API; adicionar propagandas com AdMob; e fazer login com
o Google Sign-In.

Google Sign-In
A menos que seja muito importante para sua aplicação, não faz muito sentido
implementar um mecanismo de login “do zero”, pois, além de demandar
muito esforço, seria mais uma senha que o usuário teria que lembrar. Em vez
disso, é recomendado em muitas situações realizar o login com contas de
redes sociais. Como normalmente é utilizada uma conta Google nos
dispositivos Android, será visto como realizar o login utilizando essa
credencial.

Nesta seção será implementada a tela de login do aplicativo de hotéis.
Entretanto, primeiramente é necessário adicionar este projeto no Google APIs
Console, ferramenta onde devem ser registrados os aplicativos que utilizam
as APIs serviços de Cloud do Google. Ao registrar o aplicativo nessa
ferramenta, o Google terá conhecimento de qual aplicativo está acessando
seus servidores e, consequentemente, quem é o responsável por ele. Acesse
https://console.developers.google.com, faça o login com sua conta Google e
será exibida a tela da Figura 18.1.

Na parte superior, caso já exista algum projeto associado a esta conta,
aparecerá o nome do último projeto selecionado. Caso não possua nenhum
projeto, aparecerá diretamente a opção para criar um novo projeto. Clique na
parte superior, em seguida, clique no botão de Create New Project. A tela da



Figura 18.2 será exibida.
Dê o nome que desejar ao seu projeto. Aqui chamaremos de “dominando-

android-3”, perceba que será criado automaticamente um id único para o
projeto. Em seguida, clique em Create, aguarde alguns instantes e seu projeto
estará criado.

Figura 18.1 – Dashboard do Google APIs Console.



Figura 18.2 – Criando um novo projeto no Google APIs Console.
Será exibido novamente o dashboard mostrado na Figura 18.1, mas agora

com o projeto recém-criado selecionado na parte superior. Certifique-se de
que esse projeto está selecionado e então acesse a opção Credentials no
painel do lado esquerdo e será exibida a tela da Figura 18.3.



Figura 18.3 – Tela de credenciais no Google APIs Console.
Nessa tela criaremos as credenciais para que nosso aplicativo acesse os

serviços do Google. Clique no botão Create credentials e serão exibidas três
opções de credenciais: API key, OAuth client ID e Service account key.

Selecione a opção a OAuth client id e na tela em que for exibida, clique no
botão Configure consent screen e será exibida a tela da Figura 18.4.

Figura 18.4 – Configurações da “tela de consentimento” no Google APIs
Console.

Essas informações são necessárias para a “Tela de Consentimento” que é
exibida ao usuário sempre que for necessário solicitar acesso a seus dados. É
muito importante preencher essa tela com os dados corretos em um projeto
real. Para este exemplo, preencha apenas os dados obrigatórios como
mostrado na figura e clique em Save.

Após salvar os dados da tela de consentimento, a tela da Figura 18.5 será
exibida. No campo o Application Type selecione “Android”. Então, no
campo Name dê um nome para a chave que será gerada, por exemplo,
“Android OAuth”.



Figura 18.5 – Gerando a API key no Google APIs Console.
Logo a seguir, existem mais dois campos: Signing-certificate fingerprint e

Package name. No segundo campo, coloque o nome do pacote da aplicação
android, que para o aplicativo de hotéis seja dominando.android.hotel. Na próxima
seção será visto como preencher o primeiro campo.

Gerando a chave de acesso
Toda aplicação Android antes de ser instalada no aparelho é assinada
utilizando um certificado digital. Enquanto a aplicação está sendo
desenvolvida, a aplicação é assinada com uma chave de debug localizada em
DIRETORIO_DO_USUARIO/.android/debug.keystore do computador (onde
DIRETORIO_DO_USUARIO é a pasta do usuário no sistema operacional).
No Windows, por exemplo, essa pasta fica em C:\Users\seu_usuario,
enquanto no Mac OS X ela se encontra em /Users/seu_usuario. Para publicar
uma aplicação no Google Play deve ser gerada uma chave única e usá-la para
assinar a aplicação antes de publicá-la. Esse assunto será abordado no
Capítulo 32.

Para utilizar várias APIs do Google como a do Google Maps (que será



estudado no próximo capítulo) e a do YouTube, é preciso adicionar uma
chave à aplicação. A chave é gerada a partir de uma forma curta de
certificado, chamado SHA-1 fingerprint. Para obter essa informação, abra o
terminal (ou prompt de comando do Windows) e digite o comando keytool
(esse executável vem junto do Java Development Kit). Se o comando for
reconhecido, está tudo certo; caso contrário, o diretório bin do JDK
provavelmente não deve estar na variável de ambiente PATH do seu sistema
operacional. Você pode adicionar esse caminho ao PATH ou simplesmente ir
até o diretório onde o JDK está instalado usando o comando a seguir:
cd diretorio_do_jdk/bin

Agora localize o caminho do arquivo debug.keystore do seu computador e
use-o no comando a seguir:

• Para OS X e Linux:
keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -

keypass android
• Para Windows:

keytool -list -v -keystore "%USERPROFILE%\.android\debug.keystore" -alias
androiddebugkey -storepass android -keypass android

Você obterá um resultado similar ao seguinte:
Alias name: androiddebugkey
Creation date: Nov 12, 2016
Entry type: PrivateKeyEntry
Certificate chain length: 1
Certificate[1]:
Owner: C=US, O=Android, CN=Android Debug
Issuer: C=US, O=Android, CN=Android Debug
Serial number: 1
Valid from: Sat Nov 12 00:35:46 BRT 2016 until: Mon Nov 05 00:35:46 BRT 2046
Certificate fingerprints:
    MD5: FD:71:56:F0:9B:6F:7F:E2:C8:BC:ED:0F:7A:94:0A:65
    SHA1: BA:4F:2B:1B:8A:D5:FD:5A:9A:89:D5:B6:39:36:2C:50:1B:F9:FB:73
    SHA256: 3:A4:2B:4D:91:BE:91:16:4D:E6:37:22:56:FA:42:72:FB:0B:A3:35:C3:2C:AC:90:91:F3
    Signature algorithm name: SHA1withRSA
    Version: 1

A linha que começa com SHA1 é o SHA-1 fingerprint, que será usado para
gerar a chave.

Outra maneira de conseguir essa informação é no próprio Android Studio.
Na janela do Gradle, selecione a tarefa Tasks > Android > signinReport. Se



seu projeto não contiver erros, o mesmo output visto anteriormente será
exibido na janela Gradle Console.

Voltando para a criação da chave de acesso do Google APIs Console,
preencha o campo SHA-1 certificate fingerprint com o SHA-1 fingerprint
retornado pelo comando keytool. Clique no botão Create e a chave estará
criada.

Integrando o Google Sign-In no app de hotéis
Para implementar o login no aplicativo de hotéis será utilizada a Google
Sign-In API. Faça uma cópia do projeto de web services do Capítulo 14,
renomeie o diretório para GoogleAPIs, remova o arquivo WebService.iml,
apague também os diretórios build e app/build e abra o projeto no Android
Studio.

Application Name GoogleAPIs
Package Name dominando.android.hotel
Activity Name HotelActivity

Agora faça as seguintes modificações no build.gradle do módulo app:
dependencies { ...
    implementation "com.google.android.gms:play-services-auth:$playservices_version"
}

Adicione a versão do Google Play Services no build.gradle do projeto:
playservices_version = '16.0.1'. Faça a sincronização para fazer o download da
dependência.

No pacote auth, crie a interface Auth que servirá apenas para prover id do
usuário autenticado na aplicação:
interface Auth {
    fun getUserId(): String?
}

A implementação da autenticação do aplicativo de hotéis começará pela tela
de login, mas antes crie a classe AuthManager como a seguir:
import android.content.Context
import android.content.Intent
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInClient
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
 
open class AuthManager(context: Context): Auth {



    private val appContext = context.applicationContext
    private val googleSignInClient: GoogleSignInClient by lazy {
        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
                .requestEmail()
                .build()
        GoogleSignIn.getClient(context, gso)
    }
 
    fun getUserAccount() = GoogleSignIn.getLastSignedInAccount(appContext)
 
    override fun getUserId() = getUserAccount()?.id
 
    fun getSignInIntent(): Intent = googleSignInClient.signInIntent
 
    fun signOut(callback: () -> Unit) {
        googleSignInClient.signOut()?.addOnCompleteListener {
            callback()
        }
    }
}

No início da classe é declarado um objeto do tipo GoogleSignInClient que é
iniciado utilizando o método getClient(Context,GoogleSignInOptions) da classe
GoogleSignIn. O segundo parâmetro desse método é um objeto GoogleSignInOptions
que permite configurar quais as informações do usuário a aplicação necessita.
Aqui, além das informações básicas como nome e id, é requisitado também o
email.

O método getUserAccount() retorna um objeto do tipo GoogleSignInAccount que
contém as informações do usuário autenticado na aplicação. O método
getSignInIntent() retorna um objeto Intent que será utilizado para iniciar o processo
de login. Por fim, o método signOut(()->Unit) realiza o logout na aplicação.
Perceba que ele retorna um callback para informar quando a operação foi
concluída.

Essa classe será injetada em alguns lugares da aplicação, por isso, ela será
provida no AndroidModule.kt:
val androidModule = module {
    ...
    single {
        val manager: AuthManager = get()
        manager as Auth
    }
    single {



        AuthManager(context = get())
    }
}

Agora crie uma nova activity chamada LoginActivity e deixe o arquivo de
layout activity_login.xml como a seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/colorPrimaryDark"
    tools:context="dominando.android.hotel.login.LoginActivity">
    <com.google.android.gms.common.SignInButton
        android:id="@+id/btnSignIn"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginBottom="36dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintHorizontal_bias="0.5"
        app:layout_constraintStart_toStartOf="parent" />
    <TextView
        android:id="@+id/textView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/app_name"
        android:textColor="@android:color/white"
        android:textSize="48sp"
        app:layout_constraintBottom_toTopOf="@+id/btnSignIn"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

Perceba que foi utilizado um SignInButton, que nada mais é que um botão
customizado disponibilizado pela biblioteca de autenticação do Google Play
Services. Um botão-padrão poderia ser utilizado sem problema.

Implemente a LoginActivity para que fique da seguinte forma:
import android.app.Activity
import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity



import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.common.ConnectionResult
import com.google.android.gms.common.GoogleApiAvailability
import com.google.android.gms.common.api.ApiException
import dominando.android.hotel.R
import dominando.android.hotel.common.HotelActivity
import kotlinx.android.synthetic.main.activity_login.*
import org.koin.android.ext.android.inject
 
class LoginActivity : AppCompatActivity() {
    private val authManager: AuthManager by inject()
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)
        btnSignIn.setOnClickListener { signIn() }
        checkGooglePlayServices()
    }
    private fun signIn() {
        val signInIntent = authManager.getSignInIntent()
        startActivityForResult(signInIntent, REQUEST_SIGN_IN)
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == REQUEST_SIGN_IN) {
            if (resultCode == Activity.RESULT_OK) {
                handleSignInResult(data)
            }
        } else if (requestCode == REQUEST_PLAY_SERVICES) {
            checkGooglePlayServices()
        }
    }
    private fun handleSignInResult(intent: Intent?) {
        try {
            GoogleSignIn.getSignedInAccountFromIntent(intent).getResult(ApiException::class.java)
            startActivity(Intent(this, HotelActivity::class.java))
            finish()
        } catch (e: ApiException) {
            Toast.makeText(this, R.string.error_login_failed, Toast.LENGTH_SHORT).show()
        }
    }
    private fun checkGooglePlayServices() {
        val api = GoogleApiAvailability.getInstance()
        val resultCode = api.isGooglePlayServicesAvailable(this)
        if (resultCode != ConnectionResult.SUCCESS) {



            if (api.isUserResolvableError(resultCode)) {
                val dialog = api.getErrorDialog(this, resultCode, REQUEST_PLAY_SERVICES)
                dialog.setOnCancelListener {
                    finish()
                }
                dialog.show()
            } else {
                Toast.makeText(this,
                        R.string.error_play_services_not_supported,
                        Toast.LENGTH_SHORT).show()
                finish()
            }
        }
    }
    companion object {
        private const val REQUEST_SIGN_IN = 1000
        private const val REQUEST_PLAY_SERVICES = 2000
    }
}

No método onCreate(Bundle) foi definido o evento de clique do botão de login
e, em seguida, é verificada a presença do Google Play Services com o método
checkGooglePlayServices(). Se ele não estiver disponível, verifica-se se é um
problema que pode ser resolvido pelo usuário utilizando o método
isUserResolvableError(), em caso positivo uma mensagem de erro amigável é
exibida por meio do método getErrorDialog(Context,Int,Int) para que o usuário possa
resolver o problema.

Ao clicar no botão de login, o método signIn() é chamado, onde por meio do
método getSignInIntent() do AuthManager é obtida a intent que iniciará o login. Ao
invocar o startActivityForResult(Intent,Int) com essa Intent, será exibida a tela da
Figura 18.6.

Um dialog é exibido para que o usuário selecione a conta que desejada para
fazer o login na aplicação. Ao selecionar a conta para confirmar o login, o
método onActivityResult(int,int,Intent) será chamado. No método
handleSignInResult(Intent) é verificado se o login foi bem-sucedido por meio do
método getSignedInAccountFromIntent (Intent) da classe GoogleSignIn, onde é chamado
logo na sequência o método getResult(). Caso o login falhe, será lançada uma
exceção, caso contrário será retornado um objeto do tipo GoogleSignInAccount
com as informações do usuário autenticado (que não está sendo usada
explicitamente neste momento).



Figura 18.6 – Efetuando o login com a conta Google.
Se nenhuma exceção for lançada, a tela principal da aplicação será exibida

e a tela de login fechada. Lembre-se de adicionar o texto de erro no arquivo
res/values/strings.xml:
<string name="error_login_failed">Falha ao efetuar login</string>
<string name="error_play_services_not_supported">Google Play Services não disponível ou não

suportado.</string>
Uma vez que a aplicação possui um processo de autenticação, é preciso

impedir que o usuário acesse qualquer tela da aplicação se não estiver
autenticado. Por isso, será criada uma activity base que todas as telas do
aplicativo, nas quais o usuário precise estar autenticado, herdarão dela. Essa
tela verificará se o usuário está autenticado na aplicação, e caso não esteja,
exibirá a tela de login.

Crie a classe BaseActivity no pacote common e deixe-a como a seguir:
import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import dominando.android.hotel.auth.AuthManager
import dominando.android.hotel.auth.LoginActivity
import org.koin.android.ext.android.inject
 
abstract class BaseActivity: AppCompatActivity() {



    val authManager: AuthManager by inject()
    
    override fun onStart() {
        super.onStart()
        verifyUserLoggedIn()
    }
    fun verifyUserLoggedIn() {
        val account = authManager.getUserAccount()
        if (account == null) {
            startActivity(Intent(this, LoginActivity::class.java).apply{
                addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK)
            })
            finish()
        }
    }
}

KOTLINxJAVA: Em Kotlin, por padrão, as classes são “fechadas” para extensão,
ou seja, não podem ser herdadas. Isso é o mesmo do final class do Java. Por isso,
para que uma classe possa ser herdada, deve-se utilizar a palavra reservada open (se
ela puder ser instanciada) ou abstract como foi feito com a BaseActivity.

No método onStart() é chamado o método verifyUserLoggedIn() no qual é
verificado se o usuário está autenticado na aplicação por meio do método
getUserAccount() da classe LoginManager. Se esse método retornar nulo, é porque o
usuário não está autenticado na aplicação, e nesse caso a activity atual deve
ser encerrada e a tela de login exibida. Perceba que ao chamar a tela de login,
é adicionada a FLAG_ACTIVITY_CLEAR_TASK para que a task seja limpa. Ou
seja, qualquer activity que estiver aberta, será fechada. Isso acontecerá, por
exemplo, se o usuário estiver na tela de detalhes do Hotel, e por alguma razão
o usuário não for mais válido. Com essa abordagem, tanto a tela principal
como a de detalhes serão finalizadas quando a tela de login for exibida.

O último passo é fazer com que ambas as activities do projeto herdem dessa
classe base:
class HotelActivity : BaseActivity() ...
class HotelDetailsActivity : BaseActivity() ...

Execute a aplicação e verifique se o login está funcionando corretamente. A
tela da Figura 18.7 deve ser exibida, e deve ser realizado o login com uma
conta Google definida no aparelho.



Figura 18.7 – Tela de login do aplicativo de hotéis.

Fazendo o logout e desautorizando o aplicativo
O login no aplicativo foi implementado, mas não foi disponibilizada
nenhuma opção para que o usuário pudesse realizar o logout. Esta opção será
adicionada no menu principal da aplicação. Para isso, faça a seguinte
alteração no arquivo res/menu/hotel.xml:
<menu ... >
    <item android:id="@+id/action_search" ... />
    <item
        android:id="@+id/action_user_profile"
        android:title="@string/action_user_profile"
        app:showAsAction="never" />
    <item android:id="@+id/action_info".../>
</menu>

Adicione as strings no res/values/strings.xml:
<string name="action_user_profile">Informações do usuário</string>
<string name="button_ok">OK</string>
<string name="button_logout">Logout</string>

Além da string da ação de menu, foram adicionados mais dois textos que
serão usados na tela de perfil do usuário será que criada a seguir. Ao clicar



nessa opção, será exibido um dialog com as informações do usuário
juntamente com a opção de fazer o logout.

Crie o arquivo de layout fragment_user_profile.xml e deixe-o como a
seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="16dp">
    <ImageView
        android:id="@+id/imgPhoto"
        android:layout_width="72dp"
        android:layout_height="72dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <TextView
        android:id="@+id/txtName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="16dp"
        android:textSize="18sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintHorizontal_bias="0.0"
        app:layout_constraintStart_toEndOf="@+id/imgPhoto"
        app:layout_constraintTop_toTopOf="@+id/imgPhoto" />
    <TextView
        android:id="@+id/txtEmail"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintHorizontal_bias="0.0"
        app:layout_constraintStart_toStartOf="@+id/txtName"
        app:layout_constraintTop_toBottomOf="@+id/txtName" />
    <Button
        android:id="@+id/btnLogout"
        style="@style/Widget.AppCompat.Button.Colored"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:text="@string/button_logout"
        app:layout_constraintStart_toStartOf="@+id/imgPhoto"
        app:layout_constraintTop_toBottomOf="@+id/imgPhoto" />



    <Button
        android:id="@+id/btnOk"
        style="@style/Widget.AppCompat.Button.Borderless.Colored"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/button_ok"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="@+id/btnLogout" />
</androidx.constraintlayout.widget.ConstraintLayout>

Um detalhe interessante desse arquivo de layout é que foram utilizados dois
temas diferentes para os botões: Button.Colored e Button.Borderless.Colored. O
primeiro ficará com a cor de background como colorAccent (definida no
res/values/colors.xml) e o texto branco; enquanto o segundo será
transparente, não terá bordas e ficará com a cor do texto colorAccent.

Implemente a classe que exibirá os dados do usuário autenticado e
disponibilizará a opção de logout. Crie a classe UserProfileFragment no pacote
login e deixe-a da seguinte forma:
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.DialogFragment
import androidx.fragment.app.FragmentManager
import com.bumptech.glide.Glide
import dominando.android.hotel.R
import dominando.android.hotel.common.BaseActivity
import kotlinx.android.synthetic.main.fragment_user_profile.*
import org.koin.android.ext.android.inject
 
class UserProfileFragment : DialogFragment() {
    private val authManager: AuthManager by inject()
 
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_user_profile, container, false)
    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val acct = authManager.getUserAccount()
        if (acct != null) {
            Glide.with(imgPhoto.context).load(acct.photoUrl).into(imgPhoto)
            txtName.text = acct.displayName
            txtEmail.text = acct.email



        } else {
            logout()
        }
        btnOk.setOnClickListener { dismiss() }
        btnLogout.setOnClickListener {
            authManager.signOut {
                logout()
            }
        }
        dialog.setTitle(R.string.action_user_profile)
    }
    private fun logout() {
        dismiss()
        if (activity is BaseActivity){
            (activity as BaseActivity).verifyUserLoggedIn()
        }
    }
    fun open(fm: FragmentManager) {
        val tag = "userProfileDialog"
        if (fm.findFragmentByTag(tag) == null) {
            show(fm, tag)
        }
    }
}

No método onViewCreated(View,Bundle) o usuário autenticado na aplicação é
obtido por meio do meio do método getUserAccount() da classe AuthManager. Esse
método retorna um objeto do tipo GoogleSignInAccount que possui as informações
do usuário. Foi utilizado aqui o nome do usuário, email e a foto de perfil
(atributos displayName, email e photoUrl, respectivamente).

Ao clicar no botão de logout, o método signOut() do AuthManager é chamado, e
quando a operação é concluída, o método verifyUserLoggedIn() da BaseActivity fará
com que a tela de login seja exibida. Feito isso, é preciso apenas chamar o
dialog a partir da HotelActivity:
override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    when (item?.itemId) {
        R.id.action_info -> ...
        R.id.action_user_profile ->
            UserProfileFragment().open(supportFragmentManager)
    }
    return super.onOptionsItemSelected(item)
}

Execute a aplicação e acesse a opção de informações do usuário. A tela será



exibida conforme a Figura 18.8.

Figura 18.8 – Tela de informações do usuário com opção de logout.
O último detalhe que precisa ser ajustado é no momento da sincronização

com o servidor. Atualmente é passado um usuário fixo, mas uma vez que o
mecanismo de login foi criado, deve-se passar o ID do usuário autenticado na
aplicação.

Faça a seguinte modificação na HotelHttp para obter o usuário autenticado na
aplicação:
class HotelHttp(private val service : HotelHttpApi,
                private val repository: HotelRepository,
                private val pictureFinder: FindHotelPicture,
                private val auth: Auth) {
 
    private val currentUser: String
        get() = auth.getUserId() ?: ""
    ...
}

A mudança foi simplesmente passar o AuthManager para a classe HotelHttp e
obter o usuário atual por meio do método getUserAccount(). A dependência do
AuthManager tem que ser passada para a HotelHttp, por isso faça o seguinte ajuste



no arquivo AndroidModule.kt:
val androidModule = module {
    ...
    factory {
        HotelHttp(service = get(),
                repository = get(),
                pictureFinder = get(),
                auth = get()
        )
    }
    ...
}

Se quiser recuperar esses dados, basta ver qual o id do usuário autenticado e
mudar no banco de dados do servidor.

Desinstale a aplicação e instale novamente. Em seguida, insira alguns dados
na aplicação e sincronize com o servidor. Então verifique se os dados foram
salvos no servidor e com o id do usuário correto.

Boas práticas na integração do Google Sign-In uma
aplicação servidora
Neste exemplo foi enviado para o servidor o id do usuário autenticado na
aplicação, entretanto essa não é a prática mais adequada, pois ela apresenta
alguns problemas:

• o ID do usuário foi enviado, mas nada garante que este é um usuário
Google válido;

• não foi utilizada uma conexão HTTPS que provê maior segurança na troca
de dados.

Em uma aplicação real, o mínimo que deveria ser feito seria:
• obter o token do usuário autenticado na aplicação;
• enviar esse token para o servidor;
• validar se esse token se refere a um usuário Google válido;
• em caso positivo, salvar no servidor as informações do usuário, incluindo

o ID e o token enviado pelo aplicativo;
• em cada requisição deve-se enviar esse token, em seguida, o servidor

valida o token e obtém os dados referentes àquele usuário, com isso, ele
consegue garantir a integridade da requisição que está sendo realizada.



Esse fluxo não foi implementado aqui para deixar o exemplo mais simples e
para não entrar nos detalhes da implementação do servidor, pois esses tópicos
vão muito além do objetivo deste livro. Porém, tenha em mente que a
autenticação de um aplicativo é algo muito importante e pode variar um
pouco dependendo da forma com que a segurança está sendo implementada
no servidor.

Para mais detalhes consulte a documentação oficial em
https://developers.google.com/identity/sign-in/android/backend-auth.

Desautorizando um aplicativo
Para desautorizar uma aplicação no dispositivo, o usuário tem duas opções:
utilizar o aplicativo Config. Google; ou acessar a opção Google nas
configurações do aparelho em versões mais recentes do Android como
mostra a Figura 18.9. Em ambos os casos, é preciso procurar pela opção
Aplicativos conectados (Connected apps). Nela, é exibida a lista de
aplicativos já autorizados pelo usuário e que acessam alguma informação da
conta como mostra a Figura 18.10. Ao selecionar o aplicativo de hotéis, será
exibida a tela da Figura 18.11. Clicando no botão Disconnect, o usuário será
desconectado do aplicativo. Com isso, ao abrir novamente a aplicação de
hotéis a tela de login deve ser exibida.



Figura 18.9 – Opção “Google” nas configurações do aparelho.
Como foi possível perceber, a utilização dos serviços do Google traz um

atrativo e um diferencial ao seu aplicativo. Utilizando o login do Google você
não obrigará o usuário a lembrar mais uma senha. E como desenvolvedor,
não precisará criar toda uma infraestrutura de login.



Figura 18.10 – Aplicativos conectados por uma conta Google.

Figura 18.11 – Desautorizando o nosso aplicativo.



Firebase Cloud Messaging
O Firebase Cloud Messaging, ou simplesmente FCM, é um serviço gratuito
que permite enviar mensagens para aplicações Android (e outras
plataformas), conhecidas popularmente como push notifications. O intuito
não é trafegar grande quantidade de dados, mas sim enviar mensagens
simples (de até 4 KB), como, por exemplo, para avisar que uma nova
informação está disponível no servidor. Ficará a cargo dos servidores do
FCM todo o enfileiramento de mensagens e sua entrega para a aplicação
mobile.

É possível enviar mensagens utilizando o editor de notificações online do
próprio Firebase ou a partir de outra aplicação realizando uma requisição
HTTP do tipo POST (devidamente autenticado) para os servidores do FCM.

As principais características do FCM são:
• envio de mensagens de uma aplicação servidora para aplicações Android,

onde é possível enviar mensagens para um dispositivo específico, para um
grupo de aparelhos ou por tópicos;

• a aplicação Android não necessita estar em execução para receber as
mensagens, uma vez que o sistema operacional disparará um broadcast
assim que uma mensagem for recebida;

• para utilizar o FCM, é necessário que o dispositivo esteja rodando o
Android 4.0 (API 14) ou superior e ter o aplicativo do Google Play
instalado.

O FCM posssui dois tipos de mensagens: dados e notificação. As
mensagens de dados devem sempre ser tratadas programaticamente,
independente de a aplicação estar em foreground ou background. As
mensagens do tipo notificação também devem ser tratadas via código quando
a aplicação estiver em foreground. Entretanto, quando a mensagem for do
tipo notificação e a aplicação estiver em background, uma notificação será
disparada automaticamente na barra de status do aparelho. Ao clicar nessa
notificação, a activity principal da aplicação será exibida.

Visão geral da arquitetura
A arquitetura do FCM tem como principais elementos os componentes físicos
e credenciais. Os componentes físicos envolvidos são:



• o dispositivo móvel (smartphone ou tablet) com a aplicação Android;
• servidores do FCM que enviam as mensagens para os dispositivos

registrados. Essas mensagens podem ser enviadas pelo Firebase Console
ou por uma outra aplicação (normalmente no servidor);

• aplicação servidora (opcional) que envia mensagens para o dispositivo
móvel por meio dos servidores do FCM.

As credenciais são identificadores e chaves utilizadas durante as etapas do
processo de registro e comunicação da aplicação servidora com o dispositivo
móvel.

• Application ID – é o identificador da aplicação Android que deseja
receber mensagens. Esse identificador é o nome do pacote da aplicação
que consta no AndroidManifest.xml. Isso garante que a mensagem seja
entregue à aplicação correta, uma vez que não é possível ter duas
aplicações com o mesmo nome de pacote instalada no aparelho;

• Registration token – é o identificador gerado pelo servidor FCM quando a
aplicação Android se conecta a ele. Esse número deve ser enviado para a
aplicação servidora, uma vez que ele é obrigatório para o envio das
mensagens para um dispositivo específico;

• Server API key – é a chave de acesso usada na aplicação servidora para
que ela possa enviar mensagens para os servidores FCM que serão
encaminhadas para o aplicativo Android. Essa chave é incluída no
cabeçalho da mensagem que será enviada.

Uma vez que foram apresentados os conceitos envolvidos na comunicação
com o FCM, observe como funciona o fluxo de mensagens e a interação entre
eles apresentados na Figura 18.12.



Figura 18.12 – Fluxo de mensagens de uma aplicação usando FCM.
No fluxo 1, o dispositivo Android solicita o Registration ID para o servidor

FCM. O fluxo 2 é necessário apenas caso seja necessário enviar mensagens
para um aparelho específico. Ao receber o Registration token, a aplicação
deve enviá-la para ser armazenada na aplicação servidora, para
posteriormente conseguir enviar mensagens para esse dispositivo específico.
Essa primeira etapa só é necessária uma vez ou quando o token expirar.

Quando a aplicação servidora precisar enviar uma mensagem para a
aplicação Android, na verdade, ela terá que enviar a mensagem para o
servidor do FCM (fluxo a) usando o Server API key e o Registration ID. Com
base nas duas chaves informadas, a mensagem é entregue à aplicação
Android (fluxo b).

Adicionando o projeto no Firebase Console
O primeiro passo para utilizar o FCM é gerar uma chave que identificará o
desenvolvedor e a aplicação nos servidores do Google. Para isso, acesse o
endereço https://console.firebase.google.com e efetue o login com sua conta
do Google (se já não o fez). Será exibida uma página similar à da Figura
18.13.



Figura 18.13 – Tela principal do Firebase Console.
Clique na opção Add Project e será exibida a tela da Figura 18.14.
No campo Project name pode-se inserir o nome de um novo projeto ou

selecionar um projeto existente. Utilize o projeto de hotéis que foi criado no
Google APIs Console, então selecione o projeto “dominando-android-3” e o
campo Project ID será preenchido automaticamente. Selecione o país onde
você reside no campo Country/region e clique no botão Add Firebase.

Quando o projeto for criado, a tela da Figura 18.15 será exibida. Nela,
selecione a opção Add Firebase to your Android app e será exibida a tela da
Figura 18.16.

O FCM será utilizado no projeto de hotéis. A intenção é que, quando um
hotel for inserido, alterado ou excluído no servidor, uma mensagem seja
enviada para a aplicação e ela inicie o processor de sincronização.

Preencha o campo Android package name com dominando.android.hotel. O
campo App nickname é opcional. Por fim, o campo Debug signing
certificate SHA-1 não é obrigatório para o FCM, mas é necessário para
alguns serviços. Por isso, preencha o SHA-1 com valor retornado pelo
comando keytool que foi apresentado na seção anterior e clique no botão
Register app. Será exibida a tela da Figura 18.17.



Figura 18.14 – Criando novo projeto do Firebase Console.

Figura 18.15 – Dashboard do Firebase Console.



Faça o download do arquivo google-services.json e copie-o para a pasta app
do projeto. Esse arquivo pode ser obtido a qualquer momento na opção
Project Settings do Firebase Console.

Figura 18.16 – Adicionando o Firebase ao projeto Android.



Figura 18.17 – Download do arquivo google-services.json.
Ao clicar em Next, serão exibidas as instruções para adicionar o Firebase

ao projeto. Esses passos serão realizados na próxima seção. Finalize o
assistente pulando as próximas etapas.

Adicionando o FCM ao projeto de hotéis
Para adicionar o FCM no projeto de hotéis é preciso adicionar a dependência
do plugin do Google Play Services no arquivo build.gradle do projeto:
buildscript { ...
    ext { ...
        firebase_core_version = '16.0.7'
        firebase_messaging_version = '17.3.4'
        google_services_version = '4.2.0'
    }
    dependencies { ...
        classpath "com.google.gms:google-services:$google_services_version"
    }
}
...

Note que foram adicionadas também as constantes das versões das
bibliotecas que serão utilizadas na aplicação. Agora faça as seguintes



modificações no build.gradle do módulo app:
dependencies {
    ...
    implementation "com.google.firebase:firebase-core:$firebase_core_version"
    implementation "com.google.firebase:firebase-messaging:$firebase_messaging_version"
}
apply plugin: 'com.google.gms.google-services' // Na última linha do arquivo

Foram adicionadas as dependências da biblioteca core do Firebase e a
específica do FCM. Certifique-se de aplicar o plugin do Google Services na
última linha do arquivo e faça a sincronização para baixar as dependências.

Aplicação Cliente
A utilização mais comum do FCM é informar que algo aconteceu no servidor
que o cliente deve ter conhecimento. Esse conceito será aplicado ao
aplicativo de hotéis da seguinte forma: quando um registro for incluído,
alterado ou excluído no servidor, uma mensagem será enviada para o
dispositivo via FCM. Ao receber essa mensagem, será disparada uma
notificação e a sincronização com o servidor será realizada. Dessa forma,
quando o usuário clicar na notificação, já verá os novos registros.

O tratamento do registration token ficará centralizado no objeto de
TokenManager que deve ser criado no pacote fcm e deve ficar como a seguir:
import android.content.Context
import android.preference.PreferenceManager
import dominando.android.hotel.repository.http.HotelHttp
class TokenManager(private val context: Context,
                   private val hotelHttp: HotelHttp) {
 
    fun updateToken(refreshedToken: String) {
        setRegistrationId(refreshedToken)
        setSentToServer(false)
        sendRegistrationToServer()
    }
    private fun sendRegistrationToServer() {
        //TODO
    }
    fun getRegistrationId(): String? {
        return PreferenceManager
                .getDefaultSharedPreferences(context)
                .getString(REGISTRATION_ID, null)
    }



    private fun setRegistrationId(value: String?) {
        PreferenceManager.getDefaultSharedPreferences(context)
                .edit()
                .putString(REGISTRATION_ID, value)
                .apply()
    }
    private fun isSentToServer(): Boolean {
        return PreferenceManager.getDefaultSharedPreferences(context)
                .getBoolean(SENT_TO_SERVER, false)
    }
    private fun setSentToServer(value: Boolean) {
        PreferenceManager.getDefaultSharedPreferences(context)
                .edit()
                .putBoolean(SENT_TO_SERVER, value)
                .apply()
    }
    companion object {
        private const val REGISTRATION_ID = "registrationId"
        private const val SENT_TO_SERVER = "hasSentToServer"
    }
}

Esse objeto serve para armazenar localmente (nas SharedPreferences) o
registration token e um valor booleano indicando se esse token já foi enviado
para o servidor. Isso é feito, pois caso aconteça alguma falha no envio para o
servidor, uma nova tentativa deve ser realizada posteriormente.

No método updateToken(String) o token é atualizado e é marcado como não
enviado para o servidor. Em seguida, o método sendRegistrationToServer(String) é
chamado. Esse método será implementado na próxima seção.

A próxima classe que será criada é a HotelFcmService que será responsável por
receber as mensagens vindas do servidor FCM e também tratará o processo
de recebimento e atualização do Registration token. Adicione a classe
HotelFcmService e deixe-a como a seguir:
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat



import com.google.firebase.messaging.FirebaseMessagingService
import com.google.firebase.messaging.RemoteMessage
import dominando.android.hotel.R
import dominando.android.hotel.common.HotelActivity
import dominando.android.hotel.repository.http.HotelSyncWorker
import org.koin.android.ext.android.inject
 
class HotelFcmService : FirebaseMessagingService() {
    private val tokenManager: TokenManager by inject()
    override fun onMessageReceived(remoteMessage: RemoteMessage) {
        super.onMessageReceived(remoteMessage)
        HotelSyncWorker.start()
        val title = getString(R.string.app_name)
        val message = getString(R.string.notification_text)
        if (remoteMessage.data.isNotEmpty()) {
            triggerNotification(title, remoteMessage.data["message"] ?: message)
        } else if (remoteMessage.notification != null) {
            triggerNotification(remoteMessage.notification?.body ?: title, message)
        }
    }
    override fun onNewToken(token: String) {
        super.onNewToken(token)
        tokenManager.updateToken(token)
    }
    private fun triggerNotification(title: String, msg: String) {
        val notificationId = 1
        val channelId = "channel1"
        createChannel(channelId, title)
        val notificationManager = NotificationManagerCompat.from(this)
        val it = Intent(this, HotelActivity::class.java)
        val pit = PendingIntent.getActivity(this,
                0, it, PendingIntent.FLAG_UPDATE_CURRENT)
        val builder = NotificationCompat.Builder(this, channelId)
                .setDefaults(Notification.DEFAULT_ALL)
                .setSmallIcon(R.mipmap.ic_launcher)
                .setContentTitle(title)
                .setContentText(msg)
                .setContentIntent(pit)
                .setColor(ContextCompat.getColor(this, R.color.colorAccent))
                .setAutoCancel(true)
        notificationManager.notify(notificationId, builder.build())
    }
    private fun createChannel(channelId: String, title: String) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val notificationManager = getSystemService(



                    Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(
                    NotificationChannel(
                            channelId,
                            title,
                            NotificationManager.IMPORTANCE_DEFAULT)
            )
        }
    }
}

A classe HotelFcmService herda de FirebaseMessagingService, e quando uma nova
mensagem chegar pelo serviço do FCM, o método
onMessageReceived(RemoteMessage) será disparado. Com o objeto RemoteMessage é
possível determinar se a mensagem recebida é do tipo notificação ou de
dados. Se for do tipo notificação, a propriedade notification do objeto
remoteMessage será diferente de nulo. E nesse caso a notificação é exibida com o
corpo (body) da mensagem recebida. Entretanto, se a mensagem for de dados,
o atributo data (que é um Map) do objeto remoteMessage não será vazio, então a
chave que foi passada como parâmetro pode ser lida, que neste exemplo é
“message”.

Em ambos os casos, ao chegar uma mensagem, o processo de sincronização
é iniciado por meio da classe HotelSyncWorker. O método
triggerNotification(String,String) cria uma notificação simples semelhante ao que foi
mostrado no capítulo anterior.

O método onNewToken(String) é chamado sempre quando token é gerado ou
atualizado. Neste momento, o método updateToken(String) é chamado para que o
token seja enviado para a aplicação servidora de hotéis, de modo que seja
possível enviar uma mensagem para um dispositivo específico.

Adicione agora as seguintes informações no AndroidManifest.xml:
<manifest ...>
    <application ... >
        ...
        <service
            android:name=".fcm.HotelFcmService">
            <intent-filter>
                <action android:name="com.google.firebase.MESSAGING_EVENT" />
            </intent-filter>
        </service>
    </application>



</manifest>
Adicione os seguintes textos ao res/values/strings.xml:

<string name="notification_text">Lista de Hoteis atualizada!</string>
A classe HotelFcmService está obtendo a instância de TokenManager utilizando o

inject(), então é preciso fornecer essa instância no AndroidModule.kt:
val androidModule = module {
    ...
    single {
        TokenManager(context = get(), hotelHttp = get())
    }
}

O último ajuste que deve ser feito na LoginActivity é registrar-se em um tópico
para poder receber mensagens do FCM.
class LoginActivity : AppCompatActivity() {
    ...
    private fun handleSignInResult(intent: Intent?) {
        try {
            GoogleSignIn.getSignedInAccountFromIntent(intent).getResult(ApiException::class.java)
            startActivity(Intent(this, HotelActivity::class.java))
            finish()
            FirebaseMessaging.getInstance().subscribeToTopic("hotel_sync")
        } catch (e: ApiException) {
            Toast.makeText(this, R.string.error_login_failed, Toast.LENGTH_SHORT).show()
        }
    }
}

Será demonstrado como enviar mensagens para um dispositivo específico,
mas ao se registrar em um tópico, é possível receber mensagens enviadas
pelo servidor para aquele tópico. Faça o logout e o login novamente para que
a aplicação se registre no tópico “hotel_sync” e na próxima seção será
demonstrado como enviar a mensagem para todos os aparelhos que estão
registrados para esse tópico.

Enviando mensagens pelo Firebase Console
No estágio atual que o aplicativo se encontra já é possível receber mensagens
do FCM, pois quando o usuário efetua o login a aplicação está se registrando
para o tópico “hotel_sync”. Dessa forma, já é possível receber mensagens que
são enviadas para esse tópico específico.

É possível enviar mensagens pelo Firebase Console, acessando a opção



“Cloud Messaging” e será exibida a tela da Figura 18.18. Essa tela exibe as
mensagens que foram enviadas aos clientes FCM.

Figura 18.18 – Enviando mensagens FCM pelo Firebase Console.
Caso seja a primeira mensagem, clique na opção Send your first message,

ou clique no botão New Message para enviar uma nova mensagem, então a
tela da Figura 18.19 será exibida.

No campo Message text, preencha o texto que será enviado para o
dispositivo. O campo Message Label é para uso interno do console do
Firebase. Em seguida, no campo Delivery date, é possível optar por enviar a
mensagem imediatamente ou agendá-la.



Figura 18.19 – Formulário para envio de mensagens FCM.
Logo a seguir, no campo Target é possível optar por enviar a mensagem

para: todos os usuários da aplicação ou para um segmento de usuários (por
idioma ou outra característica); para um tópico; ou para um dispositivo
específico, e nesse caso deve ser informado o registration token que foi
obtido no HotelFcmService. Selecione a opção Topic e, em seguida, digite o
tópico “hotel_sync” que foi registrado na LoginActivity. Ao clicar no botão
Send message a notificação deve ser exibida no aparelho como mostra a
Figura 18.20.



Figura 18.20 – Notificação enviada pelo FCM recebida no aparelho.

Aplicação servidora
Imagine que o aplicativo de hotéis possui uma versão web, então a ideia é
que quando um dado seja inserido, atualizado ou excluído na aplicação web,
a aplicação mobile seja atualizada automaticamente. Nesta seção será feita
uma simulação desse comportamento. Assim como fizemos no Capítulo 14,
será utilizado um script PHP que rodará no servidor Apache.

No servidor serão implementadas duas funcionalidades para utilizar o
FCM: salvar o Registration token dos aparelhos, e enviar uma mensagem
para um aparelho específico quando um registro for inserido, alterado ou
excluído. Adicione o script fcm_server.php no subdiretório
xamppfiles/htdocs/hotel_service onde está instalado o XAMPP1 e deixe-o
desta forma:
<?php
$servername = "localhost";
$username = "root";
$password = "";
$conn = new mysqli($servername, $username, $password);
if ($conn->connect_error) {
    die("Connection failed: " . $conn->connect_error);
}
$sql = "CREATE DATABASE IF NOT EXISTS hotel_db";
if (!$conn->query($sql) === TRUE) {



    echo "Erro ao criar banco de dados: " . $conn->error;
}
$sql = "CREATE TABLE IF NOT EXISTS hotel_db.Devices (
        user VARCHAR(255),
        registration_id VARCHAR(200) PRIMARY KEY
        )";
$action = $_POST['action'];
$user = $_POST['user'];
 
if ($conn->query($sql) === FALSE) {
    echo "Erro ao criar tabela: " . $conn->error;
}
if ($action == "register") {
    $registrationId = $_POST['regId'];
    $stmt = $conn->prepare(
        "INSERT INTO hotel_db.Devices (user, registration_id) VALUES (?, ?)");
    $json = json_decode(file_get_contents('php://input'));
    $stmt->bind_param("ss", $user, $registrationId);
    $stmt->execute();
    $stmt->close();
} else if ($action == "push") {
    $apiKey = "SUA_API_KEY";
    $message = $_POST["message"];
    $url = "https://fcm.googleapis.com/fcm/send";
    $sql = "SELECT registration_id FROM hotel_db.Devices WHERE user = '". $user ."'";
    $result = $conn->query($sql);
    if ($result && $result->num_rows > 0) {
        while($row = $result->fetch_assoc()) {
            $regId = $row["registration_id"];
            $ch = curl_init($url);
            $json_data = '{ "to": "'. $regId .'", "data": { "message": "'. $message .'"} }';
            curl_setopt($ch, CURLOPT_POST, 1);
            curl_setopt($ch, CURLOPT_POSTFIELDS, $json_data);
            curl_setopt($ch, CURLOPT_HTTPHEADER,
                array("Content-Type: application/json",
                      "Authorization: key=". $apiKey));
            $response = curl_exec($ch);
            echo $response;
        }
    }
}
$conn->close();
?>

O script inicia tentando estabelecer a conexão com o banco, criando-o se



ele não existir. Em seguida, é criada a tabela Device se ela não existir. Essa
tabela armazenará o Registration ID de cada dispositivo e o id do usuário.

Em seguida, como só estão sendo aceitas requisições do tipo POST, é
verificado se o parâmetro action é igual a register. Isso indica que está sendo
enviado o Registration ID para ser armazenado no servidor, então ele é
inserido no banco de dados os parâmetros “regId” e “user” que serão
enviados pela aplicação Android (como será visto a seguir).

Caso o parâmetro action seja igual a push, uma requisição será feita ao
servidor do FCM para enviar uma mensagem para os dispositivos registrados
para aquele usuário. Esse envio nada mais é que uma requisição via POST para
o endereço https://fcm.googleapis.com/fcm/send, que deve conter: o
cabeçalho Content-Type informando que enviaremos um JSON; e outro
cabeçalho, Authorization , no qual é informada a Server API key.

Na variável $apiKey deve-se informar a Server key disponível no Firebase
Console, na opção Project Settings, na aba Cloud Messaging como mostra a
Figura 18.21.

Figura 18.21 – Server key no Firebase Console.
O última etapa da implementação do FCM no aplicativo de hotéis será



enviar o registration token para o servidor. Faça as seguintes mudanças na
classe HotelHttpApi:
interface HotelHttpApi {
    ...
    @FormUrlEncoded
    @POST(FCM_SERVICE)
    fun sendRegistrationId(
            @Field("user") user: String,
            @Field("regId") registrationId: String,
            @Field("action") action: String = "register"): Call<Void>
 
    companion object { ...
        const val FCM_SERVICE = "fcm_server.php"
    }
}

Ao enviar o registration id, não está sendo enviado um JSON como foi
feito nos outros exemplos. Os dados são enviados como se viessem de um
formulário HTML. Por isso, foi utilizada a anotação @FormUrlEncoded no
método e @Field para cada campo que é enviado.

Agora adicione o seguinte método na classe HotelHttp:
fun sendRegistrationToken(token: String): Boolean {
    return currentUser.isNotBlank() && token.isNotBlank() &&
            service.sendRegistrationId(currentUser, token).execute().isSuccessful
}

Na classe TokenManager, o token será enviado para o servidor. É importante
registrar que essa classe executa na main thread, por isso, o envio deve ser
feito em uma thread separada. Poderíamos utilizar uma AsyncTask ou uma
coroutine aqui.
class TokenManager(private val context: Context,
                   private val hotelHttp: HotelHttp) {
    ...
    fun sendRegistrationToServer() {
        val regId = getRegistrationId()
        if (!isSentToServer() && regId != null && regId.isNotBlank()) {
            Thread {
                try {
                    if (hotelHttp.sendRegistrationToken(regId)) {
                        setSentToServer(true)
                    }
                } catch (e: Exception) {
                    e.printStackTrace()



                }
            }.start()
        }
    }
    ...
}

O último detalhe é, após realizar o login, enviar o token para o servidor.
Faça isso na BaseActivity como a seguir:
abstract class BaseActivity: AppCompatActivity() {
    val authManager: AuthManager by inject()
    val tokenManager: TokenManager by inject()
    // O método onStart não mudou
    fun verifyUserLoggedIn() {
        val account = authManager.getUserAccount()
        if (account == null) {
            startActivity(Intent(this, LoginActivity::class.java).apply{
                addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK)
            })
            tokenManager.updateToken("")
            finish()
        } else {
            tokenManager.sendRegistrationToServer()
        }
    }
}

Ao realizar o login, o registration id é enviado para o servidor, e, ao fazer o
logout, ele é excluído.

Desinstale a aplicação e instale novamente a partir do Android Studio e veja
se tudo continua funcionando corretamente. Inclusive, verifique se o token
obtido foi enviado para o servidor.

Simulando o envio de mensagem FCM pelo servidor
Conforme foi explicado na seção anterior, o script fcm_server.php possui duas
funções: armazenar o registration token e enviar uma mensagem para o
dispositivo via servidor FCM. Esse segundo recurso seria utilizado por uma
aplicação web quando algum hotel fosse inserido, atualizado ou excluído.
Obviamente que a aplicação web está fora do escopo deste livro, e por isso
será feita uma simulação dessa segunda funcionalidade por meio de um
simples formulário HTML. Crie o arquivo send_msg_fcm.html na pasta
xamppfiles/htdocs/hotel_service e deixe-o conforme a seguir:



<html>
<head><title>Exemplo FCM</title></head>
<body>
<form method="post" action="fcm_server.php">
<input type="hidden" name="action" value="push">
User id: <input type="text" name="user"><br>
Mensagem:<input type="text" name="message"><br>
<input type="submit" value="OK">
</form>
</body>

A página possui apenas um <form> HTML onde é informado que será feita
uma requisição do tipo POST para o script fcm_server.php. É necessário informar
a mensagem que será enviada e o id do usuário, que pode ser obtido
“debugando” a aplicação Android ou caso já tenha inserido alguma
informação no banco de dados do servidor, essa informação estará lá na
coluna user.

Certifique-se de iniciar o servidor Apache e o MySQL no XAMPP e, em
seguida, execute a aplicação Android. Feito isso, acesse o endereço
http://SEU_IP_AQUI/hotel_service/send_msg_fcm.html e a página será
exibida conforme a Figura 18.22.

Figura 18.22 – Página para teste de envio de mensagem.
Ao clicar no botão OK, a mensagem será enviada e aparecerá no aparelho

em forma de notificação. Quando a aplicação receber a mensagem do FCM, a
sincronização com o servidor será feita automaticamente e, ao clicar na
notificação, a aplicação será aberta. Como podemos observar, o FCM é um
recurso interessantíssimo para adicionar na aplicação, pois não é preciso ficar
de tempos em tempos indo ao servidor checar se existe alguma informação
nova. O servidor pode avisar quando isso acontecer.



YouTube Android Player API
A YouTube Android Player API permite carregar vídeos e playlists do
YouTube dentro da aplicação. Também é possível controlar a execução do
vídeo como pausar e ir para um ponto específico. Essa API é compatível com
Android 2.2 ou superior e requer apenas que o dispositivo tenha o aplicativo
do YouTube.

Acesse Google Developers Console
(https://console.developers.google.com), selecione o projeto que foi criado no
início do capítulo e escolha a opção Credentials. Ao adicionar o Firebase ao
projeto, algumas chaves são criadas automaticamente. Poderíamos utilizar a
chave “Android key”, que é gerada automaticamente pelo Firebase, mas crie
uma chave exclusiva para este exemplo.

Clique no botão Create credentials e selecione API key. Com isso, a chave
é criada como mostra a Figura 18.23.

Entretanto, para restringir que apenas determinada aplicação utilize essa
chave, clique em Restrict key e será mostrada a tela da Figura 18.24.
Preencha o nome da chave (aqui foi usado “YouTube_key”) e no campo Key
restriction selecione “Android apps”. Clique no botão Add package name
and fingerprint e preencha com o pacote da aplicação (aqui será usado
dominando.android.youtube) e o SHA-1 retornado no comando keytool no campo
SHA-1 certificate fingerprint. Por fim, clique no botão Save.

Figura 18.23 – Criando uma chave para a aplicação.



Figura 18.24 – Gerando chave de acesso para acessar serviços do
Google.

A API key gerada será similar a AIzaSyCpqBRMwE-HySsGAuazN5KBv2R4vq_3IFU e
será utilizada no próximo exemplo.

Pondo em prática
Application Name YouTube
Package Name dominando.android.youtube



Activity Name MainActivity

Crie um novo projeto para explorar a API do YouTube no Android. O
primeiro passo para utilizá-la é fazer o download no endereço a seguir:

https://developers.google.com/youtube/android/player/downloads/
Em seguida, descompacte o arquivo em algum lugar do seu computador e

copie o arquivo YouTubeAndroidPlayerApi.jar que se encontra no diretório
libs para a pasta app/libs do projeto.

Uma vez adicionada a biblioteca ao projeto, adicione a permissão de
INTERNET no AndroidManifest.xml:
<uses-permission android:name="android.permission.INTERNET"/>

Em seguida, altere o arquivo de layout res/layout/activity_main.xml para
conter uma YouTubePlayerView como a seguir:
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <com.google.android.youtube.player.YouTubePlayerView
        android:id="@+id/youtubePlayerView"
        android:layout_centerInParent="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
</RelativeLayout>

Agora deixe a MainActivity como a seguir. Perceba que foi declarada a
constante API_KEY, na qual deve conter a chave que foi gerada na seção
anterior. Já a constante VIDEO_ID é o identificador do vídeo no YouTube:
import android.os.Bundle
import android.widget.Toast
import com.google.android.youtube.player.YouTubeBaseActivity
import com.google.android.youtube.player.YouTubeInitializationResult
import com.google.android.youtube.player.YouTubePlayer
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : YouTubeBaseActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        youtubePlayerView.initialize(API_KEY,
                object : YouTubePlayer.OnInitializedListener {
                    override fun onInitializationFailure(
                            provider: YouTubePlayer.Provider,
                            result: YouTubeInitializationResult) {



                        Toast.makeText(this@MainActivity,
                                "Erro ao reproduzir vídeo",
                                Toast.LENGTH_SHORT).show()
                    }
                    override fun onInitializationSuccess(
                            provider: YouTubePlayer.Provider,
                            player: YouTubePlayer,
                            wasRestored: Boolean) {
                        if (!wasRestored) {
                            player.cueVideo(VIDEO_ID)
                        }
                    }
                })
    }
    companion object {
        private const val API_KEY = "SUA_API_KEY_AQUI"
        private const val VIDEO_ID = "FHZ6bI3zb4M"
    }
}

A classe herda de YouTubeBaseActivity, e no método onCreate(Bundle) obtemos a
instância do YouTubePlayerView declarado no arquivo de layout. Em seguida, é
chamado o método initialize(String, OnInitializedListener), passando a chave de acesso
que foi gerada anteriormente e uma instância da interface OnInitilizedListener.
Essa interface possui dois métodos: onInitializationSuccess(Provider provider,
YouTubePlayer, boolean), que é disparado quando a inicialização é feita com
sucesso, e quando houver algum problema, o método
onInitializationFailure(Provider, YouTubeInitializationResult) será chamado.

Quando o carregamento do vídeo é feito com sucesso, o objeto YouTubePlayer
é usado para iniciar a reprodução do vídeo invocando o método cueVideo(String)
passando como parâmetro o id do vídeo. O parâmetro wasRestored informa se o
vídeo está sendo restaurado do ponto onde parou. Execute a aplicação e ela
ficará como a Figura 18.25.



Figura 18.25 – Executando um vídeo com a API do YouTube.
Porém, você deve ter percebido que, ao girar a tela, o vídeo é paralisado

sendo necessário pressionar o botão de play novamente. Isso acontece porque
a activity foi destruída e recriada. Esse é um dos casos especiais em que
devemos impedir que a activity seja destruída. Para isso, faça a seguinte
alteração na declaração da activity no AndroidManifest.xml:
<activity
    android:name=".MainActivity"
    android:configChanges="orientation|screenSize|keyboardHidden">

Com essa configuração, o Android não destruirá a activity se houver
mudança de orientação, de tamanho de tela ou se um teclado físico for aberto.
Execute a aplicação novamente a agora é possível girar a tela livremente.

O aplicativo deve estar funcionando, entretanto, ao optar por não destruir a
activity, a alocação dinâmica de recurso (por exemplo, usar res/layout e
rest/layout-land) é perdida. Então, se quiser implementar alguma lógica para
cada orientação, é necessário fazê-lo manualmente no método
onConfigurationChanged(Configuration):
override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    if (newConfig.orientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) {
        // Aparelho em landscape
    } else {



        // Aparelho em portrait
    }
}

Com essa abordagem, é possível exibir, ocultar ou reposicionar os
componentes de acordo com a orientação do aparelho.

Nesse exemplo, foi utilizada a YouTubePlayerView, mas o mesmo pode ser feito
utilizando a classe YouTubeFragment (e YouTubeSupportFragment para biblioteca de
compatibilidade).

Como foi possível observar, é muito simples adicionar um vídeo do
YouTube na aplicação. Se você quiser saber mais detalhes, consulte a
documentação (http://goo.gl/aJUk1A) e os exemplos disponíveis no diretório
samples onde foi descompactado o arquivo da YouTubeAndroidPlayerAPI.

Propaganda com AdMob
Uma das formas de ganhar dinheiro com um aplicativo é por meio de
propagandas, e para adicioná-las é bem simples. Primeiramente, é necessário
criar uma conta no site do AdMob (http://www.google.com/ads/admob)
clicando no botão Sign into AdMob. Faça o login com sua conta Google e
será exibida uma tela semelhante à da Figura 18.26.



Figura 18.26 – Página de registro do AdMob.
Preencha o Country ou territory (país), Time zone (fuso horário) e o

Billing currency (moeda de cobrança). Por exemplo: Brazil (UTC-03:00)
Recife e Brazilian Real (BRL R$), respectivamente. Leia os termos e
condições e a política do programa AdMob, e, se concordar, marque o
checkbox e clique no botão Create AdMob Account. Será enviado um email
de confirmação.

Em seguida, uma mensagem é exibida pelo AdMob solicitando a permissão
para enviar por email sugestões de como melhorar a utilização das
propagandas no aplicativo. Marque as opções que desejar e clique em Verify
your account. Será requisitado então o número de telefone para confirmação
da conta. Informe o código internacional (Brasil +55) seguido do DDD e seu
número de telefone (ex.: +55 81 999999999). Será enviado um código via
SMS que deve ser digitado no campo correspondente. Em seguida, clique no
botão Verify. Para finalizar o processo, clique em Continue to AdMob.

A tela principal do AdMob será exibida conforme a Figura 18.27. Clique na



opção Apps do lado esquerdo e, em seguida, clique no botão Add your first
app. Será questionado se a aplicação já está publicada na Play Store ou na
App Store. Por agora, selecione No.

Figura 18.27 – Página principal do AdMob.
Preencha o nome da aplicação com “Hotéis” e no campo Platform,

selecione Android e clique no botão Add. Pronto! A aplicação foi adicionada
ao AdMob. Será gerado um App ID para a aplicação no formato ca-app-pub-
XXXXXXXXXXXXXXXX~YYYYYYYYYY no qual X é o seu publisher id e o Y é o id
do aplicativo.

Devemos adicionar um Ad Unit que identificará uma propaganda dentro do
seu aplicativo. Clique no botão Create Ad Unit e será exibida a tela da Figura
18.28.



Figura 18.28 – Monetizando uma aplicação no AdMob.
Nessa tela é possível selecionar o tipo da propaganda como Banner,

Interstitial ou Rewarded. O banner ocupará uma parte da tela do aplicativo e
ficará lá enquanto a tela estiver sendo exibida. Já o interstitial aparecerá
durante um curto período de tempo e ocupará toda a tela. A rewarded é o tipo
de propaganda muito utilizada em jogos, onde o usuário recebe algum tipo de
prêmio caso ele visualize a propaganda. Selecione a opção banner e, em
seguida, dê um nome a Ad Unit que será utilizada apenas internamente (ex.:
“banner principal”) como mostrado na Figura 18.29.

Expandindo a opção Advanced settings é possível observar um detalhe
interessante: o tempo de atualização da propaganda no campo Automatic
refresh. Ele pode ser automático (Google optimized) ou um valor entre 30 e
150 segundos. Após preencher esses campos, clique no botão Create Ad
Unit.

Será gerado um Ad Unit Id no formato ca-app-pub-
XXXXXXXXXXXXXXXX/YYYYYYYYYY, no qual X é o seu publisher id, enquanto
o Y é o id da propaganda. Clique em Done para finalizar o processo de
criação do banner. Vamos utilizar esse Ad Unit Id em nosso código.

Adicione essas duas strings no arquivo res/values/strings.xml:



<string name="admob_app_id" translatable="false">ca-app-pub-
XXXXXXXXXXXXXXXX~YYYYYYYYYY</string>

<string name="admob_adunit_id" translatable="false">ca-app-pub-
XXXXXXXXXXXXXXXX/YYYYYYYYYY</string>

Figura 18.29 – Criando uma unidade de propaganda.

Adicionando um banner
É possível utilizar o AdMob SDK para adicionar propagandas à aplicação,
mas ele já está incluso no Google Play Services.

Para adicionar uma propaganda no aplicativo de hotéis adicione a
dependência do Google Play Services ao app/build.gradle e aplicar o plugin
como a seguir:
dependencies {
    ...
    implementation "com.google.android.gms:play-services-ads:$admob_version"
}

Note que foi utilizada a constante admob_version = '17.1.3' que deve ser
declarada no build.gradle do projeto.

Em seguida, adicione a seguinte configuração dentro da tag <application> no
AndroidManifest.xml:



<meta-data
    android:name="com.google.android.gms.ads.APPLICATION_ID"
    android:value="@string/admob_app_id"/>

Além dessa configuração, também é necessária a permissão de acesso à
internet que já havia sido adicionada anteriormente.

Agora faça a seguinte mudança na HotelActivity:
import com.google.android.gms.ads.MobileAds
...
class HotelActivity ... {
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        initAdMob()
    }
    private fun initAdMob() {
        MobileAds.initialize(this, getString(R.string.admob_app_id))
    }
}

O método initialize(Activity,String) da clsse MobileAds inicializará o AdMob no
aplicativo.

Para adicionar o banner da tela principal da aplicação, faça o seguinte ajuste
no arquivo res/layout/activity_hotel.xml:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    <androidx.coordinatorlayout.widget.CoordinatorLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">
        <!-- Dentro do CoordinatorLayout nada mudou -->
    </androidx.coordinatorlayout.widget.CoordinatorLayout>
    <com.google.android.gms.ads.AdView
        xmlns:ads="http://schemas.android.com/apk/res-auto"
        android:id="@+id/adView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        ads:adSize="BANNER"
        ads:adUnitId="@string/admob_adunit_id" />
</LinearLayout>

Foi utilizado um LinearLayout para que o banner fique na parte inferior da tela



sem sobrepor nenhuma informação, nem mesmo o FAB e a SnackBar.
A AdView possui a propriedade ads:adUnitId, na qual se deve informar o Ad

Unit Id que foi gerado anteriormente. Na propriedade ads:adSize, deve ser
indicado o tamanho da propaganda como SMART_BANNER, que trata
automaticamente o tamanho do aparelho e a orientação, mas pode utilizar
qualquer um dos valores listados na Tabela 18.1.

Tabela 18.1 – Tamanho das propagandas
Constante AdSize Tamanho Disponibilidade

BANNER 320 x 50 Smartphones e tablets
LARGE_BANNER 320 x 100 Smartphones e tablets
MEDIUM_RECTANGLE 300 x 250 Smartphones e tablets
FULL_BANNER 468 x 60 Tablets
LEADBOARD 768 x 90 Tablets
SMART_BANNER Dinâmico Smartphones e Tablets

Não esqueça de adicionar o banner também na versão para tablets. Altere o
arquivo res/layout-sw600dp/activity_hotel.xml como a seguir:
<LinearLayout ...>
    <fragment ...>
    <FrameLayout ...>
        <com.google.android.gms.ads.AdView
            xmlns:ads="http://schemas.android.com/apk/res-auto"
            android:id="@+id/adView"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="bottom|center"
            ads:adSize="BANNER"
            ads:adUnitId="@string/admob_adunit_id" />
        <com.google.android.material.floatingactionbutton.FloatingActionButton ...>
    </FrameLayout>
</LinearLayout>

Agora carregue o banner na aplicação. Para isso, altere a HotelActivity para
ficar como a seguir:
private fun initAdMob() {
    MobileAds.initialize(this, getString(R.string.admob_app_id))
    val adRequest = AdRequest.Builder()
            .addTestDevice(AdRequest.DEVICE_ID_EMULATOR)
            .addTestDevice("TEST_DEVICE_ID")
            .build()
    adView.loadAd(adRequest)



}
override fun onResume() {
    super.onResume()
    adView.resume()
}
override fun onPause() {
    super.onPause()
    adView.pause()
}
override fun onDestroy() {
    super.onDestroy()
    adView.destroy()
}

No método initAds(), um AdRequest foi criado para carregar a propaganda, e
nele foi usado o método addTestDevice(String) para podermos testar a propaganda
no emulador. Para usar o aparelho, é necessário substituir o texto
TEST_DEVICE_ID pelo id do seu aparelho (use o comando adb devices para obter o
id). Para carregar a propaganda, deve-se chamar o método load(AdRequest).

Para sincronizar o ciclo de vida do banner com o da activity, foram
implementados os métodos onResume(), onPause() e onDestroy() onde foram
chamados os respectivos métodos da classe AdView (resume(), pause() e destroy()).

Novos aplicativos e novas contas do AdMob podem demorar algumas horas
para exibir o banner. O Google fornece ids de aplicativo e de banner para
teste. Modifique as strings no res/values/strings.xml como a seguir. O
resultado deve ficar como a Figura 18.30:
<string name="admob_app_id" translatable="false">ca-app-pub-

3940256099942544~3347511713</string>
<string name="admob_adunit_id" translatable="false">ca-app-pub-

3940256099942544/6300978111</string>
Pode-se definir um callback para a requisição do banner da seguinte forma:

adView.adListener = object : AdListener() {
    override fun onAdLoaded() {
        // Chamado quando o banner termina de carregar
    }
    override fun onAdFailedToLoad(errorCode: Int) {
        // Chamado quando ocorre uma falha no carregamento do banner
    }
    override fun onAdOpened() {
        // Chamado quando o banner abre um overlay que cobre a tela
    }
    override fun onAdLeftApplication() {



        // Chamado quando o usuário sai da aplicação
    }
    override fun onAdClosed() {
        // Chamado quando o usuário está prestes a retornar a aplicação após
        // clicar em um banner
    } }

Figura 18.30 – Aplicativo com banner do AdMob.
Outro detalhe é que pode ser necessário configurar uma forma de

recebimento no site do AdMob. Para isso, selecione a opção Payments, se
você ainda não possuir um, clique na opção Set up Payments e será exibida a
tela da Figura 18.31.



Figura 18.31 – Adicionando forma de pagamento no AdMob.
Depois de configurar os banners da aplicação é possível acompanhar as

visualizações e os cliques, bem como os seus rendimentos no site do AdMob.

1 Você pode baixar uma cópia desse arquivo em:
https://github.com/nglauber/dominando_android3/blob/master/fcm_server.php.



CAPÍTULO 19
Mapa e localização

Utilizar a localização do aparelho pode facilitar bastante a vida do usuário,
pois o aplicativo poderá prover informações relevantes ao local em que ele se
encontra. E, sem sombra de dúvida, agregar um mapa à exibição da
localização ajudará bastante o usuário a interpretar o seu posicionamento
geográfico. Neste capítulo, será apresentado o Google Maps SDK for Android
e o serviço de localização do Google Play Services.

Google Maps
O Google Maps SDK for Android permite adicionar um mapa ao aplicativo.
Ele trata automaticamente o download e a exibição do mapa, assim como os
gestos para mover e definir o zoom. Também é possível adicionar
marcadores, modificar a forma de visualização etc.

Para iniciar o seu uso é necessário seguir alguns passos: gerar a chave de
acesso, adicionar a dependência do Google Play Services e fazer algumas
configurações no AndroidManifest.xml.

Gerando a chave de acesso
Acesse Google API Console (https://console.developers.google.com) e
selecione o projeto utilizado no capítulo anterior. Em seguida, clique na
opção Dashboard > Enable APIs and Services e digite no campo de busca
“Maps SDK for Android”, selecione essa opção no resultado da busca e
habilite o serviço clicando no botão Enable como mostra a Figura 19.1.

Feito isso, acesse a opção Credentials na página principal para criar uma
nova chave (da mesma forma que foi feito no exemplo do capítulo anterior).
Em seguida, clique no botão Create credentials > API key e será gerada uma
nova chave. No dialog que for exibido, clique no botão Restrict key, nomeie
essa chave como “Map key” e em Key restriction selecione Android apps.



Por fim, clique no botão Add package name and fingerprint e preencha com
o nome do pacote que será usado no projeto criado a seguir
(dominando.android.mapas); então copie o SHA-1 retornado pelo comando keytool e
cole no respectivo campo, como mostra a Figura 19.2.

Figura 19.1 – Habilitando o serviço do Google Maps no Developers
Console.



Figura 19.2 – Tela para criação da chave do Google Maps.
Clique no botão Save e será gerada a API key similar a

AIzaSyAKGpjuAUcsACXhOeM-iMYWqfYgudJB5eU que será usada no projeto. A
efetivação da chave pode demorar até 5 minutos.

Trabalhando com mapas
Application Name Mapas
Package Name dominando.android.mapas
Activity Name MainActivity

Crie um novo projeto, e a primeira mudança que deve ser feita é adicionar a
dependência do Google Play Services no arquivo app/build.gradle.
dependencies {
    def map_version = '16.1.0'



    ...
    implementation "com.google.android.gms:play-services-maps:$map_version"
}

Perceba que no próprio bloco dependencies foi definida a constante
playservices_version para armazenar a versão da biblioteca. Essa é uma alternativa
em relação a salvar as constantes no bloco ext do build.gradle do projeto,
entretanto essa constante só é visível nesse bloco.

Adicionada a dependência, faça os seguintes ajustes no
AndroidManifest.xml:
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="dominando.android.mapas" >
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
    <uses-feature
        android:glEsVersion="0x00020000"
        android:required="true"/>
    <application ... >
        <activity android:name=".MainActivity">...
        </activity>
        <uses-library
            android:name="org.apache.http.legacy"
            android:required="false" />
        <meta-data
            android:name="com.google.android.maps.v2.API_KEY"
            android:value="SUA_API_KEY_AQUI" />
        <meta-data
            android:name="com.google.android.gms.version"
            android:value="@integer/google_play_services_version" />
    </application>
</manifest>

As permissões de INTERNET e ACCESS_NETWORK_STATE não precisam ser
declaradas explicitamente, pois são adicionadas automaticamente pela
biblioteca do Google Play Services, mas elas são usadas para que seja feito o
download do mapa. As permissões ACCESS_COARSE_LOCATION e
ACESS_FINE_LOCATION permitem obter a localização do aparelho baseado na
rede (Wi-Fi ou Móvel) e no GPS, respectivamente.

Um requisito dessa API é que o aparelho suporte OpenGL ES versão 2, que
é usada para desenhar o mapa, por isso, na tag <uses-feature> esse recurso está
marcado como requerido android:required, informando a versão 2 por meio da
propriedade android:glEsVersion.



Dentro da tag <aplication>, foram adicionadas duas tags <meta-data>: a primeira
indica a API key que foi gerada na seção anterior e que deve ser inserida no
lugar do valor SUA_API_KEY_AQUI; a outra tag indica a versão do Google Play
Services.

Todas as aplicações que utilizarem a API de mapas e forem compatíveis
com Android Pie (API Level 28) devem adicionar a tag <uses-library> para
indicar que a biblioteca legada de HTTP do Apache não é necessária, pois ela
foi removida no Android Pie. Caso contrário, a API de mapas tentará usá-la e
um erro ocorrerá.

Mapas e coordenadas
Para utilizar um mapa basta adicionar um <fragment> no arquivo de layout
res/layout/activity_main.xml apontando para a classe
com.google.android.gms.maps.SupportMapFragment:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">
    <fragment
        android:id="@+id/fragmentMap"
        android:name="com.google.android.gms.maps.SupportMapFragment"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

Execute a aplicação1 e será obtido um resultado similar ao da Figura 19.3.



Figura 19.3 – Adicionando um mapa ao aplicativo.
Apenas um mapa estático não é muito interessante. Para posicioná-lo em

um local específico e com um zoom mais próximo será utilizada a classe
GoogleMap. Altere a classe MainActivity deixando-a como a seguir:
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.google.android.gms.maps.CameraUpdateFactory
import com.google.android.gms.maps.GoogleMap
import com.google.android.gms.maps.SupportMapFragment
import com.google.android.gms.maps.model.LatLng
import com.google.android.gms.maps.model.MarkerOptions
 
class MainActivity : AppCompatActivity() {
    private var googleMap: GoogleMap? = null
    private var origin = LatLng(-23.561706,-46.655981)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val fragment = supportFragmentManager
                .findFragmentById(R.id.fragmentMap) as SupportMapFragment
        fragment.getMapAsync {
            initMap(it)
        }



    }
    private fun initMap(map: GoogleMap?) {
        googleMap = map?.apply {
            mapType = GoogleMap.MAP_TYPE_SATELLITE
        }
        updateMap()
    }
    private fun updateMap() {
        googleMap?.run {
            animateCamera(CameraUpdateFactory.newLatLngZoom(origin, 17.0f))
            addMarker(MarkerOptions()
                    .position(origin)
                    .title("Av. Paulista")
                    .snippet("São Paulo"))
        }
    }
}

No onCreate(Bundle) é obtida a referência para o SupportMapFragment declarado no
arquivo de layout, e a partir dela é chamado o método
getMapAsync(OnMapReadyCallback), que carrega de forma assíncrona a instância do
objeto da classe GoogleMap. Após obter o mapa, é chamado o método
initMap(GoogleMap) onde o tipo de exibição do googleMap é modificado para
satélite por meio da propriedade mapType passando o valor
MAP_TYPE_SATELLITE. Os outros possíveis valores são: MAP_TYPE_HYBRID,
MAP_TYPE_TERRAIN, MAP_TYPE_NORMAL ou MAP_TYPE_NONE.

A classe LatLng representa uma coordenada geográfica composta de latitude
e longitude. Um objeto dessa classe foi criado para inicializar o atributo origin
com as coordenadas especificadas. Em seguida, o método updateMap() é
chamado para posicionar o mapa em um local específico e configurar o
zoom. Isso é feito com o método animateCamera(CameraUpdate) passando um
objeto CameraUpdate que é criado usando newLatLngZoom(LatLng,float) da classe
CameraUpdateFactory. O valor do zoom varia entre 2 e 21, sendo 21 o mais
próximo possível.

Para incluir um ponto no mapa basta usar o método addMarker(MarkerOptions)
passando um objeto MarkerOptions informando:

• a latitude/longitude, invocando o método position(LatLng);
• um título, usando title(String);
• e uma descrição via método snippet(String).



Essas duas últimas informações são opcionais e serão exibidas ao clicar no
marcador. Ao executar a aplicação e clicar no marcador, um resultado similar
ao da Figura 19.4 deve ser obtido.

Figura 19.4 – Mapa no modo satélite.
Como é possível observar, ao clicar no marcador que foi adicionado no

mapa, dois botões são exibidos na parte inferior direita, onde o primeiro
possibilita visualizar a rota até esse local, enquanto o segundo exibe o local
no aplicativo do Google Maps. Isso pode ser desabilitado da seguinte forma:
googleMap.uiSettings.isMapToolbarEnabled = false

Também é possível habilitar os botões de zoom e desabilitar os gestos
usando as seguintes chamadas:
googleMap.uiSettings.isZoomControlsEnabled = true
googleMap.uiSettings.setAllGesturesEnabled(false)

Um recurso interessante é poder visualizar o mapa em relevo, mostrando,
por exemplo, os prédios do local selecionado no mapa. Modifique o método
updateMap() para ficar como a seguir:
private fun updateMap() {
    googleMap?.run {
        mapType = GoogleMap.MAP_TYPE_NORMAL
        uiSettings?.isZoomControlsEnabled = true



        val icon = BitmapDescriptorFactory.fromResource(R.drawable.blue_marker)
        addMarker(MarkerOptions()
                .position(origin)
                .icon(icon)
                .title("Av. Paulista")
                .snippet("São Paulo"))
        val cameraPosition = CameraPosition.Builder()
                .target(origin)
                .zoom(17f)
                .bearing(90f)
                .tilt(45f)
                .build()
        animateCamera(CameraUpdateFactory.newCameraPosition(cameraPosition))
    }
}

Foi criado um marcador com uma imagem personalizada utilizando o
método icon(BitmapDescriptor). Para isso, é necessário carregar um BitmapDescriptor
utilizando o método fromResource(int) da classe BitmapDescriptorFactory. Em seguida,
deve-se adicionar o marcador ao mapa criando um objeto do tipo MarkerOptions,
onde é definido, além do título e do snippet, a imagem que representará o
marcador. Entretanto, essa imagem deve ser um arquivo *.png, então copie a
imagem que desejar para a pasta res/drawable.

Para configurar a visualização do mapa, foi criado um objeto CameraPosition
informando o objeto LatLng com a indicação do local; o zoom via método
zoom(int); o bearing(int) que é a rotação do mapa (que no nosso caso é 90 graus);
e o tilt(int) que representa a inclinação (aqui, 45 graus). O resultado pode ser
visto na Figura 19.5.

Note que os botões de zoom foram habilitados por meio da propriedade
isZoomControlsEnabled.



Figura 19.5 – Visualização do mapa com inclinação.

Localização
A API de localização do Google Play Services torna mais fácil o
desenvolvimento de aplicativos que utilizam a posição geográfica do
aparelho, abstraindo os detalhes da tecnologia utilizada (GPS, Wi-Fi ou redes
móveis) e minimizando o consumo de bateria, já que ela seleciona
automaticamente o melhor recurso de hardware para obter a localização atual.
Neste capítulo serão apresentados dois recursos dessa API: o Fused Location
Provider e a Geofencing API:

• o Fused Location Provider informa o local mais preciso de acordo com a
necessidade. É possível optar por obter uma localização mais precisa ou
que consuma menos energia;

• a Geofencing API permite estabelecer limites em torno de um local e
receber notificações quando o usuário entrar, sair ou permanecer dentro
desses limites.

Além desses recursos, será abordado como realizar a busca por um
endereço e como traçar rotas no mapa.



Obtendo a localização atual do aparelho
Para obter a localização do aparelho, é necessário realizar três configurações
no projeto. As duas primeiras já foram realizadas para que o mapa
funcionasse, mesmo assim, elas serão listadas a seguir caso seja necessário
utilizar apenas a localização:

• Declarar as permissões necessárias no AndroidManifest.xml:
<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>

<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
• Incluir a versão do Google Play Services também no

AndroidManifest.xml:
<meta-data
        android:name="com.google.android.gms.version"
        android:value="@integer/google_play_services_version" />

• Adicionar a dependência do Google Play Services no build.gradle, que
nos provê informações sobre localização:
dependencies {
    def playservices_version = '16.0.0'
    ...
    implementation "com.google.android.gms:play-services-location:$playservices_version"
}

A partir de agora a aplicação crescerá um pouco, então ela será organizada
utilizando o padrão MVVM. Para ajudar nessa tarefa, será utilizada mais uma
vez a classe ViewModel e o LiveData para atualização dos resultados. Como será
visto a seguir, as ações de localização acontecem de forma assíncrona, por
esta razão a biblioteca de coroutines será adicionada para realizar essa tarefa.

Adicione as dependências dessas bibliotecas no build.gradle do módulo app:
apply plugin: 'kotlin-kapt'
...
dependencies {
    def coroutines_version = '1.0.1'
    def lifecycle_version = '2.0.0'
    ...
    implementation "androidx.lifecycle:lifecycle-extensions:$lifecycle_version"
    implementation "androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version"
    kapt "androidx.lifecycle:lifecycle-compiler:$lifecycle_version"
 
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutines_version"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutines_version"



}
A lógica de apresentação do aplicativo será dividida entre a MainActivity, um

fragment que exibirá o mapa e o view model. Como é de se esperar, a activity
e o fragment serão responsáveis simplesmente por exibir o conteúdo na tela,
enquanto o view model fará o processamento da lógica da UI. Crie a classe
MapViewModel e deixe-a como a seguir:
import android.annotation.SuppressLint
import android.app.Application
import android.os.Bundle
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import com.google.android.gms.common.ConnectionResult
import com.google.android.gms.common.api.GoogleApiClient
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationServices
import com.google.android.gms.maps.model.LatLng
import kotlinx.coroutines.*
import kotlin.coroutines.CoroutineContext
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine
 
class MapViewModel(app: Application) : AndroidViewModel(app), CoroutineScope {
    private val job = Job()
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job
 
    private var googleApiClient: GoogleApiClient? = null
    private val locationClient: FusedLocationProviderClient by lazy {
        LocationServices.getFusedLocationProviderClient(getContext())
    }
    private val connectionStatus = MutableLiveData<GoogleApiConnectionStatus>()
    private val currentLocationError = MutableLiveData<LocationError>()
 
    private val mapState = MutableLiveData<MapState>().apply {
        value = MapState()
    }
    override fun onCleared() {
        super.onCleared()
        job.cancel()
    }
    fun getConnectionStatus(): LiveData<GoogleApiConnectionStatus> {
        return connectionStatus



    }
    fun getCurrentLocationError(): LiveData<LocationError> {
        return currentLocationError
    }
    fun getMapState(): LiveData<MapState> {
        return mapState
    }
    fun connectGoogleApiClient() {
        if (googleApiClient == null) {
            googleApiClient = GoogleApiClient.Builder(getContext())
                    .addApi(LocationServices.API)
                    .addConnectionCallbacks(object : GoogleApiClient.ConnectionCallbacks {
                        override fun onConnected(args: Bundle?) {
                            connectionStatus.value = GoogleApiConnectionStatus(true)
                        }
                        override fun onConnectionSuspended(i: Int) {
                            connectionStatus.value = GoogleApiConnectionStatus(false)
                            googleApiClient?.connect()
                        }
                    })
                    .addOnConnectionFailedListener { connectionResult ->
                        connectionStatus.value =
                                GoogleApiConnectionStatus(false, connectionResult)
                    }
                    .build()
        }
        googleApiClient?.connect()
    }
    fun disconnectGoogleApiClient() {
        connectionStatus.value = GoogleApiConnectionStatus(false)
        if (googleApiClient != null && googleApiClient?.isConnected == true) {
            googleApiClient?.disconnect()
        }
    }
    @SuppressLint("MissingPermission")
    private suspend fun loadLastLocation(): Boolean = suspendCoroutine { continuation ->
        locationClient.lastLocation
                .addOnSuccessListener { location ->
                    if (location != null) {
                        val latLng = LatLng(location.latitude, location.longitude)
                        mapState.value = mapState.value?.copy(origin = latLng)
                        continuation.resume(true)
                    } else {
                        continuation.resume(false)
                    }



                }
                .addOnFailureListener {
                    continuation.resume(false)
                }
                .addOnCanceledListener {
                    continuation.resume(false)
                }
    }
    fun requestLocation() {
        launch {
            currentLocationError.value = try {
                val success = withContext(Dispatchers.Default) { loadLastLocation() }
                if (success) {
                     null
                } else {
                    LocationError.ErrorLocationUnavailable
                }
            } catch (e: Exception) {
                LocationError.ErrorLocationUnavailable
            }
        }
    }
    private fun getContext() = getApplication<Application>()
 
    // Data classes -----------
    data class MapState(
            val origin: LatLng? = null
    )
    data class GoogleApiConnectionStatus(
            val success: Boolean,
            val connectionResult: ConnectionResult? = null
    )
    sealed class LocationError {
        object ErrorLocationUnavailable : LocationError()
    }
}

A classe MapViewModel herda de AndroidViewModel que se diferencia da classe
ViewModel pelo fato de prover um objeto Application que pode ser usado como
Context (uma vez que Application herda de Context) nas operações que não
dependam do contexto da activity. Para acessar esse objeto mais facilmente,
foi criado o método utilitário getContext(). Essa classe também implementa
CoroutineScope para que ela possa controlar as operações assíncronas das
coroutines. Por essa razão, foi declarado o atributo job que permite que as



tarefas sejam canceladas quando o view model for desalocado. Isto está
sendo feito no método onCleared().

A conexão com o serviço de localização será feita utilizando o objeto da
classe GoogleApiClient. No método connectGoogleApiClient() é criada a instância da
classe GoogleApiClient.Builder adicionando a LocationServices.API para requisitar os
recursos de localização. Em seguida, é adicionado um objeto que implementa
a interface ConnectionCallbacks e outro que implementa OnConnectionFailedListener,
que servem respectivamente para tratar os eventos de conexão efetuados com
sucesso ou quando houver falha nessa operação. Para tentar estabelecer a
conexão, é invocado o método connect().

Para abstrair da UI os estados desse processo de conexão, a classe
GoogleApiConnectionStatus foi criada. Ela possui dois atributos: connected indica se a
conexão foi estabelecida ou não; e connectionResult permite saber se o problema
de conexão pode ser solucionado. Entenderemos melhor esse segundo
atributo quando as mudanças na MainActivity forem implementadas mais
adiante, mas perceba que foi definido no início da classe o atributo
connectionStatus que é um MutableLiveData que será exposto para UI por meio do
método getConnectionStatus(). O valor desse atributo será atualizado durante o
processo de conexão de modo que a UI poderá observar e exibir o conteúdo
de acordo com o status.

No método disconnectGoogleApiClient() a conexão com o serviço é encerrada.
O conteúdo que será desenhado no mapa será representado pela classe

MapState, que, por agora, possui apenas uma coordenada geográfica
representando o local atual do aparelho. Um LiveData para o atributo mapState foi
exposto por meio do método getMapState() que será usado pela MainActivity.

Para obter a última localização conhecida do aparelho, foi declarado o
método loadLastLocation() no qual é realizada a chamada à propriedade lastLocation
do objeto locationClient (obtido por meio da chamada
LocationServices.getFusedLocationProviderClient(Context)). Quando essa informação for
carregada, o lambda do addOnSuccessListener será chamado. Perceba que esse
lambda recebe como parâmetro um objeto da classe Location que possui a
latitude e a longitude usada para criar um objeto LatLng. Com esse objeto, o
mapState é atualizado usando uma cópia do estado atual modificando apenas o
atributo origin. Quando um erro ocorre ao carregar a localização, o lambda do
addOnFailureListener é chamado.



KOTLINxJAVA: O método copy() do Kotlin existe em toda data class e é semelhante
ao clone() do Java.

Entretanto, a parte mais interessante desse método é que um “callback” está
sendo convertido em uma chamada “síncrona” com coroutines. A função
loadLastLocation() possui o modificador suspend, que indica que ela será suspensa,
ou seja, quem chamar essa função ficará aguardando pelo seu resultado. O
bloco suspendCoroutine recebe como parâmetro um objeto Continuation, que como o
próprio nome diz, serve para dar continuidade à execução da coroutine. Ao
receber o resultado da localização, a coroutine continua sua execução
retornando true por meio da chamada continuation.resume(Boolean), ou false caso um
erro ocorra. Outra opção seria utilizar continuation.resumeWithException(Throwable).

Por fim, o método requestLocation() é que executa a coroutine para obter a
localização atual. Perceba que toda a operação é executada dentro do bloco
launch. O método loadLastLocation() é chamado usando withContext(CoroutineContext)
para que seja executado em uma thread separada. Se algum erro ocorrer, o
atributo currentLocationError será atualizado e a UI deverá exibir um erro. Perceba
que esse atributo é um LiveData do tipo LocationError. Essa classe foi definida
como uma sealed class, o que quer dizer que ela tem um número restrito e
específico de subtipos. Isso faz sentido, pois nesse exemplo existe uma
quantidade específica de erros, que por agora é apenas um, mas outros dois
serão adicionados nas próximas seções.

Para dividir melhor as responsabilidades do projeto, toda a parte de desenho
do mapa ficará em uma classe separada. Crie a classe AppMapFragment e deixe-a
como a seguir:
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProviders
import com.google.android.gms.maps.CameraUpdateFactory
import com.google.android.gms.maps.GoogleMap
import com.google.android.gms.maps.OnMapReadyCallback
import com.google.android.gms.maps.SupportMapFragment
import com.google.android.gms.maps.model.MarkerOptions
 
class AppMapFragment : SupportMapFragment() {
    private val viewModel: MapViewModel by lazy {
        ViewModelProviders.of(requireActivity()).get(MapViewModel::class.java)
    }
    private var googleMap: GoogleMap? = null
 



    override fun getMapAsync(callback: OnMapReadyCallback?) {
        super.getMapAsync {
            googleMap = it
            setupMap()
            callback?.onMapReady(googleMap)
        }
    }
    private fun setupMap() {
        googleMap?.run {
            mapType = GoogleMap.MAP_TYPE_NORMAL
            uiSettings.isMapToolbarEnabled = false
            uiSettings.isZoomControlsEnabled = true
        }
        viewModel.getMapState()
                .observe(this, Observer { mapState ->
                    if (mapState != null) {
                        updateMap(mapState)
                    }
                })
    }
    private fun updateMap(mapState: MapViewModel.MapState) {
        googleMap?.run {
            clear()
            val origin = mapState.origin
            if (origin != null) {
                addMarker(MarkerOptions()
                        .position(origin)
                        .title("Local atual"))
                animateCamera(CameraUpdateFactory.newLatLngZoom(origin, 17.0f))
            }
        }
    }
}

Essa classe herda de SupportMapFragment e possui o atributo viewModel, que é
uma instância de MapViewModel que será compartilhada com a MainActivity como
será visto mais adiante. Esse comportamento é obtido ao passar a activity
como parâmetro of(Activity) do ViewModelProviders. No método
getMapAsync(OnMapReadyCallback), quando o mapa for carregado, a instância do
mapa será armazenada no atributo googleMap e o callback original será
chamado.

Assim, antes de chamar o callback original, o método setupMap() é chamado
para que o mapa seja configurado. Logo em seguida, utilizando o método



getMapState() do viewModel, é adicionado um Observer para a mudança de estado do
mapa. Quando o estado for modificado, o método updateMap(MapState) será
chamado.

Utilizando o método clear(), são removidos quaisquer elementos que tenham
sido adicionados no mapa (como marcadores, e polylines que veremos mais
adiante). Em seguida, se o mapState possuir um ponto de origem, um marcador
é adicionado ao mapa neste local.

Para utilizar a classe AppFragment na MainActivity, basta alterar a classe no
arquivo de layout res/layout/activity_main.xml:
 <androidx.constraintlayout.widget.ConstraintLayout ...>
    <fragment
        android:id="@+id/fragmentMap"
        android:name="dominando.android.mapas.AppMapFragment"... />
</androidx.constraintlayout.widget.ConstraintLayout>

Uma vez que o MapViewModel e o AppMapFragment estão definidos, eles podem
ser utilizados na MainActivity para exibir a localização atual no mapa. Para isso,
faça as mudanças listadas a seguir:
import android.Manifest
import android.app.Activity
import android.content.Intent
import android.content.IntentSender
import android.content.pm.PackageManager
import android.os.Bundle
import android.widget.Toast
import androidx.annotation.StringRes
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProviders
import com.google.android.gms.common.ConnectionResult
import com.google.android.gms.common.GoogleApiAvailability
 
class MainActivity : AppCompatActivity() {
    private val viewModel: MapViewModel by lazy {
        ViewModelProviders.of(this).get(MapViewModel::class.java)
    }
    private val fragment: AppMapFragment by lazy {
        supportFragmentManager.findFragmentById(R.id.fragmentMap) as AppMapFragment
    }
 
    override fun onCreate(savedInstanceState: Bundle?) {



        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
    override fun onStart() {
        super.onStart()
        fragment.getMapAsync {
            initUi()
            viewModel.connectGoogleApiClient()
        }
    }
    override fun onStop() {
        super.onStop()
        viewModel.disconnectGoogleApiClient()
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == REQUEST_ERROR_PLAY_SERVICES &&
                resultCode == Activity.RESULT_OK) {
            viewModel.connectGoogleApiClient()
        }
    }
    override fun onRequestPermissionsResult(requestCode: Int,
                                            permissions: Array<out String>,
                                            grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == REQUEST_PERMISSIONS && permissions.isNotEmpty()) {
            if (permissions.firstOrNull() == Manifest.permission.ACCESS_FINE_LOCATION &&
                    grantResults.firstOrNull() == PackageManager.PERMISSION_GRANTED) {
                loadLastLocation()
            } else {
                showError(R.string.map_error_permissions)
                finish()
            }
        }
    }
    private fun initUi() {
        viewModel.getConnectionStatus()
                .observe(this, Observer { status ->
                    if (status != null) {
                        if (status.success) {
                            loadLastLocation()
                        } else {
                            status.connectionResult?.let {
                                handleConnectionError(it)
                            }



                        }
                    }
                })
        viewModel.getCurrentLocationError()
                .observe(this, Observer { error ->
                    handleLocationError(error)
                })
    }
    private fun handleLocationError(error: MapViewModel.LocationError?) {
        if (error != null) {
            when (error) {
                is MapViewModel.LocationError.ErrorLocationUnavailable ->
                    showError(R.string.map_error_get_current_location)
            }
        }
    }
    private fun loadLastLocation() {
        if (!hasPermission()) {
            ActivityCompat.requestPermissions(this,
                    arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),
                    REQUEST_PERMISSIONS)
            return
        }
        viewModel.requestLocation()
    }
    private fun handleConnectionError(result: ConnectionResult) {
        if (result.hasResolution()) {
            try {
                result.startResolutionForResult(
                        this, MainActivity.REQUEST_ERROR_PLAY_SERVICES)
            } catch (e: IntentSender.SendIntentException) {
                e.printStackTrace()
            }
        } else {
            showPlayServicesErrorMessage(result.errorCode)
        }
    }
    private fun hasPermission(): Boolean {
        val granted = PackageManager.PERMISSION_GRANTED
        return ActivityCompat.checkSelfPermission(this,
                Manifest.permission.ACCESS_FINE_LOCATION) == granted
    }
    private fun showError(@StringRes errorMessage: Int) {
        Toast.makeText(this, errorMessage, Toast.LENGTH_SHORT).show()
    }



    private fun showPlayServicesErrorMessage(errorCode: Int) {
        GoogleApiAvailability.getInstance()
                .getErrorDialog(this, errorCode, REQUEST_ERROR_PLAY_SERVICES)
                .show()
    }
    companion object {
        private const val REQUEST_ERROR_PLAY_SERVICES = 1
        private const val REQUEST_PERMISSIONS = 2
    }
}

No início da classe são declarados o viewModel e o fragment. No método onStart()
a instância do mapa é carregada por meio do método
getMapAsync(OnMapReadyCallback). Após o carregamento do mapa, o método initUi()
é chamado para que sejam adicionados um Observer para as mudanças de
estado da conexão com a GoogleApiClient invocando o método getConnectionState()
da MapViewModel.

Se a conexão com o serviço falhar, o método
handleConnectionError(ConectionResult) será chamado e então é checado se há uma
solução para o problema (normalmente instalar ou atualizar o Google Play
Services) com o método hasResolution() do objeto ConnectionResult que foi recebido
como parâmetro. Se não houver como resolver o problema, uma mensagem
de erro é exibida; caso contrário, o método startResolutionForResult(Activity,int) será
invocado, e que normalmente abrirá o Google Play para resolver o problema.
Ao voltar para aplicação, no onActivityResult(int,int, Intent) é verificado se o
problema foi solucionado; se tiver sido resolvido, um nova tentativa de
conexão é realizada.

Ainda no initUi(), também é adicionado um Observer para tratar o erro na
obtenção da localização atual utilizando o método getCurrentLocationError() do
MapViewModel. Se um erro ocorrer, o método handleLocationError(LocationError) será
chamado.

No onStart() a conexão com a API de localização é realizada invocando o
método connectGoogleApiClient() do MapViewModel. Se a conexão com o serviço for
bem-sucedida, o método loadLastLocation() é chamado. Nesse método, é
verificado se o usuário concedeu a permissão de acesso à localização do
aparelho. Caso já tenha sido concedida, é invocado o método requestLocation()
do MapViewModel, caso contrário, a permissão do usuário é solicitada. Ao
conceder a permissão, o método onRequestPermissionsResult() é chamado, e então é



feita uma nova tentativa de conexão.
Lembre-se de adicionar a string abaixo no res/values/strings.xml:

<string name="map_error_get_current_location">Erro ao obter a localização atual.</string>
<string name="map_error_permissions">Você deve aceitar as permissões para executar a aplicação.

</string>
Execute a aplicação e ela deve exibir um marcador no local atual como

mostra a Figura 19.6.

Figura 19.6 – Exibindo a localização atual no mapa.
No emulador nativo do Android, é possível enviar um localização clicando

no botão “...” e será exibida a tela da Figura 19.7. Nessa tela podem-se enviar
a latitude e longitude para o emulador, bem como carregar um arquivo de
coordenadas no formato GPX/KML e definir o intervalo em que cada
coordenada do arquivo será enviada para o emulador. Essa é uma ótima
maneira de testar a atualização de posicionamento no mapa.

Para obter uma latitude/longitude válida para enviar para o emulador, você
pode acessar o Google Maps no browser (http://maps.google.com) e clicar
em qualquer ponto do mapa com o botão direito e selecionar a opção “O que
há aqui?”. Será então exibida a coordenada geográfica do local clicado no
mapa.



Ao enviar uma localização para o emulador ela só será consumida pelo
FusedLocationProviderClient. Como isso não está acontecendo neste momento em
nosso aplicativo, abra o aplicativo do Google Maps e envie a coordenada que
desejar. Assim a classe FusedLocationProviderClient será atualizada internamente.
Obviamente isso não será necessário quando a aplicação se registrar para
detectar a mudança de localização do aparelho.

Figura 19.7 – Tela para envio de localização fictícia no emulador do
Android.

Foi visto como obter a localização atual do aparelho e exibi-la no mapa,
pois a API de localização funciona independentemente da API de mapas.
Para visualizar o local atual no mapa, basta utilizar a seguinte chamada:
googleMap.isMyLocationEnabled = true

Ativando essa propriedade um botão aparecerá na parte superior da tela, e
ao ser clicado, a localização atual será mostrada no mapa.

Verificando se o GPS está habilitado
O usuário pode desabilitar a configuração de localização do aparelho a
qualquer momento. Sendo assim, é necessário verificar essa configuração



antes de tentar obter a localização atual.
Será preciso fazer mudanças na activity e no view model. Então comece

com a classe MapViewModel:
import android.location.Location
import com.google.android.gms.common.api.ApiException
import com.google.android.gms.common.api.ResolvableApiException
import com.google.android.gms.location.*
 
class MapViewModel(app: Application) : AndroidViewModel(app) {
    ...
    @SuppressLint("MissingPermission")
    private suspend fun loadLastLocation(): Boolean = suspendCoroutine { continuation ->
        fun updateOriginByLocation(location: Location) {
            val latLng = LatLng(location.latitude, location.longitude)
            mapState.value = mapState.value?.copy(origin = latLng)
            continuation.resume(true)
        }
        fun waitForLocation() {
            val locationRequest = LocationRequest.create()
                    .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)
                    .setInterval(5 * 1000)
                    .setFastestInterval(1 * 1000)
            locationClient.requestLocationUpdates(locationRequest,
                    object : LocationCallback() {
                        override fun onLocationResult(result: LocationResult?) {
                            super.onLocationResult(result)
                            locationClient.removeLocationUpdates(this)
                            val location = result?.lastLocation
                            if (location != null) {
                                updateOriginByLocation(location)
                            } else {
                                continuation.resume(false)
                            }
                        }
                    }, null)
        }
        locationClient.lastLocation
                .addOnSuccessListener { location ->
                    if (location == null) {
                        waitForLocation()
                    } else {
                        updateOriginByLocation(location)
                    }
                }



                .addOnFailureListener {
                    waitForLocation()
                }
                .addOnCanceledListener {
                    continuation.resume(false)
                }
    }
    private suspend fun checkGpsStatus(): Boolean = suspendCoroutine { continuation ->
        val request = LocationRequest.create()
                .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)
        val locationSettingsRequest = LocationSettingsRequest.Builder()
                .setAlwaysShow(true)
                .addLocationRequest(request)
        SettingsClient(getContext()).checkLocationSettings(locationSettingsRequest.build())
                .addOnCompleteListener { task ->
                    try {
                        task.getResult(ApiException::class.java)
                        continuation.resume(true)
                    } catch (exception: ApiException) {
                        continuation.resumeWithException(exception)
                    }
                }
                .addOnCanceledListener {
                    continuation.resume(false)
                }
    }
    fun requestLocation() {
        launch {
            currentLocationError.value = try {
                checkGpsStatus()
                val success = withTimeout(20000) { loadLastLocation() }
                if (success) {
                    null
                } else {
                    LocationError.ErrorLocationUnavailable
                }
            } catch (timeout: TimeoutCancellationException) {
                LocationError.ErrorLocationUnavailable
            } catch (exception: ApiException) {
                when (exception.statusCode) {
                    LocationSettingsStatusCodes.RESOLUTION_REQUIRED ->
                        LocationError.GpsDisabled(exception as ResolvableApiException)
                    LocationSettingsStatusCodes.SETTINGS_CHANGE_UNAVAILABLE ->
                        LocationError.GpsSettingUnavailable
                    else ->



                        LocationError.ErrorLocationUnavailable
                }
            }
        }
    }
    ...
    sealed class LocationError {
        object ErrorLocationUnavailable : LocationError()
        data class GpsDisabled(val exception: ResolvableApiException): LocationError()
        object GpsSettingUnavailable: LocationError()
    }
}

O método loadLastLocation() é que sofreu uma mudança interessante e
significativa. Quando a configuração de localização do aparelho é
desabilitada, o cache que armazena a última localização é apagado. Por isso,
pode haver uma demora significativa para obter a localização atual após
reativar o GPS do aparelho.

Sendo assim, uma tentativa é realizada para obter a última localização atual,
se conseguir, a função interna updateOriginByLocation(Location) é chamada para
atualizar o estado atual do mapa e continuar a execução da coroutine. Caso
não seja possível obter a localização atual no momento, a outra função
interna waitForLocation() é chamada, na qual é registrado um objeto do tipo
LocationCallback para ficar aguardando a localização atual ficar disponível. E
apenas quando a localização estiver disponível o método
onLocationResult(Locationresult) será chamado, e nesse momento o mapa é
atualizado com a localização atual e a coroutine continua a execução.

KOTLINxJAVA: Em Kotlin é possível definir funções dentro de funções. Apesar
de parecer estranho, esse recurso pode ser interessante em algumas situações.

Para verificar se a configuração de localização está habilitada, foi utilizada
mais uma vez uma coroutine para transformar um callback em um método
que pode ser suspenso. É verificado se a configuração de localização está
habilitada utilizando o método checkLocationSettings(LocationSettingsRequest) da classe
SettingsClient. Esse método retorna um objeto Task, que representa um resultado
pendente e que será verificado ao invocar o método
addOnCompleteListener(OnCompleteListener). Nesse caso, o método
onComplete(Task<LocationSettingsResponse>) será chamado (que aqui está simplificado



com um lambda), a coroutine continuará a execução com o valor true, pois a
configuração está ativada. Caso tenha sido levantada uma exceção, a
couroutine continua com uma exceção. Por fim, se o usuário cancelar o
dialog, a coroutine continua com o valor false.

O método requestLocation() está chamando checkGpsStatus() e caso algum erro
ocorra, uma instância da classe LocationError será atribuída ao valor do LiveData
currentLocationError: GpsDisabled para quando o GPS estiver desativado; e
GpsSettingUnavailable quando não for possível alterar as configurações de GPS.
Um outro detalhe desse método é o uso do método withTimeout(Int,TimeUnit,()->T),
em que a localização é aguardada por até 20 segundos, e caso não seja
possível obtê-la naquele momento um erro será retornado.

Na activity, será verificado se a configuração de localização do aparelho foi
ativada; nesse caso, a localização atual será carregada. Caso ocorra alguma
exceção, o status do erro é verificado. Se o resultado for
RESOLUTION_REQUIRED, será solicitado ao usuário que habilite essa
configuração, caso contrário, uma mensagem de erro será exibida. Faça os
seguintes ajustes na MainActivity:
class MainActivity : AppCompatActivity() {
    ...
    private var isGpsDialogOpened: Boolean = false
    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        isGpsDialogOpened = savedInstanceState?.getBoolean(EXTRA_GPS_DIALOG) ?: false
    }
    override fun onSaveInstanceState(outState: Bundle?) {
        super.onSaveInstanceState(outState)
        outState?.putBoolean(EXTRA_GPS_DIALOG, isGpsDialogOpened)
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == REQUEST_ERROR_PLAY_SERVICES &&
                resultCode == Activity.RESULT_OK) {
            viewModel.connectGoogleApiClient()
        } else if (requestCode == REQUEST_CHECK_GPS) {
            isGpsDialogOpened = false
            if (resultCode == RESULT_OK) {
                loadLastLocation()
            } else {



                Toast.makeText(this, R.string.map_error_gps_disabled,
                    Toast.LENGTH_SHORT).show()
                finish()
            }
        }
    }
    private fun handleLocationError(error: MapViewModel.LocationError?) {
        if (error != null) {
            when (error) {
                is MapViewModel.LocationError.ErrorLocationUnavailable ->
                    showError(R.string.map_error_get_current_location)
                is MapViewModel.LocationError.GpsDisabled -> {
                    if (!isGpsDialogOpened) {
                        isGpsDialogOpened = true
                        error.exception.startResolutionForResult(
                                this, MainActivity.REQUEST_CHECK_GPS)
                    }
                }
                is MapViewModel.LocationError.GpsSettingUnavailable ->
                    showError(R.string.map_error_gps_settings)
            }
        }
    }
    ...
    companion object {
        ...
        private const val REQUEST_CHECK_GPS = 3
        private const val EXTRA_GPS_DIALOG = "gpsDialogIsOpen"
    }
}

O atributo isGpsDialogOpened foi adicionado para controlar se a mensagem que
solicita que o usuário habilite o GPS está sendo exibida. Isto está sendo feito
para evitar que esta mensagem seja exibida mais de uma vez se o usuário
girar a tela do aparelho. Por essa razão, esse valor é salvo no
onSaveInstanceState(Bundle) e recuperado no onCreate(Bundle).

Adicione os textos das mensagens de erro no res/values/strings.xml:
<string name="map_error_gps_disabled">É necessário habilitar a configuração de localização para

utilizar o aplicativo.</string>
<string name="map_error_gps_settings">Não é possível habilitar a localização</string>

Observe o método checkGpsStatus() da classe MapViewModel. Caso a
configuração de localização do aparelho não esteja habilitada, a exceção
ApiException será levantada. Se o statusCode dessa exceção for



SETTINGS_CHANGE_UNAVAILABLE, que apenas ocorre caso o aparelho não tenha
uma forma de obter a localização ou se o usuário pressionar a opção Nunca
no dialog. Como você deve ter notado, essa opção não é exibida porque o
método setAlwaysShow(boolean) foi chamado no objeto LocationSettingsRequest para
que o usuário só tenha as opções sim e não. Entretanto, se o statusCode for
RESOLUTION_REQUIRED, o método startResolutionForResult(Activity,int) é invocado em
handleLocationError(LocationError) da MainActivity e uma mensagem similar à da
Figura 19.8 será exibida.

Figura 19.8 – Solicitando a ativação do recurso de localização.
Quando o usuário pressionar qualquer uma das opções do dialog, o

onActivityResult (int,int,Intent) será chamado. Caso o usuário tenha confirmado para
habilitar a localização, teremos o RESULT_OK e, nesse caso, obtemos a última
localização; caso contrário, exibimos um Toast e fechamos a aplicação, pois a
nossa aplicação não faz sentido sem o recurso de localização.

Feito isso, execute a aplicação com a configuração de localização
desabilitada. Depois saia da aplicação e execute com ela habilitada, e nosso
aplicativo deverá continuar funcionando corretamente.

Buscando um endereço



Para realizar a busca por locais, pode-se utilizar a classe Geocoder (que não faz
parte do Google Play Services), na qual informam-se a latitude e a longitude,
ou simplesmente o nome do local ou o endereço. Essa busca retornará uma
lista de objetos Address por meio da qual é possível resgatar mais informações
sobre o endereço. Como essa busca é feita na internet, ela deve ser feita em
outra thread, e para ajudar nessa tarefa de mantermos a requisição assíncrona
mesmo ao rotacionar o aparelho, serão utilizadas mais uma vez as coroutines
em conjunto com o ViewModel e o LiveData.

Faça as seguintes mudanças na classe MapViewModel:
import android.location.Address
import android.location.Geocoder
import java.util.*
class MapViewModel(app: Application) : AndroidViewModel(app), CoroutineScope {
    ...
    private val addresses = MutableLiveData<List<Address>?>()
    private val loading = MutableLiveData<Boolean>()
    ...
    fun getAddresses(): LiveData<List<Address>?> {
        return addresses
    }
    fun isLoading(): LiveData<Boolean> {
        return loading
    }
    ...
    fun searchAddress(s: String) {
        launch {
            loading.value = true
            val geoCoder = Geocoder(getContext(), Locale.getDefault())
            addresses.value = withContext(Dispatchers.IO) {
                geoCoder.getFromLocationName(s, 10)
            }
            loading.value = false
        }
    }
    fun clearSearchAddressResult() {
        addresses.value = null
    }
    fun setDestination(latLng: LatLng) {
        addresses.value = null
        mapState.value = mapState.value?.copy(destination = latLng)
    }
    data class MapState(



            val origin: LatLng? = null,
            val destination: LatLng? = null
    )
    ...
}

Foram definidos dois LiveData: loading e addresses. O primeiro informará se os
dados estão sendo carregados, enquanto o segundo fornecerá a lista de
endereços encontrados. Esse atributos estão sendo expostos para UI por meio
dos métodos isLoading() e getAddresses(), respectivamente.

A busca por locais está sendo feita por meio do método getFromLocationName
(String,int) da classe Geocoder onde o primeiro parâmetro é o local que está sendo
procurado (Ex.: “Av. Boa Viagem”) e o segundo é a quantidade máxima de
resultados desejados. Esse método retornará uma lista de objetos do tipo
Address, que contém a informação completa do endereço.

Essa busca está sendo realizada dentro do método searchAddress(String), que
simplesmente utiliza a API de coroutines para realizar a busca de endereços
assincronamente. O valor loading é atualizado para true para que a mensagem de
“procurando...” seja exibida na tela (que será implementado a seguir). Em
seguida, a pesquisa de endereços é feita dentro do bloco
withContext(CoroutinesContext,()->T). Quando a busca for concluída, o resultado é
atribuído ao valor da propriedade addresses para que os dados sejam exibidos na
tela (que também será feito a seguir). Finalmente, o valor loading é alterado
para false de modo a ocultar a mensagem.

O resultado dessa busca será exibido em um dialog representado pela classe
AddressListFragment. Crie essa nova classe e deixe-a como a seguir:
import android.app.Dialog
import android.content.DialogInterface
import android.location.Address
import android.os.Bundle
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.DialogFragment
import androidx.lifecycle.ViewModelProviders
import com.google.android.gms.maps.model.LatLng
 
class AddressListFragment : DialogFragment() {
    private val viewModel: MapViewModel by lazy {
        ViewModelProviders.of(requireActivity()).get(MapViewModel::class.java)
    }
    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {



        val args = arguments?.getParcelableArray(EXTRA_ADDRESSES) ?: emptyArray()
        val addresses = args as Array<Address>
        val onAddressClick =
                DialogInterface.OnClickListener { _, which ->
                    val selectedAddress = addresses[which]
                    viewModel.setDestination(LatLng(
                            selectedAddress.latitude,
                            selectedAddress.longitude))
                }
        return AlertDialog.Builder(requireContext())
                .setTitle(R.string.map_title_address_result_dialog)
                .setItems(addressesToArray(addresses), onAddressClick)
                .setOnDismissListener { viewModel.clearSearchAddressResult() }
                .create()
    }
    companion object {
        private const val EXTRA_ADDRESSES = "addresses"
        fun newInstance(addresses: List<Address>): AddressListFragment {
            return AddressListFragment().apply {
                arguments = Bundle().apply {
                    putParcelableArray(EXTRA_ADDRESSES, addresses.toTypedArray())
                }
            }
        }
        private fun addressesToArray(addresses: Array<Address>): Array<String> {
            val addressTexts = mutableListOf<String>()
            for (address in addresses) {
                val street = StringBuffer()
                for (j in 0..address.maxAddressLineIndex) {
                    if (street.isNotEmpty()) {
                        street.append('\n')
                    }
                    street.append(address.getAddressLine(j))
                }
                val country = address.countryName
                addressTexts.add("$street, $country")
            }
            return addressTexts.toTypedArray()
        }
    }
}

Essa classe é um DialogFragment que recebe um array de objetos Address
contendo os endereços resultantes da busca. Para exibi-los na tela, esse array
é convertido em um array de strings utilizando o método



addressesToArray(Array<Address>), onde o array de objetos Address é percorrido para
montar um array de String para ser exibido na tela. Cada string da lista será
composta com todas as linhas do endereço e o país. Essas informações são
obtidas com getAddressLine(i) e countryName, respectivamente.

Uma vez que a lista estiver pronta, um AlertDialog é criado recebendo a lista
de endereços por meio do método
setItems(CharSequence[],DialogInterface.OnClickListener). Porém, perceba que o objeto
onAddressClick está sendo passado e será chamado quando um item da lista for
clicado, e no método onClick(DialogInterface,int) desse objeto o segundo parâmetro
representa a posição que foi clicada. Com ele, o objeto Address da posição
correspondente é obtido, um LatLng é criado e atribuído ao viewmodel usando
o método setDestination(LatLng). Isso fará com que o estado do mapa seja alterado
no MapViewModel e, consequentemente, o mapa será atualizado.

Adicione o título do dialog no res/values/strings.xml:
<string name="map_title_address_result_dialog">Selecione o destino</string>

Para incorporar essa funcionalidade à aplicação, são necessários alguns
ajustes do arquivo de layout da MainActivity. Altere o arquivo
res/layout/activity_main.xml para ficar como a seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <EditText
        android:id="@+id/edtSearch"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        app:layout_constraintEnd_toStartOf="@+id/btnSearch"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="@+id/btnSearch" />
    <ImageButton
        android:id="@+id/btnSearch"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_search"
        app:layout_constraintEnd_toEndOf="@+id/fragmentMap"
        app:layout_constraintTop_toTopOf="parent" />
    <fragment
        android:id="@+id/fragmentMap"



        android:name="dominando.android.mapas.AppMapFragment"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/btnSearch" />
    <include
        layout="@layout/layout_loading"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

Esse arquivo não tem nada de especial. Apenas foi adicionado um EditText na
parte superior para que o usuário possa digitar o endereço ou o nome do
local, e um ImageButton para efetuar a busca. O último detalhe é que este
arquivo está referenciando o arquivo res/layout/layout_loading.xml listado a
seguir:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/llProgress"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@drawable/bg_loading"
    android:orientation="vertical"
    android:visibility="gone"
    android:gravity="center"
    android:padding="24dp">
    <ProgressBar
        style="?android:attr/progressBarStyleLarge"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/pgbLoading" />
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textColor="@android:color/white"
        android:id="@+id/txtProgress" />
</LinearLayout>

Nenhuma novidade nesse arquivo também. Apenas sua propriedade



android:background que está apontando para o arquivo
res/drawable/bg_loading.xml:
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="#C000"/>
    <corners android:radius="20dp"/>
</shape>

Foi definida uma forma (shape) com uma cor sólida (solid) e com os cantos
(corners) arredondados.

Agora faça os ajustes necessários na MainActivity:
import android.location.Address
import android.view.View
import android.view.inputmethod.InputMethodManager
import kotlinx.android.synthetic.main.activity_main.*
import kotlinx.android.synthetic.main.layout_loading.*
 
class MainActivity : AppCompatActivity() {
    ...
    private fun initUi() {
        ...
        viewModel.isLoading()
                .observe(this, Observer { value ->
                    if (value != null) {
                        btnSearch.isEnabled = !value
                        if (value) {
                            showProgress(getString(R.string.map_msg_search_address))
                        } else {
                            hidePogress()
                        }
                    }
                })
        viewModel.getAddresses()
                .observe(this, Observer { addresses ->
                    if (addresses != null) {
                        showAddressListDialog(addresses)
                    }
                })
        btnSearch.setOnClickListener {
            searchAddress()
        }
    }
    ...
    private fun searchAddress() {
        val imm = getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager



        imm.hideSoftInputFromWindow(edtSearch.windowToken, 0)
        viewModel.searchAddress(edtSearch.text.toString())
    }
    private fun showProgress(message: String) {
        txtProgress.text = message
        llProgress.visibility = View.VISIBLE
    }
    private fun hidePogress() {
        llProgress.visibility = View.GONE
    }
    private fun showAddressListDialog(addresses: List<Address>) {
        AddressListFragment.newInstance(addresses).show(supportFragmentManager, null)
    }
    ...
}

No método initUi(GoogleMap) foram registrados Observer para as novas
propriedades criadas no view model. Para isLoading(), caso o valor seja true, o
método showProgress(String) é invocado e exibirá a llProgress (do arquivo
layout_loading.xml), caso contrário, a view será ocultada no método
hideProgress(). Já o Observer do getAddress() exibirá o dialog com os resultados da
busca por endereços por meio do método showAddressListDialog(List<Address>). No
evento de clique do botão btnSearch, o método searchAddress() é invocado, onde o
teclado virtual está sendo fechado com a classe InputMethodManager, e, em
seguida, o método searchAddress(String) da classe MapViewModel é chamado para
iniciar a busca pelo endereço.

As últimas mudanças necessárias devem ser feitas na classe AppMapFragment:
class AppMapFragment : SupportMapFragment() {
    ...
    private fun updateMap(mapState: MapViewModel.MapState) {
        googleMap?.run {
            clear()
            val area = LatLngBounds.Builder()
            val origin = mapState.origin
            if (origin != null) {
                addMarker(MarkerOptions()
                        .position(origin)
                        .title(getString(R.string.map_marker_origin)))
                area.include(origin)
            }
            val destination = mapState.destination
            if (destination != null) {
                addMarker(MarkerOptions()



                        .position(destination)
                        .title(getString(R.string.map_marker_destination))
                )
                area.include(destination)
            }
            if (origin != null) {
                if (destination != null) {
                    animateCamera(CameraUpdateFactory.newLatLngBounds(area.build(), 50))
                } else {
                    animateCamera(CameraUpdateFactory.newLatLngZoom(origin, 17f))
                }
            }
        }
    }
}

O updateMap(MapState) sofreu uma mudança significativa e interessante. Como
agora existem dois pontos no mapa, o mapa é “limpo” com método clear() do
googleMap, removendo qualquer elemento que tenha sido adicionado ao mapa.
Em seguida, é verificado se origin e destination são diferentes de nulo antes de
adicionar o marcador no mapa. Ao final do método, é checado se apenas a
coordenada de origin é diferente de null, e nesse caso, a câmera é posicionada
com o zoom apenas nesse ponto; mas se ambas as coordenadas existirem, é
utilizada a classe LatLngBounds para dar um zoom de modo que ambos os
pontos sejam exibidos na tela ao mesmo tempo.

Adicione ao res/values/strings.xml os textos que foram utilizados no código
anterior:
<string name="map_msg_search_address">Buscando endereço…</string>
<string name="map_marker_origin">Origem</string>
<string name="map_marker_destination">Destino</string>
<string name="map_current_location">Local atual</string>

Feito isso, execute a aplicação e faça a busca por um local; será exibida
uma tela similar à da Figura 19.9.

Após selecionar o local, o mapa exibirá os dois pontos na tela: o local atual
e o lugar pesquisado, conforme a Figura 19.10.



Figura 19.9 – Exibindo o resultado da busca por endereço.

Figura 19.10 – Exibindo dois pontos no mapa.
Na próxima seção será demonstrado como traçar uma rota entre dois pontos



no mapa.

Traçando rotas
Uma vez que estão sendo exibidos dois pontos no mapa, é possível tentar
traçar uma rota entre eles. Para fazer isso, serão utilizados dois recursos
adicionais:

• Google Directions API
(https://developers.google.com/maps/documentation/directions) – é uma
API REST que calcula o trajeto entre dois pontos, onde é possível
pesquisar direções de carro, bicicleta, ônibus e a pé. Basta informar os
nomes dos locais de origem e de destino ou suas respectivas
latitude/longitude.

• Google Maps Android API Utility Library
(https://developers.google.com/maps/documentation/android/utility) – é
um pacote com diversas classes úteis para trabalhar com mapas no
Android.

A Directions API retorna as direções codificadas em polylines, e para
decodificá-las será utilizada a classe PolyUtil da Utility Library. Acesse Google
API Console (https://console.developers.google.com) e em seguida, clique na
opção Dashboard > Enable APIs and Services e digite no campo de busca
“Directions”, selecione essa opção no resultado da busca e habilite o serviço
clicando no botão Enable.

Tanto o serviço de mapas quanto de localização são pagos, mas no
momento da escrita desse livro, os primeiros US$200,00 (duzentos dólares)
em acesso não eram cobrados pelo Google. Então provavelmente você terá
que adicionar informações pessoais como número de CPF e cartão de crédito
para utilizar esse serviço. Mas o valor disponibilizado pelo Google dá direito
a cerca de 40.000 acessos a API de Directions e 100.000 acessos a API de
Maps, o que é mais do que suficiente para você testar sua aplicação. Consulte
o site https://developers.google.com/maps para mais informações sobre o
custo do uso das APIs.

Para adicioná-la ao projeto, inclua as dependências no arquivo
app/build.gradle:
dependencies {
    def okhttp_version = '3.12.0'



    def maputils_version = '0.5'
    ...
    implementation "com.google.maps.android:android-maps-utils:$maputils_version"
    implementation "com.squareup.okhttp3:okhttp:$okhttp_version"
}

Foi incluída também a dependência da biblioteca OkHttp para facilitar
obtenção da resposta da API.

Adicione o objeto RouteHttp listado a seguir que fará a requisição ao serviço
de direções do Google e realizará o parser do JSON retornado com a
informação da rota:
import com.google.android.gms.maps.model.LatLng
import com.google.maps.android.PolyUtil
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject
import java.util.Locale
 
object RouteHttp {
    fun searchRoute(orig: LatLng, dest: LatLng): List<LatLng>? {
        try {
            val urlRoute = String.format(Locale.US,
                    "https://maps.googleapis.com/maps/api/directions/json?" +
                            "origin=%f,%f&destination=%f,%f&" +
                            "sensor=true&mode=driving&key=%s",
                    orig.latitude, orig.longitude,
                    dest.latitude, dest.longitude,
                    "SUA_SERVER_KEY")
 
            val client = OkHttpClient()
            val request = Request.Builder()
                    .url(urlRoute)
                    .build()
 
            val response = client.newCall(request).execute()
            val result = response.body()?.string()
            val json = JSONObject(result)
            val jsonRoute = json.getJSONArray("routes").getJSONObject(0)
            val leg = jsonRoute.getJSONArray("legs").getJSONObject(0)
            val steps = leg.getJSONArray("steps")
            val numSteps = steps.length()
            var step: JSONObject
 
            val latLngList = mutableListOf<LatLng>()



            for (i in 0 until numSteps) {
                step = steps.getJSONObject(i)
                val points = step.getJSONObject("polyline").getString("points")
                latLngList.addAll(PolyUtil.decode(points))
            }
            return latLngList
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return null
    }
}

Essa classe contém basicamente o método searchRoute(LatLng,LatLng), que
acessará a Directions API para obter a rota que é representada por uma lista
de objetos LatLng. Para isso, é acessado o seguinte endereço:
http://maps.googleapis.com/maps/api/directions/json?
origin=latOrig,lngOrig&destination=latDest,longDest&sensor=true&mode=driving&key=SERVER_KEY

Nessa URL são passadas as latitude/longitude de origem e de destino nos
parâmetros origin e destination respectivamente. E o parâmetro mode indica o tipo
de rota desejada, onde driving indica uma rota de automóvel. Outros possíveis
valores seriam walking (a pé), bicycling (de bicicleta) ou transit (transporte
público). Perceba que deve ser utilizada a server key, ela pode ser obtida no
Google API Console na seção Credentials.

Feita a requisição, a resposta virá em um arquivo JSON com a informação
da rota. Neste exemplo, está sendo lida apenas a primeira rota disponível no
arquivo por meio do JSONArray denominado routes, e com ele são obtidas as legs
que trazem informações sobre o percurso. Em seguida, são obtidos os steps,
que são os passos para chegar até o destino, e cada passo tem uma polyline, que
define a lista de points que formam um segmento de reta para ser ser
desenhado.

Por estar acessando um servidor web, o método searchRoute(LatLng,LatLng) deve
ser chamado em uma thread separada. Por isso, será utilizada novamente uma
coroutine na classe MapViewModel conforme a seguir:
class MapViewModel(app: Application) : AndroidViewModel(app), CoroutineScope {
    ...
    private val loadingRoute = MutableLiveData<Boolean>()
 
    fun isLoadingRoute(): LiveData<Boolean> {
        return loadingRoute



    }
    ...
    fun setDestination(latLng: LatLng) {
        addresses.value = null
        mapState.value = mapState.value?.copy(destination = latLng)
        loadRoute()
    }
    private fun loadRoute() {
        if (mapState.value != null) {
            val orig = mapState.value?.origin
            val dest = mapState.value?.destination
            if (orig != null && dest != null) {
                launch {
                    loadingRoute.value = true
                    val route = withContext(Dispatchers.IO) {
                        RouteHttp.searchRoute(orig, dest)
                    }
                    mapState.value = mapState.value?.copy(route = route)
                    loadingRoute.value = false
                }
            }
        }
    }
    ...
    data class MapState(
            val origin: LatLng? = null,
            val destination: LatLng? = null,
            val route: List<LatLng>? = null
    )
}

A implementação é bem similar ao que foi feito na busca de endereços. O
atributo loadingRoute do tipo MutableLiveData é usado para mostrar a view de
progresso com um texto diferente da busca de endereços.

Ao definir o ponto de destino, o método searchRoute(LatLng,LatLng) da classe
RotaHttp é chamado para fazer o download da informação da rota, e, em
seguida, o estado do mapa é atualizado com a rota.

Faça agora os ajustes necessários na MainActivity:
class MainActivity : AppCompatActivity() {
     ...
    private fun initUi() {
        ...
        viewModel.isLoadingRoute()
                .observe(this, Observer { value ->



                    if (value != null) {
                        btnSearch.isEnabled = !value
                        if (value) {
                            showProgress(getString(R.string.map_msg_search_route))
                        } else {
                            hidePogress()
                        }
                    }
                })
    }
    ...
}

Adicione ao res/values/strings.xml o texto que utilizamos no código
anterior:
<string name="map_msg_search_route">Traçando rota…</string>

No initUi(GoogleMap) foi registrado o observer para isLoadingRoute() para exibir a
mensagem como na Figura 19.11.

Figura 19.11 – Progresso do carregamento dos dados da rota.
Agora faça os ajustes na AppMapFragment:

import android.graphics.Color
import com.google.android.gms.maps.model.PolylineOptions
 
class AppMapFragment : SupportMapFragment() {



    private fun updateMap(mapState: MapViewModel.MapState) {
        googleMap?.run {
            ...
            val route = mapState.route
            if (route != null && route.isNotEmpty()) {
                val polylineOptions = PolylineOptions()
                        .addAll(route)
                        .width(5f)
                        .color(Color.RED)
                        .visible(true)
                addPolyline(polylineOptions)
                route.forEach { area.include(it) }
            }
            if (origin != null) {
                // Nada mudou aqui...
            }
    }
    ...
}

Quando a informação da rota estiver disponível, o método updateMap(MapState)
será invocado. Para desenhar a rota, foi criado um objeto PolylineOptions onde
foram configuradas sua cor e largura para vermelho e 5 dp, respectivamente.
Em seguida, a rota é adicionada ao mapa por meio do método
addPolyline(PolylineOptions).

A Figura 19.12 mostra nossa aplicação em execução exibindo uma rota.



Figura 19.12 – Exibindo rota no Google Maps.
Na próxima seção será demonstrado como detectar a mudança de

localização atual do aparelho.

Monitorando a localização do usuário
Ao utilizar a propriedade lastLocation do objeto FusedLocationProviderClient é
possível obter a localização atual do usuário. Também foi visto que se essa
localização demorar a ser retornada, deve-se utilizar um objeto da classe
LocationCallback para saber quando a localização do aparelho estiver disponível.

Esta interface serve, na verdade, para receber a nova posição do GPS do
aparelho. Ao criar uma subclasse de LocationCallback e implementar o método
onLocationResult (LocationResult) a nova localização será recebida a cada vez que
ela mudar ou em intervalos específicos. Para receber essa atualização deve-se
registrar um objeto do tipo LocationCallback no método
requestLocationUpdates(LocationRequest, LocationListener, PendingIntent). O objeto
LocationRequest especifica os parâmetros para a entrega da localização, como
intervalo, precisão e prioridade.

Nesta seção será demonstrado na prática como monitorar a localização do
usuário. Após realizar a busca pelo local de destino, o monitoramento da



posição do usuário iniciará e a localização será atualizada e exibida
automaticamente no mapa.

Faça as seguintes alterações na classe MapViewModel:
class MapViewModel(app: Application) : AndroidViewModel(app), CoroutineScope {
    ...
    private val currentLocation = MutableLiveData<LatLng>()
    ...
    fun getCurrentLocation(): LiveData<LatLng> {
        return currentLocation
    }
    ...
    private val locationCallback = object : LocationCallback() {
        override fun onLocationResult(locationResult: LocationResult?) {
            val location = locationResult?.lastLocation
            if (location != null) {
                currentLocation.value = LatLng(location.latitude, location.longitude)
            }
        }
    }
    @SuppressLint("MissingPermission")
    fun startLocationUpdates() {
        val locationRequest = LocationRequest.create()
                .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)
                .setInterval(5 * 1000)
                .setFastestInterval(1 * 1000)
        locationClient.requestLocationUpdates(locationRequest, locationCallback, null)
    }
    fun stopLocationUpdates() {
        LocationServices.getFusedLocationProviderClient(getContext())
                .removeLocationUpdates(locationCallback)
    }
    fun requestLocation() {
        launch {
            currentLocationError.value = try {
                checkGpsStatus()
                val success = withTimeout(2000) { loadLastLocation() }
                if (success) {
                    startLocationUpdates()
                    null
                } else {
                    LocationError.ErrorLocationUnavailable
                }
            } // restante do método não mudou...
        }



    }
    ...
}

A localização atual é exposta por meio do atributo currentLocation. Isso foi
feito separadamente do estado atual do mapa para evitar que ele seja
atualizado por completo quando apenas a localização atual for modificada.
Isso traria um comportamento indesejado que seria o mapa ficar “piscando”
cada vez que a localização do aparelho fosse recebida.

Como se pode observar, o código não sofreu muitas modificações para
receber atualizações sobre a localização do aparelho. O método requestLocation()
chama startLocationUpdates() onde é instanciado um objeto LocationRequest que
contém as configurações para que o monitoramento seja realizado. Nele foi
definido que a precisão desejada é alta por meio do método setPriority(int) e os
intervalos de tempo máximo e mínimo para receber cada nova localização
usando setInterval(long) e setFastestIterval(long), respectivamente. Por fim, o processo
de receber as informações de localização é iniciado invocando o método
requestLocationUpdates(LocationRequest, LocationCallback, Looper) da classe
FusedLocationProviderClient.

Quando houver mudança na posição geográfica, o método onLocationResult
(LocationResult) será invocado, e nele a posição do marcador é atualizado.

Agora faça os ajustes na AppMapFragment para atualizar a posição do marcador
no mapa:
class AppMapFragment : SupportMapFragment() {
    ...
    private var markerCurrentLocation: Marker? = null
    ...
    private fun setupMap() {
       ...
        viewModel.getCurrentLocation()
                .observe(this, Observer { currentLocation ->
                    if (currentLocation != null) {
                        if (markerCurrentLocation == null) {
                            val icon = BitmapDescriptorFactory
                                    .fromResource(R.drawable.blue_marker)
                            markerCurrentLocation = googleMap?.addMarker(
                                    MarkerOptions()
                                            .title(getString(R.string.map_current_location))
                                            .icon(icon)
                                            .position(currentLocation)



                            )
                        }
                        markerCurrentLocation?.position = currentLocation
                    }
                })
    }
    private fun updateMap(mapState: MapViewModel.MapState) {
        googleMap?.run {
            clear()
            markerCurrentLocation = null
            // restante do método não mudou
        }
    }
}

No método setupMap() foi adicionado um Observer para a localização atual. Se
o marcador for nulo, ele é instanciado e adicionado ao mapa. Em seguida, a
posição do marcador é atualizada utilizando o atributo position. E no método
updateMap(MapState), após o mapa ser limpo, o marcador da localização é
desalocado.

A única mudança na MainActivity é parar o recebimento de localização no
método onStop():
class MainActivity : AppCompatActivity() {
    ...
    override fun onStop() {
        super.onStop()
        viewModel.disconnectGoogleApiClient()
        viewModel.stopLocationUpdates()
    }
    ...
}

Entretanto, como testar para saber se está tudo funcionando? É necessário
sair por aí de carro ou a pé e ver se o mapa está sendo atualizado? Bem, isso é
o ideal, mas você pode simular localizações utilizando o recurso de mock
locations. A primeira coisa a fazer é habilitar a opção Allow mock locations
(Permitir Locais Fictícios) nas opções de desenvolvedor, conforme mostra a
Figura 19.13.

Para definir um local fictício para o aparelho, você pode baixar algum dos
aplicativos para simulação de GPS disponíveis no Google Play. Basta
procurar por “fake GPS” e selecionar o de sua preferência. Com esse
aplicativo você pode checar se ele está atualizando o local na tela.



Figura 19.13 – Habilitando a opção de locais fictícios no aparelho.
Porém, é possível testar localização no emulador enviando coordenadas e

verificando se o marcador é atualizado corretamente.
Ao executar a aplicação será possível visualizar o marcador sendo

atualizado no mapa ao receber novas coordenadas geográficas como mostra a
Figura 19.14.



Figura 19.14 – Mapa com marcador sendo atualizado com a posição
atual do aparelho.

Trabalhando com áreas demarcadas (Geofence)
É possível demarcar áreas para que o usuário seja notificado quando ele
entrar, sair ou permanecer nesta região. Para determinar esse lugar, deve-se
especificar a coordenada geográfica, o raio de alcance em metros e um objeto
PendingIntent que será disparado quando o usuário entrar, sair ou permanecer
nessa área, dependendo do evento desejado.

Também pode-se especificar a quantidade de tempo no qual o
monitoramento ficará ativo. Quando esse tempo expirar, essa área não será
mais monitorada até que um novo monitoramento seja adicionado.

A área demarcada será representada pela classe GeofenceInfo listada a seguir:
import com.google.android.gms.location.Geofence
data class GeofenceInfo(
    val id: String,
    val latitude: Double,
    val longitude: Double,
    val radius: Float,
    val expirationDuration: Long,
    val transitionType: Int ) {



    fun getGeofence(): Geofence {
        return Geofence.Builder()
                .setRequestId(id)
                .setTransitionTypes(transitionType)
                .setCircularRegion(latitude, longitude, radius)
                .setExpirationDuration(expirationDuration)
                .build()
    }
}

O método getGeofence() é o que realmente cria o objeto Geofence a partir dos
atributos do objeto. O método setRequestId(String) define o identificador único do
Geofence. Em setTransitionTypes(int) indica-se qual tipo de transição deseja-se
monitorar, para as transições de entrar ou sair deve-se usar
GEOFENCE_TRANSITION_ENTER e GEOFENCE_TRANSITION_EXIT respectivamente,
mas ainda existe a transição GEOFENCE_TRANSITION_DWELL que indica que o
usuário entrou na área especificada e que permaneceu lá por um tempo.

O método setCircularRegion(double,double,float) define a área do Geofence
informando a latitude, longitude e o raio, e com o método
setExpirationDuration(long) é definido o tempo de validade em milissegundos (ou
NEVER_EXPIRE se não quisermos que o Geofence expire).

Não existe uma forma de obter todas as áreas demarcadas registradas no
aparelho, então se deve implementar algum mecanismo de persistência para
salvar as áreas de interesse do aplicativo. Para deixar o exemplo mais
simples, será utilizada uma shared preferences para salvar as informações dos
geofences no formato JSON, por isso, adicione a biblioteca Gson no
build.gradle do módulo para facilitar o trabalho:
dependencies {
    def gson_version = '2.8.5'
    ...
    implementation "com.google.code.gson:gson:$gson_version"
}

Agora adicione a classe GeofenceDB, que será responsável por persistir o
GeofenceInfo. Ela deve ficar como a seguir:
import android.content.Context
import android.content.SharedPreferences
import com.google.gson.Gson
 
class GeofenceDb(context: Context) {
    private val prefs: SharedPreferences = context.getSharedPreferences(



            "geofenceDb", Context.MODE_PRIVATE)
    fun getGeofence(id: String): GeofenceInfo? {
        val gson = Gson()
        val json = prefs.getString(id, null)
        return if (json != null) {
            gson.fromJson(json, GeofenceInfo::class.java)
        } else {
            null
        }
    }
    fun saveGeofence(geofence: GeofenceInfo) {
        val gson = Gson()
        val json = gson.toJson(geofence)
        val editor = prefs.edit()
        editor.putString(geofence.id, json)
        editor.apply()
    }
    fun removeGeofence(id: String) {
        val editor = prefs.edit()
        editor.remove(id)
        editor.apply()
    }
}

Essa classe permite basicamente persistir um GeofenceInfo por meio do
método saveGeofence(GeofenceInfo) e removê-lo utilizando o método
removeGeofence(String). Para recuperar um objeto GeofenceInfo, foi definido o
método getGeofence(String).

Faça os seguintes ajustes na classe MapViewModel:
class MapViewModel(app: Application) : AndroidViewModel(app), CoroutineScope {
    ...
    private val geofenceDb: GeofenceDb by lazy { GeofenceDb(getContext()) }
    ...
    @SuppressLint("MissingPermission")
    fun setGeofence(pit: PendingIntent, latLng: LatLng) {
        if (googleApiClient?.isConnected == true) {
            val geofenceInfo = GeofenceInfo("1",
                latLng.latitude, latLng.longitude,
                500f, // em metros
                Geofence.NEVER_EXPIRE,
                Geofence.GEOFENCE_TRANSITION_ENTER or

Geofence.GEOFENCE_TRANSITION_EXIT)
            val request = GeofencingRequest.Builder()
                .setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER)



                .addGeofences(listOf(geofenceInfo.getGeofence()))
                .build()
            LocationServices.getGeofencingClient(getContext())
                .addGeofences(request, pit)
                .addOnCompleteListener {
                    if (it.isSuccessful) {
                        geofenceDb.saveGeofence(geofenceInfo)
                        mapState.value = mapState.value?.copy(geofenceInfo = geofenceInfo)
                }
            }
        }
    }
    ...
    data class MapState(
            val origin: LatLng? = null,
            val destination: LatLng? = null,
            val route: List<LatLng>? = null,
            val geofenceInfo: GeofenceInfo? = null
    )
}

No método setGeofence(GeofenceInfo) primeiramente é verificado se o
googleApiClient está conectado e, caso esteja, o objeto GeofenceInfo é criado
informando: um identificador único (aqui usamos “1”); a coordenada
recebida como parâmetro; o raio em metros da área que se deseja monitorar;
o tempo de validade (neste exemplo ele não expira); e as transições
desejadas. Perceba que foram usadas tanto a ação de sair quanto a de entrar
na área demarcada.

Um objeto GeofencingRequest é criado e adicionado à lista de geofences usando
o método addGeofences(List<Geofence>). Por fim, foi utilizada a classe
GeofencingClient para adicionar os geofences com o método
addGeofences(GeofencingRequest, PendingIntent), mas para saber se ele foi adicionado
corretamente foi utilizado addOnCompleteListener. Se o resultado tiver sido
isSuccessful, a informação é salva no repositório e o estado do mapa é
atualizado.

Para definir um GeofenceInfo no aplicativo, será implementado um clique
longo no mapa e então aquela área será delimitada:
import android.app.PendingIntent
 
class AppMapFragment : SupportMapFragment() {
     ...



    private fun setupMap() {
        googleMap?.run {
            mapType = GoogleMap.MAP_TYPE_NORMAL
            uiSettings.isMapToolbarEnabled = false
            uiSettings.isZoomControlsEnabled = true
            setOnMapLongClickListener { latLng ->
                onMapLongClick(latLng)
            }
        }
        ....
    }
    private fun onMapLongClick(latLng: LatLng) {
        val pit = PendingIntent.getBroadcast(requireContext(), 0,
                Intent(requireContext(), GeofenceReceiver::class.java),
                PendingIntent.FLAG_UPDATE_CURRENT)
        viewModel.setGeofence(pit, latLng)
    }
    ...
    private fun updateMap(mapState: MapViewModel.MapState) {
        googleMap?.run {
            ...
            val geofenceInfo = mapState.geofenceInfo
            if (geofenceInfo != null) {
                val latLng = LatLng(geofenceInfo.latitude, geofenceInfo.longitude)
                addCircle(CircleOptions()
                        .strokeWidth(2f)
                        .fillColor(0x990000FF.toInt())
                        .center(latLng)
                        .radius(geofenceInfo.radius.toDouble())
                )
            }
        }
    }
}

No método setupMap() é definido o evento de clique longo no mapa
invocando setOnMapLongClickListener(OnMapLongClickListener). Nele é chamado o
método onMapLongClick(LatLng) onde é criado um objeto PendingIntent que será
executado quando o aparelho entrar, sair ou permanecer na área especificada.
Essa PendingIntent está apontando para a classe GeofenceReceiver que deve ser
criada e deixada como a seguir:
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent



import android.widget.Toast
import com.google.android.gms.location.Geofence
import com.google.android.gms.location.GeofencingEvent
 
class GeofenceReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val geofencingEvent = GeofencingEvent.fromIntent(intent)
        if (geofencingEvent.hasError()) {
            val errorCode = geofencingEvent.errorCode
            Toast.makeText(context, "Erro no serviço de localização: $errorCode",
                    Toast.LENGTH_LONG).show()
        } else {
            val geofences = geofencingEvent.triggeringGeofences
            val transition = geofencingEvent.geofenceTransition
            geofences.forEach { geofence ->
                val msg = when (transition) {
                    Geofence.GEOFENCE_TRANSITION_ENTER ->
                        "Geofence ID: ${geofence.requestId} ENTROU do perímetro"
                    Geofence.GEOFENCE_TRANSITION_EXIT ->
                        "Geofence ID: ${geofence.requestId} SAIU do perímetro"
                    Geofence.GEOFENCE_TRANSITION_DWELL ->
                        "Geofence ID: ${geofence.requestId} PERMANECE do perímetro"
                    else ->
                        "Erro no Geofence: $transition"
                }
                Toast.makeText(context, msg, Toast.LENGTH_LONG).show()
            }
        }
    }
}

A maior parte do trabalho dessa classe é feita pela classe GeofencingEvent, que
checa se ocorreu algum erro utilizando o método hasError(Intent), em caso
positivo, o código de erro é obtido por meio da propriedade errorCode.

A propriedade geofenceTransition define o tipo de transação que fez com que
essa Intent tenha sido disparada (GEOFENCE_TRANSITION_ENTER ou
GEOFENCE_TRANSITION_EXIT). E, finalmente, para saber quais geofences foram
disparados, é utilizada a propriedade triggeringGeofences.

É importante ressaltar que o geofence permanecerá ativo enquanto ele não
expirar ou pode ser removido manualmente por meio do método
removeGeofences (List<Geofence>,OnRemoveGeofencesResultListener). Lembre-se de
declarar o receiver no AndroidManifest.xml:
<receiver android:name=".GeofenceReceiver"/>



Execute a aplicação e dê um clique longo em uma área do mapa. Em
seguida, entre na área demarcada e o resultado deve ficar conforme a Figura
19.15. Para testar no emulador, após escolher o destino e a rota ser traçada,
dê um clique longo em algum ponto do mapa para criar o Geofence. Em
seguida, envie uma coordenada para o emulador que esteja dentro da área
demarcada e o GeofenceReceiver será chamado.

Figura 19.15 – Detectando localização em área demarcada.
Com os geofences, é possível criar aplicativos que realizem uma

determinada ação “quando chegar em casa”, “quando estiver próximo à
padaria”, ou, ainda, “quando sair do trabalho”. Isso faz a aplicação ter um
atrativo a mais para os usuários.

Foi utilizado nesse exemplo o clique longo no mapa, mas um evento muito
comum de ser utilizado é o clique no marcador. Isso pode ser feito da
seguinte forma:
// Para adicionar o marcador
val marker = googleMap.addMarker(MarkerOptions()
        .position(latLng)
        .title(getString(R.string.map_marker_destination))
)
marker.tag = seuObjeto



// Para tratar o evento de clique no marcador
googleMap.setOnMarkerClickListener { marker ->
    val seuObjeto = marker.tag as SuaClasse?
    // Faça algo...
    true // se o evento for consumido, false caso contrário
}

Perceba que é permitido armazenar qualquer informação na propriedade tag
do objeto Marker. Então pode-se armazenar a informação referente ao
marcador para que, ao ser clicado, seus detalhes sejam exibidos (em uma
outra tela, por exemplo). No método setOnMarkerClickListener(OnMarkerClickListener)
do objeto GoogleMap deve-se retornar true se o evento de clique for consumido,
ou false caso contrário. Ao consumir o evento, o “info window”, que é texto
exibido sobre o marcador, não será exibido, mas também é possível definir
um evento de clique para info window utilizando o método
setOnInfoWindowClickListener(OnInfoWindowClickListener) do objeto GoogleMap:
googleMap.setOnInfoWindowClickListener { marker ->
    // Faça algo...
}

Foi visto como traçar uma rota utilizando a classe PolylineOptions. E também é
possível definir um evento de clique para esse objeto utilizando o método
setOnPolylineClickListener(OnPolylineClickListener):
googleMap.setOnPolylineClickListener { polyline ->
    // Faça algo...
}

A API de mapas e localização é realmente um mundo à parte, o qual
podemos e devemos explorar nos aplicativos. Entretanto, é importante deixar
uma ressalva que desde julho de 2018 o serviço de mapas deixou de ser
totalmente gratuito. Por esta razão, certifique-se de verificar o preço cobrado
pelo Google para utilizar os serviço de mapas, rotas etc., em aplicativos reais.

1 Se você obtiver o seguinte erro no Logcat: “Failed to load map. Error contacting Google servers. This
is probably an authentication issue (but could be due to network errors)”, verifique com atenção se a
chave utilizada é idêntica à do Google API Console.



CAPÍTULO 20
Data Binding

Em vários exemplos criados no decorrer do livro foi possível observar que
uma tarefa muito comum é obter informações de um objeto e preencher views
com as informações desse objeto. E após o usuário preencher os dados na
interface gráfica, é preciso obter as informações inseridas nos componentes
visuais, criar objetos e fazer algo com eles. Sem contar os eventos que são
disparados por esses componentes que também devem ser implementados via
código Kotlin. Com a API de Data Binding é possível injetar um pouco de
lógica dentro do arquivo de layout, permitindo uma ligação e atualização
automática entre as classes de modelo e view. Neste capítulo será abordada a
API de Data Binding e seus principais recursos.

Projeto: cadastro de livros
Neste capítulo será iniciado um novo projeto que constará de um cadastro de
livros onde toda a lógica de tela será implementada utilizando Data Binding.
Esse projeto será concluído no próximo capítulo utilizando as ferramentas do
Firebase para autenticação, persistência de dados e armazenamento de
arquivos.

Application Name Livros
Package Name dominando.android.livros
Activity Name BookListActivity

Crie um novo projeto, e no arquivo build.gradle do projeto faça as
seguintes mudanças:
buildscript {
    ext {
        appcompat_version = '1.0.2'
        constraintlayout_version = '1.1.3'
        gradle_version = '3.3.1'
        kotlin_version = '1.3.20'



        parceler_version = '1.1.12'
    }
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath "com.android.tools.build:gradle:$gradle_version"
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}
// Restante não mudou...

Como já visto anteriormente, é uma boa prática definir constantes para a
versão das dependências no build.gradle utilizando ext.nome_da_variavel. Para o
data binding especificamente, só é preciso a variável gradle_version.

Feitas essas mudanças, adicione as dependências e habilite o uso do data
binding no arquivo build.gradle do módulo app:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'
android { ...
    dataBinding {
        enabled true
    }
}
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
    implementation "androidx.appcompat:appcompat:$appcompat_version"
    implementation "androidx.constraintlayout:constraintlayout:$constraintlayout_version"
    kapt "com.android.databinding:compiler:$gradle_version"
 
    implementation "org.parceler:parceler-api:$parceler_version"
    kapt "org.parceler:parceler:$parceler_version"
}

Para utilizar o data binding é preciso apenas habilitá-lo no bloco dataBinding e
aplicar o plugin do kapt sobre a biblioteca de compilação do data binding.
Com essas simples configurações já é possível utilizar o data binding no
projeto. Foi adicionada também a dependência da biblioteca Parceler para
passar objetos entre activities utilizando a interface Parcelable.



Binding de objetos em arquivos de layout
A grande vantagem na utilização do data binding é a inclusão de parte da
lógica de UI dentro do arquivo de layout. Entretanto, antes de explorar como
isso funciona na prática, devem-se definir algumas classes de dados que serão
utilizadas no projeto. Crie o pacote model e dentro dele defina as seguintes
classes dentro do respectivo arquivo *.kt:
// MediaType.kt
enum class MediaType {
    PAPER, EBOOK
}
// Publisher.kt
import org.parceler.Parcel
 
@Parcel
data class Publisher(
        var id: String = "",
        var name: String = ""
) {
    override fun toString(): String = "$id - $name"
}
// Book.kt
    import org.parceler.Parcel
 
@Parcel
data class Book(
        var id: String = "",
        var title: String = "",
        var author: String = "",
        var coverUrl: String = "",
        var pages: Int = 0,
        var year: Int = 0,
        var publisher: Publisher? = null,
        var available: Boolean = false,
        var mediaType: MediaType = MediaType.PAPER,
        var rating: Float = 0.0f
)

Essas classes não possuem nada que já não tenha sido abordado durante o
livro.

Crie uma nova activity chamada BookDetailsActivity e deixe seu arquivo de
layout activity_book_details.xml como a seguir:
<layout



    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <data>
        <variable
            name="book"
            type="dominando.android.livros.model.Book" />
    </data>
    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:fillViewport="true">
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:orientation="vertical"
            android:padding="16dp">
            <!--<ImageView
                android:id="@+id/imgCover"
                android:layout_width="150dp"
                android:layout_height="150dp"
                android:layout_gravity="center"
                android:background="#CCC"
                android:scaleType="centerInside"
                app:imageUrl="@{book.coverUrl}" />-->
            <TextView
                android:id="@+id/txtTitle"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:gravity="center"
                android:text="@{book.title}"
                android:textColor="@{book.available ? @color/black : @color/red}"
                android:textSize="24sp" />
            <TextView
                android:id="@+id/txtAuthor"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{book.author}"
                android:textSize="20sp" />
            <TextView
                android:id="@+id/txtPages"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{@string/text_format_book_pages(book.pages)}" />
            <TextView



                android:id="@+id/txtYear"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{@string/text_format_book_year(book.year)}" />
            <TextView
                android:id="@+id/txtPublisher"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{book.publisher.name}" />
            <TextView
                android:id="@+id/txtAvailable"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{book.available ? @string/text_book_available :

@string/text_book_unavailable}" />
            <!--<TextView
                android:id="@+id/txtMediaType"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{book.mediaType}" />-->
            <RatingBar
                android:id="@+id/rtbRating"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:isIndicator="true"
                android:progressTint="@color/colorAccent"
                android:rating="@{book.rating}" />
        </LinearLayout>
    </ScrollView>
</layout>

Os arquivos de layout que utilizam a biblioteca de data binding devem
iniciar com a tag <layout>. Na tag <data> devem ser declaradas as variáveis e
imports que serão utilizados no layout. Cada variável é declarada com a tag
<variable>, na qual o nome da variável e seu tipo são definidos respectivamente
nas propriedades name e type. As variáveis definidas no arquivo de layout são
acessíveis tanto no restante do arquivo de layout quanto no código Kotlin,
como será mostrado a seguir.

As expressões nos arquivos layout são delimitadas por @{ }. Perceba que no
txtTitle o texto é definido utilizando @{book.title}, mas como se observa em
seguida, utilizam-se expressões para acessar recursos como é feito com a
propriedade textColor, na qual foi utilizado ${book.available ? @color/black : @color/red}.
Dessa forma, se o livro estiver disponível a cor do texto será preta, caso



contrário será vermelha. Adicione essas cores no arquivo
res/values/colors.xml:
<color name="black">#000</color>
<color name="red">#F00</color>

Outra expressão interessante que foi utilizada é a formatação de strings para
os componentes txtPages e txtYear. Foram utilizados os textos a seguir que
devem ser definidos no res/values/strings.xml:
<string name="text_format_book_pages">Número de páginas: %1$d</string>
<string name="text_format_book_year">Ano de publicação: %1$d</string>
<string name="text_book_available">Disponível</string>
<string name="text_book_unavailable">Indisponível</string>

O atributo available da classe Book é um Boolean, entretanto a propriedade
android:text do TextView recebe uma string. Por isso foi feita essa conversão
utilizando também strings definidas no res/values/strings.xml. Porém, isso
não pode ser feito automaticamente para as propriedades coverUrl e mediaType.
Esse problema será resolvido na próxima seção, por isso, tanto o ImageView
para a capa quanto o TextView para o tipo de mídia estão comentados
(delimitados com <!-- -->).

Ao criar esse arquivo de layout, será gerada uma classe em tempo de
compilação com base no nome do arquivo de layout. Neste exemplo, baseado
no arquivo activity_book_details.xml será gerada uma classe chamada
ActivityBookDetailsBinding. Caso queira mudar esse nome, basta utilizar a
propriedade class da tag <data>, como mostrado a seguir:
<data class="MeuSuperBinder">

Para que essa classe seja gerada, compile o projeto acessando o menu Build
> Make project. A classe gerada armazenará todas as propriedades em que o
binding será feito (neste exemplo, apenas a variável book) bem como as
referências para os componentes de UI. Com isso nem seria preciso utilizar o
kotlin-extensions nesse projeto, pois os componentes podem ser acessados
simplesmente usando meuBinding.componente.

A próxima etapa é o binding do objeto no arquivo de layout da
BookDetailsActivity como mostra o código a seguir:
import android.content.Context
import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.databinding.DataBindingUtil



import dominando.android.livros.databinding.ActivityBookDetailsBinding
import dominando.android.livros.model.Book
import org.parceler.Parcels
 
class BookDetailsActivity : AppCompatActivity() {
    private val binding: ActivityBookDetailsBinding by lazy {
        DataBindingUtil.setContentView<ActivityBookDetailsBinding>(
                this, R.layout.activity_book_details
        )
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val book = Parcels.unwrap<Book>(intent.getParcelableExtra(EXTRA_BOOK))
        if (book != null) {
            binding.book = book
        }
    }
 
    companion object {
        private const val EXTRA_BOOK = "book"
 
        fun start(context: Context, book: Book) {
            context.startActivity(
                    Intent(context, BookDetailsActivity::class.java).apply {
                        putExtra(EXTRA_BOOK, Parcels.wrap(book))
                    }
            )
        }
    }
}

O tradicional setContentView(int) foi substituído pela chamada ao método de
mesmo nome da classe DataBindingUtil. Esse método, além de definir o layout
da activity, retorna um objeto do tipo ActivityBookDetailsBinding que é gerado
automaticamente pelo data binding em tempo de compilação. Em seguida, a
instância do book que será passada via Intent é obtida e atribuída ao objeto
binding.

A BookDetailsActivity será chamada a partir da BookListActivity. Então, apenas
para testar se tudo está funcionando, faça a seguinte mudança:
class BookListActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_book_list)



        BookDetailsActivity.start(this,
                Book(
                        id = "1",
                        title = "Dominando o Android com Kotlin",
                        author = "Nelson Glauber",
                        coverUrl = "https://s3.novatec.com.br/capas-ampliadas/capa-ampliada-

9788575224632.jpg",
                        pages = 954,
                        year = 2018,
                        publisher = Publisher("1", "Novatec"),
                        available = true,
                        mediaType = MediaType.PAPER,
                        rating = 5.0f
                )
        )
    }
}

Execute a aplicação, e o resultado deve ser similar ao da Figura 20.1.

Figura 20.1 – Aplicativo Data Binding em execução.

Binding adapters para conversão de textos
A linha do componente txtMediaType ficou comentada, pois o data binding não



faz a conversão automática do tipo MediaType para texto, então é preciso fazê-
la manualmente. A API de Data Binding permite a criação de binding
adapters, que são classes simples para conversão de tipos de dados.

Crie um novo pacote chamado binding e adicione a classe TextBinding e deixe-a
como a seguir:
import android.widget.TextView
import androidx.databinding.BindingAdapter
import dominando.android.livros.R
import dominando.android.livros.model.MediaType
 
object TextBinding {
    @JvmStatic
    @BindingAdapter("android:text")
    fun setMediaTypeText(textView: TextView, mediaType: MediaType?) {
        if (mediaType == null) {
            textView.text = null
            return
        }
        val context = textView.context
        textView.text = when (mediaType) {
            MediaType.EBOOK -> context.getString(R.string.text_book_media_ebook)
            MediaType.PAPER -> context.getString(R.string.text_book_media_paper)
        }
    }
}

As strings devem ser declaradas no res/values/strings.xml:
<string name="text_book_media_paper">Impresso</string>
<string name="text_book_media_ebook">E-Book</string>

O objeto TextBinding possui apenas o método setMediaTypeText(TextView,MediaType)
o que indica que está sendo feita a conversão de um MediaType para algo que
será utilizado em um TextView. A propriedade que será afetada está definida na
anotação @BindingAdapter, que no nosso caso é a propriedade android:text. Pode-se
interpretar esse método da seguinte forma: ao atribuir um MediaType à
propriedade android:text de um TextView invoque esse método. Perceba que ele
está anotado com @JvmStatic, pois a API requer que esse método seja static do
Java que é gerado em tempo de compilação.

Descomente o componente txtMediaType do arquivo
res/layout/activity_detail.xml e execute a aplicação novamente. O tipo de
mídia do livro deve ser exibido corretamente.



Binding adapters para carregamento de imagens
O outro problema do arquivo de layout acontece na ImageView. Para atribuir
uma imagem a uma ImageView deve-se utilizar a propriedade android:src, mas
essa propriedade recebe um Drawable ou um Bitmap e o objeto book possui apenas
a URL da imagem. Por essa razão foi definida a propriedade app:imageUrl da
ImageView, que na verdade não existe. Quem fará esse tratamento será um
binding adapter que carregará a imagem baseado na URL e preencherá a
ImageView.

Adicione a dependência da biblioteca Glide que fará o trabalho de carregar
a imagem baseada na URL. Declare a constante glide_version no build.gradle do
projeto como valor ‘4.8.0’ (ou mais atual) e adicione a dependência no
build.gradle do projeto como a seguir:
dependencies {
    ...
    implementation "com.github.bumptech.glide:glide:$glide_version"
    kapt "com.github.bumptech.glide:compiler:$glide_version"
}

Feito isso, adicione a classe ImageBinding descrita a seguir no pacote binding do
projeto e deixe-a da seguinte forma:
import android.widget.ImageView
import androidx.databinding.BindingAdapter
import com.bumptech.glide.Glide
 
object ImageBinding {
    @JvmStatic
    @BindingAdapter("app:imageUrl")
    fun setImageUrl(imageView: ImageView, url: String) {
        if (url.isNotEmpty()) {
            Glide.with(imageView)
                    .load(url)
                    .into(imageView)
        }
    }
}

Desta forma, é possível passar uma string para a propriedade app:imageUrl do
ImageView. Uma grande vantagem de definir os binding adapters é que se for
preciso mudar a biblioteca de carregamento de imagens, isso só precisará ser
feito em um único lugar. Outra vantagem é possibilidade de reutilizar esse



tipo de classe em outros projetos.
Uma vez que a imagem será carregada da web, adicione a permissão de

internet no AndroidManifest.xml:
<uses-permission android:name="android.permission.INTERNET" />

Descomente o componente imgCoverUrl do arquivo
res/layout/activity_book_details.xml e execute a aplicação novamente. Se a
URL definida na propriedade coverUrl do objeto Book estiver apontando para
uma imagem válida, ela deve ser exibida corretamente no ImageView.

Two way data binding
Com a implementação feita anteriormente já é possível perceber que o data
binding faz com que o desenvolvedor poupe um bom tempo, pois a atribuição
do valores é feita automaticamente. Entretanto, e se os valores precisarem ser
editados em tempo de execução? Com o data binding é simples fazer com
que a UI seja atualizada automaticamente quando o valor do modelo for
modificado. Porém, é preciso fazer algumas mudanças na classe Book:
import androidx.databinding.BaseObservable
import androidx.databinding.Bindable
import dominando.android.livros.BR
import org.parceler.Parcel
 
@Parcel
class Book : BaseObservable() {
    @Bindable
    var id: String = ""
        set(value) {
            field = value
            notifyPropertyChanged(BR.id)
        }
    @Bindable
    var title: String = ""
        set(value) {
            field = value
            notifyPropertyChanged(BR.title)
        }
    @Bindable
    var author: String = ""
        set(value) {
            field = value
            notifyPropertyChanged(BR.author)



        }
    @Bindable
    var coverUrl: String = ""
        set(value) {
            field = value
            notifyPropertyChanged(BR.coverUrl)
        }
    @Bindable
    var pages: Int = 0
        set(value) {
            field = value
            notifyPropertyChanged(BR.pages)
        }
    @Bindable
    var year: Int = 0
        set(value) {
            field = value
            notifyPropertyChanged(BR.year)
        }
    @Bindable
    var publisher: Publisher? = null
        set(value) {
            field = value
            notifyPropertyChanged(BR.publisher)
        }
    @Bindable
    var available: Boolean = false
        set(value) {
            field = value
            notifyPropertyChanged(BR.available)
        }
    @Bindable
    var mediaType: MediaType = MediaType.PAPER
        set(value) {
            field = value
            notifyPropertyChanged(BR.mediaType)
        }
    @Bindable
    var rating: Float = 0f
        set(value) {
            field = value
            notifyPropertyChanged(BR.rating)
        }
}

A classe Book agora herda de BaseObservable, que é classe base para os objetos



que atualizarão a UI automaticamente. Todas as propriedades foram
marcadas com a anotação @Bindable e os métodos set estão chamando
notifyPropertyChanged(int) (herdado da classe BaseObervable) passando como
parâmetro o id da propriedade que foi modificada. Esses IDs são gerados
automaticamente na classe BR (assim como acontece com a classe R) em
tempo de compilação baseado no nome do atributo.

Com essa modificação, a BookListActivity deve estar apresentando erros, pois o
construtor da data class não existe mais. Faça as seguintes mudanças para
resolver o problema:
class BookListActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_book_list)
        BookDetailsActivity.start(this,
                Book().apply {
                    id = "1"
                    title = "Dominando o Android com Kotlin"
                    author = "Nelson Glauber"
                    coverUrl = "https://s3.novatec.com.br/capas-ampliadas/capa-ampliada-

9788575224632.jpg"
                    pages = 954
                    year = 2018
                    publisher = Publisher("1", "Novatec")
                    available = true
                    mediaType = MediaType.EBOOK
                    rating = 5.0f
                }
        )
    }
}

Execute a aplicação e ela deve funcionar normalmente. Assim, a ideia do
two way data binding é justamente demonstrar que, ao modificar a UI, o
objeto será modificado automaticamente. Por isso, adicione nova activity que
servirá como tela de cadastro. Crie a classe BookFormActivity e deixe seu arquivo
de layout res/layout/activity_book_form.xml como a seguir:
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    <ScrollView
        android:id="@+id/scrollView"
        android:layout_width="match_parent"
        android:layout_height="match_parent">
        <include



            android:id="@+id/content"
            layout="@layout/book_form_content" />
    </ScrollView>
</layout>

Esse arquivo de layout possui apenas uma ScrollView que possui internamente
um <include> referenciando o arquivo de layout que possui realmente o
conteúdo da tela.

Crie o arquivo res/layout/book_form_content.xml e deixe-o como a seguir:
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <data>
        <import type="java.util.List" />
        <import type="dominando.android.livros.model.MediaType" />
        <variable
            name="book"
            type="dominando.android.livros.model.Book" />
        <variable
            name="view"
            type="dominando.android.livros.BookFormActivity" />
        <variable
            name="publishers"
            type="java.util.List&lt;dominando.android.livros.model.Publisher&gt;" />
    </data>
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        android:padding="16dp">
        <EditText
            android:id="@+id/edtTitle"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/text_book_title"
            android:imeOptions="actionNext"
            android:inputType="textCapWords"
            android:text="@={book.title}" />
        <EditText
            android:id="@+id/edtAuthor"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/text_book_author"
            android:imeOptions="actionNext"
            android:inputType="textCapWords"
            android:text="@={book.author}" />



        <EditText
            android:id="@+id/edtPages"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/text_book_pages"
            android:imeOptions="actionNext"
            android:inputType="number"
            android:text="@={book.pages}" />
        <EditText
            android:id="@+id/edtYear"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/text_book_year"
            android:imeOptions="actionDone"
            android:inputType="number"
            android:text="@={book.year}" />
        <Spinner
            android:id="@+id/spnPublisher"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:entries="@{publishers}"
            android:onItemSelected="@{(p, v, pos, id)->book.setPublisher(publishers[pos])}"
            android:selection="@{publishers.indexOf(book.publisher)}" />
        <CheckBox
            android:id="@+id/chkAvailable"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:checked="@={book.available}"
            android:text="@string/text_book_available" />
        <RadioGroup
            android:id="@+id/rgMediaType"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="end"
            android:orientation="horizontal">
            <RadioButton
                android:id="@+id/rbMediaPaper"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:checked="@{book.mediaType == MediaType.PAPER}"
                android:onCheckedChanged="@{view::onMediaTypeChanged}"
                android:text="@string/text_book_media_paper" />
            <RadioButton
                android:id="@+id/rbMediaEbook"
                android:layout_width="wrap_content"



                android:layout_height="wrap_content"
                android:checked="@{book.mediaType == MediaType.EBOOK}"
                android:onCheckedChanged="@{view::onMediaTypeChanged}"
                android:text="@string/text_book_media_ebook" />
        </RadioGroup>
        <RatingBar
            android:id="@+id/rtbRating"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="end"
            android:progressTint="@color/colorAccent"
            android:rating="@={book.rating}" />
        <Button
            android:id="@+id/btnSave"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:onClick="@{view::clickSaveBook}"
            android:text="@string/button_save" />
        <ProgressBar
            android:id="@+id/progressBar"
            style="?android:attr/progressBarStyleSmall"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:visibility="gone"/>
    </LinearLayout>
</layout>

Esse arquivo de layout é um pouco mais elaborado que o da activity de
detalhes. A tag <import> está sendo utilizada para importar a classe java.util.List
que é utilizada mais adiante. Em seguida, são declaradas três variáveis: book é
objeto que representa o livro; a view é o objeto que tratará os eventos que esse
arquivo de layout disparará, e que nesse exemplo é a própria activity (use o
nome que preferir); e publishers é a lista de editoras que será exibida no Spinner.

Perceba que essa última propriedade está utilizando &lt; e &gt; que
representam respectivamente < e >. Essa notação está sendo usada, pois como
o atributo é uma List<Publisher>, não é possível utilizar os caracteres < e > em
propriedades de tags XML.

Esse arquivo possui um detalhe importantíssimo logo no primeiro EditText: a
propriedade android:text está utilizando a expressão @={book.title} (em vez de
@{book.title}, que foi vista anteriormente). Isso indica um two way data binding
com a propriedade title do objeto book. Ou seja, quando o valor for modificado
na UI, o objeto será atualizado e vice-versa.



O Spinner possui alguns detalhes interessantíssimos que demonstram bem o
poder do data binding. A propriedade android:entries está sendo utilizada para
definir os itens que serão exibidos na lista, que nesse exemplo é a
propriedade publishers definida no início do arquivo. Na propriedade
android:onItemSelected uma instrução lambda está sendo usada para definir o
evento que será chamado ao selecionar um item da lista. Nesse exemplo está
sendo invocado o método setPublisher(Publisher) do objeto book. Isso seria o
mesmo que fazer a seguinte implementação em código:
spnPublisher.onItemSelectedListener = object: AdapterView.OnItemSelectedListener {
    override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
        book.publisher = publishers[position]
    }
    override fun onNothingSelected(parent: AdapterView<*>?) {
    }
}

Perceba como ficou muito mais simples utilizar a expressão no data
binding. Qualquer evento que possua um set pode ser utilizado no arquivo de
layout.

A propriedade android:selection tem outro detalhe muito poderoso do data
binding: se a propriedade do componente não existir no XML, mas possuir
um set no código, ela pode ser utilizada normalmente. É o que está sendo feito
aqui. O item do Spinner está sendo selecionado diretamente no arquivo de
layout. Isso seria o mesmo que fazer o seguinte no código Kotlin:
spnPublisher.setSelection(publishers.indexOf(book.publisher))

O que foi feito com os RadioButton é outro bom exemplo. A propriedade
android:checked é marcada de acordo com o tipo de mídia do objeto book, mas um
método foi definido para ser chamado ao alterar o RadioButton selecionado por
meio da propriedade android:onCheckedChanged, que seria o mesmo que o seguinte
código:
radioButton.setOnCheckedChangeListener { button, isChecked ->
}

Desta forma, o data binding, mais uma vez, já facilita esse trabalho. Da
mesma forma que o botão, no evento de clique está chamando o método
clickSaveBook(View). É importante ressaltar que todos os eventos disparados pelo
arquivo de layout são executados na main/UI thread.

Para finalizar esse arquivo de layout, adicione os seguintes textos no
res/values/strings.xml:



<string name="text_book_title">Title</string>
<string name="text_book_author">Author</string>
<string name="text_book_pages">Number of pages</string>
<string name="text_book_year">Year of publication</string>
<string name="button_save">Save</string>

Implemente a BookFormActivity para que fique da seguinte forma:
import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.view.View
import android.widget.CompoundButton
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.databinding.DataBindingUtil
import dominando.android.livros.databinding.ActivityBookFormBinding
import dominando.android.livros.model.Book
import dominando.android.livros.model.MediaType
import dominando.android.livros.model.Publisher
import org.parceler.Parcels
 
class BookFormActivity : AppCompatActivity() {
    private val binding: ActivityBookFormBinding by lazy {
        DataBindingUtil.setContentView<ActivityBookFormBinding>(
                this, R.layout.activity_book_form
        )
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding.content.book = if (savedInstanceState == null) {
            Parcels.unwrap<Book>(intent.getParcelableExtra(EXTRA_BOOK)) ?: Book()
        } else {
            Parcels.unwrap<Book>(savedInstanceState.getParcelable(EXTRA_BOOK))
        }
        binding.content.publishers = listOf(
                Publisher("1", "Novatec"),
                Publisher("2", "Outra")
        )
        binding.content.view = this
    }
    override fun onSaveInstanceState(outState: Bundle?) {
        super.onSaveInstanceState(outState)
        outState?.putParcelable(EXTRA_BOOK, Parcels.wrap(binding.content.book))
    }
    fun onMediaTypeChanged(buttonView: CompoundButton, isChecked: Boolean) {



        if (isChecked) {
            if (buttonView === binding.content.rbMediaEbook) {
                binding.content.book?.mediaType = MediaType.EBOOK
            } else if (buttonView === binding.content.rbMediaPaper) {
                binding.content.book?.mediaType = MediaType.PAPER
            }
        }
    }
    fun clickSaveBook(view: View) {
        val book = binding.content.book
        if (book != null) {
            val s = "${book.title}\n" +
                    "${book.author}\n" +
                    "${book.publisher?.name}\n" +
                    "${book.pages}\n" +
                    "${book.year}\n" +
                    "${book.available}\n" +
                    "${book.rating}\n" +
                    "${book.mediaType}"
            Toast.makeText(this, s, Toast.LENGTH_SHORT).show()
        }
    }
 
    companion object {
        private const val EXTRA_BOOK = "book"
 
        fun start(context: Context, book: Book) {
            context.startActivity(
                    Intent(context, BookFormActivity::class.java).apply {
                        putExtra(EXTRA_BOOK, Parcels.wrap(book))
                    }
            )
        }
    }
}

No método onCreate(Bundle) estão sendo definidas as propriedades do binding:
o livro, a lista de editoras e a view (que aqui é a própria activity). Além disso,
foram definidos os dois métodos utilizados no arquivo de layout
onMediaTypeChanged(CompoundButton,Boolean) e clickSaveBook(View). Note que eles têm
a mesma assinatura (tipo de retorno, ordem e tipo dos parâmetros) iguais aos
respectivos métodos das interfaces OnCheckedChangedListener e OnClickListener. Se a
assinatura não estiver correta, a compilação falhará.

Note que está sendo utilizado binding.content, pois no arquivo de layout



res/layout/activity_book_form.xml está sendo feito um <include> com o id
content para o arquivo res/layout/book_form_content.xml.

Se tentar executar a aplicação agora ela não compilará, pois está faltando
um detalhe importante no arquivo de layout: as propriedades year e pages da
classe Book são do tipo Int. No entanto, esses valores estão sendo atribuídos
diretamente na propriedade android:text do EditText que espera que seja passada
uma string. Para resolver esse problema deve-se utilizar um Inverse Binding
Adapter.

Inverse Binding Adapters
Um binding adapter foi definido quando a BookDetailsActivity foi implementada,
pois era preciso passar um MediaType como valor para um TextView, então o
binding adapter fez essa conversão de tipos. Entretanto, não estava sendo
utilizado o two way data binding, então a conversão de MediaType para String foi
suficiente. A conversão de String para MediaType não foi necessária. Já os
campos year e pages estavam sendo formatados utilizando uma string definida
no res/values/strings.xml, convertendo-as para string fazendo com que o
problema não aparecesse nessa tela.

No caso do ano do livro e quantidade de páginas, além de atribuir o texto do
EditText com o valor da respectiva propriedade do objeto Book, é necessário
fazer a operação inversa. Ou seja, o valor digitado no EditText e deve ser
convertido de volta para um Int que será armazenado no objeto Book.

Crie a classe EditTextBinding dentro do pacote binding do projeto e deixe-a como
a seguir:
import android.widget.EditText
import androidx.databinding.BindingAdapter
import androidx.databinding.InverseBindingAdapter
 
object EditTextBinding {
    @JvmStatic
    @BindingAdapter("android:text")
    fun setTextFromInt(editText: EditText, value: Int) {
        if (getTextAsInt(editText) != value) {
            editText.setText(value.toString())
        }
    }
    @JvmStatic
    @InverseBindingAdapter(attribute = "android:text")



    fun getTextAsInt(editText: EditText): Int {
        return try {
            Integer.parseInt(editText.text.toString())
        } catch (e: Exception) {
            0
        }
    }
}

O método getTextAsInt(EditText) está anotado com @InverseBindingAdapter e é o
responsável por converter o que é digitado no EditText para um Int. Já o método
setTextFromInt(EditText,Int) convertá um Int para o texto que será exibido no
EditText. Note um detalhe importante aqui: é feita uma verificação para saber
se o valor atribuído ao EditText é diferente do valor atual. Isso é essencial, pois
se isso não for feito, será gerado um “loop infinito” e o componente ficaria
travado ao tentar digitar algo. É que, ao mudar o texto do EditText, a
propriedade do objeto é automaticamente alterada, e ao ser modificada,
atualizaria o texto do EditText, causando esse ciclo infinito de chamadas.

Para testar a aplicação, na BookListActivity, chame a BookFormActivity em vez da
BookDetailsActivity:
BookFormActivity.start(this,
        Book().apply {
            ...
        }
)

Execute a aplicação e um resultado similar ao da Figura 20.2 deve ser
obtido.



Figura 20.2 – Tela de edição com two way data binding.
Altere os valores de todos os campos e clique no botão Save. Você perceberá

que os valores foram automaticamente atualizados.

Data Binding em listas
Depois de iniciar o desenvolvimento da tela de detalhes e de edição, a tela de
listagem será finalmente implementada. Adicione a dependência da
RecyclerView no build.gradle:
dependencies {
    ...
    implementation "androidx.recyclerview:recyclerview:$recyclerview_version"
}

Lembre-se de adicionar a constante recyclerview_version no build.gradle do
projeto com a versão: 1.0.0 (ou mais recente).

A implementação da tela de listagem começará pelo arquivo de layout que
será utilizado pelo adapter. Crie o arquivo res/layout/item_book.xml e deixe-o
como a seguir:
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <data>



        <variable
            name="book"
            type="dominando.android.livros.model.Book" />
    </data>
    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="?attr/selectableItemBackground"
        android:padding="8dp">
        <ImageView
            android:id="@+id/imgCover"
            android:layout_width="90dp"
            android:layout_height="120dp"
            android:scaleType="centerInside"
            app:imageUrl="@{book.coverUrl}"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent" />
        <TextView
            android:id="@+id/txtTitle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:text="@{book.title}"
            android:textSize="20sp"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toEndOf="@+id/imgCover"
            app:layout_constraintTop_toTopOf="@+id/imgCover" />
        <TextView
            android:id="@+id/txtAuthor"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:layout_marginTop="8dp"
            android:text="@{book.author}"
            android:textSize="16sp"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toEndOf="@id/imgCover"
            app:layout_constraintTop_toBottomOf="@+id/txtTitle" />
    </androidx.constraintlayout.widget.ConstraintLayout>
</layout>

Não há nada nesse arquivo que não tenha sido explicado anteriormente.
Esse arquivo de layout é uma versão mais simples da tela de detalhes.

O adapter que será utilizado na tela de listagem é definido na classe



BookAdapter deve ficar como a seguir:
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.recyclerview.widget.RecyclerView
import dominando.android.livros.databinding.ItemBookBinding
import dominando.android.livros.model.Book
 
class BookAdapter(val books: List<Book>,
                  private val onClick: (Book) -> Unit)
    : RecyclerView.Adapter<BookAdapter.ViewHolder>() {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
                .inflate(R.layout.item_book, parent, false)
        return ViewHolder(view)
    }
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.binding?.run {
            val currentBook = books[position]
            book = currentBook
            root.setOnClickListener {
                onClick(currentBook)
            }
            executePendingBindings()
        }
    }
 
    override fun getItemCount(): Int = books.size
 
    inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val binding = DataBindingUtil.bind<ItemBookBinding>(view)
    }
}

Essa classe possui alguns detalhes importantes e interessantes. A
propriedade root de um binding retorna a View raiz do arquivo de layout, que
nesse exemplo (res/layout/item_book.xml) é um ConstraintLayout.

Um ponto importantíssimo é a chamada ao método executePendingBindings(),
pois quando o objeto que está fazendo o binding em um arquivo de layout é
atribuído, essa atualização só é realizada após alguns milissegundos. E numa
tela de listagem, se o usuário fizer um scroll muito rápido, essa alteração
pode ficar atrasada e ficar perceptível para o usuário. Esse método executa o



binding imediatamente.
Como é possível observar na classe ViewHolder, foi utilizada a classe

DataBindingUtils para obter o objeto binding passando como parâmetro uma View
em vez de um arquivo de layout. Uma abordagem similar é utilizada com
Fragments, onde o onCreateView(LayoutInflater,ViewGroup,Bundle) ficaria da seguinte
forma:
class MyFragment: Fragment() {
    var binding: FragmentMyBinding? = null
    
    override fun onCreateView(inflater: LayoutInflater,
                              container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        binding = DataBindingUtil.inflate(
                inflater, R.layout.fragment_my, container, false)
        return binding.root
    }
}

Uma vez que o adapter foi criado, adicione a RecyclerView no arquivo de
layout res/layout/activity_book_list.xml:
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="dominando.android.livros.BookListActivity">
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/rvBooks"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</FrameLayout>

Por fim, modifique a BookListActivity para que fique como a seguir:
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.recyclerview.widget.LinearLayoutManager
import dominando.android.livros.model.Book
import dominando.android.livros.model.MediaType
import dominando.android.livros.model.Publisher
import kotlinx.android.synthetic.main.activity_book_list.*
 
class BookListActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)



        setContentView(R.layout.activity_book_list)
        val books = listOf(
                Book().apply {
                    id = "1"
                    title = "Dominando o Android"
                    author = "Nelson Glauber"
                    coverUrl = "https://s3.novatec.com.br/capas-ampliadas/capa-ampliada-

9788575224632.jpg"
                    pages = 954
                    year = 2018
                    publisher = Publisher("1", "Novatec")
                    available = true
                    mediaType = MediaType.PAPER
                    rating = 5.0f
                }
        )
        rvBooks.layoutManager = LinearLayoutManager(this)
        rvBooks.adapter = BookAdapter(books) { book ->
            BookDetailsActivity.start(this, book)
        }
    }
}

Execute a aplicação e ela deve ficar similar à da Figura 20.3. Por enquanto,
essa tela só exibe um livro e ao clicar nele a tela de detalhes é exibida com o
restante das informações do livro. No próximo capítulo faremos a ligação da
UI com os recursos do Firebase.



Figura 20.3 – Tela de listagem de livros.

BaseObservable, Observable e Observable fields
Nesse exemplo foi visto que a classe Book herda de BaseObservable. Porém, caso
você não queira ou não possa herdar de BaseObservable, a API fornece duas
outras opções: implementar a interface androidx.databing.Observable; ou utilizar
observable fields.

Com a primeira abordagem, basicamente seria preciso copiar o conteúdo da
classe BaseObservable:
import androidx.databinding.Observable
import androidx.databinding.PropertyChangeRegistry
 
class Book: Observable {
    // Os atributos permanecem
    @Transient private var callbacks: PropertyChangeRegistry? = null
 
    override fun addOnPropertyChangedCallback(callback: Observable.OnPropertyChangedCallback) {
        synchronized(this) {
            if (callbacks == null) {
                callbacks = PropertyChangeRegistry()
            }
        }



        callbacks?.add(callback)
    }
    override fun removeOnPropertyChangedCallback(callback:

Observable.OnPropertyChangedCallback) {
        synchronized(this) {
            if (callbacks == null) {
                return
            }
        }
        callbacks?.remove(callback)
    }
    fun notifyChange() {
        synchronized(this) {
            if (callbacks == null) {
                return
            }
        }
        callbacks?.notifyCallbacks(this, 0, null)
    }
    fun notifyPropertyChanged(fieldId: Int) {
        synchronized(this) {
            if (callbacks == null) {
                return
            }
        }
        callbacks?.notifyCallbacks(this, fieldId, null)
    }
}

Se observarmos o código Java da classe BaseObservable, ela faz extamente o
que está listado no código anterior. É criada uma instância da classe
PropertyChangeRegistry, que é a responsável por notificar quando uma propriedade
é modificada. Perceba que esse atributo é marcado como @Transient para que
não faça parte da serialização do objeto, ou seja, ele será ignorado se for
passado de uma tela para outra, por exemplo. O acesso a esse objeto é feito
sempre de forma sincronizada para que não haja problemas de duas threads
acessando esse objeto ao mesmo tempo.

A segunda alternativa ao uso do BaseObservable seria os observable fields, que
são classes que começam “Observable”, tais como: ObservableBoolean,
ObservableInt, ObservableList<Publisher>, ObservableField<String>, entre outras. Utilizando
essa abordagem, a classe Book ficaria desta forma:
import androidx.databinding.ObservableBoolean



import androidx.databinding.ObservableField
import androidx.databinding.ObservableFloat
import androidx.databinding.ObservableInt
 
class Book {
    private val id = ObservableField<String>()
    private val title = ObservableField<String>()
    private val author = ObservableField<String>()
    private val coverUrl = ObservableField<String>()
    private val pages = ObservableInt()
    private val year = ObservableInt()
    private val publisher = ObservableField<Publisher?>()
    private val available = ObservableBoolean(false)
    private val mediaType = ObservableField<MediaType>(MediaType.PAPER)
    private val rating = ObservableFloat(0.0f)
    
    fun getId() = id.get()
    fun setId(id: String) { this.id.set(id) }
    fun getTitle() = title.get()
    fun setTitle(title: String) { this.title.set(title) }
    fun getAuthor() = author.get()
    fun setAuthor(author: String) { this.author.set(author) }
    fun getCoverUrl() = coverUrl.get()
    fun setCoverUrl(coverUrl: String) { this.coverUrl.set(coverUrl) }
    fun getPages() = pages.get()
    fun setPages(pages: Int) { this.pages.set(pages) }
    fun getYear() = year.get()
    fun setYear(year: Int) { this.year.set(year) }
    fun getPublisher() = publisher.get()
    fun setPublisher(publisher: Publisher) { this.publisher.set(publisher) }
    fun getAvailable() = available.get()
    fun setAvailable(available: Boolean) { this.available.set(available) }
    fun getMediaType() = mediaType.get()
    fun setMediaType(mediaType: MediaType) { this.mediaType.set(mediaType) }
    fun getRating() = rating.get()
    fun setRating(rating: Float) { this.rating.set(rating) }
}

A classe não herda de nenhuma classe e cada atributo do livro usaria os
observable fields. Em seguinda, foram definidos os métodos get e set para cada
um desses campos passando como parâmetro um valor do tipo nativo daquele
observable field (um Boolean para um ObservableBoolean, por exemplo).

Ouvindo mudanças nas propriedades



Para capturar o evento de mudança de uma propriedade, pode-se utilizar o
método addOnPropertyChangedCallback(OnPropertyChangedCallback) como a seguir:
binding.addOnPropertyChangedCallback(object : Observable.OnPropertyChangedCallback() {
    override fun onPropertyChanged(observable: Observable, i: Int) {
        if (i == BR.title) {
            val p = observable as Book
            // Propriedade title foi modificada
        }
    }
})

Perceba que só é possível fazer o cast se Book herdar de BaseObservable ou
implementar Observable. Se utilizar observable fields, o listener deve ser
adicionado diretamente para o atributo desejado.

Data binding expression language (EL)
A API do data binding possui uma poderosa linguagem de expressões que
pode ser bastante útil na criação dos layouts. Observe alguns exemplos:
<TextView ...
   android:text="@{user.displayName ?? user.lastName}"/>

Utilizando o “??” caso a expressão da esquerda retorne null, a expressão da
direita será utilizada. Nesse exemplo, se user.displayName for nulo, o user.lastName
será exibido. Bem similar ao “elvis operator” do Kotlin:
<TextView ...
    android:text="@{`User: ` + user.name}"/>

Nesse exemplo, a string "User: " está sendo concatenada com user.name.
Perceba que está sendo usado o caracter ` (apóstrofo) em vez de ‘ (aspas
simples) ou “ (aspas duplas):
<TextView ...
    android:textColor="@{book.available ? @color/black : @color/red}" />

Aqui, a cor do texto do TextView foi definida de acordo com a propriedade
available do objeto book.
<TextView ...
    android:text="@{@string/price_format(book.price)}" />

Foi utilizado algo bem similar ao exemplo anterior na tela de detalhes do
livro. É possível formatar valores com textos declarados no
res/values/strings.xml:
<string name="price_format">R$ %1$.2f</string>



Como podemos observar, a API de data binding é bastante poderosa e pode
agilizar bastante o desenvolvimento de aplicações tornando-as mais robustas
e confiáveis no que diz respeito à exibição de conteúdo, uma vez que seu
principal propósito é fazer com que os dados em memória sejam refletidos na
interface gráfica.



CAPÍTULO 21
Firebase

O Firebase é um BaaS (Backend-as-a-Service) do Google que disponibiliza
uma série de ferramentas na nuvem para desenvolvimento de aplicações
independentemente da plataforma. O Firebase possui APIs para persistência
de dados, autenticação, relatório de erros, push notifications, configuração
remota, analytics, entre outras. Com o Firebase, sua aplicação pode utilizar a
infraestrutura dos servidores do Google de forma segura e escalável. Neste
capítulo, serão apresentados três dos principais recursos do Firebase:
Authentication, Cloud Firestore e Cloud Storage.

Configurando o projeto de livros
No capítulo anterior foi criada a estrutura básica de UI do projeto de livros.
Neste capítulo serão adicionadas as APIs do Firebase para realizar a
autenticação, persistência de dados e arquivos desse projeto, mas antes é
necessário criar um novo projeto no Firebase Console. Acesse
https://console.firebase.google.com e clique na opção Add project1. Será
exibida a tela da Figura 21.1.

Dê um nome ao projeto preenchendo o campo Project name. Preencha com
“LivrosFirebase” (ou o nome que preferir) e no campo Project ID será
gerado automaticamente um identificador para esse projeto baseado no seu
nome. Selecione seu país no campo Country/region, marque a opção para
aceitar os termos de uso do Firebase e clique em Create Project. Após alguns
instantes o projeto será criado e será exibida a tela principal do Firebase
Console. Clique na opção Add Firebase to your Android app e será exibida
a tela da Figura 21.2.

No campo Android package name preencha com o nome do pacote da
aplicação que foi utilizado no capítulo anterior (dominando.android.livros). O
campo App nickname é opcional e usado apenas internamente, então



preencha com “Livros Firebase”. Em seguida, preencha o campo Debug
signing certificate SHA-1 com o SHA-1 retornado pelo comando keytool. Por
fim, clique em Register app e será exibida a tela da Figura 21.3.

Figura 21.1 – Criando novo projeto no Firebase Console.



Figura 21.2 – Adicionando o Firebase ao projeto Android.

Figura 21.3 – Download do arquivo google-services.json.



Faça o download do arquivo google-services.json e copie-o para o diretório
app do projeto. Esse arquivo pode ser baixado posteriormente na opção
Project Overview > Project Settings do Firebase Console. Clique em Next e
será exibida a última tela do assistente que fornece orientações de como
configurar o Firebase no projeto. Clique em Finish para concluir o assistente.

A primeira mudança que deve ser feita é adicionar a dependência do plugin
do Google Services no build.gradle do projeto:
buildscript { ...
    ext {
        ...
        firebase_core_version = '16.0.7'
        google_services_version = '4.2.0'
    }
    dependencies { ...
        classpath "com.google.gms:google-services:$google_services_version"
    }
}

Foram adicionadas também as constantes para a biblioteca core do Firebase
e do Google Play Services.

Em seguida, adicione a dependência da biblioteca core do Firebase e
aplique o plugin do Google Services no build.gradle do módulo app:
dependencies { ...
    implementation "com.google.firebase:firebase-core:$firebase_core_version"
}
apply plugin: 'com.google.gms.google-services'

A linha que está aplicando o plugin do Google Services deve ser a última
do arquivo.

Faça a sincronização para realizar o download das dependências no
Android Studio e começar a utilizar o Firebase no projeto de livros.

Authentication
Nesta seção será demonstrado como utilizar o Firebase Authentication, que
permite centralizar diversas formas de autenticação utilizando o Firebase.
Com ela é possível fazer o login no aplicativo utilizando email/senha,
telefone ou as contas do Google, Facebook, Twitter e Github. Neste exemplo,
será utilizado apenas o login utilizando a conta do Google.

A primeira coisa que deve ser feita é habilitar esse tipo de autenticação no



Firebase Console por meio da opção Develop > Authentication. Em seguida,
selecionar a aba Sign-in method como mostra a Figura 21.4.

Figura 21.4 – Habilitando a autenticação com a conta do Google.
Clique na opção do Google na listagem Sign-in providers e, em seguida,

clique no botão Enable. Aparecerá o campo Project public-facing name, que
é o nome que aparecerá para os usuários quando for exibida alguma
informação sobre o aplicativo. Preencha com um nome descritivo como
“Livros Firebase”, por exemplo. Por fim, selecione o seu usuário Google no
campo Project support email e clique no botão Save para concluir a
configuração.

Adicione as seguintes dependências no build.gradle do módulo app:
dependencies { ...
    implementation "com.google.firebase:firebase-auth:$firebase_auth_version"
    implementation "com.google.android.gms:play-services-auth:$playservices_version"
}

Adicione as constantes firebase_auth_version = '16.1.0' e playservices_version = '16.0.1' no
build.gradle do projeto.

Configurado o projeto, crie a tela de login do aplicativo adicionando uma
nova activity chamada SignInActivity e deixe o arquivo de layout



res/layout/acivity_sign_in.xml como a seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical"
    tools:context="SignInActivity">
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginBottom="32sp"
        android:text="@string/app_name"
        android:textSize="48sp" />
    <Button
        android:id="@+id/btnSignIn"
        style="@style/Widget.AppCompat.Button.Colored"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/button_google_sign_in" />
</LinearLayout>

A arquivo de layout é bem simples e possui apenas um TextView e um Button
que ao ser clicado iniciará o processo de login. Agora adicione as strings no
res/values/strings.xml:
<string name="error_google_sign_in">Erro ao efetuar login com a conta do Google.</string>
<string name="button_google_sign_in">Login com Google</string>

Agora implemente a SignInActivity para que fique como a seguir:
import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.google.android.gms.auth.api.Auth
import com.google.android.gms.auth.api.signin.GoogleSignInAccount
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import com.google.android.gms.common.api.GoogleApiClient
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.GoogleAuthProvider
import kotlinx.android.synthetic.main.activity_sign_in.*
 
class SignInActivity : AppCompatActivity() {
    private var googleApiClient: GoogleApiClient? = null
    private var fbAuth = FirebaseAuth.getInstance()
 



    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_sign_in)
        initGoogleSignIn()
        btnSignIn.setOnClickListener {
            signIn()
        }
    }
    private fun initGoogleSignIn() {
        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
                .requestIdToken(getString(R.string.default_web_client_id))
                .requestEmail()
                .build()
        googleApiClient = GoogleApiClient.Builder(this)
                .enableAutoManage(this) {
                    showErrorSignIn()
                }
                .addApi(Auth.GOOGLE_SIGN_IN_API, gso)
                .build()
    }
    private fun signIn() {
        val signInIntent = Auth.GoogleSignInApi.getSignInIntent(googleApiClient)
        startActivityForResult(signInIntent, RC_GOOGLE_SIGN_IN)
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == RC_GOOGLE_SIGN_IN) {
            val result = Auth.GoogleSignInApi.getSignInResultFromIntent(data)
            if (result.isSuccess) {
                val account = result.signInAccount
                if (account != null) {
                    firebaseAuthWithGoogle(account)
                } else {
                    showErrorSignIn()
                }
            } else {
                showErrorSignIn()
            }
        }
    }
    private fun firebaseAuthWithGoogle(acct: GoogleSignInAccount) {
        val credential = GoogleAuthProvider.getCredential(acct.idToken, null)
        fbAuth.signInWithCredential(credential)
                .addOnCompleteListener(this) { task ->
                    if (task.isSuccessful) {



                        finish()
                        startActivity(Intent(this, BookListActivity::class.java))
                    } else {
                        showErrorSignIn()
                    }
                }
    }
    private fun showErrorSignIn() {
        Toast.makeText(this, R.string.error_google_sign_in, Toast.LENGTH_SHORT).show()
    }
 
    companion object {
        const val RC_GOOGLE_SIGN_IN = 1
    }
}

O atributo googleApiClient é inicializado no método no método initGoogleSignIn()
utilizando a classe GoogleSignInOptions.Builder. Perceba que é necessário requisitar
o token e o email para realizar a autenticação. O método
enableAutoManage(Activity, OnConnectionFailedListener) é usado para gerenciar
automaticamente a conexão com o Google Play Services, conectando ao
serviço no onStart() da activity e desconectando no onStop(). Esse método
também recebe um callback que será chamado se houver um erro durante o
estabelecimento da conexão com o Google Play Services.

Também foi declarado o atributo fbAuth do tipo FirebaseAuth, que é utilizado
para associar o login do Google com o Firebase.

Ao clicar no botão de login, o método signIn() está sendo chamado, e nele é
obtida a Intent para realizar a autenticação com a conta Google por meio da
chamada ao método getSignInIntent(GoogleApiClient) da classe Auth.GoogleSignInApi.
Ao invocar o startActivityForResult(Intent, Int) com essa Intent, será exibida a tela da
Figura 21.5.



Figura 21.5 – Autenticação com a conta do Google.
Confirmado o login, o método onActivityResult(Int,Int,Intent) será chamado, então

o resultado do processo de autenticação é obtido por meio do método
getSignInResultFromIntent(Intent). Se ele tiver sido efetuado com sucesso, as
informações da conta do usuário são obtidas na propriedade signInAccount do
objeto result (do tipo GoogleSignInResult). Então a informação da conta é passada
para o método firebaseAuthWithGoogle(GoogleSignInAccount), onde a credencial do
usuário é obtida via método getCredential(String,String) da classe GoogleAuthProvider
(do Firebase). Por fim, a tentativa de login é realizada invocando o método
signInWithCredential (AuthCredential) do objeto FirebaseAuth. Se tudo correr bem, a
BookListActivty é carregada, caso contrário, uma mensagem de erro é exibida.

A tela de login está concluída, mas agora é preciso garantir que o usuário
esteja autenticado em todas as telas do aplicativo. Por isso, crie uma activity
base para que as demais telas da aplicação herdem dela. Essa tela não terá
arquivo de layout nem precisa estar declarada no AndroidManifest.xml.
Adicione a classe BaseActivity e deixe-a como a seguir:
import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import com.google.firebase.auth.FirebaseAuth
 



abstract class BaseActivity : AppCompatActivity() {
    protected val fbAuth : FirebaseAuth = FirebaseAuth.getInstance()
    private var hasInitCalled = false
    private var authListener: FirebaseAuth.AuthStateListener =
            FirebaseAuth.AuthStateListener { firebaseAuth ->
                val user = firebaseAuth.currentUser
                if (user != null) {
                    if (!hasInitCalled) { // Para o init ser chamado apenas uma vez
                        hasInitCalled = true
                        init()
                    }
                } else {
                    finish()
                    val it = Intent(this, SignInActivity::class.java).apply {
                        addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK)
                        addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
                    }
                    startActivity(it)
                }
            }
 
    public override fun onStart() {
        super.onStart()
        fbAuth.addAuthStateListener(authListener)
    }
    public override fun onStop() {
        super.onStop()
        fbAuth.removeAuthStateListener(authListener)
    }
 
    protected abstract fun init()
}

Foi declarado um atributo chamado authListener do tipo AuthStateListener que
será invocado quando o usuário fizer o login ou logout da aplicação. Quando
isso acontecer, é verificado se o usuário atual, obtido pela propriedade
currentUser do FirebaseAuth é diferente de null, em caso positivo, a tela de login é
exibida e a task atual é limpa, o que fará com que todas as telas sejam
encerradas. Caso o usuário esteja autenticado, é chamado o método init() que é
abstrato e todas as subclasses deverão implementar. No onStart() da activity o
listener é registrado e no onStop() ele é removido. Como esses métodos podem
ser chamados várias vezes durante o ciclo de vida, o atributo hasInitCalled foi
utilizado para garantir que o init() seja chamado apenas uma vez.



Agora faça com que as demais telas herdem da classe BaseActivity:
// BookListActivity.kt
class BookListActivity : BaseActivity() {
    ...
    override fun init() {
    }
// BookDetailsActivity.kt
class BookDetailsActivity : BaseActivity() {
    ...
    override fun init() {
    }
// BookFormActivity.kt
class BookFormActivity : BaseActivity() {
    ...
    override fun init() {
    }

O método init() de cada classe será implementado nas próximas seções, mas,
por agora, deixe-os vazios. Execute a aplicação e teremos a tela de login em
funcionamento como mostra a Figura 21.6.

Figura 21.6 – Tela de login da aplicação.
A lista dos usuários autenticados na aplicação pode ser visualizada na

opção Develop > Authentication do Firebase Console na aba Users.



O último detalhe que deve ser implementado em relação à autenticação é
dar a opção ad usuário de realizar o logout da aplicação. Isso será feito
adicionando uma opção de menu na BookListActivity. Adicione o arquivo de
menu res/menu/book_list.xml e deixe-o como a seguir:
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:id="@+id/menu_sign_out"
        android:title="@string/menu_action_logout" />
</menu>

Adicione o texto da opção de menu no res/values/strings.xml:
<string name="menu_action_logout">Logout</string>

Por fim, implemente a lógica de logout na MainActivity:
class BookListActivity : BaseActivity() {
    ...
    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        menuInflater.inflate(R.menu.book_list, menu)
        return super.onCreateOptionsMenu(menu)
    }
    override fun onOptionsItemSelected(item: MenuItem?): Boolean {
        if (item?.itemId == R.id.menu_sign_out) {
            FirebaseAuth.getInstance().signOut()
            return true
        }
        return super.onOptionsItemSelected(item)
    }
}

Para fazer o logout basta chamar o método signOut() da classe FirebaseAuth.
Quando isso acontecer, o listener que foi definido na BaseActivity (e que todas
as activities agora herdam) será disparado e fechará a tela. Execute a
aplicação novamente e tenter fazer o logout na aplicação e verifique se a tela
de login é exibida corretamente.

Cloud Firestore
O Firebase Cloud Firestore é um banco de dados NoSQL para
desenvolvimento de aplicativos móveis e web que utiliza os servidores do
Google para armazenar as informações. Ele mantém os dados locais
sincronizados automaticamente com o servidor em tempo real. Além disso, o
Firestore tem suporte offline para que o aplicativo continue funcionando



mesmo sem acesso à internet. Com o Firestore é possível realizar consultas
de forma eficiente e flexível.

O armazenamento dos dados é feito baseado em coleções, documentos e
dados. Para simplificar o entendimento, uma coleção seria uma lista de
objetos onde cada objeto é um documento e os atributos desse objeto são os
dados.

Configurando o Firestore
O Cloud Firestore será utilizado para armazenar as informações do livros. Por
isso, ele deve ser habilitado no Firebase Console. Acesse a opção Develop >
Database e será exibida a tela da Figura 21.7.

Figura 21.7 – Habilitando o Cloud Firestore.
No momento da escrita deste livro, o Firestore encontra-se em versão beta,

mas a tendência é que ele venha a substituir outro produto bem similar do
Firebase: o Realtime Database. Por essa razão, ele será utilizado aqui. Clique
na opção Create Database e será exibida a tela da Figura 21.8.

É necessário configurar as regras de segurança para o banco de dados. A
opção locked mode fará que inicialmente todos os acessos ao banco sejam



negados, enquanto a opção test mode permitirá o acesso irrestrito ao nosso
banco de dados. Essa segunda opção pode ser útil se não foi implementado
nenhum mecanismo de login no aplicativo ou simplesmente o banco seja
usado para alguns testes simples, mas na prática deve-se sempre utilizar a
primeira opção e configurar corretamente o controle de acesso. Sendo assim,
clique na opção locked mode e clique em Enable. Quando o processo for
concluído, a tela da Figura 21.9 será exibida.

Figura 21.8 – Selecionando o nível de segurança do Firestore.



Figura 21.9 – Tela do Cloud Firestore no Firebase Console.
Nessa tela é possível visualizar os dados armazenados no banco de dados.

Selecione a aba Rules na parte superior e será exibido um script definindo as
regras de segurança para acesso ao banco de dados. Modifique-o para que
fique da seguinte forma:
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if request.auth.uid != null;
    }
  }
}

Como foi implementado o processo de autenticação no aplicativo, todas as
requisições que forem feitas serão de um usuário autenticado na aplicação.
Por essa razão, foi feita essa configuração que permite com que apenas
usuários autenticados possam acessar o banco de dados. Clique em Publish
para aplicar as novas regras.

Feitas as configurações no Firebase Console, adicione a dependência da
biblioteca do Firestore no build.gradle do módulo:
dependencies { ...



    implementation "com.google.firebase:firebase-firestore:$firebase_firestore_version"
}

Declare a constante firebase_firestore_version = '18.0.1' no build.gradle do projeto e
faça a sincronização para baixar a dependência.

Inserindo e atualizando livros
Crie o pacote firebase para adicionar as classes referentes ao Firebase e
adicione a classe FbRepository que representará o repositório da aplicação e
deixe-a como a seguir:
import androidx.lifecycle.LiveData
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.SetOptions
import dominando.android.livros.model.Book
 
class FbRepository {
    private val fbAuth = FirebaseAuth.getInstance()
    private val firestore = FirebaseFirestore.getInstance()
    private val currentUser = fbAuth.currentUser
 
    fun saveBook(book: Book): LiveData<Boolean> {
        return object : LiveData<Boolean>() {
            override fun onActive() {
                super.onActive()
                if (currentUser == null) {
                    throw SecurityException("Invalid user")
                }
                val db = firestore
                val collection = db.collection(BOOKS_KEY)
                val saveTask = if (book.id.isBlank()) {
                    book.userId = currentUser.uid
                    collection.add(book).continueWith { task ->
                        if (task.isSuccessful) {
                            book.id = task.result?.id ?: ""
                        }
                    }
                } else {
                    collection.document(book.id)
                            .set(book, SetOptions.merge())
                }
                saveTask.addOnSuccessListener {
                    value = true
                }.addOnFailureListener {



                    value = false
                }
            }
        }
    }
    companion object {
        const val BOOKS_KEY = "books"
        const val USER_ID_KEY = "userId"
        const val COVER_URL_KEY = "coverUrl"
    }
}

Essa classe possui o atributo firestore do tipo FirebaseFirestore que provê acesso
ao banco de dados. O atributo fbAuth será utilizado para obter o usuário que
está autenticado na aplicação por meio da propriedade currentUser e associar o
livro ao respectivo usuário da aplicação.

Como foi explicado no início do capítulo, o Firestore é baseado em
coleções, documentos e dados. Neste exemplo, é utilizada uma coleção de
livros, onde cada livro é um documento que possui vários dados (como título,
autor, ano etc.). O acesso ao Firestore é baseado em callbacks, então para
facilitar a legibilidade abstrair essa lógica do view model e da UI, foi
utilizado o LiveData. Com a biblioteca do Firebase não é necessário utilizar
nenhuma API de threading (como AsyncTask ou Coroutines) uma vez que as
requisições em background são feitas pela própria API do Firebase.

O método saveBook(Book) será utilizado tanto para a inclusão quando
atualização dos registros, por isso, é verificado inicialmente se o objeto book
possui um id associado. Caso não possua, o registro será incluído, caso já
possua, ele é atualizado. Para ambos os casos, a coleção de livros é obtida por
meio do método collection(String) que retorna uma CollectionReference. Para incluir o
livro, o método add(Any) é chamado passando o objeto book. Perceba que está
sendo utilizado o método continueWith que será executado após a inclusão do
livro para atualizar o id do objeto book. Isso será importante mais adiante para
poder realizar o upload da capa do livro.

A atualização do registro é bem similar. Após obter a coleção de livros, o
documento do livro específico é obtido por meio do método document(String)
passando o id do livro, e então o método set(Any) é chamado.

Para saber se a operação foi realizada com sucesso, foi utilizado o
addOnSuccessListener(OnSuccessListener) e addOnFailureListener(OnFailureListener) para
quando ocorrer um erro. Poderia ser utilizado também o



addOnCompletionListener(OnCompleteListener) e checar se a propriedade isSuccessful do
objeto Task (parâmetro do OnCompleteListener).

Lembre-se de que tudo isso está acontecendo dentro de um objeto LiveData,
por isso, quando a operação for efetuada com sucesso o valor é definido
como true, e false caso algum erro ocorra. Entretanto, note que foi utilizada a
propriedade userId do livro que não existe ainda. Adicione essa propriedade à
classe Book:
@Parcel
class Book : BaseObservable() {
    ...
    var userId: String = ""
}

Essa propriedade não precisa ser “bindable”, pois não é utilizada da
interface gráfica.

Foi visto que não é recomendado que a activity ou fragment acesse
diretamente a camada de dados da aplicação. Por essa razão, será criado um
view model que ficará entre a activity e o repositório, e posteriormente será
usado para expor alguns dados via LiveData.

Por isso, adicione as dependências dessas bibliotecas no build.gradle:
dependencies {
    implementation "androidx.lifecycle:lifecycle-extensions:$lifecycle_version"
    implementation "androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version"
    kapt "androidx.lifecycle:lifecycle-compiler:$lifecycle_version"
}

Como de costume, adicione a constante lifecycle_version = '2.0.0' no build.gradle
do projeto.

Crie o pacote viewmodels onde ficarão todos os view models que serão
definidos no projeto. Em seguida, adicione a classe BookFormViewModel e deixe-
a como a seguir:
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import dominando.android.livros.firebase.FbRepository
import dominando.android.livros.model.Book
 
class BookFormViewModel : ViewModel() {
    private val repo = FbRepository()
    var book: Book? = null



 
    private var showProgress = MutableLiveData<Boolean>().apply {
        value = false
    }
    private var saveBook = MutableLiveData<Book>()
    private var savingBookOperation = Transformations.switchMap(saveBook) { book ->
        showProgress.value = true
        Transformations.map(repo.saveBook(book)) { success ->
            showProgress.value = false
            success
        }
    }
 
    fun showProgress(): LiveData<Boolean> = showProgress
    fun savingOperation(): LiveData<Boolean> = savingBookOperation
 
    fun saveBook(book: Book) {
        saveBook.value = book
    }
}

Essa classe possui alguns detalhes bem interessantes. Ela expõe um LiveData
pelo método showProgress() que será utilizado para dar um feedback visual
enquanto o registro está sendo salvo; e outro LiveData chamado savingOperation()
que indicará se o evento de salvar o livro foi bem-sucedido ou não. Esses
atributos são importantes, pois como os dados estão sendo salvos pela
internet, essa operação pode demorar alguns segundos, então é importante
exibir algum feedback visual para o usuário. E lembrando que o usuário pode
rotacionar o aparelho durante esse processo.

O método saveBook(Book) apenas altera o valor do LiveData saveBook, mas
perceba que o savingBookOperation está usando a chamada
Transformation.switchMap(LiveData, (X)->LiveData<Y>) que intercepta quando o valor de
saveBook mudou e chama a função lambda que está alterando o valor de
showProgress para true. Em seguida, é usada a chamada Transformations.map(LiveData,
(X)->Y) passando como parâmetro a operação de salvar o livro no Firebase
utilizando o atributo repo. Quando essa operação termina, o valor de
showProgress é atualizado para false e o resultado da operação é informado
atualizando o valor de savingBookOperation.

Apenas para simplificar o entendimento:
• Transformation.switchMap(LiveData,(X)->LiveData<Y>) recebe um LiveData de um tipo



X e retorna um LiveData do tipo Y;
• Transformations.map(LiveData, (X)->Y) recebe um LiveData do tipo X e retorna

um valor do tipo Y.
A classe BookFormViewModel será utilizada pela BookFormActivity, por isso, faça

as seguintes mudanças:
import androidx.lifecycle.ViewModelProviders
import androidx.lifecycle.Observer
import dominando.android.livros.viewmodels.BookFormViewModel
...
class BookFormActivity : BaseActivity() {
    private val viewModel: BookFormViewModel by lazy {
        ViewModelProviders.of(this).get(BookFormViewModel::class.java)
    }
    ...
    override fun init() {
        viewModel.showProgress().observe(this, Observer { loading ->
            loading?.let {
                btnSave.isEnabled = !loading
                binding.content.progressBar.visibility = if (it) View.VISIBLE else View.GONE
            }
        })
        viewModel.savingOperation().observe(this, Observer { success ->
            success?.let {
                if (success) {
                    showMessageSuccess()
                    finish()
                } else {
                    showMessageError()
                }
            }
        })
    }
    fun clickSaveBook(view: View) {
        val book = binding.content.book
        if (book != null) {
            try {
                viewModel.saveBook(book)
            } catch (e: Exception) {
                showMessageError()
            }
        }
    }
    private fun showMessageSuccess() {



        Toast.makeText(this, R.string.message_book_saved, Toast.LENGTH_SHORT).show()
    }
    private fun showMessageError() {
        Toast.makeText(this, R.string.message_error_book_saved, Toast.LENGTH_SHORT).show()
    }
}

No método init() foi registrado Observer para exibir a ProgressBar e desabilitar o
botão de salvar enquanto o livro estiver sendo salvo. O outro Observer vai
detectar o processo de salvar o livro, se for bem-sucedido o método
showMessageSuccess() é chamado e a tela é encerrada, caso contrário, o método
showMessageError() é chamado.

Lembre-se de adicionar as strings das mensagens no res/values/strings.xml:
<string name="message_book_saved">Livro salvo com sucesso!</string>
<string name="message_error_book_saved">Erro ao salvar livro</string>

Listando os livros
Um dos recursos mais poderosos do Firestore é a atualização em tempo real
do banco de dados. O banco de dados poderia ser acessado diretamente da
activity, mas como já foi mencionado diversas vezes ao longo do livro, é
recomendado modularizar a aplicação de modo a facilitar a manutenção. Por
isso, os dados serão carregados no repositório e as mudanças serão
observadas utilizando o LiveData.

Para implementar a tela de listagem, um novo método deve ser adicionado
na FbRepository:
class FbRepository {
    ...
    fun loadBooks(): LiveData<List<Book>> {
        return object : LiveData<List<Book>>() {
            override fun onActive() {
                super.onActive()
                firestore.collection(BOOKS_KEY)
                        .whereEqualTo(USER_ID_KEY, currentUser?.uid)
                        .get()
                        .addOnCompleteListener { task ->
                            if (task.isSuccessful) {
                                val books = task.result?.map { document ->
                                    val book = document.toObject(Book::class.java)
                                    book.id = document.id
                                    book
                                }



                                value = books
                            } else {
                                throw Exception(task.exception)
                            }
                        }
            }
        }
    }
}

O método loadbooks() retorna um objeto LiveData que encapsula o resultado da
consulta no Firebase. Esse objeto só possui o método onActive() que é chamado
quando o LiveData se torna ativo. Esse objeto inicia obtendo a referência da
coleção de livros por meio do método collection(String) e no método
whereEqualTo(String,Any) é feita a filtragem para trazer apenas os livros do usuário
atual. Os resultados são trazidos em um objeto da classe QuerySnapshot que é
obtido ao chamar o método get() e registrar um callback usando
addOnCompleteListenerListener(OnCompleteListener). Esse objeto possui uma lista de
DocumentReference, onde cada DocumentReference é convertido em um objeto Book
utilizando o método toObject(Class) do objeto document. Por fim, o valor do
LiveData é atualizado.

Crie a classe BookListViewModel que intermediará a comunicação com a
activity:
import androidx.lifecycle.LiveData
import androidx.lifecycle.ViewModel
import dominando.android.livros.firebase.FbRepository
import dominando.android.livros.model.Book
 
class BookListViewModel: ViewModel() {
    private val repo = FbRepository()
    private var booksList: LiveData<List<Book>>? = null
 
    fun getBooks(): LiveData<List<Book>> {
        var list = booksList
        if (list == null) {
            list = repo.loadBooks()
            booksList = list
        }
        return list
    }
}

Essa classe apenas mantém a referência para o LiveData retornado pelo



repositório de modo que não precise realizar a consulta toda vez que a tela
seja rotacionada.

Essa classe será utilizada na BookListActivity como a seguir:
class BookListActivity : BaseActivity() {
    private val viewModel: BookListViewModel by lazy {
        ViewModelProviders.of(this).get(BookListViewModel::class.java)
    }
    ...
    override fun init() {
        try {
            viewModel.getBooks().observe(this, Observer { books ->
                updateList(books)
            })
        } catch (e: Exception) {
            Toast.makeText(this, R.string.message_error_load_books,
                    Toast.LENGTH_SHORT).show()
        }
    }
    private fun updateList(books: List<Book>) {
        rvBooks.layoutManager = LinearLayoutManager(this)
        rvBooks.adapter = BookAdapter(books) { book ->
            BookDetailsActivity.start(this, book)
        }
    }
}

No método init() é chamado getBooks() para carregar os dados do servidor.
Como visto anteriormente, esse método retorna um LiveData<List<Book>>, por
isso está sendo registrado um Observer para atualizar a lista de livros, e nele o
método updateList(List<Book>) é chamado para exibir a listagem na RecyclerView.
Adicione no res/values/strings.xml o texto utilizado no método init():
<string name="message_error_load_books">Erro ao carregar listagem de livros</string>

Essa abordagem funciona muito bem, seu único problema é que esse LiveData
não é atualizado quando os dados são modificados no servidor, pois foi
utilizado o método get() no FbRepository. E um dos recursos mais interessantes
do Firebase Cloud Firestore é essa possibilidade de ter a atualização
automática dos dados. Para fazer isso, faça o seguinte ajuste no método
loadBooks() da classe FbRepository para ficar da seguinte forma:
fun loadBooks(): LiveData<List<Book>> {
    return object : LiveData<List<Book>>() {
        override fun onActive() {



            super.onActive()
            firestore.collection(BOOKS_KEY)
                    .whereEqualTo(USER_ID_KEY, currentUser?.uid)
                    .addSnapshotListener { querySnapshot, firebaseFirestoreException ->
                        if (firebaseFirestoreException == null) {
                            val books = querySnapshot?.map { document ->
                                    val book = document.toObject(Book::class.java)
                                    book.id = document.id
                                    book
                            }
                            value = books
                        } else {
                            throw firebaseFirestoreException
                        }
                    }
        }
    }
}

A modificação é bem simples. Foi utilizado o addSnapshotListener(EventListener)
em que é verificado se o parâmetro firebaseFirestoreException (do tipo
FirebaseFirestoreException) é igual a null. Nesse caso, nenhum erro aconteceu, então
o resultado pode ser processado normalmente. Caso contrário, uma exceção é
levantada.

Dessa forma, quando novos livros forem incluídos, alterados ou excluídos,
a listagem será atualizada automaticamente.

Ajustes de UI
Alguns ajustes de UI são necessários para testar a aplicação. Primeiramente,
será adicionado um FloatingActionButton na tela principal, que chamará
diretamente a BookFormActivity para incluir um novo livro.

É preciso adicionar a dependência da biblioteca de design no build.gradle
do módulo app:
dependencies { ...
    implementation "com.google.android.material:material:$material_design_version"
}

Adicione a constante da versão material_design_version = '1.0.0' no build.gradle do
projeto. No arquivo de layout res/layout/activity_book_list.xml adicione o
botão:
<FrameLayout



    xmlns:app="http://schemas.android.com/apk/res-auto" ...>
    <androidx.recyclerview.widget.RecyclerView ... />
    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/fabAdd"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="end|bottom"
        android:layout_margin="16dp"
        android:tint="@android:color/white"
        app:fabSize="normal"
        app:srcCompat="@drawable/ic_add" />
</FrameLayout>

Adicione o ícone ic_add na pasta res/drawable clicando com o botão
direito na pasta res e selecionando a opção New > Vector Asset.

No onCreate(Bundle) defina o evento de clique do botão para chamar a
BookFormActivity:
class BookListActivity : BaseActivity() {
    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_book_list)
        fabAdd.setOnClickListener {
            startActivity(Intent(this, BookFormActivity::class.java))
        }
    }
    ...
}

A próxima modificação será adicionar uma opção na BookDetailsActivity para
chamar a BookFormActivity. Isso será feito por uma opção de menu na toolbar.
Crie o arquivo res/menu/book_details.xml:
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
        android:id="@+id/menu_edit_book"
        android:icon="@drawable/ic_edit"
        android:title="@string/menu_action_edit"
        app:showAsAction="always|withText" />
</menu>

Adicione o texto da opção de menu no res/values/strings.xml. Também
adicione o ícone ic_edit como fizemos anteriormente para o FAB:
<string name="menu_action_edit">Editar</string>



Na BookDetailsActivity carregue esse arquivo de menu e faça com que ele
chame a BookFormActivity:
class BookDetailsActivity : BaseActivity() {
    ...
    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        menuInflater.inflate(R.menu.book_details, menu)
        return super.onCreateOptionsMenu(menu)
    }
    override fun onOptionsItemSelected(item: MenuItem?): Boolean {
        if (item?.itemId == R.id.menu_edit_book) {
            binding.book?.let {
                BookFormActivity.start(this, it)
            }
            return true
        }
        return super.onOptionsItemSelected(item)
    }
}

Execute a aplicação e o fluxo deve estar correto agora. Ao clicar no FAB da
BookListActivity, a BookFormActivity deve ser exibida com os campos em branco.
Ao inserir um registro, a tela de cadastro é fechada e a tela de listagem é
exibida com o livro recém-cadastrado. Ao clicar no item da lista, a
BookDetailsActivity é exibida. Ao clicar na opção de menu para editar, a
BookFormActivity é exibida com os dados do livro.

Entretanto, a aplicação tem um problema: ao editar um registro, a tela de
detalhes é exibida novamente, mas os dados exibidos não estão atualizados. É
preciso implementar essa lógica na BookDetailsActivity:
class FbRepository {
    ...
    fun loadBook(bookId: String): LiveData<Book> {
        return object : LiveData<Book>() {
            override fun onActive() {
                super.onActive()
                firestore.collection(BOOKS_KEY)
                        .document(bookId)
                        .addSnapshotListener { documentSnapshot, firebaseFirestoreException ->
                            if (firebaseFirestoreException == null) {
                                if (documentSnapshot != null) {
                                    val book = documentSnapshot.toObject(Book::class.java)
                                    book?.id = documentSnapshot.id
                                    value = book



                                }
                            } else {
                                throw firebaseFirestoreException
                            }
                        }
            }
        }
    }
}

O método loadBook(String) é bem similar ao loadBooks(). A única diferença é que
em vez de retornar uma lista de livros, um único livro é retornado baseado no
id.

Crie a classe BookDetailsViewModel para intermediar a comunicação entre a tela
e o repositório:
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import dominando.android.livros.firebase.FbRepository
import dominando.android.livros.model.Book
 
class BookDetailsViewModel : ViewModel() {
    private val repo = FbRepository()
    private val selectedBookId = MutableLiveData<String>()
    private var selectedBook = Transformations.switchMap(selectedBookId) { bookId ->
        repo.loadBook(bookId)
    }
    fun getBook(id: String): LiveData<Book> {
        selectedBookId.value = id
        return selectedBook
    }
}

No método getBook(String) foi feito algo bem similar à implementação do
comportamento de salvar livro. O valor de selectBookId é modificado e por meio
da instrução Transformations.switchMap(LiveData<X>,LiveData<Y>) essa mudança é
interceptada e o livro é obtido do servidor por meio do método loadBook(String)
do FbRepository.

Para utilizar essa classe, faça as seguintes mudanças na BookDetailsActivity:
class BookDetailsActivity : BaseActivity() {
    private val viewModel: BookDetailsViewModel by lazy {
        ViewModelProviders.of(this).get(BookDetailsViewModel::class.java)



    }
    ...
    override fun init() {
        binding.book?.let { book ->
            viewModel.getBook(book.id).observe(this, Observer {
                binding.book = it
            })
        }
    }
    ...
}

Foi feita uma implementação bem similar à da tela de listagem, a diferença
é que em vez de monitorar vários registros, apenas um livro específico está
sendo observado, e graças ao Data Binding, a UI será atualizada
automaticamente.

Removendo registros
A última operação é a de excluir um livro. Isso será feito usando o gesto de
swipe na tela de listagem, mas primeiramente declare a operação de exclusão
na classe FbRepository:
class FbRepository {
    ...
    fun remove(book: Book): LiveData<Boolean> {
        return object : LiveData<Boolean>() {
            override fun onActive() {
                super.onActive()
                val db = firestore
                db.collection(BOOKS_KEY)
                        .document(book.id)
                        .delete()
                        .addOnCompleteListener {
                            value = it.isSuccessful
                        }
            }
        }
    }
}

O método é bem simples. Após obter a referência para a coleção de livros, o
documento referente ao id do livro passado como parâmetro é excluído por
meio do método delete(), e o valor do LiveData é atualizado com o resultado da
operação.



Em seguida, adicione o método na classe BookListViewModel:
class BookListViewModel: ViewModel() {
     ...
     fun remove(book: Book) = repo.remove(book)
}

Finalmente faça os ajustes na BookListActivity:
class BookListActivity : BaseActivity() {
    // Demais métodos e atributos não sofreram mudanças
    private fun updateList(books: List<Book>) {
        // Restante do método não mudou...
        attachSwipeToRecyclerView()
    }
    private fun attachSwipeToRecyclerView() {
        val swipe = object : ItemTouchHelper.SimpleCallback(
                0,
                ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT) {
            override fun onMove(recyclerView: RecyclerView,
                                viewHolder: RecyclerView.ViewHolder,
                                target: RecyclerView.ViewHolder): Boolean {
                return false
            }
            override fun onSwiped(viewHolder: RecyclerView.ViewHolder,
                                  direction: Int) {
                val position = viewHolder.adapterPosition
                deleteBookFromPosition(position)
            }
        }
        val itemTouchHelper = ItemTouchHelper(swipe)
        itemTouchHelper.attachToRecyclerView(rvBooks)
    }
    private fun deleteBookFromPosition(position: Int) {
        val adapter = rvBooks.adapter as BookAdapter
        val book = adapter.books[position]
        viewModel.remove(book).observeOnce(Observer { success ->
            if (!success) {
                Toast.makeText(this,
                        R.string.message_error_delete_book, Toast.LENGTH_SHORT).show()
            }
        })
    }
}

Foi utilizada a classe ItemTouchHelper para adicionar o evento de swipe (para
esquerda ou direita) nos itens da RecyclerView. Quando esse evento ocorrer, o



método deleteBookFromPosition(Int) será chamado. Então o objeto book é obtido
baseado na respectiva posição no adapter e o método remove(String) do
BookListViewModel é chamado. Se algo der errado, uma mensagem é exibida.

Adicione o texto da mensagem no res/values/strings.xml:
<string name="message_error_delete_book">Erro ao excluir livro</string>

Perceba que foi utilizado o método observeOnce(Observer) que não existe na API
de LiveData. O intuito desse método é observar o evento apenas uma vez.
Assim, quando o resultado da operação de exclusão for obtido, o Observer será
desativado. Crie o pacote livedata e dentro dele crie o arquivo
LiveDataExtensions.kt e deixe-o da seguinte forma:
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
 
@Throws(Throwable::class)
fun <T> LiveData<T>.observeOnce(observer: Observer<T>) {
    observeForever(object : Observer<T> {
        override fun onChanged(t: T?) {
            observer.onChanged(t)
            removeObserver(this)
        }
    })
}

Aqui temos uma extension function para a classe LiveData. Extension
functions é um recurso do Kotlin que permite adicionar funções a classes
existentes. A sintaxe é basicamente:
fun ClasseDesejada.nomeDaExtensionFunction() {
}

Ao criar uma extension function, todas as instâncias daquela classe terão
acesso àquela função. Esse é um recurso muito poderoso da linguagem, tanto
que o Google criou a KTX (KoTlin eXtensions), uma biblioteca de extensões
das APIs do Android. Para mais detalhes sobre essa biblioteca, consulte a
documentação no site (https://developer.android.com/kotlin/ktx).

O aplicativo de livros já é capaz de listar, inserir, alterar e excluir livros
cadastrados. Acesse o Firebase console e você poderá visualizar os dados
inseridos na aplicação.

Cloud Storage



O Cloud Storage do Firebase é um serviço simples e poderoso para
armazenamento de arquivos. Ele realiza operações de download e upload de
forma robusta e independente da qualidade da rede. É totalmente integrado
com o sistema de autenticação do Firebase, o que garante segurança no
acesso aos arquivos armazenados. Isso sem contar a alta escalabilidade que é
comum aos serviços do Firebase.

Configurando o Storage
O aplicativo de livros utilizará o Cloud Storage para armazenar a imagem de
capa do livro. Para isso, primeiramente deve-se habilitar esse serviço no
Firebase Console na opção Develop > Storage. Será exibida a tela da Figura
21.10.

Figura 21.10 – Cloud Storage no Firebase Console.
Clique no botão Get started e será exibida uma janela informando que, por

padrão, apenas usuários autenticados podem ler, modificar ou excluir os
arquivos armazenados. Clique em Got it para fechar essa janela e certifique-
se de que as regras descritas na aba Rules estão como a seguir:
service firebase.storage {



  match /b/{bucket}/o {
    match /{allPaths=**} {
      allow read, write: if request.auth != null;
    }
  }
}

Se precisar deixar a leitura e escrita de arquivos pública, basta modificar a
seguinte linha na configuração:
allow read, write;

Lembrando que por motivos de segurança essa prática não é recomendada
para aplicações reais, mas pode ser úteis para testes rápidos.

Fazendo o upload da capa do livro
Feitas as configurações no Firebase Console, será implementada a lógica para
fazer o upload da imagem da capa do livro e mostrá-la nas telas.

Adicione a dependência da biblioteca do Cloud Storage no build.gradle do
módulo:
dependencies { ...
    implementation "com.google.firebase:firebase-storage:$firebase_storage_version"
}

Declare a constante firebase_storage_version = '16.0.5' para versão no build.gradle
do projeto. Aplique as mudanças para baixar a dependência.

A implementação do upload da capa do livro começará pela tela de edição.
Adicione uma ImageView que, ao ser clicada, abrirá a câmera do aparelho para
capturar uma foto e enviá-la para o Cloud Storage.

Abra o arquivo res/layout/book_form_content.xml e faça a seguinte
mudança:
<layout ...>
    <data ...> ... </data>
    <LinearLayout ...>
        <ImageView
            android:id="@+id/imgCoverPhoto"
            android:layout_width="144dp"
            android:layout_height="144dp"
            android:background="@android:color/darker_gray"
            android:onClick="@{view::clickTakePhoto}"
            android:scaleType="centerInside"
            app:imageUrl="@{book.coverUrl}" />
                ...



Foi adicionada apenas a ImageView cuja propriedade app:imageUrl está usando o
data binding para carregar a imagem baseada na propriedade coverUrl do objeto
book. No evento de clique, o método clickTakePhoto(View) da BookFormActivity será
chamado.

Agora faça os seguintes ajustes na classe FbRepository para realizar o upload
da capa do livro:
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import com.google.android.gms.tasks.Task
import com.google.firebase.storage.FirebaseStorage
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileOutputStream
 
class FbRepository {
    private val storageRef = FirebaseStorage.getInstance().reference.child(BOOKS_KEY)
    ...
    fun saveBook(book: Book): LiveData<Boolean> {
        return object : LiveData<Boolean>() {
            override fun onActive() {
                super.onActive()
                if (currentUser == null) {
                    throw SecurityException("Invalid user")
                }
                val db = firestore
                val collection = db.collection(BOOKS_KEY)
                val saveTask = if (book.id.isBlank()) {
                    book.userId = currentUser.uid
                    collection.add(book) .continueWith { task ->
                        if (task.isSuccessful) {
                            book.id = task.result?.id ?: ""
                        }
                    }
                } else {
                    collection.document(book.id).set(book)
                }
                saveTask.addOnSuccessListener {
                    if (book.coverUrl.startsWith("file://")) {
                        uploadFile()
                    } else {
                        value = true
                    }



                }.addOnFailureListener {
                    value = false
                }
            }
            fun uploadFile() {
                uploadPhoto(book).continueWithTask { urlTask ->
                    File(book.coverUrl).delete()
                    book.coverUrl = urlTask.result.toString()
                    firestore.collection(BOOKS_KEY)
                            .document(book.id)
                            .update(COVER_URL_KEY, book.coverUrl)
                }.addOnCompleteListener { task ->
                    value = task.isSuccessful
                }
            }
        }
    }
    private fun uploadPhoto(book: Book): Task<Uri> {
        compressPhoto(book.coverUrl)
        val storageRef = storageRef.child(book.id)
        return storageRef.putFile(Uri.parse(book.coverUrl))
                .continueWithTask { uploadTask ->
                    uploadTask.result?.storage?.downloadUrl
                }
    }
    private fun compressPhoto(path: String) {
        val imgFile = File(path.substringAfter("file://"))
        val bos = ByteArrayOutputStream()
        val bmp = BitmapFactory.decodeFile(imgFile.absolutePath)
        bmp.compress(Bitmap.CompressFormat.JPEG, 70, bos)
        val fos = FileOutputStream(imgFile)
        fos.write(bos.toByteArray())
        fos.flush()
        fos.close()
    }
}

Foi definido um atributo storageRef do tipo StorageReference que é inicializado no
começo da classe e que permite fazer o upload de arquivos para o Cloud
Storage.

Anteriormente, era preciso apenas saber se o livro tinha sido salvo no
Firestore, mas agora, além de salvar o livro, é necessário fazer o upload da
capa. Por essa razão, após salvar o livro está sendo checado se a propriedade
coverUrl do objeto Book começa com “file://”, nesse caso, o livro está apontando



para uma imagem local e é necessário fazer o upload. Caso contrário, a
imagem de capa já foi enviada ou não foi definida.

O método uploadPhoto(Book) retorna uma Task<Uri> contendo a URL da imagem
armazenada no Firebase. Antes de realizar o upload, o método compressPhoto() é
chamado para comprimir a imagem e ficar com um arquivo de imagem
menor. Aqui foi feito algo bem simples, mas este seria um bom momento
para aplicar algum algoritmo mais eficiente de compressão e
redimensionamento de imagem.

O atributo storageRef aponta para a “pasta” books na raiz do Firebase Storage.
Então um nó-filho é criado utilizando o método child(String) e que está sendo
nomeado com o mesmo id do livro. Ao chamar o método putFile(Uri) o upload
do arquivo é iniciado. Após realizar o upload, é preciso gerar uma URL para
a imagem, por isso, foi utilizado uploadTask.result.storage.downloadUrl na chamada
continueWithTask(Continuation).

Caso o upload e a geração da URL tenham sido concluídos com êxito, o
arquivo temporário de imagem é excluído localmente, o atributo coverUrl do
livro é atualizado no firestore para usar a URL recém-gerada.

No BookFormViewModel a mudança será bem simples:
class BookFormViewModel : ViewModel() {
    var tempImageFile: File? = null
    ...
    fun deleteTempPhoto() {
        tempImageFile?.let {
            if (it.exists()) it.delete()
        }
    }
    override fun onCleared() {
        super.onCleared()
        deleteTempPhoto()
    }
}

O método deleteTempPhoto(), como o próprio nome diz, será usado para apagar
o arquivo de imagem temporária. Isso acontecerá sempre antes de o usuário
escolher tirar uma nova foto e quando o BookFormViewModel for desalocado no
método onCleared().

Implemente agora as mudanças na BookFormActivity:
import android.app.Activity
import android.os.Environment



import android.provider.MediaStore
import android.text.format.DateFormat
import androidx.core.content.FileProvider
import java.io.File
import java.util.*
 
class BookFormActivity : BaseActivity() {
    ...
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (resultCode == Activity.RESULT_OK && requestCode == RC_CAMERA) {
            binding.content.book?.coverUrl =
                "file://${viewModel.tempImageFile?.absolutePath}"
        }
    }
    fun clickTakePhoto(view: View) {
        val takePictureIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
        if (takePictureIntent.resolveActivity(packageManager) != null) {
            viewModel.deleteTempPhoto()
            val fileName = DateFormat.format("ddMMyyy_hhmmss", Date()).toString()
            val file = File(getExternalFilesDir(Environment.DIRECTORY_PICTURES), "$fileName.jpg")
            val photoUri = FileProvider.getUriForFile(
                    this,
                    "dominando.android.livros.fileprovider",
                    file)
            viewModel.tempImageFile = file
            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoUri)
            startActivityForResult(takePictureIntent, RC_CAMERA)
        }
    }
    companion object {
        ...
        private const val RC_CAMERA = 1
    }
}

No método clickTakePhoto(View) é chamado a partir da instrução
android:onClick="@{view::clickTakePhoto}" do ImageView declarado no arquivo de
layout. Nesse método está sendo criada uma nova Intent com a ação
ACTION_IMAGE_CAPTURE para abrir a câmera e tirar a foto da capa do livro. Em
seguida, é verificado se essa Intent pode ser tratada utilizando o método
resolveActivity(PackageManager). Em caso positivo, caso haja uma imagem
temporária anterior, ela é apagada utilizando o método deleteTempPhoto() do
viewModel. Feito isso, um novo arquivo é criado utilizando a data atual do



aparelho, visando a diminuir a possibilidade de haver um arquivo com esse
mesmo nome. Esse arquivo é armazenado temporariamente no diretório
/Android/data/files/dominando.android.livros/Pictures no aparelho e é
passado como parâmetro da Intent para que o aplicativo de câmera saiba onde
salvar a imagem capturada.

Até o Android Marshmallow era possível passar o caminho da imagem e a
câmera conseguiria salvar a imagem desde que a permissão
WRITE_EXTERNAL_STORAGE estivesse declarada no AndroidManifest.xml.
Entretanto, por questões de segurança, a partir do Android 7 (API Level 24),
é preciso utilizar um ContentProvider para compartilhar os arquivos com outros
aplicativos, informando explicitamente os diretórios que são acessíveis por
outros aplicativos. Esse trabalho é um pouco facilitado pela classe FileProvider,
pois ela gerará a Uri correta para o arquivo que estamos criando. Para isso,
devemos declarar esse provider no AndroidManifest.xml:
<manifest ...>
    <application ...> ...
        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="dominando.android.livros.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>

Foi declarado o provider passando a classe FileProvider, a authorities que deve
ser a mesma indicada no método clickTakePhoto(View) e a propriedade
android:grantUriPermissions que dará acesso único ao conteúdo do provider. Na tag
<meta-data> é referenciado o arquivo que contém diretórios que esse provider
dará acesso. Crie o arquivo res/xml/file_paths.xml e deixe-o como a seguir:
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="book_images" path="Android/data/dominando.android.livros/files/Pictures"

/>
</paths>

Perceba que foi utilizado o <external-path> porque está sendo utilizada a
memória externa do aparelho. Porém, é possível utilizar:

• <files-path> para Context.getFilesDir();
• <cache-path> para Context.getCacheDir();



• <external-path> para Context.getExternalStorageDirectory();
• <external-files-path> para Context.getExternalFilesDir(String);
• <external-cache-path> para Context.getExternalCacheDir().
Voltando à explicação da BookFormActivity. Ao receber a imagem vinda da

câmera, o método onActivityResult(int,int,Intent) é chamado. Então o atributo coverUrl
do livro é atualizado para o caminho da imagem selecionada.

Execute a aplicação e já deve ser possível fazer o upload dos arquivos como
mostra a Figura 21.11.

Figura 21.11 – Tela de edição com a imagem da capa do livro.
Acesse o Firebase Console e na seção Develop > Storage você poderá

visualizar os arquivos que foram enviados pela nossa aplicação.

Excluindo a capa do livro
O último detalhe que é preciso acertar na aplicação é excluir o arquivo de
capa ao excluir o livro. Vá até a classe FbRepository e faça as seguintes
mudanças:
class FbRepository {
    ...



    fun remove(book: Book): LiveData<Boolean> {
        return object : LiveData<Boolean>() {
            override fun onActive() {
                super.onActive()
                val db = firestore
                db.collection(BOOKS_KEY)
                        .document(book.id)
                        .delete()
                        .continueWithTask { task ->
                            if (task.isSuccessful)
                                storageRef.child(book.id).delete()
                            else
                                throw Exception(task.exception)
                        }
                        .addOnCompleteListener {
                            value = it.isSuccessful
                        }
            }
        }
    }
}

Com a referência para a “pasta” raiz que foi nomeada como “books”
(constante BOOKS_KEY) e após excluir o registro no firestore, a referência para
a imagem específica é obtida com o método child(String), e, em seguida, o
método delete() é chamado para excluir o arquivo.

Crashlytics
Ao publicar um aplicativo na loja, qualquer pessoa ao redor do mundo pode
baixá-lo no seu aparelho. Entretanto, caso um erro aconteça na aplicação,
como saber o que aconteceu?

O Firebase Crashlytics é uma ferramenta de relatório de erros que ajuda a
monitorar, priorizar e corrigir problemas no seu aplicativo. Com o
Crashlytics é possível visualizar o stack trace do erro ocorrido facilitando
assim a análise do problema e, consequentemente, diminuindo o tempo para a
correção.

Para habilitar o Crashlytics acesse a opção Quality > Crashlytics no
Firebase Console e será exibida a tela da Figura 21.12.

Como essa é uma aplicação nova, selecione a primeira opção. Então será
exibido o botão Go to Crashlytics Docs que fornece as informações de como



adicionar a biblioteca no nosso projeto. Clique nesse botão e serão exibidas
informações similares ao que será mostrado logo a seguir.

Utilizar o Crashlytics na aplicação não requer nenhuma linha de código.
Bastam algumas modificações nos scripts de compilação e a aplicação estará
pronta para reportar os erros no console do Firebase automaticamente.

Figura 21.12 – Crashlytics no Firebase Console.
Faça as seguintes alterações no build.gradle do projeto:

buildscript {
    ext { ...
        fabric_version = '1.25.4'
        crashlytics_version = '2.9.9'
    }
    repositories { ...
        maven {
           url 'https://maven.fabric.io/public'
        }
    }
    dependencies { ...
        classpath "io.fabric.tools:gradle:$fabric_version"
    }
}



allprojects { ...
    repositories { ...
       maven {
           url 'https://maven.google.com/'
       }
    }
}

Agora aplique o plugin e adicione as dependências no build.gradle do
módulo app:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'
apply plugin: 'io.fabric'
 
dependencies { ...
    implementation "com.google.firebase:firebase-core:$firebase_core_version" // essa já foi adicionada
    implementation "com.crashlytics.sdk.android:crashlytics:$crashlytics_version"
}

Faça a sincronização para baixar as dependências e execute a aplicação.
Aguarde alguns instantes para que o Crashlytics seja ativado no seu projeto.
Quando isso ocorrer será exibida a tela da Figura 21.13.



Figura 21.13 – Crashlytics habilitado para o projeto.
Ao clicar no botão, será exibido o dashboard do Crashlytics no qual

aparecem os erros ocorridos na aplicação como mostra a Figura 21.14.

Figura 21.14 – Crashlytics dashboard.
Pronto! A partir de agora, se acontecer algum erro na aplicação o relatório

de erro aparecerá no Firebase Console. Para testar se está tudo funcionando
basta simular um erro (ou crash) adicionando o código abaixo em algum
lugar da aplicação:
Crashlytics.getInstance().crash()

Após verificar que a aplicação fechou, remova a linha anterior e execute a
aplicação novamente. Isso fará com que o Crashlytics envie o relatório de
erro. Assim, se tudo correr bem, um relatório de erro deverá aparecer no
dashboard do Crashlytics no Firebase Console em até 5 minutos.

Como foi possível observar neste capítulo, o Firebase fornece uma série de
serviços para auxiliar o desenvolvedor na criação de aplicações. Vimos
apenas alguns dos seus recursos, consulte a documentação do Firebase para
saber mais detalhes sobre os tópicos apresentados aqui e sobre outros
serviços do Firebase.



1 A página do Firebase Console muda com certa frequência, então essas opções podem variar com o
tempo.



CAPÍTULO 22
Contatos e SMS

Com a API de contatos é possível listar as informações de todos os contatos
existentes no aparelho. Essas informações podem ser bastante úteis em vários
cenários. Neste capítulo veremos como listar e adicionar contatos no
aparelho. E em tempos de aplicativos de mensagens instantâneas, o SMS
(Short Message Service) ainda apresenta uma série de benefícios em relação a
outros tipos de tecnologias de troca de mensagens, tais como: a entrega
imediata mesmo sem conexão de dados; funcionamento independente de
plataforma; e a fácil integração com outras tecnologias. Neste capítulo
também será demonstrado como enviar e receber mensagens SMS dentro de
um aplicativo Android.

Content Provider de contatos
A API de contatos consta basicamente de um conjunto de classes que
representam as informações armazenadas no banco de dados da aplicação de
contatos, e que são compartilhadas para os desenvolvedores por meio de um
content provider.

O próximo exemplo listará os contatos cadastrados no aparelho, e ao clicar
em um dos contatos, seus detalhes serão exibidos.

Application Name Contatos
Package Name dominando.android.contatos
Activity Name ContactsActivity

Crie um novo projeto, e a primeira coisa que deve ser feita é adicionar as
permissões de leitura e escrita dos contatos no AndroidManifest.xml:
<uses-permission android:name="android.permission.READ_CONTACTS"/>
<uses-permission android:name="android.permission.WRITE_CONTACTS"/>

Em seguida, defina o arquivo de layout que será usado no adapter da
listagem de contatos. Crie o arquivo res/layout/item_contact.xml e deixe-o



conforme a seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:gravity="center_vertical"
    android:orientation="horizontal">
 
    <QuickContactBadge
        android:id="@+id/qcbPhoto"
        android:layout_width="72dp"
        android:layout_height="72dp"
        android:scaleType="centerCrop" />
    <TextView
        android:id="@+id/txtName"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginEnd="16dp"
        android:layout_marginStart="8dp" />
</LinearLayout>

Foi usado o componente QuickContactBadge que dá acesso rápido às
informações do contato. Implemente a classe ContactAdapter deixando-a como a
seguir:
import android.content.Context
import android.database.Cursor
import android.provider.ContactsContract
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.cursoradapter.widget.CursorAdapter
import com.squareup.picasso.Picasso
import kotlinx.android.synthetic.main.item_contact.view.*
 
class ContactAdapter(context: Context, c: Cursor?) : CursorAdapter(context, c, 0) {
    lateinit var indexes: IntArray
 
    override fun newView(context: Context, cursor: Cursor, parent: ViewGroup): View {
        indexes = intArrayOf(
                cursor.getColumnIndex(ContactsContract.Contacts._ID),
                cursor.getColumnIndex(ContactsContract.Contacts.LOOKUP_KEY),
                cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME)
        )
        return LayoutInflater.from(context)
                .inflate(R.layout.item_contact, parent, false)



    }
    override fun bindView(view: View, context: Context, cursor: Cursor) {
        val txtNome = view.txtName
        val qcbBadge = view.qcbPhoto
        val contactUri = ContactsContract.Contacts.getLookupUri(
                cursor.getLong(indexes[0]),
                cursor.getString(indexes[1]))
        txtNome.text = cursor.getString(indexes[2])
        qcbBadge.assignContactUri(contactUri)
        Picasso.get()
                .load(contactUri)
                .placeholder(R.mipmap.ic_launcher)
                .into(qcbBadge)
    }
}

A classe que herda de CursorAdapter; e no método
newView(Context,Cursor,ViewGroup), além de carregar o arquivo de layout, o
atributo indexes é inicializado com a posição das colunas que serão lidas para
evitar que essa informação tenha que ser obtida sempre no
bindView(View,Context,Cursor). As colunas com os dados básicos do contato estão
na classe ContactsContract.Contacts; aqui são usadas: _ID que é o identificador
único do contato; LOOKUP_KEY, que é um campo que facilita a obtenção de
mais dados sobre o contato; e DISPLAY_NAME, que é o nome do contato.

No bindView(View,Context,Cursor), é criada uma Uri que representa o endereço
único do contato usando o método getLookupUri(long, String), e, em seguida,
atribuímos o resultado ao QuickContactBadge por meio do método
assignContactUri(Uri). Assim, ao clicar nesse componente, mais informações
sobre o contato serão exibidas.

Para preencher a imagem do contato, foi usada a biblioteca Picasso. Então
adicione a dependência no build.gradle:
dependencies { ...
    implementation 'com.squareup.picasso:picasso:2.71828'
}

Para acessar a lista de contatos que é disponibilizada via content provider é
aconselhável usar as classes CursorLoader e o CursorAdapter. Adicione a classe
ContactListFragment e deixe-a como a seguir:
import android.content.Intent
import android.database.Cursor
import android.os.Bundle



import android.provider.ContactsContract
import android.view.View
import android.widget.ListView
import androidx.cursoradapter.widget.CursorAdapter
import androidx.fragment.app.ListFragment
import androidx.loader.app.LoaderManager
import androidx.loader.content.CursorLoader
import androidx.loader.content.Loader
 
class ContactListFragment : ListFragment(), LoaderManager.LoaderCallbacks<Cursor> {
    private var contactAdapter: CursorAdapter? = null
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        retainInstance = true
    }
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        contactAdapter = ContactAdapter(requireContext(), null)
        listAdapter = contactAdapter
        LoaderManager.getInstance(this).initLoader(0, null, this)
    }
    override fun onListItemClick(l: ListView?, v: View?, position: Int, id: Long) {
        super.onListItemClick(l, v, position, id)
        contactAdapter?.cursor?.let { cursor ->
            cursor.moveToPosition(position)
            val contactId = cursor.getLong(
                    cursor.getColumnIndex(ContactsContract.Contacts._ID))
            val lookupKey = cursor.getString(
                    cursor.getColumnIndex(ContactsContract.Contacts.LOOKUP_KEY))
            val contactUri = ContactsContract.Contacts.getLookupUri(contactId, lookupKey)
            val it = Intent(Intent.ACTION_VIEW, contactUri)
            startActivity(it)
        }
    }
    override fun onCreateLoader(id: Int, args: Bundle?): Loader<Cursor> {
        return CursorLoader(
                requireContext(),
                ContactsContract.Contacts.CONTENT_URI,
                COLUMNS,
                ContactsContract.Contacts.HAS_PHONE_NUMBER + " = 1", null,
                ContactsContract.Contacts.DISPLAY_NAME
        )
    }
    override fun onLoadFinished(loader: Loader<Cursor>, data: Cursor) {



        contactAdapter?.swapCursor(data)
    }
    override fun onLoaderReset(loader: Loader<Cursor>) {
        contactAdapter?.swapCursor(null)
    }
 
    companion object {
        private val COLUMNS = arrayOf(
                ContactsContract.Contacts._ID,
                ContactsContract.Contacts.LOOKUP_KEY,
                ContactsContract.Contacts.DISPLAY_NAME
        )
    }
}

Para carregar os dados em background foi utilizada a classe CursorLoader e a
interface LoaderCallbacks para saber quando os dados estão carregados. O array
COLUMNS define os campos que são utilizados na listagem. O ponto
interessante é que estão sendo listados apenas os contatos com número de
telefone. Esse filtro é feito por meio da condição HAS_PHONE_NUMBER igual a
1 no método onCreateLoader(int, Bundle).

No método onListItemClick(ListView, View, int, long), o objeto Cursor usado para
preencher a lista é obtido, move-se a linha do cursor para a posição
selecionada, e então o conteúdo das colunas _ID e LOOKUP_ID é lido. Em
seguida, é criada a Uri que representa esse contato e uma Intent é criada
utilizando essa Uri. Com ela, ao clicar no item da lista, os detalhes do contato
serão exibidos pela aplicação de contatos.

O arquivo de layout dessa activity res/layout/activity_contacts.xml contém
apenas um ConstraintLayout:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/container"
    tools:context=".ContactsActivity">
</androidx.constraintlayout.widget.ConstraintLayout>

O acesso aos contatos necessita do tratamento especial de permissões a
partir do Android Marshmallow. Altere a ContactsActivity para adicionar o
fragment com a listagem dos contatos apenas se o usuário aceitar as



permissões:
import android.Manifest
import android.content.pm.PackageManager
import android.os.Bundle
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
 
class ContactsActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_contacts)
    }
    override fun onResume() {
        super.onResume()
        if (!hasPermission(Manifest.permission.READ_CONTACTS) ||
                !hasPermission(Manifest.permission.WRITE_CONTACTS)) {
            ActivityCompat.requestPermissions(this,
                    arrayOf(
                            Manifest.permission.WRITE_CONTACTS,
                            Manifest.permission.READ_CONTACTS
                    ),
                    RC_PERMISSION_CONTACT)
        } else {
            init()
        }
    }
    private fun hasPermission(permission: String): Boolean {
        return ActivityCompat.checkSelfPermission(this, permission) ==
                PackageManager.PERMISSION_GRANTED
    }
    override fun onRequestPermissionsResult(
            requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
        if (requestCode == RC_PERMISSION_CONTACT && grantResults.isNotEmpty()) {
            if (!grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
                Toast.makeText(this, R.string.error_permission,
                        Toast.LENGTH_SHORT).show()
                finish()
            }
        }
    }
    private fun init() {
        if (supportFragmentManager.findFragmentByTag(TAG_CONTACT_LIST) == null) {
            supportFragmentManager



                    .beginTransaction()
                    .replace(R.id.container, ContactListFragment(), TAG_CONTACT_LIST)
                    .commit()
        }
    }
 
    companion object {
        private const val TAG_CONTACT_LIST = "contacts_fragment"
        private const val RC_PERMISSION_CONTACT = 1
    }
}

No onResume() é checado se a permissão de acesso aos contatos foi
concedida, e, se ainda não foi, ela é solicitada. No método init() é adicionado o
fragment ContactListFragment, se ele ainda não tiver sido adicionado.

Adicione o texto a seguir no res/values/strings.xml.
<string name="error_permission">Você precisa aceitar as permissões.</string>

Ao executar a aplicação, teremos algo similar à Figura 22.1 (após aceitar as
permissões no caso do Android 6). E ao clicar na imagem do contato será
exibido um resumo com as informações do contato similar ao da Figura 22.2.
Ao clicar no item da lista, teremos comportamento semelhante1.

Figura 22.1 – Listagem dos contatos do aparelho.



Figura 22.2 – Informações do contato ao clicar na foto.

Inserindo contatos
Para listar os contatos do aparelho, foi utilizado o content provider, que
também pode ser utilizado para inserir, alterar e até excluir contatos no
aparelho. Entretanto, para isso é preciso a permissão WRITE_CONTACTS no
AndroidManifest.xml.

Desde a versão 2.0 do Android, a agenda de contatos armazena suas
informações em formato mestre/detalhe, em que o registro mestre contém o
id interno do contato, seu nome e sobrenome. Enquanto o detalhe pode
conter: endereço, emails, telefones etc. Os telefones, por sua vez, podem ser:
Mobile, Mobile Work, Home, Work, Fax etc. Como é preciso inserir
informações em tabelas diferentes (internamente no Android), essa operação
tem de ser feita em batch. Crie o objeto ContactUtils e deixe-o como a seguir:
import android.content.ContentProviderOperation
import android.content.Context
import android.content.OperationApplicationException
import android.graphics.Bitmap
import android.os.RemoteException
import android.provider.ContactsContract



import java.io.ByteArrayOutputStream
import java.util.ArrayList
 
object ContactUtils {
    fun insertContact(context: Context, name: String, phoneNumber: String,
                      address: String, photo: Bitmap) {
        // Lista de operações que serão realizadas em batch
        val operation = ArrayList<ContentProviderOperation>()
        // Armazenará o id interno do contato e servirá para inserir os detalhes
        val backRefIndex = 0
        // Associa o contato à conta-padrão do phoneNumber
        operation.add(
                ContentProviderOperation.newInsert(
                    ContactsContract.RawContacts.CONTENT_URI)
                    .withValue(ContactsContract.RawContacts.ACCOUNT_TYPE, null)
                    .withValue(ContactsContract.RawContacts.ACCOUNT_NAME, null)
                    .build())
        // Adiciona o name do contato e alimenta id
        operation.add(
                ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
                    .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, backRefIndex)
                    .withValue(ContactsContract.Data.MIMETYPE,
                    ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE)
                    .withValue(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME,
                    name)
                    .build())
        // Adiciona um endereço ao contato a partir do id
        operation.add(
                ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
                    .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, backRefIndex)
                    .withValue(ContactsContract.Data.MIMETYPE,
                    ContactsContract.CommonDataKinds.StructuredPostal.CONTENT_ITEM_TYPE)
                    .withValue(
                    ContactsContract.CommonDataKinds.StructuredPostal.FORMATTED_ADDRESS,
                                address)
                    .build())
        // Associa um phoneNumber ao contato do tipo "Home"
        operation.add(
                ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
                    .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, backRefIndex)
                    .withValue(ContactsContract.Data.MIMETYPE,
                    ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE)
                    .withValue(ContactsContract.CommonDataKinds.Phone.NUMBER, phoneNumber)
                        .withValue(ContactsContract.CommonDataKinds.Phone.TYPE,
                                ContactsContract.CommonDataKinds.Phone.TYPE_HOME)



                        .build())
        // Adiciona imagem ao contato
        val stream = ByteArrayOutputStream()
        photo.compress(Bitmap.CompressFormat.JPEG, 75, stream)
        operation.add(
                ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
                    .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, backRefIndex)
                    .withValue(ContactsContract.Data.IS_SUPER_PRIMARY, 1)
                    .withValue(ContactsContract.Data.MIMETYPE,
                    ContactsContract.CommonDataKinds.Photo.CONTENT_ITEM_TYPE)
                    .withValue(ContactsContract.CommonDataKinds.Photo.PHOTO,
                                stream.toByteArray())
                        .build())
        // Aplica o batch de inclusão
        try {
            context.contentResolver.applyBatch(
                    ContactsContract.AUTHORITY, operation)
        } catch (e: RemoteException) {
            e.printStackTrace()
        } catch (e: OperationApplicationException) {
            e.printStackTrace()
        }
    }
}

O método está todo comentado, mas basicamente está sendo criada uma
lista de operações que serão efetuadas no Content Provider de contatos. A
primeira operação é associar o contato à conta-padrão do aparelho. Em
seguida, o nome do contato é inserido e seu id é obtido. Isso é necessário,
pois com esse id serão inseridos os demais campos. Em seguida, são
adicionados um endereço, um telefone e a imagem do contato, sendo esta
representada por um array de bytes.

O fragment para cadastrar um novo contato será criado começando pelo
arquivo de layout res/layout/fragment_contact.xml listado a seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="16dp">
    <ImageView
        android:id="@+id/imgPhoto"
        android:layout_width="96dp"
        android:layout_height="96dp"



        android:background="#CCC"
        android:clickable="true"
        android:focusable="true" />
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">
        <EditText
            android:id="@+id/edtName"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/hint_name"
            android:inputType="textPersonName" />
        <EditText
            android:id="@+id/edtAddress"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/hint_address" />
        <EditText
            android:id="@+id/edtPhone"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/hint_phone"
            android:inputType="phone" />
    </LinearLayout>
</LinearLayout>

O arquivo de layout é bem simples e não tem nada que já não tenha sido
visto, então adicione no res/values/strings.xml as strings que foram utilizadas
nesse layout:
<string name="hint_name">Nome</string>
<string name="hint_address">Endereço</string>
<string name="hint_phone">Telefone</string>
<string name="dialog_title">Adicionar contato</string>
<string name="action_new_contact">Novo contato</string>
<string name="button_ok">OK</string>
<string name="button_cancel">Cancelar</string>

Implemente agora a classe ContactFragment deixando-a como a seguir:
import android.app.Activity.RESULT_OK
import android.app.Dialog
import android.content.DialogInterface
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.BitmapFactory



import android.os.Bundle
import android.widget.EditText
import android.widget.ImageView
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.DialogFragment
import java.io.FileNotFoundException
 
class ContactFragment : DialogFragment(), DialogInterface.OnClickListener {
    lateinit var edtName: EditText
    lateinit var edtPhone: EditText
    lateinit var edtAddress: EditText
    lateinit var imgPhoto: ImageView
    private var selectedPhoto: Bitmap? = null
 
    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val view = requireActivity().layoutInflater.inflate(R.layout.fragment_contact, null)
        edtName = view.findViewById(R.id.edtName)
        edtPhone = view.findViewById(R.id.edtPhone)
        edtAddress = view.findViewById(R.id.edtAddress)
        imgPhoto = view.findViewById(R.id.imgPhoto)
        imgPhoto.setOnClickListener {
            selectPhotoFromGallery()
        }
        return AlertDialog.Builder(requireContext())
                .setTitle(R.string.dialog_title)
                .setView(view)
                .setPositiveButton(R.string.button_ok, this)
                .setNegativeButton(R.string.button_cancel, null)
                .create()
    }
    private fun selectPhotoFromGallery() {
        val intent = Intent(Intent.ACTION_PICK)
        intent.type = "image/*"
        startActivityForResult(intent, 0)
    }
    override fun onClick(dialog: DialogInterface, which: Int) {
        val photo = selectedPhoto
        if (edtName.text.isNotEmpty() && edtPhone.text.isNotEmpty() && photo != null) {
            ContactUtils.insertContact(
                    requireContext(),
                    edtName.text.toString(),
                    edtPhone.text.toString(),
                    edtAddress.text.toString(),
                    photo)
        }



    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (resultCode == RESULT_OK && data != null && data.data != null) {
            try {
                val options = BitmapFactory.Options()
                options.inSampleSize = 4
                selectedPhoto = BitmapFactory.decodeStream(
                        requireContext().contentResolver.openInputStream(data.data),
                        null,
                        options
                )
                imgPhoto.setImageBitmap(selectedPhoto)
            } catch (e: FileNotFoundException) {
                e.printStackTrace()
            }
        }
    }
}

Observa-se que essa classe herda de DialogFragment, e no método
onCreateDialog(Bundle) o arquivo de layout é carregado e os componentes de
interface gráfica inicializados. Ao clicar no ImageView, o método onClick(View)
será invocado, e nele abrimos a activity para selecionar uma foto do
dispositivo. Após selecionar a imagem, o método onActivityResult(int,int,Intent) é
invocado. Como normalmente a imagem vinda da câmera possui uma
resolução alta, um redimensionamento é feito nessa imagem para ¼ do seu
tamanho, utilizando o atributo inSampleSize da classe BitmapFactory.Options. Essa é
uma maneira simples de redimensionar a imagem, mas para uma forma mais
eficiente, consulte o método loadImage(File,int,int) da classe MediaUtils no Capítulo
25.

Ao clicar no botão OK do dialog, o método onClick(DialogInterface,int) será
chamado, e nele o contato é inserido utilizando a classe ContactUtils criada
anteriormente.

Esse fragment será chamado a partir de uma opção de menu na
ContactsActivity. Para isso, crie o arquivo res/menu/contacts.xml:
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item android:icon="@android:drawable/ic_menu_add"
        android:id="@+id/action_new_contact"
        android:title="@string/action_new_contact"



        app:showAsAction="always"/>
</menu>

Agora adicione estes dois métodos à ContactsActivity:
override fun onCreateOptionsMenu(menu: Menu?): Boolean {
    menuInflater.inflate(R.menu.contacts, menu)
    return super.onCreateOptionsMenu(menu)
}
override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    if (item?.itemId == R.id.action_new_contact){
        val fragment = ContactFragment()
        fragment.show(supportFragmentManager, "new_contact")
    }
    return super.onOptionsItemSelected(item)
}

Execute a aplicação; ao clicar no botão de adicionar na barra de título, será
exibida a tela da Figura 22.3. Preencha os campos e selecione uma foto para
o contato. Em seguida, clique no botão Ok; o registro será inserido e já será
exibido na tela de listagem.

Para abrir a aplicação de contatos para inserir um novo contato, pode-se
usar o código a seguir na ContactUtils:
fun insertContactWithApp(context: Context,
                         name: String, phone: String, email: String, address: String) {
    context.startActivity(
            Intent(ContactsContract.Intents.Insert.ACTION).apply {
                setType(ContactsContract.RawContacts.CONTENT_TYPE)
                        .putExtra(ContactsContract.Intents.Insert.NAME, name)
                        .putExtra(ContactsContract.Intents.Insert.EMAIL, email)
                        .putExtra(ContactsContract.Intents.Insert.EMAIL_TYPE,
                                ContactsContract.CommonDataKinds.Email.TYPE_WORK)
                        .putExtra(ContactsContract.Intents.Insert.PHONE, phone)
                        .putExtra(ContactsContract.Intents.Insert.PHONE_TYPE,
                                ContactsContract.CommonDataKinds.Phone.TYPE_WORK)
                        .putExtra(ContactsContract.Intents.Insert.POSTAL, address)
            })
}



Figura 22.3 – Contato adicionado programaticamente.
Podemos invocar o método que definimos anteriormente da seguinte forma:

insertContactWithApp(context, "Fulano", "81988990000", "fulano@email.com", "Rua do Bolo")
O resultado ficará conforme a Figura 22.4.



Figura 22.4 – Inserindo um contato via Intent.

Recebendo e enviando mensagens SMS
Para capturar o recebimento de mensagens SMS, a única coisa que é preciso
fazer é declarar um broadcast receiver que detecte essa ação, enquanto para
realizar o envio é utilizada a classe SmsManager.

Application Name SMS
Package Name dominando.android.sms
Activity Name MainActivity

Crie um novo projeto para utilizar esse recurso na prática. Em seguida,
adicione a classe SmsReceiver que interceptará a chegada da mensagem SMS:
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.os.Build
import android.telephony.SmsMessage
import android.widget.Toast
 
class SmsReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, it: Intent) {
        val sms = getMessagesFromIntent(it)[0]



        val phoneAddress = sms?.originatingAddress
        val message = sms?.messageBody
        Toast.makeText(context,
                "Mensagem recebida de $phoneAddress - $message",
                Toast.LENGTH_LONG).show()
    }
    companion object {
        fun getMessagesFromIntent(intent: Intent): Array<SmsMessage?> {
            val pdus = intent.getSerializableExtra("pdus") as Array<*>
            val messages = arrayOfNulls<SmsMessage>(pdus.size)
            for (i in pdus.indices) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    val format = intent.getStringExtra("format")
                    messages[i] = SmsMessage.createFromPdu(pdus[i] as ByteArray, format)
                } else {
                    messages[i] = SmsMessage.createFromPdu(pdus[i] as ByteArray)
                }
            }
            return messages
        }
    } }

Atualmente, as mensagens SMS utilizam o formato PDU (Protocol
Description Unit), que permite a utilização de vários encondings. Por isso, ao
receber as mensagens, deve-se ler a informação extra da intent chamada
“pdus” que é um array de arrays de bytes (byte[][] do Java). O array é percorrido, e
para cada elemento do array, é chamado para o método createFromPdu(byte[]) da
classe SmsMessage que monta a mensagem SMS. Uma vez de posse do objeto
SmsMessage, é possível obter as informações da mensagem como remetente e o
texto da mensagem.

É preciso adicionar a permissão para receber SMS no AndroidManfest.xml
e também declarar a classe SmsReceiver utilizando a ação
android.provider.Telephony.SMS_RECEIVED para que ele seja disparado quando a
mensagem chegar:
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="dominando.android.sms" >
    <uses-permission android:name="android.permission.RECEIVE_SMS"/>
    <uses-permission android:name="android.permission.READ_SMS" />
    <uses-permission android:name="android.permission.SEND_SMS"/>
    <application ... >
       ...
        <receiver android:name="SmsReceiver"



            android:permission="android.permission.BROADCAST_SMS">
            <intent-filter>
                <action android:name="android.provider.Telephony.SMS_RECEIVED"/>
                <category android:name="android.intent.category.DEFAULT"/>
            </intent-filter>
        </receiver>
    </application>
</manifest>

Perceba que também foi adicionada a permissão para enviar SMS
(android.permission.SEND_SMS), pois esse recurso será utilizado logo a seguir.
Entretanto, também é necessário solicitar essa permissão explicitamente para
receber SMS.

Faça as seguintes mudanças na MainActivity:
import android.Manifest
import android.content.pm.PackageManager
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val permissions = arrayOf(
                Manifest.permission.READ_SMS,
                Manifest.permission.RECEIVE_SMS
        )
        val hasPermissions = permissions.all {
            ContextCompat.checkSelfPermission(this, it) == PackageManager.PERMISSION_GRANTED
        }
        if (!hasPermissions) {
            ActivityCompat.requestPermissions(this, permissions, 0)
        }
    }
}

Feito isso, execute a aplicação em um aparelho real e envie um SMS para
ele. Quando a mensagem for recebida, um Toast deve ser exibido. Também é
possível testar o recebimento de SMS no emulador clicando nos “...” e
selecionando a opção Phone como mostra a Figura 22.5. Em seguida, é só
digitar a mensagem e clicar no botão Send Message.



Figura 22.5 – Emulando o envio de SMS para o emulador.
O envio da mensagem também é bem simples. Adicione no arquivo de

res/layout/activity_main.xml duas caixas de texto para o número do telefone
de destino e o conteúdo da mensagem respectivamente, e um botão para
enviar o SMS:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    android:orientation="vertical"
    tools:context=".MainActivity">
    <EditText
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Digite o número do telefone"
        android:inputType="phone"
        android:id="@+id/edtPhoneNumber" />
    <EditText



        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Digite sua mensagem aqui"
        android:maxLength="160"
        android:id="@+id/edtMessage" />
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Enviar"
        android:id="@+id/btnSend"
        android:onClick="sendSmsClick"/>
</LinearLayout>

Sem muito mistério nesse arquivo de layout, faça os seguintes ajustes na
MainActivity:
import android.Manifest
import android.app.Activity
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.os.Bundle
import android.telephony.SmsManager
import android.telephony.TelephonyManager
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    private var smsSenderBroadcast: SmsSenderBroadcast? = null
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val tm = getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager
        if (tm.phoneType == TelephonyManager.PHONE_TYPE_NONE) {
            Toast.makeText(this, "Dispositivo não suporta SMS",
                    Toast.LENGTH_SHORT).show()
            finish()
            return
        }



    }
    override fun onResume() {
        super.onResume()
        val permissions = arrayOf(
                Manifest.permission.READ_SMS,
                Manifest.permission.RECEIVE_SMS,
                Manifest.permission.SEND_SMS
        )
        val hasPermissions = permissions.all {
            ActivityCompat.checkSelfPermission(this, it) == PackageManager.PERMISSION_GRANTED
        }
        if (!hasPermissions) {
            ActivityCompat.requestPermissions(this, permissions, REQUEST_SMS)
        }
        smsSenderBroadcast = SmsSenderBroadcast()
        registerReceiver(smsSenderBroadcast, IntentFilter(ACTION_SENT))
        registerReceiver(smsSenderBroadcast, IntentFilter(ACTION_DELIVERED))
    }
    override fun onPause() {
        super.onPause()
        if (smsSenderBroadcast != null) {
            unregisterReceiver(smsSenderBroadcast)
        }
    }
    override fun onRequestPermissionsResult(
            requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
        if (!grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
            Toast.makeText(this, "Você necessita aceitar as permissões.",
                    Toast.LENGTH_SHORT).show()
            finish()
        }
    }
    fun sendSmsClick(v: View) {
        val pitSent = PendingIntent.getBroadcast(
                this, 0, Intent(ACTION_SENT), 0)
        val pitDelivered = PendingIntent.getBroadcast(
                this, 0, Intent(ACTION_DELIVERED), 0)
        val smsManager = SmsManager.getDefault()
        smsManager.sendTextMessage(
                edtPhoneNumber.text.toString(), null,
                edtMessage.text.toString(),
                pitSent,
                pitDelivered)
    }
    class SmsSenderBroadcast : BroadcastReceiver() {



        override fun onReceive(context: Context, intent: Intent) {
            var message: String? = null
            val action = intent.action
            val result = resultCode
            if (result == Activity.RESULT_OK) {
                if (ACTION_SENT == action) {
                    message = "Enviado com sucesso."
                } else if (ACTION_DELIVERED == action) {
                    message = "Entregue com sucesso."
                }
            } else {
                if (ACTION_SENT == action) {
                    message = "Falha ao enviar: $result"
                } else if (ACTION_DELIVERED == action) {
                    message = "Falhar ao entregar: $result"
                }
            }
            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
        }
    }
 
    companion object {
        private const val REQUEST_SMS = 1
        private const val ACTION_SENT = "sms_enviado"
        private const val ACTION_DELIVERED = "sms_entregue"
    }
}

A lógica principal da aplicação concentra-se no método sendSmsClick(View).
Com a instância da classe SmsManager, o envio da mensagem é feito por meio
do método sendTextMessage(String,String,String,PendingIntent,PendingIntent). O primeiro e
o terceiro parâmetros desse método representam, respectivamente, o número
de telefone de destino e o texto da mensagem.

Nos dois últimos parâmetros pode-se passar um objeto PendingIntent para,
respectivamente, saber quando a mensagem foi enviada e quando ela foi
recebida pelo destinatário. Elas podem ser nulas, mas foram adicionadas aqui
para exemplificar o uso. As ações ACTION_SENT e ACTION_DELIVERED foram
declaradas para registrar o broadcast receiver SmsSenderBroadcast no onResume() e
o desregistrar no onPause().

No broadcast receiver é checado primeiramente se a ação foi bem-sucedida
usando a propriedade resultCode, que pode assumir os seguintes valores:

• Activity.RESULT_OK – ação executada com sucesso;



• SmsManager.RESULT_ERROR_GENERIC_FAILURE – erro genérico no envio da
mensagem;

• SmsManager.RESULT_ERROR_RADIO_OFF – sem sinal da rede de telefonia;
• SmsManager.RESULT_ERROR_NULL_PDU – mensagem vazia.
Logo em seguida é checado qual foi a ação disparada (envio ou entrega).
Faltou apenas explicar o segundo parâmetro do método sendTextMessage(String,

String,String,PendingIntent,PendingIntent), que serve para indicar o caminho de um
servidor para encaminhar o SMS. Esse parâmetro é muito útil para testes,
pois algumas operadoras cobram pelo envio excedente de mensagens de
texto. Então você pode definir um servidor que interceptará a mensagem e a
encaminhará para o destino sem necessariamente utilizar a operadora de
telefonia.

SMS API a partir do Kit Kat (4.4)
A API de SMS contém um content provider que era acessível para todas as
aplicações, precisando apenas que elas declarassem as permissões necessárias
no AndroidManifest.xml. Entretanto, a partir do Android 4.4 Kit Kat (API
Level 19), esses dados estão disponíveis apenas para leitura. Dessa forma, se
uma aplicação (que não a padrão do S.O.) tentar inserir, alterar ou excluir
dados desse provider, ela falhará sem disparar nenhuma exceção.

A grande vantagem dessa abordagem é garantir ao usuário final que
nenhum SMS deixará de ser entregue por ter sido bloqueado por outra
aplicação. Isso traz mais segurança e confiabilidade ao sistema.

Caso precise desenvolver um aplicativo de envio e recebimento de SMS,
isso ainda é possível. Basta seguir algumas etapas descritas na documentação
do Android (http://android-developers.blogspot.com.br/2013/10/getting-
your-sms-apps-ready-for-kitkat.html).

Como foi possível notar neste capítulo, o envio e o recebimento de
mensagens de texto são bem simples e requerem poucos passos. No próximo
capítulo falaremos sobre comunicação via Bluetooth.

1 Em versões anteriores ao Lollipop, o comportamento é um pouco diferente.



CAPÍTULO 23
Bluetooth

Desde a versão 2.0 (Eclair, API Level 5) a plataforma Android disponibiliza
o acesso à API de Bluetooth que fornece acesso a toda a pilha de protocolos,
permite realizar a busca por dispositivos disponíveis na área de alcance,
estabelecer a conexão e, por fim, trocar informações entre eles. Neste capítulo
serão abordadas as principais classes da Bluetooth API, será explicado o
processo de conexão entre os aparelhos e, por fim, os conceitos apresentados
serão aplicados no desenvolvimento de uma aplicação de bate-papo onde dois
aparelhos trocarão mensagens entre si via Bluetooth.

Bluetooth API
A tecnologia Bluetooth é requisito obrigatório em aparelhos Android a partir
da versão 2.0, e desde então os desenvolvedores podem aproveitar esse
recurso utilizando a Bluetooth API disponível no pacote android.bluetooth. As
principais classes desse pacote são: BluetoothAdapter, BluetoothDevice,
BluetoothServerSocket e BluetoothSocket.

A classe BluetoothAdapter representa o adaptador Bluetooth e serve como o
ponto de partida para realizar todo o processo de conexão. Com ele, é
possível realizar a busca por aparelhos, obter a referência para os dispositivos
próximos e aguardar conexões de outros aparelhos.

O dispositivo Bluetooth é representado pela classe BluetoothDevice, que
permite obter informações do aparelho, tais como: o tipo do dispositivo
(smartphone, computador, fone de ouvido etc.), seu nome amigável (friendly
name) e o endereço físico (MAC address).

A conexão é estabelecida utilizando as classes BluetoothServerSocket e
BluetoothSocket. Elas funcionam de forma semelhante ao java.net.ServerSocket e
java.net.Socket. A primeira abre uma conexão e aguarda conexões cliente.
Quando essa conexão é estabelecida, uma instância de BluetoothSocket é



retornada, e, a partir dessa instância, é possível obter os objetos InputStream e
OutputStream para ler e escrever informações pela rede.

Permissões
Para utilizar os recursos de Bluetooth do aparelho, a aplicação precisa ter as
permissões android.permission.BLUETOOTH e android.permission.BLUETOOTH_ADMIN. A
primeira é necessária para utilizar qualquer recurso Bluetooth, e a segunda é
requerida para permitir ativar o Bluetooth do aparelho, caso esteja desligado,
e para realizar a busca por dispositivos:
<uses-permission android:name="android.permission.BLUETOOTH"/>
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/>

Segundo a documentação do Android, essas permissões são de baixo risco,
então não precisam ser solicitadas em tempo de execução.

Ativando o Bluetooth
Para utilizar qualquer recurso Bluetooth, é preciso da instância da classe
BluetoothAdapter, que pode ser obtida invocando o método getDefaultAdapter(); caso
esse método retorne null, quer dizer que o aparelho não tem suporte a
Bluetooth:
val btAdapter = BluetoothAdapter.getDefaultAdapter()
if (btAdapter == null) {
   // Aparelho não suporta Bluetooth
}

Depois de obter a instância do adaptador, é necessário checar se o aparelho
está com o Bluetooth ativado. Deixar o Bluetooth do aparelho ligado
consome mais bateria; sendo assim, é interessante mantê-lo desligado e ativá-
lo apenas quando necessário. Podemos checar se o Bluetooth está ativo e,
caso não esteja, solicitar ao usuário que o ative:
if (!btAdapter.isEnabled) {
    val it = Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE)
    startActivityForResult(it, BT_ACTIVATE)
}

A solicitação para que o usuário ative o Bluetooth é feita via Intent com a
ação ACTION_REQUEST_ENABLE definida na classe BluetoothAdapter. Quando essa
Intent é disparada, o Android exibe a mensagem apresentada na Figura 23.1.

Note que a requisição é feita invocando o método startActivityForResult(Intent,int),



que recebe como argumento, além do objeto Intent, um inteiro que representa o
código de requisição. O resultado dessa requisição é tratado no método
onActivityResult (int,int,Intent), por meio do qual é checado se o código de
requisição foi BT_ACTIVATE; em caso positivo, é verificado se o usuário
confirmou a ativação por meio do parâmetro resultCode, que deve ser igual a
RESULT_OK.

Figura 23.1 – Solicitando permissão para ativar o Bluetooth.
Com essa informação, pode-se tomar a decisão de continuar com o fluxo

normal da aplicação, ou encerrá-la caso o recurso de Bluetooth seja essencial:
override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    super.onActivityResult(requestCode, resultCode, data)
    if (BT_ACTIVATE == requestCode) {
        if (RESULT_OK == resultCode) {
            // Usuário confirmou a ativação do Bluetooth
        } else {
            // Usuário recusou a ativação do Bluetooth
        }
    }
}

Processo de conexão



No processo de conexão Bluetooth, é preciso inicialmente definir quem será
o “servidor” e quem será o “cliente”. O servidor disponibilizará um serviço
que é composto de um nome e um identificador (falaremos sobre isso mais
adiante) e ficará aguardando as conexões. Para que um cliente possa se
conectar ao servidor, ele deverá realizar uma busca por aparelhos em sua área
de alcance para obter informações como o endereço físico (Mac Address) e o
nome amigável (friendly name). Durante esse processo, todo tipo de
dispositivo pode ser encontrado (como fones de ouvido, laptops e mouses).
Sendo assim, é preciso saber qual dispositivo tem o serviço desejado, para
então conectar-se a ele. Esse processo é ilustrado na Figura 23.2.

Figura 23.2 – Processo de conexão entre dispositivos Bluetooth.

Servidor
Para disponibilizar um serviço de modo que os clientes possam se conectar, é
preciso deixar o aparelho visível, ou seja, ele deve poder ser descoberto por
outros aparelhos que estejam no seu raio de alcance. Dessa forma, quando for
feita a busca, ele passará algumas informações como endereço físico, tipo e
nome amigável.

Entretanto, os dispositivos Android não ficam visíveis por padrão. Essa
opção deve ser habilitada no menu de configurações do aparelho ou
programaticamente como a seguir:



val discoverableIntent = Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE)
discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 120)
startActivityForResult(discoverableIntent, BT_VISIBILITY)

Semelhante ao que foi feito para ativar o Bluetooth do aparelho, para tornar
o dispositivo visível é utilizada uma Intent que é disparada com a ação
ACTION_REQUEST_DISCOVERABLE definida na classe BluetoothAdapter. A diferença
é que o tempo que o aparelho deve ficar visível é passado como parâmetro,
que nesse exemplo foi de 120 segundos. Quando essa requisição for recebida,
será exibida uma mensagem similar à Figura 23.3, pedindo a confirmação do
usuário.

Figura 23.3 – Solicitando permissão para tornar o dispositivo visível.
Como foi explicado anteriormente, para saber se o usuário confirmou ou

não essa mensagem, deve-se utilizar o método onActivityResult(int,int,Intent), só que
dessa vez verificando se o requestCode é igual a BT_VISIBILITY e o resultCode igual
ao tempo requisitado. Com isso, o servidor poderá ser encontrado pelos
clientes quando eles iniciarem o processo de busca.

Para disponibilizar um serviço de modo a aguardar por conexões dos
clientes, o servidor deverá iniciar uma nova Thread que inicializará um objeto
BluetoothServerSocket por meio do método listenUsingRfcommWithServiceRecord(String,



UUID) do objeto BluetoothAdapter. Os argumentos desse método são: uma string,
que representa o nome do serviço; e o identificador do serviço, representado
por um objeto da classe java.util.UUID (Universally Unique Identifier). Esse
identificador é um número hexadecimal de 128 bits, que, segundo a própria
documentação, “é grande o suficiente para você poder escolher qualquer
número aleatório”. Existem alguns geradores de UUID na internet que podem
ser utilizados para gerar o UUID do serviço.

A instância de BluetoothServerSocket fica aguardando as conexões cliente ao
chamar o método accept(). Esse é um blocker method, ou seja, a thread em que
esse método estiver sendo executado ficará parada até que uma conexão
cliente seja estabelecida. Por isso esse processo deve ser realizado em uma
thread separada, para que apenas ela fique parada, enquanto as demais
continuem funcionando normalmente. A seguir temos um exemplo de como
disponibilizar uma conexão servidora e aguardar as conexões cliente:
val MY_SERVICE_UUID = UUID.fromString("db12d1e9-caba-84ef-398b-12011984abcd")
val serverSocket = btAdapter.listenUsingRfcommWithServiceRecord("Meu_Servico",

MY_SERVICE_UUID)
val clientSocket = serverSocket.accept()
handleSocketConnection(clientSocket)

Uma vez que a conexão é estabelecida, é preciso abrir os fluxos de entrada
e saída para poder enviar e receber informações. Nesse exemplo, o método
handleSocketConnection(BluetoothSocket) realizaria essa tarefa recebendo o objeto
BluetoothSocket como parâmetro, a partir do qual é possível abrir o InputStream e o
OutputStream. Esse método será implementado mais adiante, mas, antes, será
explicado como estabelecer a conexão do lado cliente.

Cliente
Para se conectar a um outro aparelho, é necessário realizar uma busca por
dispositivos, também conhecida como inquiry, discovery ou scan. Esse
procedimento busca dispositivos ativos e visíveis na área de alcance do
aparelho (que normalmente é de aproximadamente dez metros) e retorna a
referência para os dispositivos encontrados em instâncias da classe
BluetoothDevice.

Para iniciar o processo de busca, deve-se utilizar o método startDiscovery() do
objeto BluetoothAdapter. Ele é um método assíncrono, ou seja, ele inicia o
processo de busca, e a execução do programa continua. Quando um aparelho



é descoberto, o Android envia uma mensagem de broadcast com a ação
BluetoothDevice.ACTION_FOUND contendo a referência do dispositivo encontrado.
Para capturar essa mensagem, deve-se utilizar uma classe que herde de
BroadcastReceiver e registrá-la para que o Android possa notificá-la quando essa
ação ocorrer (isso será visto logo em seguida). Além disso, é importante
saber quando a busca por aparelhos for concluída para exibir os dispositivos
encontrados, de modo que o usuário possa escolher a qual aparelho ele deseja
se conectar. Sendo assim, o receiver também deverá tratar a ação
BluetoothAdapter.ACTION_DISCOVERY_FINISHED:
private class BtEventsReceiver: BroadcastReceiver() {
    override fun onReceive(context: Context?, intent: Intent?) {
        if (BluetoothDevice.ACTION_FOUND == intent?.action) {
            val device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE) as?

BluetoothDevice
            remoteDevices.add(device)
        } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED == intent?.action) {
            // Busca concluída
        }
    }
}

Perceba que o dispositivo encontrado é armazenado em uma lista chamada
remoteDevices. Isso é necessário para que seja possível escolher o aparelho para
estabelecer a conexão. Note ainda que o broadcast receiver é privado, pois, se
ele for criado em um arquivo separado e registrado no AndroidManifest.xml,
ficará ativo mesmo quando a aplicação não estiver executando. Sendo assim,
ele deve ser registrado na activity que iniciará o processo de conexão
bluetooth. O código a seguir mostra como é feito o registro do receiver para
tratar os eventos de Bluetooth necessários:
val btEventsReceiver = BtEventsReceiver()
val filter1 = IntentFilter(BluetoothDevice.ACTION_FOUND)
val filter2 = IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)
registerReceiver(btEventsReceiver, filter1)
registerReceiver(btEventsReceiver, filter2)

Para registrar o receiver, foram criados dois objetos da classe IntentFilter
passando as ações do processo de busca que se deseja tratar com o broadcast
receiver. Em seguida, o método registerReceiver(BroadcastReceiver,IntentFilter) é
chamado.

Antes de encerrar a aplicação, deve-se desregistrar o receiver para evitar



que ele fique ativo depois do término da aplicação. Isso pode ser feito na
activity invocando o método unregisterReceiver(BroadcastReceiver) passando o objeto
btEventsReceiver.

Uma vez que a busca de dispositivos for concluída, deve-se escolher o
aparelho para realizar a conexão. Durante o processo de descoberta, os
aparelhos encontrados estão sendo armazenados na lista remoteDevices como
instâncias de BluetoothDevice. Será utilizado um desses objetos para estabelecer
a conexão com o servidor:
val MY_SERVICE_UUID = UUID.fromString("db12d1e9-caba-84ef-398b-12011984abcd")
val device = remoteDevices[position]
val socket = device.createRfcommSocketToServiceRecord(MY_SERVICE_UUID)
socket.connect()
handleSocketConnection(socket)

O processo inicia com a criação de um objeto UUID que representa o
endereço do servidor. Em seguida, o dispositivo remoto é obtido a partir da
lista de dispositivos encontrada, que na prática será determinada pela posição
que o usuário selecionar. Por fim, é criado o objeto BluetoothSocket chamando o
método createRfcommSocketToServiceRecord(UUID), que recebe o identificador do
serviço como argumento.

Uma vez que a conexão entre os dois aparelhos é estabelecida, as
informações do dispositivo remoto ficam armazenadas no dispositivo local de
modo que elas possam ser recuperadas posteriormente. Isso é particularmente
útil, pois dessa forma não é preciso realizar a busca por aparelhos que já são
conhecidos. Para obter a lista de aparelhos conhecidos, deve-se utilizar a
propriedade bondedDevices do objeto BluetoothAdapter:
val knownDevices = btAdapter.bondedDevices
if (knownDevices.size > 0) {
    for (device in knownDevices) {
        Log.d("NGVL", "${device.name}\n ${device.address}")
    }
}

Estabelecida a conexão, o método handleSocketConnection(BluetoothSocket), que é
utilizado tanto pela conexão cliente quanto pelo servidor, carregará os objetos
InputStream e OutputStream em uma nova thread que ficará aguardando a chegada
de mensagens que, ao chegarem, devem ser exibidas na tela. Como já foi
explicado no capítulo sobre HTTP, apenas a thread de UI da aplicação pode
realizar esse trabalho. Para atualizar a tela é utilizado um objeto da classe



Handler:
private fun handleSocketConnection(socket: BluetoothSocket) {
    Thread {
        try {
            val inputStream = DataInputStream(socket.inputStream)
            val outputStream = DataOutputStream(socket.outputStream)
            var string = ""
            while (true) {
                string = inputStream.readUTF()
                uiHandler.obtainMessage(MSG_TEXT, string).sendToTarget()
            }
        } catch (e: IOException) {
            Log.e("NGVL", "Erro de comunicação BT", e)
        }
    }.start()
}

A cada nova mensagem recebida, o uiHandler envia uma mensagem para a UI
Thread por meio da chamada obtainMessage(String,String).sendToTarget().

Conhecido o processo de conexão, será demonstrado como aplicá-lo na
prática.

Enviando e recebendo mensagens
A aplicação de exemplo será um bate-papo no qual dois dispositivos poderão
trocar mensagens entre si. Ele é bem similar ao existente nos exemplos do
SDK do Android, mas, de modo a facilitar o entendimento, o deixamos mais
compacto e didático.

Application Name Bluetooth
Package Name dominando.android.bluetooth
Activity Name MainActivity

Crie um novo projeto e, seguindo as orientações explicadas nas seções
anteriores, faça as seguintes mudanças no AndroidManifest.xml:
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="dominando.android.bluetooth" >
    <uses-permission android:name="android.permission.BLUETOOTH"/>
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/>
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <application ... >
        <activity
            android:name=".MainActivity"



            android:configChanges="orientation|keyboardHidden|keyboard|screenSize">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>

Um detalhe que merece ser observado é a propriedade android:configChanges
adicionada à activity para evitar que ela seja destruída ao rotacionar o
aparelho, fazendo com que os objetos da classe sejam desalocados e
recriados. Poderíamos utilizar outras técnicas que vimos ao longo do livro,
mas deixamos dessa forma para deixar o exemplo mais simples.

Começe a implementação do projeto definindo o arquivo Constants.kt que
contém apenas o nome o id do serviço:
import java.util.*
const val SERVICE_NAME = "DominandoChat"
val SERVICE_UUID = UUID.fromString("2accaffd-18dd-43ac-a2c4-623550cf9c8f")

Agora crie a classe BtThreadCommunication que deve ficar como a seguir:
import android.bluetooth.BluetoothSocket
import android.os.Handler
import java.io.DataInputStream
import java.io.DataOutputStream
import java.io.IOException
 
class BtThreadCommunication(private val uiHandler: Handler) {
    private var inputStream: DataInputStream? = null
    private var outputStream: DataOutputStream? = null
 
    fun handleConnection(socket: BluetoothSocket) {
        try {
            uiHandler.obtainMessage(MSG_CONNECTED).sendToTarget()
            val deviceName = socket.remoteDevice?.name
            inputStream = DataInputStream(socket.inputStream)
            outputStream = DataOutputStream(socket.outputStream)
            var string: String?
            while (true) {
                string = inputStream?.readUTF()
                uiHandler.obtainMessage(MSG_TEXT, "$deviceName: $string")?.sendToTarget()
            }
        } catch (e: IOException) {
            e.printStackTrace()



            uiHandler.obtainMessage(MSG_DISCONNECTED, "${e.message} #3")?.sendToTarget()
        }
    }
    fun closeConnection() {
        try {
            inputStream?.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
        try {
            outputStream?.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }
    fun sendMessage(message: String) {
        outputStream?.writeUTF(message)
    }
    companion object {
        const val MSG_TEXT = 0
        const val MSG_CONNECTED = 1
        const val MSG_DISCONNECTED = 2
    }
}

O método handleConnection(BluetoothSocket) é o principal método dessa classe.
Ele será utilizado quando a aplicação for cliente e também quando for
servidora. Ele recebe o objeto BluetoothSocket, e com ele obtém-se o inputStream e
outputStream do tipo DataInputStream e DataOutputStream que são responsáveis pela
leitura e escrita dos dados da conexão. Note que é usado um loop infinito
com um while(true), pois é preciso ficar esperando mensagens infinitamente já
que a chamada inputStream.readUTF() é um block method que deixará a thread
parada até que uma nova mensagem seja recebida. Quando a conexão é
interrompida, esse método gera uma exceção e o loop é interrompido.

Outro detalhe importante dessa classe é o atributo uiHandler, que é o objeto
responsável por enviar mensagens da thread de comunicação para atualizar a
tela. Nesse exemplo, existem três tipos de mensagens: MSG_TEXT quando uma
mensagem é enviada pelo outro dispositivo; MSG_CONNECTED quando a
conexão com o outro dispositivo foi estabelecida; e MSG_DISCONNECTED
quando a conexão com o outro dispositivo foi perdida. Ao chamar o
uiHandler.obtainMessage(int,Object).sendToTarget() a mensagem é enviada para que a



thread de UI seja atualizada.
A próxima classe que deve ser criada é a BtThread que será a superclasse das

threads servidora e cliente. Ela deve ficar da seguinte forma:
import android.bluetooth.BluetoothSocket
import android.os.Handler
 
abstract class BtThread(protected val uiHandler: Handler) : Thread() {
    var socket: BluetoothSocket? = null
    var threadCommunication = BtThreadCommunication(uiHandler)
 
    fun sendMessage(message: String) {
        threadCommunication.sendMessage(message)
    }
    open fun startThread() {
        start()
    }
    open fun stopThread() {
        try {
            threadCommunication.closeConnection()
            socket?.close()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}

Essa classe herda de Thread e está mantendo os conceitos que são comuns
tanto para o servidor quanto para o cliente. Ambos precisarão de um Handler e
da BtThreadCommunication para ficar aguardando mensagens do outro dispositivo.
Independente de ser cliente ou servidor, é possível enviar mensagens, por isso
o método sendMessage(String) está definido aqui, mas ele apenas delegará a tarefa
para o objeto threadCommunication. O método startThread() apenas invoca o método
start() (definido na classe Thread) que executará o método run() (das subclasses
que veremos a seguir) em paralelo à thread de UI. O método stopThread()
encerra a lógica de comunicação e fecha a conexão com o outro dispositivo.

Implemente agora as subclasses de BtThread começando pela BtThreadServer:
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothServerSocket
import android.os.Handler
import java.io.IOException
 
class BtThreadServer(



        private val btAdapter: BluetoothAdapter?,
        uiHandler: Handler) : BtThread(uiHandler) {
    var serverSocket: BluetoothServerSocket? = null
 
    override fun run() {
        try {
            serverSocket = btAdapter?.listenUsingRfcommWithServiceRecord(
                SERVICE_NAME, SERVICE_UUID)
            socket = serverSocket?.accept()
            threadCommunication.handleConnection(socket!!)
 
        } catch (e: Exception) {
            uiHandler.obtainMessage(
                    BtThreadCommunication.MSG_DISCONNECTED,
                    "${e.message} #1")?.sendToTarget()
            e.printStackTrace()
        }
    }
    override fun stopThread() {
        super.stopThread()
        try {
            serverSocket?.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }
}

Essa classe recebe como parâmetro do construtor BluetoothAdapter que será
utilizado para aguardar a conexão de clientes e o Handler para atualizar a UI.
No método run() o processo de conexão é iniciado invocando o método
listenUsingRfcommWithServiceRecord(String,UUID) que retornará o BluetoothServerSocket.
Em seguida, ao invocar o método accept() do socket servidor a execução da
thread ficará parada nessa linha até que um cliente se conecte ao servidor ou
o serverSocket seja fechado. Ao receber a conexão, o BluetoothSocket é passado
para a threadCommunication para receber e enviar mensagens por esse canal de
comunicação.

A BtThreadClient estabelecerá a comunicação com o servidor e deve ficar
como a seguir:
import android.bluetooth.BluetoothDevice
import android.os.Handler
 
class BtThreadClient(



        private val device: BluetoothDevice,
        uiHandler: Handler) : BtThread(uiHandler) {
 
    override fun run() {
        try {
            socket = device.createRfcommSocketToServiceRecord(SERVICE_UUID)
            socket?.connect()
            threadCommunication.handleConnection(socket!!)
        } catch (e: Exception) {
            e.printStackTrace()
            uiHandler.obtainMessage(BtThreadCommunication.MSG_DISCONNECTED,
                "${e.message} [2]")?.sendToTarget()
        }
    }
}

No construtor dessa classe é recebido, além do Handler de comunicação com
a UI, o BluetoothDevice que representa o dispositivo ao qual a aplicação estará
conectada. No método run() foi criado um socket invocando o método
createRfcommSocketToServiceRecord(UUID) e a conexão é estabelecida com o método
connect(). Por fim, o socket é passado para que o threadCommunication faça o
tratamento das mensagens da conexão.

Finalmente, defina a classe UiHandler que servirá de ponte entre a UI thread e
as threads de conexão e comunicação:
import android.os.Handler
import android.os.Message
 
class UiHandler(
        private val messageReceivedCallback: (String) -> Unit,
        private val connectionChangeCallback: (Boolean) -> Unit) : Handler() {
    override fun handleMessage(msg: Message) {
        super.handleMessage(msg)
        when (msg.what) {
            BtThreadCommunication.MSG_TEXT ->
                messageReceivedCallback(msg.obj.toString())
            BtThreadCommunication.MSG_CONNECTED ->
                connectionChangeCallback(true)
            BtThreadCommunication.MSG_DISCONNECTED ->
                connectionChangeCallback(false)
        }
    }
}

Essa classe recebe no construtor duas funções: o messageReceivedCallback será



chamado quando uma nova mensagem for recebida; e o connectionChangeCallback
é invocado quando a conexão foi estabelecida ou perdida. Note que o
primeiro recebe uma String como parâmetro, que representa a mensagem
recebida. Enquanto o segundo recebe um Boolean, em que true indica que a
conexão foi estabelecida e false que a conexão foi perdida. No método
handleMessage(Message) apenas é verificado o tipo da mensagem recebida e
chamado o método de callback correspondente.

Uma vez que foi definida a parte de comunicação, crie a tela da aplicação.
Altere o arquivo de layout res/layout/activity_main.xml e deixe-o da seguinte
forma:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    <RelativeLayout
        android:id="@+id/vwProgressContainer"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="8dp"
        android:visibility="gone">
        <TextView
            android:id="@+id/txtProgressMessage"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />
        <ProgressBar
            android:id="@+id/progressbar"
            style="?android:attr/progressBarStyleHorizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_alignParentStart="true"
            android:layout_below="@+id/txtProgressMessage"
            android:layout_toStartOf="@+id/btnCancel"
            android:indeterminate="true"
            android:max="100" />
        <Button
            android:id="@+id/btnCancel"
            style="@style/Widget.AppCompat.Button.Borderless"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentEnd="true"



            android:text="@android:string/cancel" />
    </RelativeLayout>
    <ListView
        android:id="@+id/lstMessages"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <EditText
            android:id="@+id/edtMessage"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1" />
        <Button
            android:id="@+id/btnSend"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Enviar" />
    </LinearLayout>
</LinearLayout>

O layout possui de uma ListView que exibirá as mensagens enviadas e
recebidas, um EditText para digitar a mensagem e um botão para enviá-la.
Também foi definido o vwProgressContainer que possui um TextView e uma
ProgressBar para dar um feedback para o usuário durante o processo de
conexão. Ele está invisível no momento, mas será exibido e ocultado quando
for necessário.

Implemente as mudanças na classe MainActivity apresentada a seguir. Boa
parte de sua implementação já foi explicada conceitualmente nas seções
anteriores, agora será vista a junção do processo de conexão com a interface
gráfica:
import android.Manifest
import android.app.Activity
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothDevice
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import androidx.appcompat.app.AppCompatActivity



import android.os.Bundle
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.widget.ArrayAdapter
import android.widget.Toast
import androidx.annotation.StringRes
import androidx.appcompat.app.AlertDialog
import androidx.core.app.ActivityCompat
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    private val btAdapter: BluetoothAdapter? = BluetoothAdapter.getDefaultAdapter()
    private val remoteDevices = mutableListOf<BluetoothDevice>()
    private var btThread: BtThread? = null
    private var btEventsReceiver: BtEventsReceiver? = null
    private var messagesAdapter: ArrayAdapter<String>? = null
 
    public override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        messagesAdapter = ArrayAdapter(this, android.R.layout.simple_list_item_1)
        lstMessages.adapter = messagesAdapter
        if (btAdapter != null) {
            if (btAdapter.isEnabled) {
                checkLocationPermission()
            } else {
                val enableBtIntent = Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE)
                startActivityForResult(enableBtIntent, BT_ACTIVATE)
            }
        } else {
            Toast.makeText(this, R.string.msg_error_bt_not_found,
                    Toast.LENGTH_LONG).show()
            finish()
        }
        registerBluetoothEventReceiver()
        btnSend.setOnClickListener {
            sendButtonClick()
        }
    }
    private fun checkLocationPermission() {
        if (ActivityCompat.checkSelfPermission(
                        this, Manifest.permission.ACCESS_COARSE_LOCATION)
                == PackageManager.PERMISSION_DENIED) {
            ActivityCompat.requestPermissions(this,



                    arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION),
                    RC_LOCATION_PERMISSION)
        }
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == BT_ACTIVATE) {
            if (Activity.RESULT_OK == resultCode) {
                checkLocationPermission()
            } else {
                Toast.makeText(this, R.string.msg_activate_bluetooth,
                        Toast.LENGTH_SHORT).show()
                finish()
            }
        } else if (requestCode == BT_VISIBLE) {
            if (resultCode == BT_DISCOVERY_TIME) {
                startServerThread()
            } else {
                hideProgress()
                Toast.makeText(this, R.string.msg_device_invisible,
                        Toast.LENGTH_SHORT).show()
            }
        }
    }
    private fun registerBluetoothEventReceiver() {
        btEventsReceiver = BtEventsReceiver()
        val filter1 = IntentFilter(BluetoothDevice.ACTION_FOUND)
        val filter2 = IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)
        registerReceiver(btEventsReceiver, filter1)
        registerReceiver(btEventsReceiver, filter2)
    }
    override fun onDestroy() {
        unregisterBluetoothEventReceiver()
        stopAll()
        super.onDestroy()
    }
    private fun unregisterBluetoothEventReceiver() {
        unregisterReceiver(btEventsReceiver)
    }
 
    private fun stopAll() {
        btThread?.stopThread()
        btThread = null
    }
    override fun onCreateOptionsMenu(menu: Menu): Boolean {



        menuInflater.inflate(R.menu.menu_bluetooth_chat, menu)
        return super.onCreateOptionsMenu(menu)
    }
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.action_client -> startClient()
            R.id.action_server -> startServer()
        }
        return super.onOptionsItemSelected(item)
    }
    private fun startServer() {
        val discoverableIntent = Intent(
                BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE)
        discoverableIntent.putExtra(
                BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION,
                BT_DISCOVERY_TIME)
        startActivityForResult(discoverableIntent, BT_VISIBLE)
    }
    private fun startServerThread() {
        showProgress(R.string.msg_server, BT_DISCOVERY_TIME.toLong() * 1000, cancelClick = {
            stopAll()
        })
        stopAll()
        val uiHandler = UiHandler(this::onMessageReceived, this::onConnectionChanged)
        btThread = BtThreadServer(btAdapter, uiHandler)
        btThread?.startThread()
    }
    private fun startClient() {
        showProgress(R.string.msg_searching_server, BT_DISCOVERY_TIME * 1000L) {
            btAdapter?.cancelDiscovery()
            stopAll()
        }
        remoteDevices.clear()
        btAdapter?.startDiscovery()
    }
    private fun showDiscoveredDevices(devices: List<BluetoothDevice>) {
        hideProgress()
        if (devices.isNotEmpty()) {
            val devicesFound = arrayOfNulls<String>(devices.size)
            for (i in devices.indices) {
                devicesFound[i] = devices[i].name
            }
            val dialog = AlertDialog.Builder(this)
                    .setTitle(R.string.devices_found)
                    .setSingleChoiceItems(devicesFound, -1) { dialog, which ->



                        startClientThread(which)
                        dialog.dismiss()
                    }
                    .create()
            dialog.show()
        } else {
            Toast.makeText(this, R.string.msg_no_devices_found, Toast.LENGTH_SHORT).show()
        }
    }
    private fun startClientThread(index: Int) {
        stopAll()
        val uiHandler = UiHandler(this::onMessageReceived, this::onConnectionChanged)
        btThread = BtThreadClient(remoteDevices[index], uiHandler)
        btThread?.startThread()
    }
    private fun showProgress(@StringRes message: Int,
                             timeout: Long = 0,
                             cancelClick: (() -> Unit)? = null) {
        vwProgressContainer.visibility = View.VISIBLE
        txtProgressMessage.setText(message)
        btnCancel.setOnClickListener {
            hideProgress()
            cancelClick?.invoke()
        }
        if (timeout > 0) {
            vwProgressContainer.postDelayed({
                hideProgress()
                cancelClick?.invoke()
            }, timeout)
        }
    }
    private fun hideProgress() {
        vwProgressContainer.visibility = View.GONE
    }
    private fun onMessageReceived(message: String) {
        messagesAdapter?.add(message)
        messagesAdapter?.notifyDataSetChanged()
    }
    private fun onConnectionChanged(connected: Boolean) {
        hideProgress()
        if (connected) {
            Toast.makeText(this,
                    R.string.msg_connected,
                    Toast.LENGTH_SHORT).show()
        } else {



            Toast.makeText(this,
                    R.string.msg_disconnected,
                    Toast.LENGTH_SHORT).show()
        }
    }
    private fun sendButtonClick() {
        val msg = edtMessage.text.toString()
        try {
            btThread?.sendMessage(msg)
            messagesAdapter?.add(getString(R.string.my_message, msg))
            messagesAdapter?.notifyDataSetChanged()
        } catch (e: Exception) {
            e.printStackTrace()
        }
        edtMessage.text.clear()
    }
    private inner class BtEventsReceiver : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (BluetoothDevice.ACTION_FOUND == intent.action) {
                val device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE) as

BluetoothDevice
                remoteDevices.add(device)
            } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED == intent.action) {
                showDiscoveredDevices(remoteDevices)
            }
        }
    }
    companion object {
        private const val BT_ACTIVATE = 0
        private const val BT_VISIBLE = 1
        private const val BT_DISCOVERY_TIME = 120
        private const val RC_LOCATION_PERMISSION = 2
    }
}

A classe ficou um pouco extensa, mas ela será explicada em detalhes. O
atributo remoteDevices armazenará a lista de dispositivos encontrados na busca
pelo servidor, caso o usuário esteja fazendo uma conexão cliente. O atributo
btThread representa a thread de comunicação, que pode ser servidora
(BtThreadServer) ou cliente (BtThreadClient). O atributo btEventsReceiver é utilizado ao
tentar realizar uma conexão do tipo cliente, onde ele será notificado quando
um novo dispositivo for encontrado e quando a busca por dispositivos for
concluída.

No método onCreate(Bundle), é feita uma série de verificações. Primeiro é



checado se o BluetoothAdapter é nulo, nesse caso, isso significa que o dispositivo
não possui bluetooth, então é exibida uma mensagem e a tela é fechada. Se
ele possui bluetooth, é verificado se está habilitado, e caso não esteja, é
solicitado que o usuário habilite o bluetooth. O resultado dessa operação será
tratado no onActivityResult (int,int,Intent). Se o usuário não concordou em habilitar o
bluetooth, uma mensagem é exibida e a tela é encerrada. Caso o bluetooth já
esteja habilitado, é solicitada a permissão de localização imprecisa
(ACCESS_COARSE_LOCATION) que é necessária para a comunicação cliente.
Essa busca é tratada pelo btEventsReceiver que é registrado para receber esses
eventos usando o método registerBluetoothEventReceiver(), e desregistrado no
onDestroy() ao chamar unregisterBluetoothEventReceiver().

A aplicação utiliza a action bar para iniciar o processo de conexão tanto
cliente quanto servidor. Isso é feito no método onCreateOptionsMenu(Menu) e o
tratamento desses itens de menu é realizado no método
onOptionItemSelected(MenuItem). Note que está sendo usado o arquivo de menu
res/menu/menu_bluetooth_chat.xml que deve ficar como a seguir:
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item android:id="@+id/action_server"
        android:title="@string/action_start_server"
        app:showAsAction="never" />
    <item android:id="@+id/action_client"
        android:title="@string/action_start_client"
        app:showAsAction="never" />
</menu>

Tanto a classe quanto esse arquivo estão usando as strings que devem ser
adicionadas no arquivo res/values/strings.xml:
<string name="action_start_server">Iniciar servidor</string>
<string name="action_start_client">Iniciar cliente</string>
<string name="msg_error_bt_not_found">Aparelho não suporta Bluetooth</string>
<string name="msg_searching_server">Procurando dispositivos…</string>
<string name="msg_activate_bluetooth">Você deve ativar o Bluetooth para continuar.</string>
<string name="msg_device_invisible">Para iniciar o servidor, seu aparelho deve estar visível.</string>
<string name="devices_found">Aparelhos encontrados</string>
<string name="msg_server">Aguardando por conexões…</string>
<string name="msg_disconnected">Desconectou</string>
<string name="my_message">Eu: %s</string>
<string name="msg_no_devices_found">Nenhum dispositivo encontrado</string>
<string name="msg_connected">Conectado!</string>



Ao escolher a opção servidor, no método startServer() será disparada uma
intenção requisitando que o dispositivo fique visível por determinado período
de tempo. Quando o usuário confirmar, o método onActivityResult(int,int,Intent) será
chamado e será inicializada a thread servidora por meio do método
startServerThread() que fica aguardando por conexões. Caso tenha escolhido a
opção cliente, o método startClient() será invocado para que o processo de busca
por dispositivos seja inicializado utilizando btAdapter.startDiscovery().

O btEventsReceiver é notificado quando um dispositivo é encontrado e quando
a operação de busca é concluída. Como foi explicado anteriormente, quando
um dispositivo é encontrado, ele é armazenado em remoteDevices, e quando o
processo de busca termina, essa lista é exibida para o usuário escolher a qual
aparelho ele quer se conectar. Isso é feito pelo método
showDiscoveredDevices(List<BluetoothDevice>), onde a lista de dispositivos
encontrados é percorrida para preencher um array com os nomes desses
aparelhos. Em seguida, os nomes contidos nesse array são exibidos em um
dialog. Ao clicar em um dos nomes, o processo de conexão inicia-se com a
chamada ao método startClientThread().

Para ambos os casos, a view de progresso é exibida utilizando o método
showProgress(Int,Long,()->Unit). Esse método exibe a view de progresso, e recebe
como parâmetro: a mensagem que será exibida; quanto tempo essa view deve
ficar visível (ou zero, caso deva ficar até o usuário cancelar); e uma função
que será chamada ao clicar no botão de cancelar. A view de progresso é
ocultada após determinado tempo invocando o método postDelayed(Runnable,long).
Ocultá-la se faz necessário uma vez que, caso o processo de conexão servidor
tenha sido iniciado, só deve ser exibida a view de progresso durante o tempo
que o aparelho estiver visível. O mesmo acontece com a conexão cliente que
deve ocultar o progress quando a busca por dispositivos termina. Quando
ocultar a view de progresso (pelo usuário ou quando o tempo decorrido tiver
terminado), o método cancelClick() passado como parâmetro será chamado.

Perceba que nos métodos startClientThread(Int) e startServerThread(), ao criar a
instância da classe UiHandler são passados como parâmetro as funções
onMessageReceived(String) e onConnectionChanged(Boolean) que serão utilizados para
respectivamente receber as mensagens vindas do outro dispositivo e para
saber quando a conexão com o outro dispositivo foi estabelecida ou
encerrada. O método sendButtonClick() envia a mensagem para o outro



dispositivo por meio da chamada btThread.send(msg) (da classe BtThread).
Infelizmente, o emulador ainda não suporta conexões Bluetooth. Deste

modo, para testar a aplicação, são necessários dois aparelhos reais. Sendo
assim, instale a aplicação e faça o teste deixando um aparelho como servidor
e o outro como cliente, então é só começar o bate-papo.

Ao iniciar o servidor, a tela da Figura 23.4 será exibida.

Figura 23.4 – Servidor aguardando por conexões.
Quando o cliente for iniciado, a busca por dispositivos será realizada.

Quando a busca for concluída a lista de aparelhos encontrados será exibida
conforme a Figura 23.5. Ao selecionarmos um aparelho da lista, a conexão é
estabelecida e os aparelhos podem trocar mensagens como mostra a Figura
23.6.



Figura 23.5 – Lista de dispositivos bluetooth encontrados.

Figura 23.6 – Chat Bluetooth em execução.
Neste capítulo foi apresentada a API de Bluetooth, explicando seus



principais conceitos e mostrando como aplicá-los na prática. Foi possível
observar como é relativamente simples a sua utilização, e de posse desse
conhecimento é possível criar aplicativos com mais recursos para os usuários,
como: jogos multiplayer, aplicativos que compartilham informações com
outros aparelhos, ou, ainda, aplicações que sincronizam suas informações
com um computador pessoal.



CAPÍTULO 24
AppWidgets

O termo widget muitas vezes é utilizado para definir componentes de
interface gráfica com o usuário (GUI) como botões, caixas de texto, menus,
ícones, barras de rolagem etc. No Android, esse termo se refere a
componentes de aplicativos que executam na tela principal do aparelho e até
na tela de bloqueio.

Os widgets têm o intuito informar e facilitar o acesso do usuário a
funcionalidades da aplicação e apresentar informações relevantes sem que o
usuário tenha que abrir o aplicativo para obtê-las. Condições meteorológicas,
bolsa de valores, emails e mensagens de redes sociais são bons exemplos de
informações que podem ser exibidas pelos widgets.

No Android, eles estão presentes desde a versão 1.5 por meio do AppWidget
framework. Esta API permite que os desenvolvedores criem aplicativos que
podem ser arrastados para a home screen de forma que o usuário possa
interagir com eles, fazendo com que se tornem um canal de acesso rápido a
uma aplicação.

Widget API
Os dois principais elementos envolvidos na criação de um Widget são:
AppWidgetProviderInfo e o AppWidgetProvider. O primeiro consiste em um
arquivo XML que contém informações sobre o widget, tais como o arquivo
de layout, dimensão, tempo de atualização e, opcionalmente, uma activity de
configuração que permite modificar as características do widget. Já o
AppWidgetProvider é a classe que tratará os eventos e o ciclo de vida do widget.
Ela herda de BroadcastReceiver e é notificada toda vez que o widget é atualizado,
habilitado, desabilitado e excluído.

Crie um novo projeto para utilizar os widgets na prática. Perceba que o
projeto não terá uma activity, apesar de que os widgets podem ser inseridos



normalmente em qualquer projeto junto a activities, services e broadcasts
receivers. Então, no momento de criar a activity no assistente de criação do
projeto, escolha a opção Add No Activity.

Application Name Widgets
Package Name dominando.android.widgets
Activity Name -

O primeiro widget deste projeto mostrará alguns links favoritos onde será
possível ver o próximo link clicando nos botões laterais que serão
adicionados no arquivo de layout.

AppWidgetProviderInfo
Para começar, adicione o arquivo de configuração do widget. Crie o diretório
res/xml e adicione o arquivo favorites_widget.xml e deixe-o como a seguir:
<appwidget-provider
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/widget_favorites"
    android:minHeight="40dp"
    android:minWidth="294dp"
    android:updatePeriodMillis="86400000"
    android:resizeMode="horizontal"
    android:widgetCategory="home_screen|keyguard"/>

Cada uma das propriedades utilizadas no arquivo estão detalhadas a seguir:
• android:initialLayout – indica o arquivo de layout que representa o widget;
• android:minHeight e android:minWidth – determinam a altura e a largura mínima

do widget. Esses valores devem tomar por base que um widget pode
ocupar no mínimo uma e no máximo quatro células para ser portável na
maioria dos aparelhos. Cada célula ocupa 40 dp, então se o seu widget
ocupar mais de uma célula você deve usar a fórmula: número de células * 70dp -
30dp. Isso é necessário, pois automaticamente são adicionadas margens ao
widget;

• android:updatePeriodMillis – determina a periodicidade em milissegundos que o
widget solicitará ao Android para ser atualizado. Entretanto, não é
garantido que esse valor seja cumprido, e para economizar bateria é
aconselhável não colocar valores inferiores a uma hora;

• android:configure – define uma activity de configuração que será chamada
antes que o widget seja adicionado à home screen. Nela poderão ser



informados parâmetros para o widget. Esse atributo é opcional e não será
usado nesse exemplo;

• android:resizeMode – indica a posição em que o widget pode ser
redimensionado, se apenas na horizontal, na vertical ou em ambas;

• android:widgetCategory – define se o widget aparecerá na home screen, na lock
screen (tela de bloqueio) ou em ambas. Os widgets na tela de bloqueio
estão disponíveis a partir do Android 4.2 (API Level 17);

• android:previewImage – a partir do Android 3.0, pode-se especificar uma
imagem que será exibida no menu de widgets do aparelho.

Existem outras propriedades, mas essas são as principais.

Layout de um widget
A criação de um arquivo de layout para um widget é idêntica à que é usada
para activities e fragments. Entretanto, existem algumas pequenas restrições
em termos de componentes. Só podem ser usados os gerenciadores de layout:
FrameLayout, LinearLayout, RelativeLayout e GridLayout. E os componentes permitidos
são: AnalogClock, Button, Chronometer, ImageButton, ImageView, ProgressBar, TextView,
ViewFlipper, ListView, GridView, StackView, AdapterViewFlipper.

Adicione o arquivo res/layout/widget_favorites.xml e deixe-o como a
seguir:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#0099CC"
    android:orientation="horizontal">
    <ImageButton
        android:id="@+id/btnPrevious"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:src="@drawable/ic_arrow_back" />
    <TextView
        android:id="@+id/txtSite"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_weight="1"
        android:gravity="center"
        android:shadowColor="#000"



        android:shadowRadius="5"
        android:text="@string/default_text"
        android:textColor="#FFFFFF" />
    <ImageButton
        android:id="@+id/btnNext"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:src="@drawable/ic_arrow_forward" />
</LinearLayout>

Nada de especial nesse arquivo de layout. Lembre-se apenas de adicionar as
imagens ic_arrow_back e ic_arrow_forward clicando com o botão direito
sobre a pasta res e selecionando a opção New > Vector Asset.

Adicione as seguintes strings no res/values/strings.xml:
<string name="widget_label">Links Favoritos</string>
<string name="default_text">Clique para navegar nos favoritos</string>

O layout está concluído e na próxima seção será implementada a lógica do
widget.

AppWidgetProvider
O comportamento de um widget é realizado em uma classe que herda de
AppWidgetProvider que, por sua vez, herda de BroadcastReceiver. Essa classe
receberá os eventos do sistema operacional informando quando o widget foi
adicionado, removido, habilitado ou desabilitado por meio dos seguintes
métodos:

• onUpdate() – esse método é chamado quando o usuário adiciona um widget
na tela e periodicamente de acordo com o parâmetro android:updatePeriodMillis.
Entretanto, se for definida uma activity de configuração com o parâmetro
android:configure, essa activity deverá disparar esse evento a primeira vez;

• onDeleted() – é invocado quando o widget é removido da tela;
• onEnabled() – é disparado quando o primeiro widget é adicionado à tela. O

usuário pode colocar quantas instâncias do widget desejar, mas esse
método só será chamado para a primeira instância;

• onDisabled() – é chamado quando a última instância do widget é removida da
tela;

• onReceive(Context,Intent) – é chamado antes de todos os métodos descritos
anteriormente, uma vez que a classe AppWidgetProvider é uma subclasse de



BroadcastReceiver.
Conhecidos os métodos do ciclo de vida de um widget, criar a classe

FavoritesWidget e deixe-a como a seguir:
import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.Context
import android.content.Intent
import android.widget.RemoteViews
class FavoritesWidget : AppWidgetProvider() {
    override fun onUpdate(context: Context,
                          appWidgetManager: AppWidgetManager,
                          appWidgetIds: IntArray) {
        super.onUpdate(context, appWidgetManager, appWidgetIds)
        val views = RemoteViews(
                context.packageName, R.layout.widget_favorites)
        for (appWidgetId in appWidgetIds) {
            initButtons(context, appWidgetId, views)
        }
        appWidgetManager.updateAppWidget(appWidgetIds, views)
    }
    override fun onDeleted(context: Context, appWidgetIds: IntArray) {
        super.onDeleted(context, appWidgetIds)
        val it = Intent(context, FavoritesReceiver::class.java)
        it.putExtra(EXTRA_ACTION, ACTION_DELETE)
        it.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds)
        context.sendBroadcast(it)
    }
    private fun initButtons(context: Context, appWidgetId: Int, views: RemoteViews) {
        views.setOnClickPendingIntent(R.id.btnNext,
                actionPendingIntent(context, ACTION_NEXT, appWidgetId))
        views.setOnClickPendingIntent(R.id.btnPrevious,
                actionPendingIntent(context, ACTION_PREVIOUS, appWidgetId))
        views.setOnClickPendingIntent(R.id.txtSite,
                actionPendingIntent(context, ACTION_SITE, appWidgetId))
    }
    private fun actionPendingIntent(
            ctx: Context, action: String, appWidgetId: Int): PendingIntent {
        val actionIntent = Intent(ctx, FavoritesReceiver::class.java)
        actionIntent.putExtra(EXTRA_ACTION, action)
        actionIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
        return PendingIntent.getBroadcast(
                ctx, appWidgetId+action.hashCode(), actionIntent,

PendingIntent.FLAG_UPDATE_CURRENT)



    }
    companion object {
        const val EXTRA_ACTION = "acao"
        const val ACTION_PREVIOUS = "anterior"
        const val ACTION_NEXT = "proximo"
        const val ACTION_DELETE = "excluir"
        const val ACTION_SITE = "site"
    }
}

O método onUpdate(Context,AppWidgetManager,int[]) é chamado quando o widget é
adicionado à tela. Perceba que o array de inteiros recebido como parâmetro
contém os ids dos widgets que foram atualizados. Quando a atualização é
feita automaticamente pelo Android baseado no android:updatePeriodMillis, os ids
de todas as instâncias desse widget são passados, mas quando uma nova
instância é adicionada, apenas o id daquela instância é recebido.

É importante ter em mente que o widget não roda no processo da aplicação,
mas sim no da home screen, então, para ter acesso aos componentes gráficos
é usada a classe RemoteViews e para atualizar o seu conteúdo é usado o método
updateAppWidget (int[],RemoteViews) da classe AppWidgetManager.

Outro detalhe interessante é que os componentes só podem disparar
PendingIntent ao serem clicados, e, nesse exemplo, o FavoritesReceiver está sendo
chamado mudando apenas o parâmetro informado (próximo e anterior). Esses
eventos foram definidos no método initButtons(Context, int, RemoteViews), por meio
do qual foi utilizado o método setOnClickPendingIntent(int, PendingIntent) da classe
RemoteViews, passando o id do componente e a PendingIntent que será executada
ao ser clicada. Esse objeto é criado no método actionPendingIntent(Context,String,int).
Perceba que o segundo parâmetro da PendingIntent deve ser único para cada
widget e cada botão, por isso foi passado o id do widget somado com o
hashcode da ação o que dificilmente gerará conflito.

No método onDeleted(Context, int[]) do widget é enviada uma mensagem de
broadcast informando que aquele widget está sendo excluído para que ele não
controle mais em que posição ele se encontra. Veremos essa implementação a
seguir.

Tratando eventos de clique em Widgets
Um dos grandes problemas ao se desenvolver um widget é o tratamento dos
eventos que são disparados por ele. Esses eventos devem ser tratados na



própria classe do widget ou em outro broadcast receiver. Entretanto, por ser
um broadcast receiver, ele não mantém estado, pois seu ciclo de vida se
encerra após a execução do método onReceive(Context, Intent). Para resolver esse
problema, deve-se utilizar alguma forma de persistência para armazenar o
estado dos widgets.

Tendo em vista essa característica, será definido um broadcast receiver que
receberá os eventos do widget e manterá o estado de cada widget em shared
preferences:
import android.appwidget.AppWidgetManager
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.preference.PreferenceManager
import android.widget.RemoteViews
 
class FavoritesReceiver : BroadcastReceiver() {
    private val sites = arrayOf(
            "www.nglauber.com.br",
            "developer.android.com",
            "www.google.com.br",
            "kotlinlang.org",
            "github.com/nglauber")
 
    override fun onReceive(context: Context, intent: Intent?) {
        if (intent != null) {
            val action = intent.getStringExtra(FavoritesWidget.EXTRA_ACTION)
            if (action != null) {
                when (action) {
                    FavoritesWidget.ACTION_NEXT,
                    FavoritesWidget.ACTION_PREVIOUS -> {
                        val appWidgetId = intent.getIntExtra(
                                AppWidgetManager.EXTRA_APPWIDGET_ID,
                                AppWidgetManager.INVALID_APPWIDGET_ID)
                        val position = newPosition(context, action, appWidgetId)
                        val views = RemoteViews(
                                context.packageName, R.layout.widget_favorites)
                        views.setTextViewText(R.id.txtSite, sites[position])
                        val appWidgetManager = AppWidgetManager.getInstance(context)
                        appWidgetManager.updateAppWidget(appWidgetId, views)
                    }
                    FavoritesWidget.ACTION_DELETE -> {
                        val deletedWidgets = intent.getIntArrayExtra(



                                AppWidgetManager.EXTRA_APPWIDGET_IDS)
                        for (id in deletedWidgets) {
                            remove(context, id)
                        }
                    }
                    FavoritesWidget.ACTION_SITE -> {
                        val appWidgetId = intent.getIntExtra(
                                AppWidgetManager.EXTRA_APPWIDGET_ID,
                                AppWidgetManager.INVALID_APPWIDGET_ID)
                        val position = getPosition(context, appWidgetId)
                        val site = sites[position]
                        val it = Intent(Intent.ACTION_VIEW,
                                Uri.parse("http://$site"))
                        it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        context.startActivity(it)
                    }
                }
            }
        }
    }
    private fun newPosition(context: Context, action: String, appWidgetId: Int): Int {
        var position = getPosition(context, appWidgetId)
        if (FavoritesWidget.ACTION_NEXT == action) {
            position++
            if (position >= sites.size) {
                position = 0
            }
        } else if (FavoritesWidget.ACTION_PREVIOUS == action) {
            position--
            if (position < 0) {
                position = sites.size - 1
            }
        }
        savePosition(context, appWidgetId, position)
        return position
    }
    private fun getPosition(context: Context, appWidgetId: Int): Int {
        val prefs = PreferenceManager.getDefaultSharedPreferences(context)
        val prefKey = "$PREF_KEY_PREFIX$appWidgetId"
        return prefs.getInt(prefKey, 0)
    }
    private fun savePosition(context: Context, appWidgetId: Int, newPosition: Int) {
        val prefs = PreferenceManager.getDefaultSharedPreferences(context)
        val prefKey = "$PREF_KEY_PREFIX$appWidgetId"
        prefs.edit().putInt(prefKey, newPosition).apply()



    }
    private fun remove(context: Context, appWidgetId: Int) {
        val prefs = PreferenceManager.getDefaultSharedPreferences(context)
        val prefKey = "$PREF_KEY_PREFIX$appWidgetId"
        prefs.edit().remove(prefKey).apply()
    }
    companion object {
        private const val PREF_KEY_PREFIX = "widget_"
    }
}

Esta classe contém um array com os links favoritos e na shared preferences
está sendo armazenada em qual posição da lista cada instância do widget está.
O widget então fará requisições a este receiver, que serão tratadas pelo
método onReceive(Context,Intent). Nesse método é verificada qual ação foi
disparada pelo widget baseado no parâmetro EXTRA_ACTION da Intent.

Caso seja a ACTION_NEXT ou ACTION_PREVIOUS, a nova posição a ser exibida
é obtida de acordo com o id do widget por meio do método newPosition(Context,
String, int). Em seguida, é criada uma instância da classe RemoteViews, onde o
texto do componente é atualizado, e, por fim, o widget é atualizado usando o
método updateAppWidget(int,RemoteViews) do AppWidgetManager.

A ação ACTION_DELETE apenas remove o widget do shared preferences e a
ação ACTION_SITE abre o navegador na URL em que foi clicada.

Assim como todo BroadcastReceiver, ele deve ser declarado no
AndroidManifest.xml, e deve obrigatoriamente tratar a ação
APPWIDGET_UPDATE e ter uma tag <meta-data> referenciando o arquivo de
configuração do widget criado anteriormente:
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="dominando.android.widgets">
    <application ... >
        <receiver
            android:name=".FavoritesWidget"
            android:label="@string/widget_label">
            <intent-filter>
                <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
            </intent-filter>
            <meta-data
                android:name="android.appwidget.provider"
                android:resource="@xml/favorites_widget" />
        </receiver>
        <receiver android:name=".FavoritesReceiver"/>



    </application>
</manifest>

Ao tentar executar a aplicação, o Android Studio exibirá um erro, pois não
há nenhuma Activity para ser executada. Selecione a opção Run > Edit
Configurations e será exibida a tela da Figura 24.1.

No campo Launch, selecione a opção Nothing e, em seguida, clique em
OK. Agora será possível executar a aplicação normalmente. Entretanto,
aparentemente nada aparecerá no aparelho. Para ver o widget em
funcionamento é preciso arrastá-lo até a home screen. Isso pode variar de
acordo com o modelo do aparelho ou da versão do Android, mas na maioria
dos casos você pode pressionar algum lugar vago na home screen por dois
segundos e a opção aparecerá, como mostrado na Figura 24.2.

Figura 24.1 – Alterando as configurações de execução do projeto.



Figura 24.2 – Opção para adicionar widgets.
Encontre a opção adequada no seu aparelho e selecione o widget na lista e

arraste-o para a home screen. Ele ocupará uma linha inteira da tela, então
escolha uma área com espaço. A Figura 24.3 mostra nosso widget em
execução.



Figura 24.3 – Widget em execução.
É importante lembrar que o tempo de execução de um broadcast receiver

não pode exceder a 10 segundos. Por isso, se a ação do receiver tiver uma
ação mais longa, deve-se utilizar outra estratégia como o agendamento de
tarefas e dados em cache. Lembrando que a partir do Android 8 não é
possível iniciar serviços em background.

Nesse exemplo, foi visto como um widget pode exibir informações para o
usuário. Como fazer para exibir informações em formato de lista?

Widgets de listagem
A partir da versão 3.0 é possível criar widgets que exibem uma lista de
informações como emails e notícias. Para demonstrar esse tipo de aplicação,
será criado um widget que exibirá uma lista de times de futebol, e ao clicar no
nome do clube, sua página oficial será exibida no browser.

Crie primeiramente o arquivo de layout do widget definido em
res/layout/widget_teams.xml:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"



    android:orientation="vertical">
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="#009688"
        android:gravity="center"
        android:padding="8dp"
        android:text="@string/teams_widget_title"
        android:textAppearance="?android:attr/textAppearanceMedium"
        android:textColor="#FFEB3B" />
    <ListView
        android:id="@+id/lstTeams"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="#E0F2F1" />
</LinearLayout>

Aqui não temos nada de especial, apenas um TextView que vai exibir o título
e um ListView que exibirá a listagem dos clubes. Declare as strings a seguir no
res/values/strings.xml:
    <string name="teams_widget_title">Clubes do Brasil</string>
    <string name="teams_widget_label">Widget de Clubes</string>

O código a seguir representa o layout que será usado em cada linha do
widget e que deve estar no arquivo res/layout/item_team_widget.xml. Ela
contém apenas um ImageView e um TextView, que exibirão o escudo e o nome do
clube, respectivamente:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/root"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal">
    <ImageView
        android:id="@+id/imgCrest"
        android:layout_margin="8dp"
        android:layout_width="36dp"
        android:layout_height="36dp"
        android:src="@mipmap/ic_launcher" />
    <TextView
        android:id="@+id/txtName"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center"



        android:gravity="center"
        android:textColor="#333"
        android:textSize="16sp" />
</LinearLayout>

Agora que foram definidos os layouts do widget, crie o arquivo de
configuração em res/xml/teams_widget.xml:
<appwidget-provider
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/widget_teams"
    android:minHeight="110dp"
    android:minWidth="110dp"
    android:resizeMode="horizontal|vertical" />

Perceba que está sendo permitido o redimensionamento horizontal e
vertical na propriedade android:resizeMode.

A classe Team listada a seguir é apenas uma abstração de um time de futebol
dentro da aplicação. Ela contém o nome do clube, o nome do arquivo com a
imagem do escudo (que, para esse exemplo, foi colocado na pasta
app/src/main/assets) e a URL da página oficial:
data class Team(val name: String, val crest: String, val url: String)

A seguir, foram listadas as classes TeamService e TeamRemoteViewsFactory. Elas
fornecerão os dados que serão exibidos pelo widget. A primeira apenas
retorna uma instância da segunda por meio do método onGetViewFactory(Intent),
que é chamado pelo framework quando o widget precisa exibir as
informações. Em seguida, foi definida uma lista de objetos da classe Team,
que é preenchida no método onCreate(Context,Intent), que é chamado quando o
provedor dos dados é criado. O método onDestroy(), por sua vez, é chamado
quando o provedor é destruído. E o método getCount() retorna quantos
elementos esse provedor de dados está retornando. Em nosso caso,
retornamos a quantidade de itens que existem na lista:
import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.widget.RemoteViews
import android.widget.RemoteViewsService
import java.util.ArrayList
 
class TeamService : RemoteViewsService() {
    override fun onGetViewFactory(intent: Intent): RemoteViewsService.RemoteViewsFactory {



        return TeamRemoteViewsFactory(this.applicationContext)
    }
    internal inner class TeamRemoteViewsFactory(
            private val context: Context
    ) : RemoteViewsService.RemoteViewsFactory {
        private val listTeams = ArrayList<Team>()
        override fun onCreate() {
            listTeams.add(Team("América-MG", "america-mg.png",
                    "www.americamineiro.com.br"))
            listTeams.add(Team("Atlético-MG", "atl_mg.png",
                    "www.atletico.com.br"))
            listTeams.add(Team("Atlético-PR", "atl_pr.png",
                    "www.atleticoparanaense.com"))
            listTeams.add(Team("Bahia", "bahia.png",
                    "www.esporteclubebahia.com.br"))
            listTeams.add(Team("Botafogo", "botafogo.png",
                    "www.botafogo.com.br"))
            listTeams.add(Team("Ceará", "ceara.png",
                    "www.cearasc.com"))
            listTeams.add(Team("Chapecoense", "chapecoense.png",
                    "chapecoense.com"))
            listTeams.add(Team("Corinthians", "corinthians.png",
                    "www.corinthians.com.br"))
            listTeams.add(Team("Cruzeiro", "cruzeiro.png",
                    "www.cruzeiro.com.br"))
            listTeams.add(Team("Flamengo", "flamengo.png",
                    "www.flamengo.com.br"))
            listTeams.add(Team("Fluminense", "fluminense.png",
                    "www.fluminense.com.br"))
            listTeams.add(Team("Grêmio", "gremio.png",
                    "www.gremio.net"))
            listTeams.add(Team("Internacional","internacional.png",
                    "www.internacional.com.br"))
            listTeams.add(Team("Palmeiras", "palmeiras.png",
                    "www.palmeiras.com.br"))
            listTeams.add(Team("Paraná", "parana.png",
                    "www.paranaclube.com.br"))
            listTeams.add(Team("Santos", "santos.png",
                    "www.santosfc.com.br"))
            listTeams.add(Team("São Paulo", "sao_paulo.png",
                    "www.saopaulofc.net"))
            listTeams.add(Team("Sport", "sport.png",
                    "www.sportrecife.com.br"))
            listTeams.add(Team("Vasco", "vasco.png",
                    "www.crvascodagama.com"))



            listTeams.add(Team("Vitória", "vitoria.png",
                    "www.ecvitoria.com.br"))
        }
        override fun onDestroy() {
            listTeams.clear()
        }
        override fun getCount(): Int {
            return listTeams.size
        }
        override fun getViewAt(position: Int): RemoteViews {
            val (name, crest, url) = listTeams[position]
            var bmp: Bitmap? = null
            try {
                bmp = BitmapFactory.decodeStream(context.assets.open(crest))
            } catch (e: Exception) {
                e.printStackTrace()
            }
            val rv = RemoteViews(context.packageName, R.layout.item_team_widget)
            rv.setTextViewText(R.id.txtName, name)
            rv.setImageViewBitmap(R.id.imgCrest, bmp)
            val fillInIntent = Intent()
            fillInIntent.putExtra(TeamWidget.EXTRA_URL, "http://$url")
            rv.setOnClickFillInIntent(R.id.root, fillInIntent)
            return rv
        }
        override fun getLoadingView(): RemoteViews? {
            return null
        }
        override fun getViewTypeCount(): Int {
            return 1
        }
        override fun getItemId(position: Int): Long {
            return position.toLong()
        }
        override fun hasStableIds(): Boolean {
            return false
        }
        override fun onDataSetChanged() {}
    }
}

O método mais importante dessa classe é o getViewAt(int), similar ao que
existe na classe BaseAdapter; esse método vai retornar um objeto RemoteViews que
representará cada uma das linhas da ListView que está no widget. Na definição
do getViewAt(int), é obtido o objeto Team da lista baseado na posição que é



recebida pelo parâmetro position, e feito o destructuring para as constantes
name, crest e url. Em seguida, a imagem do escudo do clube é carregada 1 (que
deve estar na pasta assets). Depois, um objeto RemoteViews é criado passando o
nome do pacote da aplicação e o arquivo de layout. E finalmente o texto do
TextView é alterado para o nome do clube, e a ImageView recebe a imagem do
escudo do clube.

O método getLoadingView() pode retornar uma View que informe o progresso do
carregamento da informação de determinada linha da lista. Isso é utilizado
principalmente quando se está baixando informações da rede, ou de alguma
fonte que possa demandar tempo. Quando retornamos null, a view-padrão é
exibida. O método getViewTypeCount() diz quantos tipos de view essa listagem
tem. Em nosso caso, só temos um tipo, o método getItemId(), que retorna o id de
um objeto de uma posição da lista. Como não definimos ids para os clubes,
retornamos a própria posição. No método hasStableIds(), informamos se nossa
lista tem ids estáveis, ou seja, se determinado id está se referindo sempre ao
mesmo objeto. Isso indica que, em caso de uma mudança nos dados, os ids
podem ser alterados. Retornamos false, uma vez que estamos retornando como
id apenas a posição do elemento na lista. Por último, o método
onDataSetChanged(), que é chamado quando precisamos atualizar a lista que o
widget está exibindo em tempo de execução.

Agora crie a classe TeamWidget definida a seguir:
import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.widget.RemoteViews
 
class TeamWidget : AppWidgetProvider() {
 
    override fun onReceive(context: Context, intent: Intent) {
        if (ACTION_CLICK == intent.action) {
            val url = intent.getStringExtra(EXTRA_URL)
            val it = Intent(Intent.ACTION_VIEW, Uri.parse(url))
            it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            context.startActivity(it)
        }
        super.onReceive(context, intent)



    }
    override fun onUpdate(context: Context,
                          appWidgetManager: AppWidgetManager, appWidgetIds: IntArray) {
        for (appWidgetId in appWidgetIds) {
            val intent = Intent(context, TeamService::class.java)
            val rv = RemoteViews(
                    context.packageName, R.layout.widget_teams)
            rv.setRemoteAdapter(R.id.lstTeams, intent)
            val it = Intent(context, TeamWidget::class.java)
            it.action = ACTION_CLICK
            it.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
            val pit = PendingIntent.getBroadcast(
                    context, 0, it, PendingIntent.FLAG_UPDATE_CURRENT)
            rv.setPendingIntentTemplate(R.id.lstTeams, pit)
            appWidgetManager.updateAppWidget(appWidgetId, rv)
        }
        super.onUpdate(context, appWidgetManager, appWidgetIds)
    }
    companion object {
        const val ACTION_CLICK = "chamar_url"
        const val EXTRA_URL = "url"
    }
}

Diferentemente do que foi feito no outro exemplo, essa classe está tratando
o evento de clique no próprio widget, então no onReceive(Context,Intent) é checado
se a ação disparada foi a ACTION_CLICK, que é chamada quando o usuário clica
em um item da lista. Em caso positivo, a URL recebida como parâmetro
EXTRA_URL da intent é aberta no browser do aparelho.

No onUpdate(Context,AppWidgetManager, int[]) foi criada uma Intent para o serviço
que preencherá a lista do widget e, em seguida, uma instância de RemoteViews
foi criada passando como parâmetro o layout do widget. Depois a Intent é
passada para a instância de RemoteViews chamando setRemoteAdapter(int,Intent). Isso
determinará que esse serviço preencherá a ListView com o id lstTeams.

O evento de clique no item da lista é feito em duas etapas. Primeiro, é
criada a Intent apontando para a própria classe do widget, mas definindo sua
ação como ACTION_CLICK, e passamos o id do widget como parâmetro. Em
seguida, é usado o método setPendingIntentTemplate(int, PendingIntent) para informar
que esse será o template da Intent, que será disparada ao clicar no item da lista,
mas sem os parâmetros necessários para sua real execução. A segunda etapa
determina qual posição da lista foi clicada e, consequentemente, permite



obter a informação do clube. Essa informação é preenchida na classe
TeamRemoteViewsFactory com o método setOnClickFillInIntent(int, Intent) que é invocado
no método getView(int).

Finalmente, declare tanto o TeamWidget (receiver) quanto o TeamService
(service) no AndroidManifest.xml, conforme apresentado a seguir:
<receiver android:name=".TeamWidget"
    android:label="@string/teams_widget_label">
    <intent-filter>
        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
    </intent-filter>
    <meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/teams_widget" />
</receiver>
<service
    android:name=".TeamService"
    android:exported="false"
    android:permission="android.permission.BIND_REMOTEVIEWS" />

O detalhe interessante aqui é que o serviço que preenche o widget deve ter a
permissão android.permission.BIND_REMOTEVIEWS para que possa preencher views
remotas. Como este serviço não deve ser acessível por outras aplicações,
setamos a propriedade android:exported para false. A Figura 24.4 apresenta os dois
widgets que desenvolvemos neste capítulo em execução.



Figura 24.4 – Widget com a lista de clubes.
Os widgets, além de facilitarem a vida do usuário, podem aumentar o

engajamento do seu aplicativo; e você pode e deve utilizar esse recurso
exclusivo do Android em seus projetos.

1 Você pode fazer o download dessas imagens no GitHub do livro ou usar as suas próprias.



CAPÍTULO 25
Multimídia

No capítulo sobre serviços foi visto como tocar músicas existentes no
aparelho utilizando a classe MediaPlayer. No exemplo de upload de imagens, foi
utilizada a galeria de mídia do aparelho para selecionar uma foto. E no
aplicativo de livros foi demonstrado como tirar uma foto com a câmera do
aparelho. Neste capítulo vamos explorar um pouco mais detalhadamente os
recursos multimídia do Android utilizando o microfone, o áudio e a câmera
do aparelho.

Câmera
Nesta seção veremos como utilizar a câmera do aparelho para tirar fotos e
gravar vídeos que aparecerão na galeria de mídias do aparelho. Para isso, crie
um novo projeto e adicione a seguinte dependência no build.gradle do
módulo app:
dependencies { ...
    implementation 'androidx.exifinterface:exifinterface:1.0.0'
}

A ExifInterface permite obter algumas informações de arquivos de mídia.
Nesse exemplo, essas informações são necessárias para saber se se deve
rotacionar a foto tirada pela câmera. A plataforma já possui uma
implementação dessa classe no pacote android.media, porém ela possui algumas
falhas de segurança que foram corrigidas nessa biblioteca.

Application Name Multimidia
Package Name dominando.android.multimidia
Activity Name MainActivity

Adicione o objeto MediaUtils, onde serão definidos alguns métodos que serão
usados mais adiante:
import android.content.Context



import android.content.Intent
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.text.format.DateFormat
import androidx.core.content.FileProvider
import androidx.exifinterface.media.ExifInterface
import java.io.File
import java.io.IOException
import java.util.*
 
object MediaUtils {
    const val REQUEST_CODE_PHOTO = 1
    const val REQUEST_CODE_VIDEO = 2
    const val REQUEST_CODE_AUDIO = 3
    const val PROVIDER_AUTHORITY = "dominando.android.multimidia.fileprovider"
    private const val PREFERENCE_MEDIA = "midia_prefs"
    private const val MEDIA_FOLDER = "Dominando_Android"
 
    enum class MediaType(val extension: String, val preferenceKey: String) {
        MEDIA_PHOTO(".jpg", "last_photo"),
        MEDIA_VIDEO(".mp4", "last_video"),
        MEDIA_AUDIO(".3gp", "last_audio")
    }
 
    fun newMedia(mediaType: MediaType): File {
        val fileName = DateFormat.format("yyyy-MM-dd_hhmmss", Date()).toString()
        val mediaDir = File(
                Environment.getExternalStorageDirectory(),
                MEDIA_FOLDER)
        if (!mediaDir.exists()) {
            if (!mediaDir.mkdirs()) {
                throw IllegalArgumentException("Fail to create directories")
            }
        }
        return File(mediaDir, fileName + mediaType.extension)
    }
    fun saveLastMediaPath(ctx: Context, mediaType: MediaType, mediaPath: String) {
        ctx.getSharedPreferences(PREFERENCE_MEDIA, Context.MODE_PRIVATE)
                .edit()
                .putString(mediaType.preferenceKey, mediaPath)
                .apply()



        ctx.sendBroadcast(Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE).apply {
            data = Uri.parse(mediaPath)
        })
    }
    fun getLastMediaPath(ctx: Context, mediaType: MediaType): String? {
        return ctx.getSharedPreferences(PREFERENCE_MEDIA, Context.MODE_PRIVATE)
                .getString(mediaType.preferenceKey, null)
    }
    fun loadImage(imageFile: File, width: Int, height: Int): Bitmap? {
        if (width == 0 || height == 0) return null
        val bmpOptions = BitmapFactory.Options()
        bmpOptions.inJustDecodeBounds = true
        BitmapFactory.decodeFile(imageFile.absolutePath, bmpOptions)
        val realPhotoWidth = bmpOptions.outWidth
        val realPhotoHeight = bmpOptions.outHeight
        val scale = Math.min(
                realPhotoWidth / width,
                realPhotoHeight / height)
        bmpOptions.inJustDecodeBounds = false
        bmpOptions.inSampleSize = scale
        bmpOptions.inPreferredConfig = Bitmap.Config.RGB_565
        var bitmap = BitmapFactory.decodeFile(
                imageFile.absolutePath, bmpOptions)
        bitmap = rotateImage(bitmap, imageFile.absolutePath)
        return bitmap
    }
    private fun rotateImage(bitmap: Bitmap, filePath: String): Bitmap {
        var bmp = bitmap
        try {
            val ei = ExifInterface(filePath)
            val orientation = ei.getAttributeInt(ExifInterface.TAG_ORIENTATION,
                    ExifInterface.ORIENTATION_NORMAL)
            when (orientation) {
                ExifInterface.ORIENTATION_ROTATE_90 -> bmp = rotateImage(bitmap, 90f)
                ExifInterface.ORIENTATION_ROTATE_180 -> bmp = rotateImage(bitmap, 180f)
                ExifInterface.ORIENTATION_ROTATE_270 -> bmp = rotateImage(bitmap, 270f)
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
        return bmp
    }
    private fun rotateImage(source: Bitmap, angle: Float): Bitmap {
        val matrix = Matrix()
        matrix.postRotate(angle)



        return Bitmap.createBitmap(
                source, 0, 0,
                source.width, source.height,
                matrix, true)
    }
    fun getVideoUri(context: Context): Uri {
        val newVideoFile = MediaUtils.newMedia(MediaUtils.MediaType.MEDIA_VIDEO)
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            FileProvider.getUriForFile(context,
                    MediaUtils.PROVIDER_AUTHORITY, newVideoFile)
        } else {
            Uri.fromFile(newVideoFile)
        }
    }
}

Esse é um objeto utilitário na qual foram definidas algumas constantes e
métodos que serão utilizados nas telas de captura de imagem, áudio e vídeo
que serão construídas mais adiante. O método newMedia(MediaType) gera um
nome de arquivo para a nova mídia utilizando a data do aparelho. Perceba
que foi criado um subdiretório chamado Dominando_Android dentro da pasta
DCIM, que é onde ficam as imagens e os vídeos do aplicativo de câmera. Se
você quiser utilizar outro diretório, é só escolher outro local, como foi visto
no capítulo sobre persistência.

O método saveLastMediaPath(Context,MediaType,String) armazena em uma
SharedPreferences o caminho do último vídeo, da última foto ou do último áudio
salvo (dependendo do parâmetro mediaType). Porém, um detalhe
importantíssimo é o sendBroadcast(Intent), que é disparado com a ação
ACTION_MEDIA_SCANNER_SCAN_FILE. Isso fará com que o Android escaneie o
sistema de arquivos e adicione essa nova mídia à galeria de mídia. Já o
método getLastMediaPath(Context,MediaType) retorna o caminho da última mídia
salva de acordo com o seu tipo (foto, áudio ou vídeo).

As imagens tiradas com as câmeras atuais são bem maiores que a tela do
aparelho. Então o ideal é carregar a imagem redimensionada para a área em
que ela será exibida. Isso é feito no método loadImage(File,Int,Int) passando o
arquivo de imagem a ser carregado e a largura e a altura do ImageView onde
essa imagem será exibida. Um objeto BitmapFactory.Options é instanciado e a
propriedade inJustDecodeBounds é definida para true indicando que apenas o
tamanho da imagem será lido, sem carregá-la realmente em memória. Assim,



quando o método decodeFile(String,Options) é chamado, o objeto bmpOptions
armazenará o tamanho real da imagem, e de posse dessa informação, é
calculada a escala que será aplicada à imagem. Feito isso, a escala é passada
para o atributo inSampleSize do objeto bmpOptions e a propriedade inJustDecodeBounds
é modificada para false. Um último ajuste que foi realizado foi utilizar a
propriedade inPreferredConfig definindo-a com o valor RGB_565. Isso demanda
menos memória, pois cada pixel da imagem é armazenado em 2 bytes, mas
não tem transparência, ao contrário do ARGB_8888 (padrão) que demanda 4
bytes por pixel, mas dá suporte à transparência. Por fim, a imagem real já
redimensionada é carregada e retornada.

A câmera do aparelho pode tirar fotos em portrait ou landscape, por isso é
preciso saber a orientação da foto; essa informação é obtida no método
rotateImage (Bitmap,String) utilizando a classe ExifInterface. Por meio do método
getAttributeInt (String,Int) a orientação da foto é obtida. Caso seja necessário
rotacionar a imagem, o método rotate(Bitmap,Float) é chamado, mas a rotação só
é efetivamente realizada com o método postRotate(float) da classe Matrix.

Como foi explicado no Capítulo 21, deve-se utilizar um ContentProvider para
compartilhar os arquivos com outros aplicativos, informando explicitamente
os diretórios que são acessíveis a eles. Para isso, é necessário declarar esse
provider no AndroidManifest.xml:
<manifest ...>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <application ...> ...
        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="dominando.android.multimidia.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths"/>
        </provider>
    </application>
</manifest>

O provider é declarado passando a classe FileProvider, a authorities que deve ser
a mesma indicada no método newMedia(MediaType) e a propriedade
android:grantUriPermissions dará acesso único ao conteúdo do provider. Na tag
<meta-data> é referenciado o arquivo que contém diretórios que esse provider



dará acesso. Crie o arquivo res/xml/file_paths.xml e deixe-o como a seguir:
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="media_files" path="Dominando_Android" />
</paths>

Perceba que foi utilizada a tag <external-path>, pois será utilizado o diretório
obtido com a chamada Environment.getExternalStorageDirectory(). Para diretórios
diferentes, consulte o Capítulo 21 onde já foi explicado o uso de cada tag.

O último método da classe MediaUtils é o getVideoUri(Context), que será usado
quando for demonstrada a gravação de vídeos (ainda neste capítulo). Esse
método será responsável por gerar uma Uri para o vídeo que será gravado com
o aplicativo de câmera. Até o Android Marshmallow (API Level 23) era
possível passar uma Uri para um arquivo, entretanto, a partir do Android
Nougat (API Level 24), é necessário passar uma Uri para um Content
Provider, e nesse caso é usada a classe FileProvider declarada no
AndroidManifest.xml.

As operações com imagens normalmente devem ser feitas fora da UI
thread. Para fazer isso, serão utilizadas as coroutines do Kotlin devido à sua
simplicidade. Adicione essas dependências no build.gradle:
dependencies {
    def coroutines_version = '1.1.0'
    ...
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutines_version"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutines_version"
}

Serão implementados dois fragments para demonstrar o uso da câmera do
aparelho: o primeiro possibilitará tirar fotos, e o outro, gravar vídeos. Esses
dois fragments terão algo em comum: terão que verificar a permissão de
leitura no cartão de memória. Por essa razão, essa implementação ficará na
classe MultimediaFragment listada a seguir:
import android.Manifest
import android.content.pm.PackageManager
import android.os.Bundle
import androidx.core.app.ActivityCompat
import androidx.fragment.app.Fragment
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlin.coroutines.CoroutineContext
 



abstract class MultimediaFragment : Fragment(), CoroutineScope {
    lateinit var job: Job
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        job = Job()
    }
    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
    }
    protected fun hasPermission(): Boolean {
        val permissions = listOf(
                Manifest.permission.WRITE_EXTERNAL_STORAGE
        )
        return permissions.all {
            ActivityCompat.checkSelfPermission(requireActivity(), it) ==
                    PackageManager.PERMISSION_GRANTED
        }
    }
    protected fun requestPermissions(requestCode: Int = REQUEST_CODE_PERMISSION) {
        requestPermissions(arrayOf(
                Manifest.permission.WRITE_EXTERNAL_STORAGE), requestCode)
    }
 
    companion object {
        const val REQUEST_CODE_PERMISSION = 1
    }
}

A classe MultimidiaFragment é marcada como abstract para que ela não possa ser
instanciada diretamente. O método hasPermission() verifica se a aplicação possui
a permissão de escrever no cartão de memória. Essa permissão é solicitada no
método requestPermissions(Int).

Essa classe implementa CoroutineScope para poder executar algumas ações de
forma assíncrona. Por isso, um Job pai é instanciado no onCreate(Bundle) e todos
os “jobs filhos” serão cancelados quando o fragment for destruído.

Tirando fotos
Para tirar fotos, adicione um novo fragment chamado CameraPhotoFragment, e seu



arquivo de layout res/layout/fragment_camera_photo.xml deve ficar como a
seguir:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical">
    <ImageView
        android:id="@+id/imgPhoto"
        android:layout_width="150dp"
        android:layout_height="150dp"
        android:background="#cccccc"
        android:scaleType="centerInside"/>
    <ImageButton
        android:id="@+id/btnTakePhoto"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_camera"/>
</LinearLayout>

Nada de especial a comentar nesse arquivo, pois ele possui apenas um
ImageView que exibirá a foto que será tirada com a câmera e um botão que
abrirá o aplicativo de câmera.

Agora adicione a classe CameraPhotoFragment e deixe como a seguir:
import android.app.Activity
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Bundle
import android.provider.MediaStore
import android.view.*
import androidx.core.content.FileProvider
import kotlinx.android.synthetic.main.fragment_camera_photo.*
import kotlinx.coroutines.*
import java.io.File
 
class CameraPhotoFragment : MultimediaFragment(), ViewTreeObserver.OnGlobalLayoutListener {
    private var photoFile: File? = null
    private var imageWidth: Int = 0
    private var imageHeight: Int = 0
 
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        retainInstance = true



        if (photoFile == null) {
            activity?.let {
                val lastPath = MediaUtils.getLastMediaPath(it, MediaUtils.MediaType.MEDIA_PHOTO)
                if (lastPath != null) {
                    photoFile = File(lastPath)
                }
            }
        }
    }
    override fun onCreateView(inflater: LayoutInflater,
            container: ViewGroup?, savedInstanceState: Bundle?): View? {
        val layout = inflater.inflate(
                R.layout.fragment_camera_photo, container, false)
        layout.viewTreeObserver.addOnGlobalLayoutListener(this)
        return layout
    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        btnTakePhoto.setOnClickListener {
            openCamera()
        }
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (resultCode == Activity.RESULT_OK && requestCode ==

MediaUtils.REQUEST_CODE_PHOTO) {
            loadImage()
        }
    }
    override fun onGlobalLayout() {
        view?.viewTreeObserver?.removeOnGlobalLayoutListener(this)
        imageWidth = imgPhoto.width
        imageHeight = imgPhoto.height
        loadImage()
    }
    private fun openCamera() {
        activity?.let {
            if (hasPermission()) {
                try {
                    val newPhotoFile = MediaUtils.newMedia(MediaUtils.MediaType.MEDIA_PHOTO)
                    photoFile = newPhotoFile
                    val photoUri = FileProvider.getUriForFile(it,
                            MediaUtils.PROVIDER_AUTHORITY, newPhotoFile)
                    val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
                    intent.putExtra(MediaStore.EXTRA_OUTPUT, photoUri)



                    startActivityForResult(intent, MediaUtils.REQUEST_CODE_PHOTO)
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            } else {
                requestPermissions(RC_OPEN_CAMERA)
            }
        }
    }
    private fun loadImage() {
        val file = photoFile
        if (file?.exists() == true) {
            if (hasPermission()) {
                launch {
                    val bitmap = withContext(Dispatchers.IO) {
                        MediaUtils.loadImage(file, imageWidth, imageHeight)
                    }
                    imgPhoto.setImageBitmap(bitmap)
                    activity?.let {
                        MediaUtils.saveLastMediaPath(it,
                                MediaUtils.MediaType.MEDIA_PHOTO, file.absolutePath)
                    }
                }
            } else {
                requestPermissions(RC_LOAD_PHOTO)
            }
        }
    }
    override fun onRequestPermissionsResult(requestCode: Int,
                                            permissions: Array<out String>,
                                            grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (grantResults.none { it == PackageManager.PERMISSION_DENIED }) {
            when (requestCode) {
                RC_LOAD_PHOTO -> loadImage()
                RC_OPEN_CAMERA -> openCamera()
            }
        }
    }
    companion object {
        private const val RC_LOAD_PHOTO = 1
        private const val RC_OPEN_CAMERA = 2
    }
}

No método onActivityCreated(Bundle) tenta-se obter o caminho última imagem



que foi carregada utilizando o método getLastMediaPath(String,MediaType) da classe
MediaUtils. Em caso de sucesso, esse caminho é armazenado no atributo
photoFile.

O onCreateView(LayoutInflater,ViewGroup,Bundle) possui um detalhe interessante:
após carregar o layout do fragment uma chamada é feita ao método
addGlobalListener(ViewTreeObserver.OnGlobalLayoutListener) do objeto ViewTreeObserver
obtido por meio da propriedade viewTreeObserver da view que foi carregada.
Essa instrução é importante, pois ao inicializar a view do fragment, ainda não
são conhecidas as dimensões (largura e altura) de cada componente.
Entretanto, essa informação é necessária para exibir a foto no ImageView em
um tamanho otimizado. No método onGlobalLayout(), que é chamado quando o
layout está pronto e com as dimensões definidas, a imagem é carregada e a
classe é desregistrada como listener das mudanças de layout invocando
removeOnGlobalLayoutListener(ViewTreeObserver.OnGlobalLayoutListener), pois nesse
exemplo esse evento só é necessário uma vez.

Ao clicar no botão btnTakePhoto o fluxo de tirar uma foto é iniciado com a
chamada ao método openCamera(). Nele, é checado inicialmente se a aplicação
possui a permissão de armazenamento no cartão de memória. Em caso
positivo, a classe MediaUtils gera um novo arquivo para armazenar a foto que
será tirada pelo aplicativo de câmera. Para que a câmera tenha acesso a esse
arquivo, é gerada uma Uri por meio do método getUriForFile(Context,String,File) da
classe FileProvider. Por fim, a aplicação de câmera é chamada usando a ação
ACTION_IMAGE_CAPTURE e a Uri do arquivo é passada no parâmetro
EXTRA_OUTPUT. Sem ela, a imagem seria salva com tamanho e qualidade
inferior a que a câmera realmente tirou e não seria salva no sistema de
arquivos. Como a câmera foi chamada com startActivityForResult(Intent,int), o
resultado, ou seja, a foto tirada, deve ser tratada no método
onActivityResult(int,int,Intent).

Nesse método é verificado se o resultado que está vindo é da requisição
feita pela nossa tela. Isso é feito checando se o requestCode é igual a
REQUEST_CODE_PHOTO e se o usuário realmente tirou a foto checando se o
resultCode é igual a RESULT_OK. Nesse caso, o método loadImage() é chamado. A
foto que é tirada com as câmeras atuais requer muita memória para ser
alocada; sendo assim, o carregamento da imagem é feito de forma assíncrona
utilizando as coroutines. Finalmente, a imagem é atribuída ao ImageView e o



caminho da imagem carregada é salvo.
Para testar esse exemplo, adicione este fragment ao arquivo de layout

res/layout/activity_main.xml:
<fragment
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/fragmentPhoto"
    class="dominando.android.multimidia.CameraPhotoFragment" />

Execute a aplicação e clique no botão para abrir o aplicativo de câmera
conforme a Figura 25.1.

Figura 25.1 – Aplicação de câmera em execução.
Ao tirar a foto, um preview será exibido onde é preciso confirmar o uso da

foto. Feita essa confirmação, a aplicação de câmera será fechada. Ao voltar
para a aplicação, a foto recém-capturada será exibida como mostra a Figura
25.2.



Figura 25.2 – Aplicação exibindo foto recém-capturada.
Como pode ser visto neste exemplo, é muito simples tirar fotos utilizando o

aplicativo de câmera do aparelho, bem como utilizá-las na aplicação. Assim,
uma boa foto merece ficar no papel de parede do seu aparelho, não é?

Alterando o papel de parede do aparelho
É possível alterar o papel de parede do aparelho utilizando a classe
WallpaperManager como mostra o código a seguir:
val bitmap = BitmapFactory.decodeFile(photoPath?.absolutePath)
WallpaperManager.getInstance(activity).setBitmap(bitmap)

Para utilizar esse código é preciso adicionar a permisão SET_WALLPAPER ao
AndroidManifest.xml:
<uses-permission android:name="android.permission.SET_WALLPAPER"/>

Lembre-se de que alterar o papel de parede, assim como o carregamento de
qualquer imagem maior, é uma operação que demanda alguns segundos,
então é aconselhável fazê-la em background. Adicione mais um botão no
arquivo de layout res/layout/fragment_camera_photo.xml:
<ImageButton
    android:layout_width="wrap_content"



    android:layout_height="wrap_content"
    android:src="@android:drawable/ic_menu_gallery"
    android:id="@+id/btnWallpaper" />

Configure o seu evento de clique no onViewCreated(View,Bundle):
btnWallpaper.setOnClickListener {
    setCurrentImageAsWallpaper()
}

E defina o método setCurrentImageAsWallpaper(), como a seguir:
import android.app.WallpaperManager
import android.content.Context
import android.util.DisplayMetrics
import android.widget.Toast
import kotlinx.coroutines.experimental.DefaultDispatcher
import kotlinx.coroutines.experimental.withContext
 
class CameraPhotoFragment ... {
    ...
    private fun setCurrentImageAsWallpaper() {
        val path = photoFile
        if (path != null) {
            launch {
                val windowManager = requireActivity()
                        .getSystemService(Context.WINDOW_SERVICE) as WindowManager
                val metrics = DisplayMetrics()
                windowManager.defaultDisplay.getMetrics(metrics)
                val bitmap = withContext(Dispatchers.IO) {
                    MediaUtils.loadImage(path, metrics.widthPixels, metrics.heightPixels)
                }
                if (bitmap != null) {
                    try {
                        withContext(Dispatchers.Default) {
                            WallpaperManager.getInstance(activity).setBitmap(bitmap)
                        }
                        Toast.makeText(activity,
                                "Papel de parede alterado", Toast.LENGTH_SHORT).show()
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
        }
    }
    ...
}



Perceba que o tamanho da tela do aparelho é obtido por meio das classes
WindowManager e DisplayMetrics. Dessa forma, a imagem carregada será
redimensionada para ter a proporção da tela do aparelho. Note também que
dois processos assíncronos estão sendo realizados nesse exemplo utilizando o
método withContext(CoroutinesContext, ()->T). O primeiro carrega a imagem do
sistema de arquivos, e o segundo altera o papel de parede.

Gravando vídeos
A gravação de vídeo é bem similar à captura de fotos. Demonstraremos o uso
desse recurso na classe CameraVideoFragment e seu layout está descrito no
arquivo res/layout/fragment_camera_video.xml mostrado a seguir:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    <ImageButton
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_camera"
        android:id="@+id/btnVideo" />
    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="@android:color/black">
        <VideoView
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_gravity="center"
            android:id="@+id/videoView" />
    </FrameLayout>
</LinearLayout>

O detalhe aqui é o componente VideoView, que fornece uma maneira simples
de reproduzir um arquivo de vídeo do sistema de arquivos ou que esteja
dentro do APK. Por exemplo, o fragmento de código a seguir executa um
vídeo armazenado na pasta res/raw:
val uri = Uri.parse("android.resource://" + activity?.packageName + "/raw/arquivo_video")
videoView.setVideoURI(uri)
videoView.requestFocus()
videoView.start()



Como o vídeo está dentro do APK (Android Package), foi utilizada a Uri
com o prefixo android.resource:// seguido do pacote da aplicação e do caminho do
arquivo. Para carregar o vídeo na VideoView o método setVideoURI(Uri) foi
utilizado. O método start() iniciará a execução do vídeo.

Implemente a classe CameraVideoFragment que exibirá um vídeo gravado pela
câmera do aparelho e armazenado no sistema de arquivos. Deixe a classe da
seguinte forma:
import android.app.Activity
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.provider.MediaStore
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.ViewTreeObserver
import android.widget.MediaController
import kotlinx.android.synthetic.main.fragment_camera_video.*
 
class CameraVideoFragment : MultimediaFragment(), ViewTreeObserver.OnGlobalLayoutListener {
    private var videoUri: Uri? = null
    private var position: Int = 0
    private var isPlaying: Boolean = false
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        retainInstance = true
        if (videoUri == null) {
            val videoPath = MediaUtils.getLastMediaPath(
                    requireActivity(), MediaUtils.MediaType.MEDIA_VIDEO)
            if (videoPath != null) {
                videoUri = Uri.parse(videoPath)
            }
        }
    }
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        val layout = inflater.inflate(
                R.layout.fragment_camera_video, container, false)
        layout.viewTreeObserver.addOnGlobalLayoutListener(this)
        return layout
    }



    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        videoView.setMediaController(MediaController(activity))
        btnVideo.setOnClickListener {
            openCamera()
        }
    }
    override fun onPause() {
        isPlaying = videoView.isPlaying
        position = videoView.currentPosition
        if (position == videoView.duration) {
            position = 0
        }
        super.onPause()
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == MediaUtils.REQUEST_CODE_VIDEO && resultCode ==

Activity.RESULT_OK) {
            loadVideo()
        }
    }
    override fun onGlobalLayout() {
        view?.viewTreeObserver?.removeOnGlobalLayoutListener(this)
        loadVideo()
    }
    private fun openCamera() {
        if (hasPermission()) {
            activity?.let {
                try {
                    videoUri = MediaUtils.getVideoUri(requireContext())
                    val captureVideoIntent = Intent(MediaStore.ACTION_VIDEO_CAPTURE).apply {
                        putExtra(MediaStore.EXTRA_OUTPUT, videoUri)
                    }
                    if (captureVideoIntent.resolveActivity(it.packageManager) != null) {
                        startActivityForResult(captureVideoIntent, MediaUtils.REQUEST_CODE_VIDEO)
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        } else {
            requestPermissions(RC_OPEN_CAMERA)
        }
    }



    private fun loadVideo() {
        activity?.let {
            videoUri?.let { uri ->
                if (hasPermission()) {
                    videoView.setVideoURI(uri)
                    videoView.seekTo(position)
                    if (isPlaying) {
                        videoView.start()
                    }
                    MediaUtils.saveLastMediaPath(it,
                            MediaUtils.MediaType.MEDIA_VIDEO,
                            uri.toString())
                } else {
                    requestPermissions(RC_LOAD_VIDEO)
                }
            }
        }
    }
    override fun onRequestPermissionsResult(requestCode: Int,
                                            permissions: Array<out String>,
                                            grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (grantResults.none { it == PackageManager.PERMISSION_DENIED }) {
            when (requestCode) {
                RC_LOAD_VIDEO -> loadVideo()
                RC_OPEN_CAMERA -> openCamera()
            }
        }
    }
    companion object {
        private const val RC_LOAD_VIDEO = 1
        private const val RC_OPEN_CAMERA = 2
    }
}

Essa classe é bem similar à anterior, então observe as diferenças entre elas.
O VideoView por si só não contém o controle de play e pause, bem como um
indicador de progresso do vídeo, e para exibir esses controles é utilizado o
método setMediaController(MediaController).

Assim como foi feito para tirar uma foto, o aplicativo de câmera é invocado
ao clicar no botão por meio do método openCamera(), mas dessa vez foi usada a
ação ACTION_VIDEO_CAPTURE. Ao voltar do aplicativo de câmera, o método
onActivityResult (int,int,Intent) será chamado, e em loadVideo() essa videoUri é atribuída



ao componente VideoView por meio do método setVideoURI(Uri). Por fim, a
execução do vídeo é solicitada chamando o método start() do VideoView.

Outro ponto que merece atenção é tratar a mudança de orientação para que
o vídeo não seja reiniciado. No onPause() são armazenadas duas informações
sobre o vídeo: o atributo isPlaying do VideoView informa se o vídeo está
executando; e a posição atual do vídeo que é obtida com currentPosition e da
VideoView e armazenada no atributo position.

Para posicionar a execução do vídeo em um momento específico, é usado o
método seekTo(int); e se o vídeo estava executando antes de rotacionar a tela, a
execução é retomada com o método start().

Altere o arquivo de layout da MainActivity para exibir esse fragment e execute
a aplicação, que deve ficar como na Figura 25.3.
<fragment
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/fragmentVideo"
    class="dominando.android.multimidia.CameraVideoFragment" />

Execute a aplicação e grave um vídeo com a câmera do aparelho. Em
seguida, execute com o vídeo e ele deve funcionar corretamente.



Figura 25.3 – Executando o vídeo dentro da aplicação.

Criando uma activity de câmera
Nos dois exemplos anteriores simplesmente foi disparada uma Intent para a
aplicação de câmera e o resultado capturado na activity da aplicação. Um
recurso muito comum é adicionar a câmera dentro do próprio aplicativo. Para
projetar os frames capturados pela câmera dentro do aplicativo deve-se
utilizar a classe android.hardware.Camera e android.view.SurfaceView. Para gravar vídeos
será utilizada a classe android.media.MediaRecorder.

Nesse exemplo será criada uma activity de câmera que qualquer aplicativo
possa chamar para gravar vídeos ou tirar fotos. Para isso, deve-se adicionar
no AndroidManifest.xml a permissão para acessar a câmera e indicar que esse
recurso de hardware será utilizado:
<uses-permission android:name="android.permission.CAMERA"/>
<uses-permission android:name="android.permission.RECORD_AUDIO" />
<uses-feature android:name="android.hardware.camera"/>
<uses-feature android:name="android.hardware.camera.autofocus"/>

Para gravar vídeos com áudio, é necessário adicionar também a permissão
RECORD_AUDIO. Na última tag, informamos que vamos usar o recurso de
autofoco da câmera, o que nos ajuda na captura da imagem.

Adicione uma nova activity ao projeto chamada DominandoCameraActivity e
ajuste sua declaração no AndroidManifest.xml para ficar como a seguir:
<activity
    android:name=".DominandoCameraActivity"
    android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
    android:screenOrientation="userLandscape">
    <intent-filter>
        <action android:name="android.media.action.IMAGE_CAPTURE"/>
        <category android:name="android.intent.category.DEFAULT"/>
    </intent-filter>
    <intent-filter>
        <action android:name="android.media.action.VIDEO_CAPTURE"/>
        <category android:name="android.intent.category.DEFAULT"/>
    </intent-filter>
</activity>

O tema da activity foi definido como full screen para usar o tamanho
máximo da tela com a câmera. A activity será mantida em uma orientação
fixa (em landscape) e ela atenderá pelas ações de IMAGE_CAPTURE e



VIDEO_CAPTURE, as mesmas que foram usadas nas seções anteriores. Dessa
forma, quando a aplicação for executada, o Android perguntará com qual
câmera o usuário deseja tirar a foto ou gravar o vídeo, conforme mostrado na
Figura 25.4.

Figura 25.4 – Activity como opção de captura de foto e vídeo.
Editaremos o arquivo de layout res/layout/activity_dominando_camera.xml

para que fique da seguinte forma:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/rootCameraLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:keepScreenOn="true">
    <FrameLayout
        android:id="@+id/vwPreviewCamera"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />



    <Button
        android:id="@+id/btnCapture"
        android:layout_width="100dp"
        android:layout_height="0dp"
        android:layout_gravity="center_vertical|end"
        android:background="#CCCC"
        android:text="Capturar"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="@+id/vwPreviewCamera"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

O layout é bem simples, o detalhe aqui é que o FrameLayout está apenas
preenchendo o espaço onde ficará a pré-visualização da câmera, pois em
tempo de execução será adicionada uma SurfaceView, que é uma superfície
dedicada e eficiente na qual pode-se desenhar livremente e com uma
performance excelente. Para evitar que a visualização da câmera fique
distorcida, foi utilizado o ConstraintLayout, que já possui uma propriedade para
exibir uma View em determinado aspect ratio.

Neste exemplo o que será desenhado serão os frames vindos da câmera.
Para isso crie a classe CameraSurfaceView listada a seguir:
import android.content.Context
import android.hardware.Camera
import android.view.SurfaceHolder
import android.view.SurfaceView
import android.view.View
import java.io.IOException
 
class CameraSurfaceView(context: Context, private val camera: Camera) :
        SurfaceView(context), SurfaceHolder.Callback {
 
    var previewSizeReadyCallback: ((Int, Int)->Unit)? = null
    private var previewSize: Camera.Size? = null
 
    init {
        holder.addCallback(this)
    }
    override fun surfaceCreated(holder: SurfaceHolder) {
        try {
            camera.setPreviewDisplay(holder)
            camera.startPreview()
        } catch (e: IOException) {
            e.printStackTrace()



        }
    }
    override fun surfaceDestroyed(holder: SurfaceHolder) {
    }
    override fun surfaceChanged(holder: SurfaceHolder, format: Int, w: Int, h: Int) {
        if (holder.surface == null) {
            return
        }
        try {
            camera.stopPreview()
        } catch (e: Exception) {
            e.printStackTrace()
        }
        try {
            val parameters = camera.parameters
            parameters.setPreviewSize(previewWidth(), previewHeight())
            camera.parameters = parameters
            camera.setPreviewDisplay(holder)
            camera.startPreview()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        val width = View.resolveSize(suggestedMinimumWidth, widthMeasureSpec)
        val height = View.resolveSize(suggestedMinimumHeight, heightMeasureSpec)
        setMeasuredDimension(width, height)
        try {
            if (camera.parameters.supportedPreviewSizes != null) {
                previewSize = getOptimalPreviewSize(
                    camera.parameters.supportedPreviewSizes, width, height
                )
                previewSizeReadyCallback?.invoke(previewWidth(), previewHeight())
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
    private fun previewWidth() = previewSize?.width ?: 0
    private fun previewHeight() = previewSize?.height ?: 0
 
    private fun getOptimalPreviewSize(sizes: List<Camera.Size>?, w: Int, h: Int): Camera.Size? {
        val ASPECT_TOLERANCE = 0.1
        val targetRatio = h.toDouble() / w
        if (sizes == null) return null



        var optimalSize: Camera.Size? = null
        var minDiff = Double.MAX_VALUE
        for (size in sizes) {
            val ratio = size.width.toDouble() / size.height
            if (Math.abs(ratio - targetRatio) > ASPECT_TOLERANCE) continue
            if (Math.abs(size.height - h) < minDiff) {
                optimalSize = size
                minDiff = Math.abs(size.height - h).toDouble()
            }
        }
        if (optimalSize == null) {
            minDiff = java.lang.Double.MAX_VALUE
            for (size in sizes) {
                if (Math.abs(size.height - h) < minDiff) {
                    optimalSize = size
                    minDiff = Math.abs(size.height - h).toDouble()
                }
            }
        }
        return optimalSize
    }
}

Perceba que a classe implementa a interface SurfaceHolder.Callback, que permite
ter conhecimento sobre mudanças ocorridas na SurfaceView e contém os
seguintes métodos:

• surfaceCreated(SurfaceHolder) – é chamado apenas na primeira vez em que a
SurfaceView é criada. Nesse momento, o SurfaceHolder recebido como
parâmetro é passado para o método setPreviewDisplay(SurfaceHolder). Com isso,
os frames vindos da câmera serão desenhados na SurfaceView. Em seguida,
a visualização da câmera é iniciada com o método startPreview();

• surfaceDestroyed(SurfaceHolder) – método disparado quando a SurfaceView é
destruída;

• surfaceChanged(SurfaceHolder) – invocado quando alguma mudança de formato
ou tamanho da SurfaceView acontece. Nesse momento, a pré-visualização da
câmera é interrompida usando stopPreview() e logo em seguida tenta-se
iniciar a visualização novamente.

Ao invocar o método addCallback(SurfaceHolder.Callback) é informado que a
própria classe tratará os eventos de mudança na SurfaceView.

Para exibir uma câmera dentro do aplicativo é essencial respeitar a



proporção de tela (aspect ratio). Como a câmera do aparelho não suporta
todas as proporções, é necessário calcular a proporção que melhor se adéqua
ao tamanho da SurfaceView. O método onMeasure(Int,Int) é chamado quando a View
tem o seu tamanho determinado, e nesse momento é invocado o método
getOptimalPreviewSize(List<Camera.Size>,Int,Int)1 para obter a melhor proporção de tela
suportada pela câmera. Ao obter essa informação, o callback
previewSizeReadyCallback será chamado passando a largura e altura. Essa
informação será utilizada para redimensionar o vwPreviewCamera definido no
arquivo de layout.

Implemente agora a classe DominandoCameraActivity que deve ficar como a
seguir:
import android.Manifest
import android.app.Activity
import android.content.pm.PackageManager
import android.hardware.Camera
import android.media.MediaRecorder
import android.net.Uri
import android.os.Bundle
import android.provider.MediaStore
import androidx.core.app.ActivityCompat
import kotlinx.android.synthetic.main.activity_dominando_camera.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlin.coroutines.CoroutineContext
class DominandoCameraActivity : Activity(), CoroutineScope {
    private var camera: Camera? = null
    private var surfacePreview: CameraSurfaceView? = null
    private var mediaRecorder: MediaRecorder? = null
    private var isRecording: Boolean = false
    private var inPreviewMode: Boolean = false
    private var outputUri: Uri? = null
 
    lateinit var job: Job
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job
 
    public override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_dominando_camera)
        val uri = intent.getParcelableExtra<Uri>(MediaStore.EXTRA_OUTPUT)
        if (uri != null) {



            outputUri = uri
        }
        btnCapture.setOnClickListener {
            val action = intent.action
            if (action == MediaStore.ACTION_IMAGE_CAPTURE) {
                takePicture()
            } else if (action == MediaStore.ACTION_VIDEO_CAPTURE) {
                recordVideo()
            }
        }
        job = Job()
    }
    override fun onResume() {
        super.onResume()
        if (isCameraAvailable()) {
            if (hasPermissions()) {
                openCamera()
            } else {
                requestPermissions()
            }
        }
    }
    override fun onPause() {
        super.onPause()
        releaseMediaRecorder()
        releaseCamera()
        if (isRecording) {
            contentResolver.delete(outputUri, null, null)
        }
    }
    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
    }
    override fun onBackPressed() {
        super.onBackPressed()
        setResult(RESULT_CANCELED)
        outputUri?.let { uri ->
            contentResolver.delete(uri, null, null)
        }
    }
    private fun hasPermissions(): Boolean {
        return ActivityCompat.checkSelfPermission(this,
                Manifest.permission.CAMERA) ==
                PackageManager.PERMISSION_GRANTED &&



                ActivityCompat.checkSelfPermission(this,
                        Manifest.permission.WRITE_EXTERNAL_STORAGE) ==
                PackageManager.PERMISSION_GRANTED &&
                ActivityCompat.checkSelfPermission(this,
                        Manifest.permission.RECORD_AUDIO) ==
                PackageManager.PERMISSION_GRANTED
    }
    private fun requestPermissions() {
        ActivityCompat.requestPermissions(this,
                arrayOf(Manifest.permission.CAMERA,
                        Manifest.permission.WRITE_EXTERNAL_STORAGE,
                        Manifest.permission.RECORD_AUDIO),
                REQUEST_PERMISSIONS)
    }
    override fun onRequestPermissionsResult(requestCode: Int,
                                            permissions: Array<out String>,
                                            grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (grantResults.none { it == PackageManager.PERMISSION_DENIED }) {
            openCamera()
        }
    }
    // Próximos métodos virão aqui
    companion object {
        const val REQUEST_PERMISSIONS = 1
    }
}

No onCreate(Bundle) é obtido o parâmetro EXTRA_OUTPUT com o caminho
completo de onde o arquivo deve ser criado. Esse parâmetro foi passado no
exemplo de câmera com intents, mas agora está sendo implementada a
própria activity de câmera, então é importante ter o mesmo comportamento.
Esse caminho é atribuído à propriedade outputUri.

Como você deve ter percebido, o código da activity está incompleto, mas
não se preocupe, vamos explicar individualmente cada método que está
ausente.

No método onResume() é checado se o aparelho possui uma câmera utilizando
o método isCameraAvailable() definido a seguir:
private fun isCameraAvailable(): Boolean {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA)
}

Com a classe PackageManager pode-se verificar se o aparelho tem determinado



recurso utilizando o método hasSystemFeature(int). Apesar de ser um recurso
comum, essa checagem resguarda a aplicação. Em seguida, a câmera do
aparelho é aberta para começar a visualização utilizando o método
openCamera():
private fun openCamera() {
    try {
        camera = Camera.open()
        camera?.let { cam ->
            surfacePreview = CameraSurfaceView(this, cam).apply {
                previewSizeReadyCallback = { w, h ->
                    val constraintSet = ConstraintSet()
                    constraintSet.clone(rootCameraLayout)
                    constraintSet.setDimensionRatio(R.id.vwPreviewCamera, "h,$w:$h")
                    constraintSet.applyTo(rootCameraLayout)
                }
            }
            vwPreviewCamera.addView(surfacePreview)
            val params = cam.parameters
            params.focusMode = Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE
            cam.parameters = params
        }
    } catch (e: Exception) {
        e.printStackTrace()
    } }

Após abrir a câmera usando o Camera.open(), um objeto CameraSurfaceView é
instanciado para que os frames da câmera sejam desenhados nele e, em
seguida, a surfacePreview é adicionada ao FrameLayout usando o método
addView(View). Um detalhe importante é que foi registrado um lambda para o
previewSizeCallback da classe CameraSurfaceView, para que o FrameLayout seja
redimensionado e respeite o aspect ratio da câmera. Com o ConstraintLayout isso
é simplificado, bastando utilizar a propriedade setDimensionRatio(Int,String). Neste
exemplo é informado que a altura (h) deve preencher a altura da tela, e a
largura deve seguir a proporção “largura:altura” (w:h), resultando em algo
como “h,1280:790”. Após adicionar a SurfaceCameraView, o modo de
autofoco da câmera é ativado:
private fun releaseMediaRecorder() {
    mediaRecorder?.run {
        reset()
        release()
    }



    camera?.lock()
    mediaRecorder = null
}
private fun releaseCamera() {
    if (camera != null) {
        camera?.release()
        camera = null
        surfacePreview?.holder?.removeCallback(surfacePreview)
    }
}

No onPause(), o método releaseCamera() é chamado para liberar o preview a
câmera por meio da chamada camera.release(). A liberação do mediaRecorder (que é
usado para gravar vídeos) é feita no método releaseMediaRecorder(). E, para
finalizar, o método lock() do objeto camera é chamado para que outras
aplicações possam acessar a câmera do aparelho.

Ainda no onPause(), está sendo tratado o cenário de pressionar a tecla de
liga/desliga, home ou back durante a gravação do vídeo. Nesse caso, o
arquivo é excluído:
private fun takePicture() {
    if (inPreviewMode) {
        setResult(RESULT_OK)
        finish()
    } else {
        camera?.takePicture(null, null, pictureCallback)
    }
}
private val pictureCallback = Camera.PictureCallback { data, camera ->
    outputUri?.let { uri ->
        try {
            val fileDescriptor = contentResolver
                    .openFileDescriptor(uri, "rw")?.fileDescriptor
            val fos = FileOutputStream(fileDescriptor)
            fos.write(data)
            fos.close()
            inPreviewMode = true
            btnCapture.text = "OK"
            camera.stopPreview()
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }
}



No evento de clique do botão, é verificado qual foi a ação disparada pelo
usuário. Nos exemplos anteriores, para tirar uma foto foi usada a ação
ACTION_IMAGE_CAPTURE, e para gravar um vídeo ACTION_VIDEO_CAPTURE.

No método takePicture() foi utilizado o atributo inPreviewMode para saber se o
usuário já clicou para capturar a foto e está apenas visualizando o preview.
Nesse caso, o resultado é definido como RESULT_OK, e a tela atual é fechada.
Porém, caso ainda não tenha tirado a foto, o método
takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback) do objeto
camera é chamado. O primeiro argumento desse método é um listener/callback
chamado quando a foto é tirada. O segundo retorna os bytes da foto capturada
sem nenhuma compressão, e o último tem o mesmo propósito do anterior,
mas os bytes retornados constituem uma imagem no formato JPEG.

O atributo pictureCallback é um listener usado para obtermos a imagem
capturada da câmera e será passado para o método que acabamos de explicar.
No onPictureTaken(byte[], Camera) (omitido pelo lambda), os bytes são lidos e
salvos no caminho do sistema de arquivos que foi recebido como parâmetro.
Também foi modificado o texto do botão e o valor do atributo inPreviewMode.

No método onBackPressed() definimos que o usuário cancelou a operação de
tirar foto, por esta razão, retornamos RESULT_CANCELED e apagamos a foto
(caso ela tenha sido tirada).

Uma vez apresentados os métodos para tirar fotos, os métodos relacionados
à gravação de vídeo serão apresentados:
private fun recordVideo() {
    if (isRecording) {
        finishRecording()
    } else {
        launch {
            val success = withContext(Dispatchers.Default) {
                prepareRecording()
            }
            if (success) {
                mediaRecorder?.start()
                btnCapture.text = "Stop"
                isRecording = true
            } else {
                releaseMediaRecorder()
            }
        }
    }



}
private fun prepareRecording(): Boolean {
    camera?.unlock()
    outputUri?.let { uri ->
        try {
            val fileDescriptor = contentResolver
                    .openFileDescriptor(uri, "rw")?.fileDescriptor
            mediaRecorder = MediaRecorder().apply {
                setCamera(camera)
                setAudioSource(MediaRecorder.AudioSource.CAMCORDER)
                setVideoSource(MediaRecorder.VideoSource.CAMERA)
                setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH))
                setOutputFile(fileDescriptor)
                setMaxDuration(60_000) // 1 minuto
                setOnInfoListener { mr, what, extra ->
                    if (what ==

MediaRecorder.MEDIA_RECORDER_INFO_MAX_DURATION_REACHED) {
                        finishRecording()
                    }
                }
                setPreviewDisplay(surfacePreview?.holder?.surface)
            }
            mediaRecorder?.prepare()
        } catch (e: IOException) {
            e.printStackTrace()
            releaseMediaRecorder()
            return false
        }
    }
    return true
}
private fun finishRecording() {
    mediaRecorder?.stop()
    releaseMediaRecorder()
    camera?.lock()
    isRecording = false
    val it = Intent()
    it.data = outputUri
    setResult(RESULT_OK, it)
    finish()
}

No método recordVideo() é verificado se a gravação foi iniciada por meio do
atributo isRecording; nesse caso o método finishRecording() é chamado, o
mediaRecorder é interrompido, a câmera é liberada, o caminho do vídeo que foi



gravado é retornado para a activity que iniciou a gravação do vídeo e a tela é
encerrada.

Caso a gravação ainda não tenha sido iniciada, o método prepareRecording() é
chamado e a gravação é iniciada usando o método start() do mediaRecorder.

No método prepareRecording(), os parâmetros para a gravação do vídeo são
configurados. Primeiramente, a câmera é desbloqueada usando o método
unlock() para que possa ser usada, em seguida, o MediaRecorder é instanciado e a
câmera é atribuída a ele usando o método setCamera(Camera). Logo após, as
fontes de áudio e vídeo usando o setAudioSource(int) e setVideoSource(int) são
definidas, bem como a qualidade do vídeo por meio do método
setProfile(CamcorderProfile). Nesse exemplo foi usada uma gravação com a melhor
qualidade possível (CamcorderProfile.QUALITY_HIGH).

O caminho onde o vídeo será gravado é definido com o método setOutputFile
(String) e a duração máxima do vídeo com o setMaxDuration(int) passando o limite
de um minuto (6.000 milissegundos). Como esse limite foi definido, é preciso
saber quando ele foi alcançado; isso é feito definindo um listener com o
método setOnInfoListener(OnInfoListener). Nele é verificado se o evento ocorrido foi
o de duração máxima alcançada
(MEDIA_RECORDER_INFO_MAX_DURATION_REACHED) e, nesse caso, a gravação
concluída.

Os últimos detalhes do método prepareRecording() são: o preview da gravação
que está usando a instância da classe CameraSurfaceView; e a chamada ao método
prepare() para que o mediaRecorder se prepare para começar a gravação. No
método recordVideo(), se tudo correr bem com a preparação do mediaRecorder, a
gravação é iniciada, caso contrário liberamos o mediaRecorder no método
releaseMediaRecorder().

Como a aplicação agora trata a ação de câmera, é preciso fazer uma
pequena modificação na MultimediaFragment:
abstract class MultimediaFragment : Fragment() {
    protected fun hasPermission(): Boolean {
        val permissions = listOf(
                Manifest.permission.WRITE_EXTERNAL_STORAGE,
                Manifest.permission.CAMERA
        )
        return permissions.all {
            ActivityCompat.checkSelfPermission(requireActivity(), it) ==
                    PackageManager.PERMISSION_GRANTED



        }
    }
    protected fun requestPermissions(requestCode: Int = REQUEST_CODE_PERMISSION) {
        requestPermissions(arrayOf(
                Manifest.permission.WRITE_EXTERNAL_STORAGE,
                Manifest.permission.CAMERA), requestCode)
    }
    companion object {
        const val REQUEST_CODE_PERMISSION = 1
    }
}

Teste a DominandoCameraActivity com os dois fragments desenvolvidos
anteriormente nesta seção. Tente tirar a foto e gravar o vídeo e perceberá que
a activity está se comportando como a câmera nativa do aparelho, conforme é
possível observar na Figura 25.5.

Figura 25.5 – Activity de câmera em execução.

Camera1, Camera2 e bibliotecas
Como é possível observar, a classe DominandoCameraActivity possui trechos
informando que algumas classes estão obsoletas (deprecated). Isso acontece
porque a API de câmera existente no Android desde a sua primeira versão
(android.hardware) foi substituída pela Camera2 API (android.hardware.camera2) no
Android Lollipop (API Level 21). Entretanto, até o término da escrita deste
livro não existia uma documentação oficial no site para desenvolvedores
Android (developer.android.com) mesmo após quatro anos do seu
lançamento. Por essa razão, o exemplo da seção anterior foi mantido, uma
vez que ele é totalmente funcional e ainda atende à maioria dos casos,
inclusive em versões mais recentes do Android.



A API de Camera1 é relativamente simples, mas bastante limitada. Com a
API de Camera2, o desenvolvedor tem maior controle sobre os recursos da
câmera. Uma comparação que é feita entre essas duas APIs é que a Camera1
é como uma câmera digital simples de point-and-shot, já a Camera2 API é
como uma câmera profissional DSLR (Digital Single Lens Reflex) que
proporciona uma foto mais profissional, mas que precisa realizar mais
configurações para obter uma foto melhor.

A título de comparação, um código para tirar uma foto e gravar um vídeo
com a API de Camera2 pode possuir cerca de três vezes mais linhas de
código do que foi implementado aqui. Por essa razão, não será demonstrado
aqui a utilização da Camera2, mas caso você precise de fotos com uma
qualidade melhor que a proporcionada pela Camera1, consulte futuramente o
repositório do livro ou um dos seguintes repositórios do Google:

• demonstrando como tirar fotos
(https://github.com/googlesamples/android-Camera2Basic);

• gravando vídeos (https://github.com/googlesamples/android-
Camera2Video);

• Capturando frames da câmera e demonstrando o uso de autofocus,
autoexposure, auto-white-balance etc.
(https://github.com/googlesamples/android-Camera2Raw).

Dependendo da necessidade do seu aplicativo, pode valer a pena utilizar
alguma biblioteca para facilitar o trabalho com a câmera. As duas mais
populares são:

• Camera Kit (https://github.com/CameraKit/camerakit-android)
• Fotoapparat (https://github.com/Fotoapparat/Fotoapparat)
Cada uma dessas opções possui seus prós e contras, por isso é necessário

analisar a opção que melhor se adéqua ao projeto.

Mobile Vision API
A Mobile Vision API é uma biblioteca que permite detectar objetos em fotos
ou vídeos. Atualmente é possível detectar rostos, textos e códigos de barras
(1D e 2D) utilizando detectors disponibilizados pela API. Durante a escrita
deste livro essa API estava sendo incorporada pela MLKit do Firebase, que é
uma biblioteca compacta de machine learning (aprendizado de máquina) para



ser utilizada em dispositivos mobile.
A utilização dessa API é bastante simples. Vejamos o exemplo a seguir

para detectar um código de barras:
val detector = BarcodeDetector.Builder(context)
        .setBarcodeFormats(Barcode.ALL_FORMATS)
        .build()
// Detecção não está funcionando
if (!detector.isOperational) return
 
val frame = Frame.Builder().setBitmap(myBitmap).build()
val barCodes = detector.detect(frame)
if (barCodes.size() > 0) {
    // barcode detectado
    val barCode = barCodes.valueAt(0)
    barCode.rawValue
}

Foi declarado um detector utilizando a classe BarcodeDetector.Builder informando
para detectar todos os tipos de códigos de barras, mas pode-se especificar
apenas os que forem necessários. No momento da escrita deste livro são
suportados 25 tipos de códigos de barras.

Após instanciar o detector, é verificado se o detector possui todos os
requisitos para funcionar utilizando a propriedade isOperational. Com a classe
Frame.Builder, um objeto Frame é criado a partir de um Bitmap para que ele possa
ser reconhecido pelo detector. Por fim, o método detect(Frame) do BarcodeDetector é
chamado e ele retorna um SparseArray<Barcode>. Se essa lista não estiver vazia, é
porque algum código de barras foi detectado. Nesse caso, é pego apenas o
primeiro e o seu conteúdo é lido utilizando a propriedade rawValue.

Esse valor segue o formato <tipo>:<conteúdo>, onde a primeira parte é o tipo do
código de barras (o mesmo que pode-se informar no BarcodeDetector.Builder) e a
segunda parte é o valor detectado.

A abordagem para outos tipos de detecção é bem similar, por exemplo, para
detectar faces usa-se o FaceDetector e textos o TextRecognizer.

Entretanto, se você já utilizou algum leitor de código de barras, você já
deve ter percebido que ele detecta o conteúdo utilizando a câmera do
aparelho. Vejamos como implementar essa lógica.

Adicione a seguinte dependência no build.gradle:
dependencies {
    def mlkit_version = '19.0.2'



    ...
    implementation "com.google.firebase:firebase-ml-vision:$mlkit_version"
}

Perceba que foi utilizada a dependência do Firebase MLKit, que até esta
versão contém a Mobile Vision API.

Crie o arquivo de layout res/layout/fragment_camera_detection.xml e
deixe-o como a seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/relativeLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <SurfaceView
        android:id="@+id/surfaceView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <TextView
        android:id="@+id/txtBarCode"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginStart="16dp"
        android:layout_marginEnd="16dp"
        android:layout_marginBottom="16dp"
        android:background="#9CCC"
        android:padding="16dp"
        android:textColor="@android:color/white"
        android:textSize="20sp"
        app:layout_constraintBottom_toBottomOf="@+id/surfaceView"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

O arquivo de layout não possui nada de especial. A SurfaceView exibirá o
conteúdo da câmera enquanto o TextView exibirá o resultado do que for
detectado.

Crie a classe CameraDetectionFragment e deixe-a como a seguir:
import android.annotation.SuppressLint
import android.content.pm.PackageManager



import android.os.Bundle
import android.view.LayoutInflater
import android.view.SurfaceHolder
import android.view.View
import android.view.ViewGroup
import com.google.android.gms.vision.CameraSource
import com.google.android.gms.vision.Detector
import com.google.android.gms.vision.barcode.Barcode
import com.google.android.gms.vision.barcode.BarcodeDetector
import kotlinx.android.synthetic.main.fragment_camera_detection.*
import java.io.IOException
 
class CameraDetectionFragment : MultimediaFragment() {
    private val detector: BarcodeDetector by lazy {
        BarcodeDetector.Builder(activity)
                .setBarcodeFormats(Barcode.ALL_FORMATS)
                .build()
    }
    private val cameraSource: CameraSource by lazy {
        CameraSource.Builder(activity, detector)
                .setFacing(CameraSource.CAMERA_FACING_BACK)
                .setAutoFocusEnabled(true)
                .setRequestedPreviewSize(800, 512)
                .build()
    }
    override fun onCreateView(inflater: LayoutInflater,
                              container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_camera_detection,
                container, false)
    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        initProcessor()
        surfaceView.holder.addCallback(object: SurfaceHolder.Callback {
            override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) {
            }
            override fun surfaceDestroyed(holder: SurfaceHolder?) {
                cameraSource.stop()
            }
            override fun surfaceCreated(holder: SurfaceHolder?) {
                startDetection()
            }
        })
    }



    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>,
grantResults: IntArray) {

        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (grantResults.none { it == PackageManager.PERMISSION_DENIED }) {
            startDetection()
        }
    }
    private fun initProcessor() {
        detector.setProcessor(object: Detector.Processor<Barcode> {
            override fun release() {
            }
            override fun receiveDetections(detections: Detector.Detections<Barcode>) {
                val barCodes = detections.detectedItems
                if (barCodes.size() != 0) {
                    txtBarCode.post {
                        txtBarCode.text = barCodes.valueAt(0).displayValue
                    }
                }
            }
        })
    }
    @SuppressLint("MissingPermission")
    private fun startDetection() {
        if (hasPermission()) {
            try {
                cameraSource.start(surfaceView.holder)
            } catch (ex: IOException) {
                ex.printStackTrace()
            }
        } else {
            requestPermissions()
        }
    }
    override fun onDestroy() {
        super.onDestroy()
        cameraSource.release()
        detector.release()
    }
}

O primeiro atributo da classe é o detector do tipo BarDetector. Ele é instanciado
utilizando a classe BarDetector.Builder informando que todos os tipos de códigos
de barras devem ser detectados. O atributo cameraSource como o próprio nome
diz, define que a câmera do aparelho será a fonte das imagens que serão
processadas pela API para tentar reconhecer o código de barras. O método



setFacing(int) indica se a câmera que deve ser utilizada é a frontal ou traseira. O
autofoco é habilitado por meio do método setAutoFocusEnabled(boolean). Por fim,
foi definido o tamanho do frame que será capturado com o método
setRequestedPreviewSize(int,int). Quanto menor o frame, mais rápida a detecção,
porém um frame muito pequeno pode ser difícil de detectar. Então, na prática
é importante encontrar um tamanho de frame ideal em uma aplicação real.

No método onViewCreated(View,Bundle) é invocado o método initProcessor() que
atribuirá um Detector.Processor ao detector. A nomenclatura dessa API deixa claro
que esta classe processará os objetos de determinado tipo, que nesse exemplo
será do tipo Barcode. Quando um ou mais códigos de barras forem detectados,
o método receiveDetections(Detector.Detections) será invocado. Então é só obter os
objetos detectados por meio da propriedade detectedItems do objeto detections.

Neste exemplo a propriedade displayValue do objeto Barcode é utilizada para ter
uma visualização amigável do código de barras detectado. Podem-se obter
informações mais detalhadas de acordo com o tipo de código de barras.
Primeiramente deve-se obter o tipo do código de barras utilizando a
propriedade valueFormat, em seguida, de acordo com o tipo, podem-se obter as
informações de acordo com a Tabela 25.1.

Tabela 25.1 – Informações adicionais do código de barras
Propriedade

da classe Tipo Descrição
Barcode

calendarEvent Barcode.CalendarEvent Se o valueFormat for CALENDAR_EVENT, traz informações de um evento
como: local, descrição, data de início e fim etc.

contactInfo Barcode.ContactInfo Se o valueFormat for CONTACT_INFO, traz informações do contato como:
nome, emails, telefones, endereços etc.

email Barcode.Email Se o valueFormat for EMAIL, traz as informações de um email como: se é o
email pessoal ou profissional, o endereço de email em si, o corpo e assunto
do email.

geoPoint Barcode.GeoPoint Se o valueFormat for GEO, traz a latitude e longitude do local.
phone Barcode.Phone Se o valueFormat for PHONE, traz o número do telefone e o tipo (casa,

trabalho, celular etc.).
sms Barcode.Sms Se o valueFormat for SMS, traz o número do telefone e mensagem.
url Barcode.UrlBookmark Se o valueFormat for URL, traz o título e o endereço do site.
wifi Barcode.WiFi Se o valueFormat for WIFI, traz o tipo de encriptação da rede (aberta, WPA

ou WEP), o nome da rede e a senha.

Um detalhe importante é que a detecção é feita em uma thread separada,
por isso foi utilizado o método post(Runnable) (da classe Handler) para poder



atualizar a UI.
Após inicializar o processor, um callback foi adicionado para saber quando

a surfaceView estiver pronta. Quando isto ocorrer, o método
onSurfaceCreated(SurfaceHolder) será invocado, e nesse momento o método
startDetection() é chamado. Nele é verificado se as permissões foram concedidas,
e, em caso positivo, a chamada cameraSource.start(SurfaceHolder) é realizada e
inicializará a câmera e a detecção dos códigos de barras.

Referencie esse fragment no arquivo de layout da MainActivity e execute a
aplicação. Tente detectar um código de barras e o resultado ficará como o da
Figura 25.6.

Figura 25.6 – Detectando códigos de barra com a Mobile Vision API.
Para fazer a detecção de faces é muito simples. Basta alterar o detector e o

processor:
import com.google.android.gms.vision.face.Face
import com.google.android.gms.vision.face.FaceDetector
 
class CameraDetectionFragment : MultimediaFragment() {
    private val detector: FaceDetector by lazy {
        FaceDetector.Builder(activity)
                .setClassificationType(FaceDetector.ALL_CLASSIFICATIONS)



                .setMode(FaceDetector.ACCURATE_MODE)
                .setProminentFaceOnly(false)
                .build()
    }
    private val cameraSource: CameraSource by lazy {
        CameraSource.Builder(activity, detector)
                .setFacing(CameraSource.CAMERA_FACING_FRONT)
                .setAutoFocusEnabled(true)
                .setRequestedPreviewSize(800, 512)
                .build()
    }
    // Demais métodos não mudaram
    private fun initProcessor() {
        detector.setProcessor(object: Detector.Processor<Face> {
            override fun release() {
            }
            override fun receiveDetections(detections: Detector.Detections<Face>) {
                val faces = detections.detectedItems
                if (faces.size() != 0) {
                    var text = ""
                    for (index in 0 until faces.size()) {
                        val face = faces[index]
                        if (face != null) {
                            text += "Face: ${face.id} \n" +
                                    "Smiling: ${face.isSmilingProbability}\n" +
                                    "RightEye: ${face.isRightEyeOpenProbability} \n" +
                                    "LeftEye: ${face.isLeftEyeOpenProbability} "
                        }
                        txtBarCode.post {
                            txtBarCode.text = text
                        }
                    }
                }
            }
        })
    }
}

O processo aqui é bem similar ao que foi feito no código de barras. O
FaceDetector é instanciado utilizando a classe FaceDetector.Builder. Com o método
setClassificationType(int) é informado que se desejam todas as classificações da
face, tais como sorriso e olhos abertos. O modo de detecção foi definido
como preciso (ACCURATE_MODE) em vez de rápido (FAST_MODE) utilizando o
método setMode(int). E, por fim, com o método setProminentFaceOnly(false) é



informado que devem ser detectadas todas as faces e não apenas a que estiver
em mais evidência.

No processor são detectados objetos do tipo Face. Esse objeto possui o id da
face detectada (utilizado internamente pela API), a probabilidade de a face
estar sorrindo (isSmilingProbability), com o olho direito aberto
(isRightEyeOpenProbability) ou o olho esquerdo aberto (isLeftEyeOpenProbability). A
Figura 25.7 mostra a detecção de face em funcionamento e como é possível
notar, eu tenho o olho direito mais fechado que o esquerdo ☺.

Figura 25.7 – Detectando face com a Mobile Vision API.
A detecção de textos segue a mesma abordagem. É preciso mudar apenas o

detector e o processor:
import com.google.android.gms.vision.text.TextBlock
import com.google.android.gms.vision.text.TextRecognizer
 
class CameraDetectionFragment : MultimediaFragment() {
    private val detector: TextRecognizer by lazy {
        TextRecognizer.Builder(activity).build()
    }
    private val cameraSource: CameraSource by lazy {
        CameraSource.Builder(activity, detector)



            .setFacing(CameraSource.CAMERA_FACING_BACK)
            .setAutoFocusEnabled(true)
            .setRequestedPreviewSize(800, 512)
            .build()
    }
    // Demais métodos não mudaram
    private fun initProcessor() {
        detector.setProcessor(object: Detector.Processor<TextBlock> {
            override fun release() {
            }
            override fun receiveDetections(detections: Detector.Detections<TextBlock>) {
                val texts = detections.detectedItems
                if (texts.size() != 0) {
                    var textOutput = ""
                    for (index in 0 until texts.size()) {
                        val text = texts[index]
                        if (text != null) {
                            textOutput += "$index: ${text.value}\n"
                        }
                    }
                    txtBarCode.post {
                        txtBarCode.text = textOutput
                    }
                }
            }
        })
    }
}

O detector agora é da classe TextRecognizer e não possui nenhum parâmetro
especial para instanciá-lo. E quando o texto é detectado, é feita a leitura da
propriedade value do objeto TextBlock.

Execute a aplicação novamente e teste a detecção de texto. A Figura 25.8
mostra a detecção de texto em funcionamento.

Como podemos observar, a Mobile Vision API é muito simples de usar e
seus detectores são muito precisos. Entretanto, durante a escrita deste livro a
Mobile Vision API estava sendo substituída pelo ML Kit, uma biblioteca de
machine learning incorporada ao Firebase, mas que ainda estava em versão
beta. Além disso, ela requer mais linhas de código para atingir o mesmo
objetivo que apresentamos aqui, sem contar o fato que era necessário criar
um projeto no Firebase Console para poder utilizá-la. Por essa razão, ela não
foi demonstrada aqui.



Figura 25.8 – Detectando textos com a Mobile Vision API.

Gravando áudio
Nesta seção serão demonstrados alguns recursos de áudio no Android.
Primeiramente, será apresentado como realizar a gravação de áudio utilizando
o microfone do aparelho e, em seguida, será mostrado o reconhecimento de
voz e a transformação para texto.

Para capturar o áudio do microfone do aparelho, a primeira coisa que deve
ser feita é adicionar a permissão RECORD_AUDIO no AndroidManifest.xml:
<uses-permission android:name="android.permission.RECORD_AUDIO"/>

Para exemplificar o uso do recurso de gravação de áudio, será adicionado
um novo fragment. Crie o arquivo de layout
res/layout/fragment_record_audio.xml e deixe-o como a seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/relativeLayout2"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp">



    <ImageButton
        android:id="@+id/btnRecord"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_btn_speak_now"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <ImageButton
        android:id="@+id/btnPlay"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_media_play"
        app:layout_constraintStart_toEndOf="@+id/btnRecord"
        app:layout_constraintTop_toTopOf="parent" />
    <Chronometer
        android:id="@+id/chronometer"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

A novidade neste arquivo de layout é o componente Chronometer, que é uma
subclasse de TextView e permite exibir um cronômetro. Para iniciar o
cronômetro, deve-se chamar o método start(), e para pará-lo, o método stop().
Para reiniciá-lo, basta utilizar o método setBase(long) e dar um novo ponto de
partida. Normalmente é passado o retorno do método
SystemClock.elapsedRealtime(), que retorna a quantidade de milissegundos desde
que o aparelho foi ligado pela última vez.

Vamos agora para a implementação do RecordAudioFragment:
import android.media.MediaPlayer
import android.media.MediaRecorder
import android.os.Bundle
import android.os.SystemClock
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import kotlinx.android.synthetic.main.fragment_record_audio.*
import java.io.File
import java.io.IOException
 
class RecordAudioFragment : MultimediaFragment() {
    private var mediaRecorder: MediaRecorder? = null



    private var mediaPlayer: MediaPlayer? = null
    private var audioFile: File? = null
    private var isRecording: Boolean = false
    private var isPlaying: Boolean = false
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        retainInstance = true
        val audioPath = MediaUtils.getLastMediaPath(
                requireContext(), MediaUtils.MediaType.MEDIA_AUDIO)
        if (audioPath != null) {
            audioFile = File(audioPath)
        }
    }
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_record_audio, container, false)
    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        btnRecord.setOnClickListener {
            chronometer.stop()
            if (isRecording) {
                stopRecording()
            } else {
                startRecording()
            }
            updateButtons()
        }
        btnPlay.setOnClickListener {
            chronometer.stop()
            if (isPlaying) {
                stopPlaying()
            } else {
                startPlaying()
            }
            updateButtons()
        }
    }
    override fun onPause() {
        super.onPause()
        stopRecording()
        stopPlaying()
    }
    private fun startPlaying() {



        if (audioFile?.exists() == true) {
            if (hasPermission()) {
                try {
                    mediaPlayer = MediaPlayer().apply {
                        setDataSource(audioFile?.absolutePath)
                    }
                    mediaPlayer?.setOnCompletionListener {
                        isPlaying = false
                        chronometer.stop()
                        updateButtons()
                    }
                    mediaPlayer?.prepare()
                    mediaPlayer?.start()
                    chronometer.base = SystemClock.elapsedRealtime()
                    chronometer.start()
                    isPlaying = true
                } catch (e: IOException) {
                    e.printStackTrace()
                }
            } else {
                requestPermissions()
            }
        }
    }
    private fun startRecording() {
        if (hasPermission()) {
            try {
                audioFile = MediaUtils.newMedia(MediaUtils.MediaType.MEDIA_AUDIO)
                mediaRecorder = MediaRecorder().apply {
                    setAudioSource(MediaRecorder.AudioSource.MIC)
                    setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP)
                    setOutputFile(audioFile?.absolutePath)
                    setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB)
                }
                mediaRecorder?.prepare()
                mediaRecorder?.start()
                chronometer.base = SystemClock.elapsedRealtime()
                chronometer.start()
                isRecording = true
            } catch (e: Exception) {
                e.printStackTrace()
            }
        } else {
            requestPermissions()
        }



    }
    private fun updateButtons() {
        btnRecord.setImageResource(
                if (isRecording)
                    android.R.drawable.ic_media_pause
                else
                    android.R.drawable.ic_btn_speak_now)
        btnRecord.isEnabled = !isPlaying
        btnPlay.setImageResource(
                if (isPlaying)
                    android.R.drawable.ic_media_pause
                else
                    android.R.drawable.ic_media_play)
        btnPlay.isEnabled = !isRecording
    }
    private fun stopPlaying() {
        if (mediaPlayer != null && isPlaying) {
            mediaPlayer?.stop()
            mediaPlayer?.release()
            mediaPlayer = null
            isPlaying = false
        }
    }
    private fun stopRecording() {
        if (mediaRecorder != null && isRecording) {
            mediaRecorder?.stop()
            mediaRecorder?.release()
            mediaRecorder = null
            isRecording = false
            audioFile?.let {
                MediaUtils.saveLastMediaPath(requireContext(),
                        MediaUtils.MediaType.MEDIA_AUDIO, it.absolutePath)
            }
        }
    }
}

Essa tela parece um pouco com as anteriores no que se refere ao
armazenamento e à recuperação da última mídia gravada. O método
updateButtons() habilitará ou não os botões de acordo com a ação que a tela
estiver realizando. O btnRecord servirá para iniciar e parar a gravação, já o
btnPlay servirá para executar o áudio e também pará-lo.

Para gravar o áudio, foi utilizada a classe MediaRecorder, na qual, por meio do
método setAudioSource(int), é informada a origem do áudio, que neste exemplo é



o microfone do aparelho representado pela constante
MediaRecorder.AudioSource.MIC. É possível configurar também o formato de saída
usando o método setOutputFormat(int); passando o valor
MediaRecorder.OutputFormat.THREE_GPP, será gerado um arquivo no formato 3gpp.
Outra configuração interessante de fazer é definir o encoding do arquivo por
meio do método setAudioEncoder(int), e nesse exemplo foi usado o formato AMR
(Adaptive Multi-Rate) usando a constante MediaRecorder.AudioEncoder.AMR_NB. O
arquivo que será gerado na gravação é definido no método setOutputFile(String).
Por fim, para iniciar a gravação, invocamos o método prepare() e, em seguida,
start() do MediaRecorder.

Para executar o áudio, foi utilizada a classe MediaPlayer. E como é possível
perceber, após definir o arquivo que será executado com a chamada ao
método setDataSource(String), um listener é definido por meio do método
setOnCompletionListener(OnCompletionListener) para saber quando o áudio acabou de
tocar. Isso é necessário para restaurar o estado dos botões.

Note que tanto para o MediaPlayer quanto para o MediaRecorder, foi utilizado o
método stop() e release() para respectivamente parar e liberar os recursos
alocados. Altere o arquivo de layout da MainActivity e teste esse novo fragment.

Altere a classe MultimediaFragment para solicitar a permissão para gravação de
áudio:
abstract class MultimediaFragment : Fragment() {
    protected fun hasPermission(): Boolean {
        val permissions = listOf(
                Manifest.permission.WRITE_EXTERNAL_STORAGE,
                Manifest.permission.CAMERA,
                Manifest.permission.RECORD_AUDIO
        )
        return permissions.all {
            ActivityCompat.checkSelfPermission(requireActivity(), it) ==
                    PackageManager.PERMISSION_GRANTED
        }
    }
    protected fun requestPermissions(requestCode: Int = REQUEST_CODE_PERMISSION) {
        requestPermissions(arrayOf(
                Manifest.permission.WRITE_EXTERNAL_STORAGE,
                Manifest.permission.CAMERA,
                Manifest.permission.RECORD_AUDIO), requestCode)
    }
    companion object {



        const val REQUEST_CODE_PERMISSION = 1
    }
}

Para testar esse novo fragment, altere o arquivo
res/layout/activity_main.xml para que a tag <fragment> aponte para essa nova
classe. O resultado deve ficar conforme a Figura 25.9.

Figura 25.9 – Gravação de voz com o MediaRecorder.

Reconhecimento de voz via intent
Na seção anterior foi demonstrado como capturar o áudio por meio do
microfone resultando um arquivo de áudio. Com a API de reconhecimento de
voz no Android é muito simples transformar voz em texto, e apesar de estar
presente desde a versão 2.1, esse recurso nem sempre é muito explorado
pelos desenvolvedores.

Para utilizá-lo, basta chamar a activity que iniciará o reconhecimento do
que será falado e, em seguida, obter a lista dos textos que foram
reconhecidos.

A primeira coisa a ser feita antes de utilizar esse recurso é checar se o
aparelho suporta essa funcionalidade. Isso pode ser feito simplesmente



checando se a ação ACTION_RECOGNIZE_SPEECH pode ser tratada como mostra
o trecho de código a seguir:
val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH)
if (intent.resolveActivity(packageManager) != null) {
    // Aparelho suporta reconhecimento de voz
} else {
    // Aparelho NÃO suporta reconhecimento de voz
}

Para iniciar o reconhecimento de voz, basta usar disparar uma Intent com a
ação ACTION_RECOGNIZE_SPEECH utilizando o método startActivityForResult(Intent,int)
como mostrado no código seguinte. O resultado será algo similar à Figura
25.10:
val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH)
intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
    RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
intent.putExtra(RecognizerIntent.EXTRA_PROMPT, "Fale alguma coisa!")
startActivityForResult(intent, MediaUtils.REQUEST_CODE_AUDIO)

O parâmetro EXTRA_LANGUAGE_MODEL ajuda o reconhecimento de voz a dar
resultados mais precisos. Aqui pode-se optar por LANGUAGE_MODE_FREE_FORM
ou LANGUAGUE_MODE_WEB_SEARCH. O primeiro é o reconhecimento livre e o
segundo é baseado em termos de busca na web.



Figura 25.10 – Reconhecimento de voz com intent.
Após capturar a voz, o reconhecimento será feito e os resultados serão

enviados de volta para a activity. Para tratar esse retorno é usado o método
onActivityResult (int,int,Intent) da activity, como demonstrado a seguir:
override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    super.onActivityResult(requestCode, resultCode, data)
    if (requestCode == MediaUtils.REQUEST_CODE_AUDIO && resultCode == RESULT_OK) {
        // Contém a lista com os resultados
        val matches = data?.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS)
        // Faça o que quiser com os textos de retorno
    }
}

Os resultado do reconhecimento de voz é trazido no parâmetro
EXTRA_RESULTS da Intent em forma de um ArrayList<String>.

Para testar o reconhecimento de voz, crie o arquivo de layout
res/layout/fragment_voice_recognition.xml e deixe-o como a seguir:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ImageButton
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_btn_speak_now"
        android:id="@+id/btnVoice" />
    <ListView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/lstResults" />
</LinearLayout>

Nesse arquivo de layout temos apenas um botão que iniciará a activity de
reconhecimento de voz e uma ListView para exibir os textos reconhecidos.
Agora crie a classe VoiceRecognitionFragment e deixe-a assim:
import android.app.Activity
import android.content.Intent
import android.os.Bundle
import android.speech.RecognizerIntent
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup



import android.widget.ArrayAdapter
import android.widget.Toast
import androidx.fragment.app.Fragment
import kotlinx.android.synthetic.main.fragment_voice_recognition.*
import java.util.*
 
class VoiceRecognitionFragment : Fragment() {
    private val voiceIntent: Intent by lazy {
        Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
                    RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(RecognizerIntent.EXTRA_PROMPT,
                    "Fale alguma coisa!")
        }
    }
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.fragment_voice_recognition, container, false)
    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        btnVoice.setOnClickListener {
            openVoiceRecognitionIntent()
        }
    }
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        if (voiceIntent.resolveActivity(requireActivity().packageManager) == null) {
            btnVoice.isEnabled = false
            Toast.makeText(activity, "Aparelho não suporta comando de voz.",
                    Toast.LENGTH_SHORT).show()
            activity?.finish()
        }
    }
    private fun openVoiceRecognitionIntent() {
        startActivityForResult(voiceIntent, MediaUtils.REQUEST_CODE_AUDIO)
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == MediaUtils.REQUEST_CODE_AUDIO && resultCode ==

Activity.RESULT_OK) {
            val matches = data?.getStringArrayListExtra(
                    RecognizerIntent.EXTRA_RESULTS)
            updateResultsList(matches)
        }



    }
    private fun updateResultsList(results: ArrayList<String>?) {
        if (results != null) {
            lstResults.adapter = ArrayAdapter(requireActivity(),
                    android.R.layout.simple_list_item_1, results)
        }
    }
}

Note que com algumas poucas linhas foi possível adicionar o recurso de
reconhecimento de voz, o que pode facilitar bastante a inserção de
informações na aplicação por parte do usuário.

Mais uma vez, para testar este fragment altere o arquivo
res/layout/activity_main.xml de modo a apontar para essa classe.

Reconhecimento de voz com SpeechRecognizer
O exemplo anterior utiliza uma Intent para reconhecer uma voz e transformá-la
em texto, mas, assim como foi feito com a câmera, é possível incorporar esse
recurso dentro da aplicação sem o dialog-padrão. Para fazer isso, deve-se
utilizar a classe SpeechRecognizer e a interface RecognitionListener, que avisará
quando os eventos do reconhecimento de voz forem disparados. Essa
interface possui os métodos listados na Tabela 25.2.

Tabela 25.2 – Métodos da interface RecognitionListener
Método Descrição

onReadyForSpeech(Bundle) Chamado quando o sistema está pronto para receber o comando de voz.
onBeginningOfSpeech() O usuário começou a falar.
onRmsChanged(float) O nível do som mudou no áudio. Não é garantido ser chamado.
onBufferReceived(byte[]) Permite dar um feedback quando mais sons são capturados. Não é garantido ser

chamado.
onEndOfSpeech() Chamado quando o usuário para de falar.
onError(int) Um erro de rede ou de reconhecimento da voz ocorreu.
onResults(Bundle) Chamado quando o reconhecimento da voz foi concluído e os resultados estão

disponíveis.
onPartialResults(Bundle) Chamado quando parte do reconhecimento da voz foi feito e os resultados estão

disponíveis.
onEvent(int,Bundle) Não utilizado. Reservado para eventos futuros.

Para iniciar o reconhecimento, é preciso instanciar uma Intent com a mesma
ação usada no exemplo anterior:
val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {



    putExtra(RecognizerIntent.EXTRA_LANGUAGE_PREFERENCE, "pt")
    putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
             RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH)
    putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 5)
}
val speechRecognizer = SpeechRecognizer.createSpeechRecognizer(activity)
speechRecognizer.setRecognitionListener(recognitionListener)
speechRecognizer.startListening(intent)

Na intent é passado o idioma português usando o parâmetro
EXTRA_LANGUAGE_PREFERENCE, mas, se não passar esse parâmetro, será
utilizado o idioma do aparelho. Outro parâmetro que está sendo passado aqui
é a quantidade máxima de resultados que pode ser retornada usando o
EXTRA_MAX_RESULTS.

Para funcionar também com essa nova abordagem, o exemplo anterior terá
algumas mudanças. Primeiro altere o arquivo de layout
res/layout/fragment_voice_recognition.xml:
<LinearLayout ...>
    <ImageButton
        android:id="@+id/btnVoice" ... />
    <ProgressBar
        style="?android:attr/progressBarStyleHorizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:visibility="invisible"
        android:id="@+id/pgrVoice" />
    <CheckBox
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Usar Intent"
        android:id="@+id/chkIntent" />
    <ListView
        android:id="@+id/lstResults" ... />
</LinearLayout>

Foi adicionado um CheckBox para poder optar por usar o reconhecimento
com Intent ou via SpeechRecognizer. O ProgressBar servirá para dar um feedback
durante o reconhecimento da voz. Agora altere a classe VoiceRecognitionFragment,
que ficará assim:
class VoiceRecognitionFragment : MultimediaFragment() {
    private var isRecognizing = false
    private val speechRecognizer: SpeechRecognizer by lazy {
        SpeechRecognizer.createSpeechRecognizer(activity)



    }
    // O atributo voiceIntent e o método onCreateView não mudaram...
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        if (voiceIntent.resolveActivity(activity?.packageManager) == null) {
            btnVoice.isEnabled = false
            Toast.makeText(activity, "Aparelho não suporta comando de voz.",
                    Toast.LENGTH_SHORT).show()
            activity?.finish()
        } else {
            speechRecognizer.setRecognitionListener(recognitionListener)
        }
    }
    override fun onPause() {
        super.onPause()
        speechRecognizer.destroy()
    }
    private fun openVoiceRecognitionIntent() {
        if (chkIntent.isChecked) {
            startActivityForResult(voiceIntent, MediaUtils.REQUEST_CODE_AUDIO)
        } else {
            if (hasPermission()) {
                if (isRecognizing) {
                    stopRecognizing()
                } else {
                    startRecognizing()
                }
            } else {
                requestPermissions()
            }
        }
    }
    private fun startRecognizing() {
        pgrVoice.visibility = View.VISIBLE
        pgrVoice.isIndeterminate = true
        voiceIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 5)
        speechRecognizer.startListening(voiceIntent)
        isRecognizing = true
    }
    private fun stopRecognizing() {
        pgrVoice.visibility = View.INVISIBLE
        pgrVoice.isIndeterminate = false
        speechRecognizer.stopListening()
        isRecognizing = false
    }



    // O método onActivityResult não mudou
    private fun updateResultsList(results: ArrayList<String>?) {
        if (results != null) {
            lstResults.adapter = ArrayAdapter(activity!!,
                            android.R.layout.simple_list_item_1, results)
        }
        pgrVoice.visibility = View.INVISIBLE
        isRecognizing = false
    }
    private val recognitionListener = object: RecognitionListener {
        override fun onBeginningOfSpeech() {
            pgrVoice.isIndeterminate = false
            pgrVoice.max = 10
        }
        override fun onEndOfSpeech() {
            pgrVoice.isIndeterminate = true
        }
        override fun onRmsChanged(v: Float) {
            pgrVoice.progress = v.toInt()
        }
        override fun onError(i: Int) {
            Toast.makeText(activity, "Problemas no comando de voz. Erro: $i",
                    Toast.LENGTH_SHORT).show()
            pgrVoice.visibility = View.INVISIBLE
        }
        override fun onResults(bundle: Bundle) {
            val results = bundle.getStringArrayList(
                    SpeechRecognizer.RESULTS_RECOGNITION)
            updateResultsList(results)
        }
        override fun onPartialResults(bundle: Bundle) {
        }
        override fun onReadyForSpeech(bundle: Bundle) {
        }
        override fun onBufferReceived(bytes: ByteArray) {
        }
        override fun onEvent(i: Int, bundle: Bundle) {
        }
    }
}

A maior parte do código já foi explicada e parte do que foi adicionado diz
respeito a modificações de interface gráfica causada pela adição do CheckBox e
ProgressBar.

No onPause(), o objeto speechRecognizer invoca seu método destroy(). No



openVoiceRecognitionIntent(), caso esteja sendo usado o speechRecognizer, é verificado
se o usuário concedeu a permissão de acesso ao microfone, em caso positivo,
é checado se o reconhecimento de voz está sendo realizado no momento,
neste caso, o reconhecimento de voz é interrompido usando o stopRecognizing(),
caso não esteja, o reconhecimento de voz é iniciado usando o método
startRecognizing().

O objeto recognitionListener tratará os métodos do reconhecimento de voz. Ao
começar a falar o método onBeginningOfSpeech() a barra de progresso é colocado
em modo indeterminado e quando o fim do reconhecimento é detectado, o
método onEndOfSpeech() é chamado, e nele a barra de progresso volta ao estado
normal. Entretanto, o mais importante é o onResults(Bundle), que traz os textos
reconhecidos, similar ao que é feito no onactivityResult(int,int,Intent). Outro método
que merece atenção é o onError(int), que captura a ocorrência de erros na
detectção da voz. Os erros possíveis são listados na Tabela 25.3 e estão
localizados na classe SpeechRecognizer.

Tabela 25.3 – Tipos de erro ao reconhecer voz
Tipo do erro Motivo

ERROR_AUDIO Erro na gravação do áudio.
ERROR_CLIENT Outros erros do cliente.
ERROR_INSUFFICIENT_PERMISSIONS Permissão não suficiente.
ERROR_NETWORK Erros relacionados à conexão.
ERROR_NETWORK_TIMEOUT A conexão expirou.
ERROR_NO_MATCH Nenhum resultado encontrado.
ERROR_RECOGNIZER_BUSY O serviço de reconhecimento de voz está ocupado.
ERROR_SERVER O servidor que faz o reconhecimento mandou uma mensagem de erro.
ERROR_SPEECH_TIMEOUT Timeout quando não é falado nada.

Com essas constantes, é possível checar se algum erro específico ocorreu e
exibir uma mensagem apropriada para o usuário. Execute a aplicação e veja
que o resultado obtido pelo SpeechRecognizer é similar ao obtido por meio da
Intent.

Execute a aplicação novamente e resultado deve ficar similar ao da Figura
25.11.



Figura 25.11 – Reconhecimento de voz.

1 Esse método foi extraído do exemplo da API de Câmera do Google (https://bit.ly/2pdXJUV).



CAPÍTULO 26
Animações

Muitas vezes o aplicativo está totalmente funcional, mas falta algo para dar
um toque de sutileza e trazer uma experiência mais agradável para o usuário.
Utilizar animações no lugar certo e de forma inteligente traz um aspecto
profissional e atraente ao aplicativo. Neste capítulo serão demonstradas
diversas formas de animações no Android e como aplicá-las de modo a tornar
as ações dos aplicativos mais suaves e atrativas.

View Animations
Desde a primeira versão, o Android contém classes para realizar animações
que reposicionam, ampliam, rotacionam e mudam a transparência de uma
view. Essas animações podem ser definidas via código Kotlin ou em arquivos
XML (na pasta res/anim), podendo inclusive ser aplicadas combinações
dessas animações. A Tabela 26.1 lista os tipos de animações existentes na
API de View Animations.

Tabela 26.1 – Tipos de View Animations do Android
Classe Tag XML Comportamento

AlphaAnimation <alpha> Anima a opacidade (transparência) da view.
RotateAnimation <rotate> Anima a rotação da view, permitindo definir o eixo de rotação.
ScaleAnimation <scale> Anima a escala da view, permitindo definir um ponto central.
TranslateAnimation <translate> Anima a posição da view na tela, inclusive proporcional ao tamanho da tela.
AnimationSet <set> Representa um grupo de animações que devem executar juntas.

Toda animação pode ter uma interpolação (interpolator) que afeta a forma
como a animação é executada. A lista das possíveis interpolações que podem
ser aplicadas a animações é apresentada na Tabela 26.2.

Tabela 26.2 – Tipos de interpolator que podem ser associados a uma
animação



Interpolator Comportamento da animação
AccelerateDecelerateInterpolator Começa e termina lentamente, mas acelera no meio.
AccelerateInterpolator Começa lentamente, mas acelera até o final.
AnticipateInterpolator Começa na direção inversa e depois continua linearmente.
AnticipateOvershootInterpolator Similar a anterior, mas faz um efeito de ricochetear ao final.
BounceInterpolator Faz um efeito de elástico ao final.
CycleInterpolator Repete a animação ‘N’ vezes de forma senoidal.
DecelerateInterpolator Começa rapidamente e termina lentamente.
FastOutLinearInInterpolator Acelera rápido e mantém a aceleração até o fim da animação.
FastOutSlowInInterpolator Acelera rápido e desacelera lentamente.
LinearOutSlowInInterpolator Começa com um pico de velocidade e desacelera lentamente.
LinearInterpolator Executa linearmente (padrão).
OvershootInterpolator Vai para a frente, ultrapassa o limite e depois volta ao valor final.

Pode ficar complicado entender o que cada interpolator faz a partir da sua
descrição, então crie um novo projeto para visualizar cada uma das
animações e interpolators.

Application Name Animacoes
Package Name dominando.android.animacoes
Activity Name MainActivity

Este exemplo demonstrará todas as animações e interpolators disponíveis.
O usuário poderá selecionar tanto a animação quanto o interpolator. Adicione
ambas as listagens no res/values/arrays.xml:
<resources>
    <string-array name="view_animations">
        <item>AlphaAnimation</item>
        <item>RotateAnimation</item>
        <item>ScaleAnimation</item>
        <item>TranslateAnimation</item>
        <item>AnimationSet</item>
    </string-array>
    <string-array name="interpolators">
        <item>AccelerateDecelerateInterpolator</item>
        <item>AccelerateInterpolator</item>
        <item>AnticipateInterpolator</item>
        <item>AnticipateOvershootInterpolator</item>
        <item>BounceInterpolator</item>
        <item>CycleInterpolator</item>
        <item>DecelerateInterpolator</item>
        <item>FastOutLinearInInterpolator</item>
        <item>FastOutSlowInInterpolator</item>



        <item>LinearOutSlowInInterpolator</item>
        <item>LinearInterpolator</item>
        <item>OvershootInterpolator</item>
    </string-array>
</resources>

Em seguida, crie uma nova activity chamada ViewAnimationsActivity e altere o
arquivo de layout res/layout/activity_view_animations.xml para ficar da
seguinte forma:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    android:orientation="vertical">
    <Spinner
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/spnAnimations"
        android:entries="@array/view_animations"/>
    <Spinner
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/spnInterpolators"
        android:entries="@array/interpolators"/>
    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:background="#F0F0FF"
        android:layout_weight="1">
        <ImageView
            android:layout_width="150dp"
            android:layout_height="150dp"
            android:id="@+id/imgBazinga"
            android:layout_gravity="center"
            android:src="@drawable/bazinga" />
    </FrameLayout>
    <Button
        android:id="@+id/btnPlay"
        style="@style/Widget.AppCompat.Button.Colored"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="end"
        android:text="Play!" />
</LinearLayout>



O arquivo de layout possui dois componentes Spinner para listar as
animações e interpolators disponíveis na API. Em seguida, dentro de um
FrameLayout existe uma ImageView está usando a imagem bazinga.png que deve
estar na pasta res/drawable (adicione a imagem de sua preferência). Por fim,
temos um botão para executar a animação.

Explicado o layout, as animações serão implementadas na classe
ViewAnimationsActivity que deve ficar como a seguir:
import androidx.appcompat.app.AppCompatActivity
import android.view.animation.*
import androidx.interpolator.view.animation.FastOutLinearInInterpolator
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import androidx.interpolator.view.animation.LinearOutSlowInInterpolator
import kotlinx.android.synthetic.main.activity_view_animations.*
 
class ViewAnimationsActivity : AppCompatActivity() {
    private val animations: Array<Animation> by lazy {
        initAnimations()
    }
    private val interpolators: Array<Interpolator> by lazy {
        initInterpolators()
    }
    private val animationListener = object: Animation.AnimationListener {
        override fun onAnimationStart(animation: Animation?) {
        }
        override fun onAnimationEnd(animation: Animation?) {
            btnPlay.isEnabled = true
            animation?.setAnimationListener(null)
        }
        override fun onAnimationRepeat(animation: Animation?) {
        }
    }
    public override fun onCreate(savedInstanceState: android.os.Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_view_animations)
        btnPlay.setOnClickListener { executeAnimation() }
    }
    private fun initAnimations(): Array<Animation> {
        val animationDuration = 1000L
        val alphaAnim = AlphaAnimation(1f, 0f)
        val rotateAnim = RotateAnimation(
                0f, 360f,
                Animation.RELATIVE_TO_SELF, 0.5f,
                Animation.RELATIVE_TO_SELF, 0.5f)



        val scaleAnim = ScaleAnimation(
                1f, 3f, 1f, 3f,
                Animation.RELATIVE_TO_SELF, 0.5f,
                Animation.RELATIVE_TO_SELF, 0.5f)
        val translateAnim = TranslateAnimation(
                Animation.RELATIVE_TO_SELF, 0f,
                Animation.RELATIVE_TO_SELF, 1.0f,
                Animation.RELATIVE_TO_SELF, 0f,
                Animation.RELATIVE_TO_SELF, 2.0f)
        val set = AnimationSet(true)
        set.addAnimation(alphaAnim)
        set.addAnimation(rotateAnim)
        set.addAnimation(scaleAnim)
        set.addAnimation(translateAnim)
        val animations = arrayOf( alphaAnim, rotateAnim, scaleAnim, translateAnim, set)
        for (i in 0..animations.size - 2) {
            animations[i].duration = animationDuration
            animations[i].repeatMode = Animation.REVERSE
            animations[i].repeatCount = 1
        }
        return animations
    }
    private fun initInterpolators(): Array<Interpolator> {
        return arrayOf(
                AccelerateDecelerateInterpolator(),
                AccelerateInterpolator(1.0f), // <- fator (opcional)
                AnticipateInterpolator(2.0f), // <- tensão (opcional)
                AnticipateOvershootInterpolator(2.0f, 1.5f), // <- tensão, tensão extra
                                                             // tension (opcional)
                BounceInterpolator(),
                CycleInterpolator(2f), // <- ciclos
                DecelerateInterpolator(1.0f), // <- fator (opcional)
                FastOutLinearInInterpolator(),
                FastOutSlowInInterpolator(),
                LinearOutSlowInInterpolator(),
                LinearInterpolator(),
                OvershootInterpolator(2.0f) // <- tensão (opcional)
        )
    }
    private fun executeAnimation() {
        val interpolator = interpolators[spnInterpolators.selectedItemPosition]
        val animation = animations[spnAnimations.selectedItemPosition]
        animation.interpolator = interpolator
        animation.setAnimationListener(animationListener)
        imgBazinga.startAnimation(animation)



        btnPlay.isEnabled = false
    }
}

Os atributos animations e interpolators foram declarados no início da classe e
conterão respectivamente as listas de animações e interpolators, e serão
inicializados nos métodos initAnimations() e initInterpolators().

Também foi declarado o atributo animationListener do tipo da interface
AnimationListener para ouvir as mudanças de estado da animação. Com essa
interface é possível saber quando a animação começou, terminou e quando
foi repetida por meio dos métodos onAnimationStart(Animation),
onAnimationEnd(Animation) e onAnimationRepeat(Animation),. Neste exemplo, apenas o
segundo método está sendo utilizado para habilitar o botão quando a
animação encerrar.

Ao clicar no btnPlay, o método executeAnimation() é chamado, então um
Interpolator é obtido da lista interpolators acordo com a posição selecionada no
spnInterporlators. Em seguida, um objeto Animation é carregado da lista animations
baseada na opção selecionada do spnAnimations de animações. Com o objeto
animation, o interpolator é definido e o objeto que ouvirá a mudança no estado da
animação com o método setAnimationListener(AnimationListener).

O método initAnimations() fará a inicialização de todas as animações. A
primeira animação é uma AlphaAnimation que recebe como parâmetros a
transparência inicial e final (1 quer dizer opaco; 0, transparente). Nesse caso,
essa animação fará a ImageView desaparecer completamente.

A RotateAnimation fará a view girar. Para isso, deve-se informar o ângulo
inicial e final e uma posição X e Y para servir de eixo de rotação. Nesse
exemplo, foi passada uma posição relativa à imagem RELATIVE_TO_SELF
baseada na metade do seu tamanho (0.5). O valor 0.0 seria o lado esquerdo ou
superior, e 1.0 seria o lado direito ou inferior, para os eixos X e Y,
respectivamente.

A próxima animação é uma ScaleAnimation, que fará com que a imagem
aumente de tamanho. Ela recebe como argumento a proporção inicial e final
em X, depois a proporção inicial e final em Y, e assim como a anterior, pede
uma âncora para determinar o ponto de origem do aumento da imagem.

Uma TranslateAnimation serve para movimentar a view para uma nova posição
X e Y. Aqui foi informado que ela deve movimentar-se da posição X inicial 0
para 200 final, e Y inicial 0 e final 300.



E a última animação executa todas as animações de uma vez com um
AnimationSet. Perceba que as animações foram adicionadas utilizando o método
addAnimation(Animation).

Foi utilizado um for para definir três propriedades de todas as animações:
• duration para informar a duração da animação em milissegundos;
• repeatMode que indica o tipo de repetição da animação, e que pode ser

REVERSE ou RESTART;
• repeatCount estipulando a quantidade de vezes que a animação repetirá.
Faça com que a MainActivity chame a ViewAnimationsActivity, execute a aplicação

e você deve ter um resultado similar ao da Figura 26.1.

Figura 26.1 – Aplicação com animações em execução.
Nesse exemplo foram criadas animações via código, mas elas podem ser

criadas em arquivos XML na pasta res/anim. Essas mesmas animações
ficariam da seguinte forma em arquivos XML:

• res/anim/transparency.xml
<alpha xmlns:android="http://schemas.android.com/apk/res/android"
    android:repeatCount="1"
    android:repeatMode="reverse"
    android:duration="1000"



    android:fromAlpha="1"
    android:toAlpha="0"/>

• res/anim/rotation.xml
<rotate xmlns:android="http://schemas.android.com/apk/res/android"
    android:repeatCount="1"
    android:repeatMode="reverse"
    android:duration="1000"
    android:fromDegrees="0"
    android:toDegrees="360"
    android:pivotX="50%"
    android:pivotY="50%" />

• res/anim/expand.xml
<scale xmlns:android="http://schemas.android.com/apk/res/android"
    android:repeatCount="1"
    android:repeatMode="reverse"
    android:duration="1000"
    android:fromXScale="1"
    android:fromYScale="1"
    android:toXScale="3"
    android:toYScale="3"
    android:pivotX="50%"
    android:pivotY="50%"/>

• res/anim/move.xml
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:repeatCount="1"
    android:repeatMode="reverse"
    android:duration="1000"
    android:fromXDelta="0"
    android:fromYDelta="0"
    android:toXDelta="100%"
    android:toYDelta="200%" />

• res/anim/all_together.xml
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <alpha .../>
    <rotate .../>
    <scale .../>
    <translate .../>
</set>

O arquivo res/anim/all_together.xml deve reunir o conteúdo dos demais



arquivos dentro da tag <set>. Ele foi omitido aqui para não ser redundante.
Para testar, altere o método initAnimations() para usar os arquivos que foram
criados:
private fun initAnimations(): Array<Animation> {
    return arrayOf(
        AnimationUtils.loadAnimation(this, R.anim.transparency),
        AnimationUtils.loadAnimation(this, R.anim.rotation),
        AnimationUtils.loadAnimation(this, R.anim.expand),
        AnimationUtils.loadAnimation(this, R.anim.move),
        AnimationUtils.loadAnimation(this, R.anim.all_together)
    )
}

Perceba que, nesse exemplo, por ter sido utilizado o parâmetro REVERSE na
propriedade repeatMode, a imagem sempre volta à posição original.

Para que a view mantenha seu aspecto visual após a animação, utilize a
propriedade fillAfter passando o valor true.

Apesar de estar carregando o arquivo de animação e atribuindo o
interpolator em tempo de execução, seria possível atribuir o interpolator
diretamente no XML utilizando a propriedade android:interpolator como mostrado
a seguir:
<translate ...
    android:interpolator="@android:anim/overshoot_interpolator" />

clipChildren e clipToPadding
Como é possível perceber, as animações de escala e de translação ficam
limitadas ao FrameLayout onde o ImageView está contido. Esse é o
comportamento-padrão das views no Android, onde o desenho da View é feito
dentro dos limites do ViewGroup onde ela se encontra. Ou seja, qualquer parte
da view que esteja fora desse limite não será desenhado na tela. Se quiser
desabilitar esse comportamento, utilize as propriedades android:clipChildren e
android:clipToPadding de um ViewGroup. A primeira informa que as views-filhas
serão desenhadas além dos limites do ViewGroup, enquanto a segunda permite
que a view seja desenhada no espaço resevado ao padding da ViewGroup.

Faça a seguinte mudança no arquivo
res/layout/activity_view_animations.xml:
<LinearLayout ...
    android:clipChildren="false"



    android:clipToPadding="false">
Execute a aplicação novamente e selecione a animação de escala ou de

translação. Será possível notar que durante a animação a ImageView será
desenhada além dos limites do layout.

ObjectAnimator e ViewPropertyAnimator
A API de animações apresentada na seção anterior é muito interessante, mas
ela tem um problema. Suponha que um botão seja reposicionado na tela
utilizando uma TranslateAnimation, e após a animação o usuário queira clicar
nesse botão. Ele não conseguirá, pois uma característica (ou bug?) da API de
animação é que apenas o aspecto visual do componente é alterado, mas não
seu conteúdo interno. Isso quer dizer que, apesar de o botão mudar a posição
visualmente, ele continuará na posição antiga. Ou seja, se após a animação o
usuário clicar no botão, o evento de clique não ocorrerá.

Outra limitação da API antiga é que só possível animar um conjunto
limitado de propriedades (escala, posição, rotação e transparência).

Devido a essas limitações, o Google introduziu uma nova API de animação
na versão 3.0 (API Level): ObjectAnimator. Com ela é possível animar qualquer
propriedade da view representada por valores numéricos, sendo que essas
mudanças são efetivadas internamente na view e ainda há a possibilidade de
acompanhar cada passo da animação.

No Android 3.1 (API 11) a classe ViewPropertyAnimator foi adicionada. Ela
utiliza internamente a classe ObjectAnimator e permite realizar animações de
forma simples e declarativa.

Assim como nas View Animations, é possível especificar uma duração (que
por padrão é de 300 milissegundos), um interpolator, a quantidade de vezes
que a animação se repetirá, um conjunto de animações e a duração de cada
frame (por padrão é de 10 milissegundos).

ViewPropertyAnimator
Para entender melhor esta classe, crie uma activity similar à anterior e chame-
a de PropertyAnimationsActivity, cujo arquivo de layout
(res/layout/activity_property_animations.xml) é listado a seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"



    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    android:clipToPadding="false"
    tools:context=".PropertyAnimationsActivity">
    <Spinner
        android:id="@+id/spnAnimators"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:entries="@array/animators"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <Spinner
        android:id="@+id/spnInterpolators"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:entries="@array/interpolators"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/spnAnimators" />
    <ImageView
        android:id="@+id/imgBazinga"
        android:layout_width="150dp"
        android:layout_height="150dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:srcCompat="@drawable/bazinga" />
</androidx.constraintlayout.widget.ConstraintLayout>

Visualmente, o arquivo de layout é bem similar ao definido na seção
anterior. Foi utilizado um ConstraintLayout para demonstrar que as animações
podem ser aplicadas em qualquer gerenciador de layout.

Adicione o seguinte array no arquivo res/values/arrays.xml:
    <string-array name="animators">
        <item>AlphaAnimator</item>
        <item>RotateAnimator</item>
        <item>ScaleAnimator</item>
        <item>TranslateAnimator</item>
        <item>AnimatorSet</item>
    </string-array>



Agora deixe o código da PropertyAnimationsActivity como a seguir:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.view.animation.*
import androidx.interpolator.view.animation.FastOutLinearInInterpolator
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import androidx.interpolator.view.animation.LinearOutSlowInInterpolator
import kotlinx.android.synthetic.main.activity_property_animations.*
 
class PropertyAnimationsActivity : AppCompatActivity() {
 
    private var listInterpolators = arrayOf(
            AccelerateDecelerateInterpolator(),
            AccelerateInterpolator(1.0f), // <- fator (opcional)
            AnticipateInterpolator(2.0f), // <- tensão (opcional)
            AnticipateOvershootInterpolator(2.0f, 1.5f), // <- tensão, tensão extra tension (opcional)
            BounceInterpolator(),
            CycleInterpolator(2f), // <- ciclos
            DecelerateInterpolator(1.0f), // <- fator (opcional)
            FastOutLinearInInterpolator(),
            FastOutSlowInInterpolator(),
            LinearOutSlowInInterpolator(),
            LinearInterpolator(),
            OvershootInterpolator(2.0f) // <- tensão (opcional)
    )
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_property_animations)
        imgBazinga.setOnClickListener {
            executeAnimator()
        }
    }
    private fun executeAnimator() {
        val animationIndex = spnAnimators.selectedItemPosition
        val interpolator = listInterpolators[spnInterpolators.selectedItemPosition]
        executeViewPropertyAnimation(animationIndex, interpolator)
    }
    private fun executeViewPropertyAnimation(index: Int, interpolator: Interpolator) {
        when (index) {
            0 -> imgBazinga.animate()
                    .alpha(0f)
                    .setDuration(ANIMATION_DURATION)
                    .setInterpolator(interpolator)
                    .withEndAction {



                        imgBazinga.animate()
                                .alpha(1f)
                                .setDuration(ANIMATION_DURATION)
                                .start()
                    }
            1 -> imgBazinga.animate()
                    .rotation(360f)
                    .setDuration(ANIMATION_DURATION)
                    .withEndAction {
                        imgBazinga.animate()
                                .rotation(0f)
                                .setDuration(ANIMATION_DURATION)
                                .start()
                    }
            2 -> imgBazinga.animate()
                    .scaleX(2f)
                    .scaleY(2f)
                    .setDuration(ANIMATION_DURATION)
                    .withEndAction {
                        imgBazinga.animate()
                                .scaleX(1f)
                                .scaleY(1f)
                                .setDuration(ANIMATION_DURATION)
                                .start()
                    }
            3 -> imgBazinga.animate()
                    .translationX(500f)
                    .setDuration(ANIMATION_DURATION)
                    .withEndAction {
                        imgBazinga.animate()
                                .translationX(0f)
                                .setDuration(ANIMATION_DURATION)
                                .start()
                    }
            4 -> imgBazinga.animate()
                    .alpha(0f)
                    .rotation(360f)
                    .scaleX(2f)
                    .scaleY(2f)
                    .translationX(500f)
                    .setDuration(ANIMATION_DURATION)
                    .withEndAction {
                        imgBazinga.animate()
                                .alpha(1f)
                                .rotation(0f)



                                .scaleX(1f)
                                .scaleY(1f)
                                .translationX(0f)
                                .setDuration(ANIMATION_DURATION)
                                .start()
                    }
        }
    }
    companion object {
        private const val ANIMATION_DURATION = 1000L
    }
}

A lista de interpolators é declarada logo no início da classe, similar ao que
foi feito no exemplo da seção anterior. No onCreate(Bundle) o evento de clique
do ImageView é definido e simplesmente está invocando o método
executeAnimator(). Nele, o índice dos Spinners é obtido para selecionar qual
animação e qual interpolator deve ser utilizado. Em seguida, o método
executeViewPropertyAnimation(Int,Interpolator) é chamado.

Nesse método executeViewPropertyAnimation(Int,Interpolator) foi utilizado o índice
passado como parâmetro para executar a respectiva animação. Ao invocar o
método animate() da ImageView é retornado um objeto do tipo ViewPropertyAnimator.
Com esse objeto podemos:

• definir a duração utilizando o método setDuration(long);
• um intervalo de tempo antes que animação execute utilizando o método

setStartDelay(long);
• o interpolator usando setInterpolator(Interpolator);
• animar as posições x, y e z por meio dos métodos x(float), y(float), z(float),

xBy(float), yBy(float) e zBy(float);
• com o método rotation(float) ou rotationBy(float) a rotação é feita em ambos os

eixos (x e y), mas pode-se rotacionar cada eixo individualmente utilizando
os métodos rotationX(float), rotationXBy(float), rotationY(float) e rotationYBy(float);

• a translação pode ser feita usando os métodos translationX(float),
translationBy(float), translationY(float), translationYBy(float), translationZ(float) e
translationZBy(float);

• escala em X e Y utilizando scaleX(float), scaleXBy(float), scaleY(float) e
scaleXBy(float);

• transparência da view com os métodos alpha(float) e alphaBy(float);



• definir uma ação a ser executada quando a animação começar ou terminar
utilizando respectivamente withStartAction(Runnable) e withEndAction(Runnable).

Perceba que é possível combinar a animação de várias propriedades
simplesmente encadeando chamadas de maneira simples.

Faça com que a MainActivity chame a PropertyAnimationsActivity e execute a
aplicação. As animações devem ser similares ao exemplo da seção anterior.

ObjectAnimator
Utilizar a classe ViewPropertyAnimator permite realizar animações de forma bem
simples e similar à classe Animation que foi vista no início do capítulo.
Entretanto, ela é limitada às propriedades listadas anteriormente. Para utilizar
uma propriedade diferente, deve-se utilizar a classe ObjectAnimator que é
subclasse de ValueAnimator, que, por sua vez, é subclasse de Animator.

Observe como ficaria o exemplo anterior utilizando a classe ObjectAnimator.
Defina o método a seguir na classe PropertyAnimationsActivity:
private fun executeObjectAnimator(index: Int, interpolator: Interpolator) {
    val animList = mutableListOf<Animator>()
 
    val alphaAnim = ObjectAnimator.ofFloat(
            imgBazinga, View.ALPHA, 0f).apply {
        duration = ANIMATION_DURATION
        repeatCount = 1
        repeatMode = ValueAnimator.REVERSE
    }
    animList.add(alphaAnim)
 
    val rotateAnim = ObjectAnimator.ofFloat(
            imgBazinga, View.ROTATION, 360f).apply {
        duration = ANIMATION_DURATION
        repeatCount = 1
        repeatMode = ValueAnimator.REVERSE
    }
    animList.add(rotateAnim)
    val scaleX = ObjectAnimator.ofFloat(
            imgBazinga, View.SCALE_X, 2f).apply {
        repeatCount = 1
        repeatMode = ValueAnimator.REVERSE
        duration = ANIMATION_DURATION
    }
    val scaleY = ObjectAnimator.ofFloat(



            imgBazinga, View.SCALE_Y, 2f).apply {
        repeatCount = 1
        repeatMode = ValueAnimator.REVERSE
        duration = ANIMATION_DURATION
    }
    val set = AnimatorSet()
    set.playTogether(scaleX, scaleY)
    animList.add(set)
 
    val translAnim = ObjectAnimator.ofFloat(
            imgBazinga, View.TRANSLATION_X, 0f, 500f).apply {
        duration = ANIMATION_DURATION
        repeatMode = ValueAnimator.REVERSE
        repeatCount = 1
    }
    animList.add(translAnim)
 
    val allTogether = AnimatorSet()
    allTogether.playTogether(alphaAnim, rotateAnim, set, translAnim)
    animList.add(allTogether)
 
    animList[index].interpolator = interpolator
    animList[index].start()
}

Foi utilizado o método ofFloat(T,Property,float) para criar um objeto da classe
ObjectAnimator. Para cada animação, foi definida a duração na propriedade
duration, a quantidade de vezes que a animação será repetida em repeatCount. A
propriedade repeatMode indica que a animação deve ser feita de forma reversa
ao repetir.

Para executar a animação de escala, foi utilizado um AnimatorSet para animar
as propriedades SCALE_X e SCALE_Y juntas. Para que isso aconteça, o método
playTogether (Animator...) foi utilizado. Para que as animações executem de forma
sequencial, deveria ser chamado o método playSequentially(Animator...).

Algo bem semelhante foi feito com o objeto allTogether para executar todas as
animações de uma única vez. Todas as animações que foram criadas são
adicionadas na lista animList. Então, no final do método, é executada apenas a
animação correspondente ao índice que foi passado como parâmetro.

Para testar esse exemplo, altere o método executeAnimator() para chamar o
executeObjectAnimator(Int,Interpolator):
private fun executeAnimator() {
    val animationIndex = spnAnimators.selectedItemPosition



    val interpolator = listInterpolators[spnInterpolators.selectedItemPosition]
    executeObjectAnimator(animationIndex, interpolator)
}

O mesmo efeito de animação do exemplo anterior deve ser obtido. Como se
pode notar, o código ficou maior que o exemplo anterior, mas uma das
vantagens de utilizar o ObjectAnimator é a possibilidade de definir as animações
em arquivos XML. Crie os seguintes arquivos na pasta res/animator:

• res/animator/fade.xml
<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="1000"
    android:propertyName="alpha"
    android:repeatCount="1"
    android:repeatMode="reverse"
    android:valueFrom="1"
    android:valueTo="0"
    android:valueType="floatType" />

• res/animator/rotation.xml
<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="1000"
    android:propertyName="rotation"
    android:repeatCount="1"
    android:repeatMode="reverse"
    android:valueFrom="0"
    android:valueTo="360"
    android:valueType="floatType" />

• res/animator/scale.xml
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:ordering="together">
    <objectAnimator
        android:duration="1000"
        android:propertyName="scaleX"
        android:repeatCount="1"
        android:repeatMode="reverse"
        android:valueFrom="1"
        android:valueTo="2"
        android:valueType="floatType" />
    <objectAnimator
        android:duration="1000"
        android:propertyName="scaleY"
        android:repeatCount="1"



        android:repeatMode="reverse"
        android:valueFrom="1"
        android:valueTo="2"
        android:valueType="floatType" />
</set>

• res/animator/translate.xml
<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="1000"
    android:propertyName="translationX"
    android:repeatCount="1"
    android:repeatMode="reverse"
    android:valueFrom="0"
    android:valueTo="500"
    android:valueType="floatType" />

• res/animator/all_together.xml
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:ordering="together">
    <!-- Coloque todas as animações anteriores aqui-->
</set>

Os arquivos são bem descritivos e autoexplicativos, uma vez que os
conceitos já são conhecidos. A tag <objectAnimator> representa um objeto da
classe ObjectAnimator, enquanto a tag <set> representa um AnimatorSet.

Para carregar esses arquivos, defina o método a seguir na classe
PropertyAnimationsActivity:
private fun executeObjectAnimatorFromXml(index: Int, interpolator: Interpolator) {
    val animList = listOf(
            AnimatorInflater.loadAnimator(this, R.animator.fade),
            AnimatorInflater.loadAnimator(this, R.animator.rotation),
            AnimatorInflater.loadAnimator(this, R.animator.scale),
            AnimatorInflater.loadAnimator(this, R.animator.translate),
            AnimatorInflater.loadAnimator(this, R.animator.all_together)
    )
    animList[index].interpolator = interpolator
    animList[index].setTarget(imgBazinga)
    animList[index].start()
}

O arquivo de animação é carregado utilizando o método
loadAnimator(Context,int) da classe AnimatorInflater. Em seguida, o interpolator é
atribuído à animação, e, finalmente, a View alvo da animação é atribuída



utilizando o método setTarget(Object).
Para testar esse método, basta alterar novamente o método executeAnimator():

private fun executeAnimator() {
    val animationIndex = spnAnimators.selectedItemPosition
    val interpolator = listInterpolators[spnInterpolators.selectedItemPosition]
    executeObjectAnimatorFromXml(animationIndex, interpolator)
}

Para ser notificado sobre as mudanças de estado da animação, pode-se
utilizar o código a seguir:
animator.addListener(object : AnimatorListenerAdapter() {
    override fun onAnimationCancel(animation: Animator) { }
    override fun onAnimationEnd(animation: Animator) { }
    override fun onAnimationRepeat(animation: Animator) { }
    override fun onAnimationStart(animation: Animator) { }
    override fun onAnimationPause(animation: Animator) { }
    override fun onAnimationResume(animation: Animator) { }
})

No método addListener(AnimatorListener) foi passado um objeto do tipo
AnimatorListenerAdapter, que já implementa todos os métodos da interface
AnimatorListener. Então só é preciso implementar os métodos desejados. Foram
listados todos aqui apenas exemplificar sua declaração.

TypeEvaluator
Para realizar as animações, a classe ValueAnimator (super classe de ObjectAnimator)
utiliza implementações da interface TypeEvaluator para calcular os valores
utilizados por cada frame da animação. A API já disponibiliza três
implementações dessa interface: IntEvaluator, FloatEvaluator e ArgbEvaluator. Como
os próprios nomes descrevem, as duas primeiras implementações são
utilizadas em propriedades do tipo Int e Float respectivamente, enquanto a
última é utilizada em propriedades que utilizam cores.

Para exemplificar o uso do ArgbEvaluator, será criado um exemplo que anima
a cor do texto e de background de um TextView. Para isso, faça a seguinte
mudança no arquivo res/layout/activity_property_animations.xml:
<androidx.constraintlayout.widget.ConstraintLayout ...
    <TextView
        android:id="@+id/txtArgb"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"



        android:layout_margin="8dp"
        android:text="ARG Evaluator"
        android:textSize="24sp"
        android:textColor="#000"
        android:background="#FFF"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent" />

Adicione a seguinte implementação na classe PropertyAnimationsActivity:
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    ...
    txtArgb.setOnClickListener { animateText() }
}
private fun animateText() {
    val textColorAnim = ObjectAnimator.ofArgb(
            txtArgb, "textColor",
            Color.BLACK, Color.WHITE).apply {
        duration = 1000L
        repeatMode = ValueAnimator.REVERSE
        repeatCount = 1
    }
    val bgColorAnim = ObjectAnimator.ofArgb(
            txtArgb, "backgroundColor",
            Color.WHITE, Color.RED).apply {
        duration = 1000L
        repeatMode = ValueAnimator.REVERSE
        repeatCount = 1
    }
    val set = AnimatorSet()
    set.playTogether(textColorAnim, bgColorAnim)
    set.start()
}

Para animar as propriedades textColor e backgroundColor foi utilizado o método
ofArgb(Object,String,int...) da classe ObjectAnimator. Perceba que são passadas como
parâmetro as cores inicial e final. Outro detalhe é que, assim como nos outros
exemplos, a animação reversa está sendo realizada.

Para implementar uma animação com uma progressão de valores diferentes,
deve-se implementar um TypeEvaluator personalizado.

Execute a aplicação novamente e clique no TextView que foi adicionado e a
mudança de cor será feita de forma animada.



Animação quadro a quadro
Um tipo de animação bastante comum é a quadro a quadro, ou sprite, como
também é conhecida. A ideia é exibir uma sequência de imagens em
intervalos curtos de tempo dando a impressão de animação. Ao refletir um
pouco, é exatamente isso que acontece em filmes, onde os quadros (frames)
são executados sequencialmente e, à medida que eles passam pelo projetor, a
exibição do filme é feita.

No Android, podemos obter um comportamento similar via código por
meio da classe AnimationDrawable ou no XML pela tag <animation-list>.

Para demonstrar esse recurso, pegue um conjunto de imagens que formarão
a animação e coloque-as na pasta res/drawable. Aqui foram utilizadas as
imagens owl_1.png, owl_2.png e owl_3.png apresentadas juntas na Figura
26.2.

  

Figura 26.2 – Imagens utilizadas na animação quadro a quadro.
Depois é só criar o arquivo XML animação res/drawable/sprite_owl.xml,

que deve ficar como a seguir:
<animation-list
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:oneshot="false">
    <item
        android:drawable="@drawable/owl_1"



        android:duration="2000" />
    <item
        android:drawable="@drawable/owl_2"
        android:duration="100" />
    <item
        android:drawable="@drawable/owl_3"
        android:duration="200" />
    <item
        android:drawable="@drawable/owl_1"
        android:duration="100" />
</animation-list>

Como se pode observar, cada quadro é definido com a tag <item> em que a
imagem é atribuída na propriedade android:drawable e na propriedade
android:duration define-se o tempo que cada imagem será exibida. Outro ponto
interessante é o atributo android:oneshot, que, se definido como true, fará com que
a animação só execute uma vez.

Agora basta utilizar a animação em uma ImageView. Adicione a SpriteActivity e
deixe o seu arquivo de layout res/layout/activity_sprite.xml como a seguir:
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ImageView
        android:id="@+id/imgSprite"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerHorizontal="true"
        android:layout_centerVertical="true"
        android:background="@drawable/sprite_owl" />
</RelativeLayout>

Agora deixe a SpriteActivity como a seguir:
import android.graphics.drawable.AnimationDrawable
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import kotlinx.android.synthetic.main.activity_sprite.*
class SpriteActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_sprite)
        imgSprite.setOnClickListener {
            val spriteAnimation = imgSprite.background as AnimationDrawable
            if (spriteAnimation.isRunning) {



                spriteAnimation.stop()
            } else {
                spriteAnimation.start()
            }
        }
    }
}

Para obter a instância do “sprite” definido como background da ImageView
foi utilizada a propriedade background e feito o cast para a classe adequada
AnimationDrawable. Para iniciar a animação, basta chamar o método start() e para
parar a animação invocamos o stop().

Foi utilizado o arquivo XML para definir os quadros da animação, mas isso
poderia ser feito via código com o método addFrame(Drawable, int):
spriteAnimation.addFrame(
        ResourcesCompat.getDrawable(resources, R.drawable.owl_1, theme), 2000)
spriteAnimation.addFrame(
        ResourcesCompat.getDrawable(resources, R.drawable.owl_2, theme), 100)
spriteAnimation.addFrame(
        ResourcesCompat.getDrawable(resources, R.drawable.owl_3, theme), 200)
spriteAnimation.addFrame(
        ResourcesCompat.getDrawable(resources, R.drawable.owl_1, theme), 100)
spriteAnimation.isOneShot = false

De maneira bem simples, é possível dar um toque especial à aplicação
fazendo uma animação quadro a quadro personalizada. Faça com que a
MainActivity chame a SpriteActivity e execute a aplicação. Ao clicar na imagem, a
animação iniciará; clicando novamente, a animação será interrompida.

Animando alterações no layout
No Android 3.0 foi adicionado o recurso de animar automaticamente as
mudanças de layout. Com ele, uma animação é realizada: quando a
visibilidade (propriedade visibility) de uma view é modificada; quando seu
tamanho ou posicionamento é alterado; e quando uma view é adicionada ou
removida de um ViewGroup (FrameLayout, LinearLayout, RelativeLayout etc.). Para
utilizar esse recurso, basta definir a propriedade android:animateLayoutChanges
como true.

Crie uma nova activity chamada LayoutChangesActivity e deixe o seu arquivo de
layout res/layout/activity_layout_changes.xml da seguinte forma:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"



    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    <Button
        android:id="@+id/btnAdd"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Adicionar" />
    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent">
        <LinearLayout
            android:id="@+id/llContainer"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:animateLayoutChanges="true"
            android:orientation="vertical" />
    </ScrollView>
</LinearLayout>

A ideia desse exemplo é adicionar um Button ao llContainer quando o botão
btnAdd for clicado. Essa implementação é feita a seguir:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.view.View
import android.widget.Button
import kotlinx.android.synthetic.main.activity_layout_changes.*
 
class LayoutChangesActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_layout_changes)
        var count = 1
        val removeClickListener = View.OnClickListener { view ->
            llContainer.removeView(view)
        }
        btnAdd.setOnClickListener {
            llContainer.addView(Button(this).apply {
                text = "Button $count"
                setOnClickListener(removeClickListener)
            })
            count++
        }
    }



}
Ao clicar no botão btnAdd um novo botão é adicionado ao llContainer usando o

método addView(View). Um texto é atribuído ao botão e o objeto
removeClickListener é usado para tratar o evento de click do botão adicionado. O
removeClickListener apenas removerá o botão do layout utilizando o método
removeView(View).

A animação-padrão é um fade-in e fade-out para quando uma View é
adicionada e removida respectivamente. Para mudar essa transição, defina o
método a seguir e chame-o no onCreate(Bundle):
private fun initTransition() {
    val display = windowManager.defaultDisplay
    val size = Point()
    display.getSize(size)
    val width = size.x
    llContainer.layoutTransition = LayoutTransition().apply {
        val slideRight = ObjectAnimator.ofPropertyValuesHolder(
                null as Any?,
                PropertyValuesHolder.ofFloat(View.X, 0f, width.toFloat())
        )
        slideRight.duration = 300
        val scaleUp = ObjectAnimator.ofPropertyValuesHolder(
                null as Any?,
                PropertyValuesHolder.ofFloat(View.SCALE_X, 0f, 1f),
                PropertyValuesHolder.ofFloat(View.SCALE_Y, 0f, 1f)
        )
        scaleUp.duration = 300
        scaleUp.startDelay = 300
        scaleUp.interpolator = OvershootInterpolator()
        setAnimator(LayoutTransition.APPEARING, scaleUp)
        setAnimator(LayoutTransition.DISAPPEARING, slideRight)
    }
}

Com a propriedade layoutTransition é possível definir uma transição
diferenciada quando houver mudanças no layout. Para a transição de
“aparecer” algo no layout (LayoutTransition.APPEARING), foi definida a animação
scaleUp, já para quando algo “desaparece” do layout
(LayoutTransition.DISAPPEARING) foi atribuída a animação slideRight. Perceba que
foi utilizada a classe WindowManager para obter a largura da tela. Execute a
aplicação novamente, e com essa mudança uma animação diferenciada será
executada ao incluir e excluir um botão da tela.



Transition API
No Android KitKat (API Level 19) foi lançada a Transitions API que permite
realizar transições dentro da própria tela de forma muito simples. Como foi
mostrado na seção anterior, é possível animar as mudanças ocorridas no
layout utilizando a propriedade android:animateLayoutChanges. Entretanto, essas
animações vão acontecer sempre que uma mudança ocorra. Para que a
animação seja executada apenas em determinada situação, deve-se utilizar a
Transitions API.

Essa API é bem simples e possui poucas classes, e a principal delas é a
TransitionManager que é responsável por armazenar o estado atual do layout da
tela, verificar as mudanças que foram feitas e realizar a animação. Para que
isso ocorra, basta utilizar a seguinte chamada:
TransitionManager.beginDelayedTransition(viewGroup)

Isso fará com que as mudanças de layout tais como: exibir, ocultar ou
redimensionar uma view sejam realizadas de forma suave por meio de uma
animação.

A transition API traz algumas transições predefinidas. No KitKat (API 19),
foram adicionadas as transições Fade (in ou out), ChangeBounds, AutoTransition e
TransitionSet. E no Lollipop (API 21) foram adicionadas Slide, Explode,
ChangeClipBounds, ChangeImageTransform e ChangeTransform. A Tabela 26.3 resume o
comportamento das transições.

Tabela 26.3 – Tipos Transition
Transition Comportamento da transição

Fade Muda a opacidade da View.
ChangeBounds Muda as dimensões da View.
AutoTransition Executa o Fade (out) das views que são removidas e/ou ocultadas, o ChangeBounds das

views que mudaram de tamanho e faz o Fade (in) das views que são adicionadas e/ou
inseridas.

TransitionSet Executa várias transições em sequência ou em paralelo.
Slide Desliza a view na horizontal ou na vertical.
Explode Espalha as views para todas as bordas da tela para criar um efeito “de explosão”.
ChangeClipBounds Anima a mudança da área de clip da view.
ChangeImageTransform Anima a mudança na matriz da imagem de uma ImageView.
ChangeTransform Anima a rotação e escala da view.

Para entender esse conceito na prática, crie uma nova activity chamada



TransitionActivitiy e deixe seu arquivo de layout
/res/layout/activity_transition.xml da seguinte forma:
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/llContainer"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">
    <TextView
        android:id="@+id/txtName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Nome" />
    <EditText
        android:id="@+id/edtName"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
    <TextView
        android:id="@+id/txtEmail"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Email" />
    <EditText
        android:id="@+id/edtEmail"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
    <Button
        android:id="@+id/btnOk"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="OK" />
</LinearLayout>

Nada de especial nesse layout. Então faça a seguinte implementação na
TransitionActivity:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.transition.*
import android.view.Gravity
import android.view.View
import kotlinx.android.synthetic.main.activity_transition.*
 
class TransitionActivity : AppCompatActivity() {
    private var fieldsVisible = true



 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_transition)
        btnOk.setOnClickListener {
            executeTransition()
            fieldsVisible = !fieldsVisible
            val visibility = if (fieldsVisible) View.VISIBLE else View.GONE
            txtName.visibility = visibility
            edtName.visibility = visibility
            txtEmail.visibility = visibility
            edtEmail.visibility = visibility
        }
    }
    private fun executeTransition() {
        val transitionSet = TransitionSet()
        transitionSet.ordering = TransitionSet.ORDERING_SEQUENTIAL
        if (fieldsVisible) {
            executeInvisibleTransition(transitionSet)
        } else {
            executeVisibleTransition(transitionSet)
        }
        TransitionManager.beginDelayedTransition(llContainer, transitionSet)
    }
    private fun executeInvisibleTransition(transitionSet: TransitionSet) {
        transitionSet.addTransition(Explode())
        transitionSet.addTransition(ChangeBounds())
    }
    private fun executeVisibleTransition(transitionSet: TransitionSet) {
        transitionSet.addTransition(ChangeBounds())
        transitionSet.addTransition(Slide(Gravity.END))
    }
}

Ao clicar no botão, os dois TextView e os dois EditText são ocultados, mas ao
chamar o método executeTransition() antes, fará com que essa transição seja feita
de forma animada por meio do TransitionManager.

No método executeTransition() foi criado um objeto TransitionSet que permite
executar um conjunto de transições. A ordem das transições é definida como
sequencial (ORDERING_SEQUENTIAL). Quando os campos estiverem visíveis
será executada a transição para ocultar os componentes por meio do método
executeInvisibleTransition(TransitionSet), e a operação contrária é feita no método
executeVisibleTransition(TransitionSet).



Ao ocultar as views são utilizadas as transições ChangeBounds e Explode. A
primeira será responsável por animar o redimensionamento da view, já que
ela ficará menor quando os componentes forem ocultados. A segunda, por
sua vez, fará com que os itens desapareçam saindo pelas bordas rapidamente
como uma “explosão”. Perceba que a ordem é importante. A transição foi
definida como sequencial, então os componentes sairão da tela primeiro para
depois redimensionar o layout.

A transição de exibir as views utiliza a classe Slide para animar as views do
lado direito da tela (ou esquerdo para idiomas RTL) para a outra extremidade
da tela. Note que aqui foi feita a ordem inversa. Primeiro foram
redimensionadas as views e depois o slide é feito.

Chame a TransitionActivity a partir da MainActivity e execute a aplicação. Ao
clicar no botão já poderão ser vistas as transições em ação.

É possível customizar a transição para componentes específicos, como, por
exemplo, fazer com que cada um dos dois EditText anime de uma direção
diferente. Faça o seguinte ajuste no método executeVisibleTransition():
private fun executeVisibleTransition(transitionSet: TransitionSet) {
    transitionSet.addTransition(ChangeBounds())
    transitionSet.addTransition(TransitionSet().apply {
        ordering = TransitionSet.ORDERING_TOGETHER
        addTransition(Slide(Gravity.START).apply {
            addTarget(txtName)
            addTarget(edtName)
        })
        addTransition(Slide(Gravity.END).apply {
            addTarget(txtEmail)
            addTarget(edtEmail)
        })
    })
}

Após a transição de mudança de tamanho do layout com ChangeBounds um
TransitionSet foi adicionado. Todas as transições desse conjunto serão
executadas juntas, por isso foi definida a propriedade ordering como
ORDERING_TOGETHER. Em seguida, foi adicionada a transição de Slide
começando do início da tela. Com o método addTarget(View) são definidas as
views que serão alvo dessa transição, que serão txtName e edtName. Logo em
seguida é criada outra transição do tipo Slide, mas começando do fim da tela e
tendo como target txtEmail e edtEmail.



Execute a aplicação novamente. Agora, quando os campos ficarem visíveis,
cada par (TextView e respectivo EditText) aparecerá de uma extremidade da tela
diferente ao mesmo tempo.

É possível implementar essas mesmas transições em arquivos XML. Crie o
diretório res/transition e adicione o arquivo fields_invisible.xml:
<transitionSet xmlns:android="http://schemas.android.com/apk/res/android"
    android:transitionOrdering="sequential">
    <explode />
    <changeBounds />
</transitionSet>

Agora crie o arquivo res/transition/fields_visible.xml:
<transitionSet xmlns:android="http://schemas.android.com/apk/res/android"
    android:transitionOrdering="sequential">
    <changeBounds />
    <transitionSet android:transitionOrdering="together">
        <slide android:slideEdge="start">
            <targets>
                <target android:targetId="@+id/txtName"/>
                <target android:targetId="@+id/edtName"/>
            </targets>
        </slide>
        <slide android:slideEdge="end">
            <targets>
                <target android:targetId="@+id/txtEmail"/>
                <target android:targetId="@+id/edtEmail"/>
            </targets>
        </slide>
    </transitionSet>
</transitionSet>

Como se pode observar, as tags XML são tão descritivas ou até mais que as
classes que foram utilizadas anteriormente. Da mesma forma que foi
adicionado uma view como target de uma transição com o método
addTarget(View) da classe TransitionSet, aqui foram utilizadas as tags <targets> e
<target>. Pode-se também utilizar o método excludeTarget(View) e a propriedade
android:excludeId para excluir determinada view da transição. Por exemplo:
// No xml
    <target android:excludeId="@+id/txtEmail"/>
// No código
    transition.excludeTarget(txtEmail)

Para carregar esses arquivos, deve-se utilizar a classe TransitionInflater. Crie o



método executeTransitionXml() e deixe-o como a seguir:
private fun executeTransitionXml() {
    val transition = if (fieldsVisible) {
        TransitionInflater.from(this).inflateTransition(R.transition.fields_invisible)
    } else {
        TransitionInflater.from(this).inflateTransition(R.transition.fields_visible)
    }
    TransitionManager.beginDelayedTransition(llContainer, transition)
}

Agora invoque esse método no evento de clique do botão:
btnOk.setOnClickListener {
    executeTransitionXml()
    ...
}

Ao executar a aplicação deve-se obter uma transição idêntica à que foi feita
anteriormente via código.

Foram utilizadas as subclasses de Transition disponíveis na plataforma, mas é
possível definir uma transição customizada criando uma subclasse de
Transition.

Obviamente que, assim como as demais APIs que já foram apresentadas
aqui, é possível definir um listener para saber sobre a mudança de estado de
uma transição. Para isso, basta utilizar o método addListener(TransitionListener) de
qualquer objeto Transition e passar uma instância da interface TransitionListener:
transition.addListener(object : Transition.TransitionListener {
    override fun onTransitionEnd(transition: Transition?) {}
    override fun onTransitionResume(transition: Transition?) {}
    override fun onTransitionPause(transition: Transition?) {}
    override fun onTransitionCancel(transition: Transition?) {}
    override fun onTransitionStart(transition: Transition?) {}
})

A Transition API é muito poderosa e ajuda a implementar transições na tela
atual de maneira bem simples.

Animações circulares
Um efeito muito utilizado no Material Design é o reveal effect, uma
animação para exibir ou ocultar um componente com um efeito circular. Um
exemplo clássico do seu uso é implementar uma transição que simule a
transformação de um FloatingActionButton em alguma outra view.



Para exemplificar esse efeito, adicione a biblioteca do material design no
build.gradle para usar o FloatingActionButton:
dependencies {
    implementation 'com.google.android.material:material:1.0.0'
}

Crie uma nova activity chamada RevealActivity e deixe o arquivo de layout
res/layout/activity_reveal.xml da seguinte forma:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/rootLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".RevealActivity">
    <com.google.android.material.card.MaterialCardView
        android:id="@+id/viewCard"
        android:layout_width="0dp"
        android:layout_height="300dp"
        android:layout_margin="16dp"
        android:visibility="invisible"
        app:cardBackgroundColor="@color/colorAccent"
        app:cardCornerRadius="6dp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/fabAdd"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginEnd="@dimen/default_margin"
        android:layout_marginBottom="@dimen/default_margin"
        android:tint="@android:color/white"
        app:fabSize="normal"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

A ideia desse exemplo é fazer o botão mover-se até o centro da CardView e
então fazer o efeito de revelar (reveal effect). Adicione a dimensão
default_margin no arquivo res/values/dimens.xml, pois ela também será usada no
código Kotlin:
<resources>



    <dimen name="default_margin">16dp</dimen>
</resources>

Agora faça a seguinte implementação na classe RevealActivity:
import android.animation.Animator
import android.animation.AnimatorListenerAdapter
import android.os.Bundle
import android.view.View
import android.view.ViewAnimationUtils
import androidx.appcompat.app.AppCompatActivity
import androidx.constraintlayout.widget.ConstraintSet
import androidx.constraintlayout.widget.ConstraintSet.*
import androidx.transition.*
import kotlinx.android.synthetic.main.activity_reveal.*
 
class RevealActivity : AppCompatActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_reveal)
        fabAdd.setOnClickListener { showCard() }
        viewCard.setOnClickListener { hideCard() }
    }
    private fun showCard() {
        moveFab(true)
    }
    private fun hideCard() {
        revealAnimation(false, viewCard.width, fabAdd.width)
    }
    private fun revealAnimation(forward: Boolean, initialRadius: Int, finalRadius: Int) {
        val cx = viewCard.width / 2
        val cy = viewCard.height / 2
        val anim = ViewAnimationUtils.createCircularReveal(viewCard, cx, cy,
                initialRadius.toFloat(), finalRadius.toFloat())
        anim.addListener(object : AnimatorListenerAdapter() {
            override fun onAnimationEnd(animation: Animator) {
                super.onAnimationEnd(animation)
                if (!forward) {
                    viewCard.visibility = View.INVISIBLE
                    fabAdd.visibility = View.VISIBLE
                    moveFab(false)
                }
            }
        })
        if (forward) {



            viewCard.visibility = View.VISIBLE
        }
        anim.start()
    }
    private fun moveFab(forward: Boolean) {
        val transition = TransitionSet().apply {
            addTransition(ChangeBounds())
            addTransition(ChangeTransform())
            ordering = TransitionSet.ORDERING_TOGETHER
            duration = resources
                    .getInteger(android.R.integer.config_mediumAnimTime)
                    .toLong()
            setPathMotion(ArcMotion())
            addListener(object : TransitionListenerAdapter() {
                override fun onTransitionEnd(transition: Transition) {
                    if (forward) {
                        fabAdd.visibility = View.INVISIBLE
                        revealAnimation(true, fabAdd.width, viewCard.width)
                    }
                }
            })
        }
        val constraintSet = ConstraintSet()
        constraintSet.clone(rootLayout)
        TransitionManager.beginDelayedTransition(rootLayout, transition)
        if (forward) {
            with(constraintSet) {
                clear(R.id.fabAdd, BOTTOM)
                clear(R.id.fabAdd, END)
                listOf(TOP, START, BOTTOM, END).forEach {
                    connect(R.id.fabAdd, it, R.id.viewCard, it, 0)
                }
            }
            constraintSet.applyTo(rootLayout)
            fabAdd.scaleX = 2f
            fabAdd.scaleY = 2f
        } else {
            with(constraintSet) {
                val margin = resources.getDimension(R.dimen.default_margin).toInt()
                listOf(TOP, START, BOTTOM, END).forEach {
                    clear(R.id.fabAdd, it)
                }
                connect(R.id.fabAdd, BOTTOM, PARENT_ID, BOTTOM, margin)
                connect(R.id.fabAdd, END, PARENT_ID, END, margin)
            }



            constraintSet.applyTo(rootLayout)
            fabAdd.scaleX = 1.0f
            fabAdd.scaleY = 1.0f
        }
    }
}

KOTLINxJAVA: O bloco with permite acessar as propriedades do objeto passado
como parâmetro sem ter que referenciá-lo todas as vezes. Além disso, dentro
desse bloco, this é o objeto passado por parâmetro.

Nessa classe são realizadas duas ações: a primeira é iniciada pelo método
showCard() e acontece ao clicar no FAB, que fará com que o botão movimente-
se até o centro do CardView (que estará invisível), e nesse momento a animação
circular ocorrerá, deixando o FAB invisível e o CardView visível; a segunda
ação acontece ao clicar no CardView, que chama o método hideCard() e realizará a
animação reversa.

O método showCard() chama o método moveFab(Boolean). Quando o parâmetro
forward for true, isso indica que o botão deve mover-se para o centro do
CardView. Então é criada uma instância de TransitionSet que ficará responsável
por animar as mudanças que forem realizadas no layout. Foram utilizadas as
transições ChangeBounds e ChangeTransform que tratam respectivamente o
posicionamento e a escala dos componentes. Também foi definido que as
animações devem acontecer juntas (ORDERING_TOGETHER), a duração utilizará
um valor-padrão do Android (400 ms) e a movimentação será feita como uma
curva utilizando o ArcMotion. Ao terminar a animação, é verificado se forward é
true, se sim o FAB é ocultado e o reveal effect começará.

Configurada a transição, a classe ConstraintSet é utilizada para configurar as
constraints dos componentes adicionados em um ConstraintLayout.
Primeiramente é invocado o método clone(ConstraintLyout) para obter o estado
atual do ContraintLayout. Em seguida, é verificado se o parâmetro forward é
verdadeiro, que é o caso quando o método atual é chamado a partir do
showCard(). Então o FAB é desconectado do canto inferior direito da tela
(BOTTOM/END) utilizando o método clear(Int,Int). Em seguida, são aplicadas as
novas constraints utilizando o método applyTo(ConstraintLayout) para que FAB
fique no centro do viewCard. E, por fim, a escala do FAB é aumentada
utilizando as propriedades scaleX e scaleY para dar um efeito mais interessante.



Para criar a reveal animation é utilizado o método createCircularReveal(View, int,
int, float, float) da classe ViewAnimationUtils, passando como parâmetro a view que
será animada e as coordenadas x e y de onde a animação deve iniciar. Os dois
últimos parâmetros representam respectivamente o raio inicial e final do
círculo que será criado no efeito da animação. Como esse método retorna um
objeto Animator, foi definido um listener para ocultar a CardView se o parâmetro
forward for false.

O método hideCard() faz a operação reversa. Chama primeiro a
revealAnimation(Boolean,Int,Int) e, ao terminar, chama o moveFab(Boolean).

Execute a aplicação e veja o reveal effect em funcionamento.

Transições entre Activities
Desde a primeira versão do Android é possível realizar animações entre
activities utilizando o método overridePendingTransition(int,int), em que são
passados como parâmetro, respectivamente, os arquivos XML de animação
da saída da activity atual e de entrada da activity que será exibida.

Vamos criar uma transição de tela para abrir cada exemplo que foi
implementado nesse capítulo a partir da MainActivity:
import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.ArrayAdapter
import android.widget.ListView
 
class MainActivity : AppCompatActivity() {
    private val options = mapOf(
            "View Animations" to ViewAnimationsActivity::class.java,
            "Property Animations" to PropertyAnimationsActivity::class.java,
            "Sprite Animation" to SpriteActivity::class.java,
            "Layout Animation" to LayoutChangesActivity::class.java,
            "Transitions" to TransitionActivity::class.java,
            "Reveal" to RevealActivity::class.java
    )
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val adapter = ArrayAdapter(this,
                android.R.layout.simple_list_item_1,
                options.keys.toList())



        val listView = ListView(this)
        listView.adapter = adapter
        listView.setOnItemClickListener { _, _, position, _ ->
            showActivity(position)
        }
        setContentView(listView)
    }
    private fun showActivity(position: Int) {
        val key = options.keys.toList()[position]
        startActivity(Intent(this, options[key]))
    }
}

Criamos um Map chamado options no qual as chaves são os textos que serão
exibidos na ListView e o valor é a classe da activity que será aberta. No
onCreate(Bundle), um ArrayAdapter é criado passando as chaves do Map options. O
ListView é instanciado, seu adapter é atribuído e no evento de clique dos itens
da lista é chamado o método showActivity(Int). Por fim, a ListView é definida
como conteúdo da activity chamando o setContentView(View). Como o arquivo de
layout da MainActivity não é usado, exclua o arquivo
res/layout/activity_main.xml.

Execute a aplicação e agora cada um dos exemplos que foram feitos até
aqui podem ser executados ao clicar no respectivo item da lista. Porém, ainda
não foi definida nenhuma transição entre as activities.

Para fazer isso, adicione os arquivos res/anim/slide_left_in.xml e
res/anim/slide_left_out.xml e deixe-os como a seguir:

• res/anim/slide_left_in.xml
<translate
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromXDelta="100%"
    android:toXDelta="0"
    android:duration="300"/>

• res/anim/slide_left_out.xml
<translate
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromXDelta="0"
    android:toXDelta="-100%"
    android:duration="500"/>

Perceba que foram usados os atributos android:fromXDelta e android:toXDelta com
valores percentuais, que nesse exemplo foi de 100% que indica toda a largura



da view (ou seja, a largura da tela). Caso fosse usado android:fromYDelta e
android:toYDelta, o percentual indicaria a altura da tela.

Feito isso, altere o método showActivity(Int) para ficar da seguinte forma:
private fun showActivity(position: Int) {
    val key = options.keys.toList()[position]
    startActivity(Intent(this, options[key]))
    overridePendingTransition(R.anim.slide_left_in, R.anim.slide_left_out)
}

Isso fará com que a activity seja aberta com uma transição de slide da
direita para a esquerda. Entretanto, ao fechar qualquer activity, a animação-
padrão de saída será executada. Para sobrescrever esse comportamento crie a
classe BaseActivity e deixe-a como a seguir:
import androidx.appcompat.app.AppCompatActivity
 
abstract class BaseActivity: AppCompatActivity() {
    override fun finish() {
        super.finish()
        overridePendingTransition(R.anim.slide_right_in, R.anim.slide_right_out)
    }
}

A transição-padrão foi substituída ao sobrescrever o método finish() da
activity que é chamado quando a tecla de voltar é pressionada ou quando a
activity é explicitamente encerrada.

Faça com que as demais activities do projeto herdem da BaseActivity:
class ViewAnimationsActivity : BaseActivity() { ... }
class PropertyAnimationsActivity : BaseActivity() { ... }
class SpriteActivity : BaseActivity() { ... }
class LayoutChangesActivity : BaseActivity() { ... }
class TransitionActivity : BaseActivity() { ... }
class RevealActivity : BaseActivity() { ... }

Em seguida, adicione os arquivos de animação que foram utilizados na
transição de encerramento da tela:

• res/anim/slide_right_in.xml
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromXDelta="-100%"
    android:toXDelta="0"
    android:duration="500"/>

• res/anim/slide_right_out.xml



<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromXDelta="0"
    android:toXDelta="100%"
    android:duration="500"/>

Execute a aplicação e agora as animações de slide funcionarão tanto ao
abrir quanto ao fechar as activities.

Transição de activities com ActivityOptions
Desde o Android 3.0, a classe ActivityOptions permite alterar a transição-padrão
entre activities. Ela contém basicamente três métodos:

• makeCustomAnimation(Context, int, int) – que configura uma animação
personalizada para a activity que está saindo da tela e outra para a que
está sendo aberta. Essas animações devem estar definidas em arquivos da
pasta res/anim;

• makeScaleUpAnimation(View,int,int,int,int) – que define uma animação de escala
para a activity que será aberta. Nesse caso, deve-se passar como
parâmetro a view que servirá de ponto de partida de onde a activity será
animada, a posição inicial x/y em relação a essa view, e a largura e altura
da activity ao começar a animação;

• makeThumbnailScaleUpAnimation(View,Bitmap,int,int) – é bem parecida com a
anterior, com a diferença que é passado um Bitmap que será usado no
começo da animação de escala.

É possível obter o mesmo comportamento do overridePendingTransition(int,int)
utilizando a classe ActivityOptions com o seguinte código:
private fun showActivity(position: Int) {
    val key = options.keys.toList()[position]
    val animation = ActivityOptions.makeCustomAnimation(this,
            R.anim.slide_left_in, R.anim.slide_left_out).toBundle()
    startActivity(Intent(this, options[key]), animation)
}

Já para fazer uma animação de escala, podemos utilizar esse código na
classe ViewAnimationsActivity:
public override fun onCreate(savedInstanceState: android.os.Bundle?) {
    ...
    imgBazinga.setOnClickListener { view ->
        val animation = ActivityOptions.makeScaleUpAnimation(
                view, 0, 0, view.width, view.height).toBundle()



        startActivity(Intent(this, LayoutChangesActivity::class.java), animation)
    }
}

Foram demonstradas aqui algumas formas de realizar animações entre
activities. Outras formas serão vistas no Capítulo 30.

Animações entre fragments
Aplicar animações em fragments não requer muito esforço. Basicamente
deve-se chamar o método setCustomAnimations(int,int) da classe FragmentManager. No
aplicativo de hotéis, quando executado em tablets, o fragment de detalhes é
carregado na mesma activity. Nesse momento, é interessante atribuir uma
animação para o fragment que será exibido.

Abra o projeto “Google APIs” do Capítulo 18, e na classe HotelActivity, faça a
seguinte mudança no método showDetailsFragment(Long):
private fun showDetailsFragment(hotelId: Long) {
    searchView?.setOnQueryTextListener(null)
    val fragment = HotelDetailsFragment.newInstance(hotelId)
    supportFragmentManager
            .beginTransaction()
            .setCustomAnimations(R.anim.enter_hotel_details, R.anim.exit_hotel_details)
            .replace(R.id.details, fragment, HotelDetailsFragment.TAG_DETAILS)
            .commit()
}

Defina os arquivos de animação para ter o efeito desejado:
• res/anim/enter_hotel_details.xml

<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromYDelta="100%"
    android:toYDelta="0"
    android:duration="500"/>

• res/anim/exit_hotel_details.xml
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromYDelta="0"
    android:toYDelta="-100%"
    android:duration="500"/>

Execute a aplicação em um tablet e ao selecionar um hotel da lista os
detalhes serão exibidos com uma animação de baixo para cima. É possível
animar fragments de maneira semelhante ao que foi feito com as activities.



Animação no ViewPager
Um componente bastante utilizado para facilitar a navegação de telas é o
ViewPager, que foi estudado no Capítulo 9 no projeto Navegacao.

É possível customizar a transição entre as páginas desse componente
criando uma subclasse de ViewPager.PageTransformer e implementando o método
transformPage (View,int). Esse método será invocado a cada movimentação feita na
página que está sendo exibida e na seguinte. O parâmetro int indica a posição
da página em relação ao centro da tela, onde o valor zero indica que a página
preencheu toda a tela. Então, com base nesse valor, é possível criar a
animação que desejarmos.

Adicione ao projeto Navegacao (Capítulo 9) a classe a seguir que está
disponível no site do Android.
import android.view.View
import androidx.viewpager.widget.ViewPager
 
class ZoomPageTransformer : ViewPager.PageTransformer {
    override fun transformPage(view: View, position: Float) {
        val minScale = 0.85f
        val minAlpha = 0.5f
        val pageWidth = view.width
        val pageHeight = view.height
        when {
            (position < -1) ->
                view.alpha = 0f
            (position <= 1) -> {
                val scaleFactor = Math.max(minScale, 1 - Math.abs(position))
                val vertMargin = pageHeight * (1 - scaleFactor) / 2
                val horzMargin = pageWidth * (1 - scaleFactor) / 2
                view.apply {
                    translationX = if (position < 0) {
                        horzMargin - vertMargin / 2
                    } else {
                        -horzMargin + vertMargin / 2
                    }
                    scaleX = scaleFactor
                    scaleY = scaleFactor
                    alpha = minAlpha + (scaleFactor - minScale) /
                            (1 - minScale) * (1 - minAlpha)
                }
            }
            else ->



                view.alpha = 0f
        }
    }
}

Para usá-la, vá até a PagerActivity e chame o método
setPageTransformer(boolean,PageTransformer) do objeto viewPager:
viewPager.setPageTransformer(true, ZoomPageTransformer())

Execute a aplicação e acesse a opção View Pager no menu lateral. Ao abrir
a PagerActivity e fazer a transição de páginas será possível observar a animação.

Esse é mais um exemplo de como podemos aplicar animações aos nossos
aplicativos dando uma suavidade às transições de páginas do ViewPager.

Considerações sobre animações
Uma vez compreendidas as APIs de animação do Android, elas podem ser
aplicadas para deixar os aplicativos mais profissionais e atraentes para o
usuário. Entretanto, é importante ressaltar que você não deve exagerar no seu
uso. Excesso de animações ou animações demoradas podem deixar a
aplicação chata ou até difícil de usar.

Normalmente as animações-padrão são a melhor escolha, pois trazem uma
consistência com o resto do sistema e podem deixar os usuários mais à
vontade, uma vez que eles já estão acostumados com o que acontece nos
outros aplicativos.

As animações são perfeitas para evitar que coisas simplesmente apareçam
na tela sem nenhuma suavidade. Voltaremos a falar sobre esse assunto no
Capítulo 30.



CAPÍTULO 27
Gestos e toque na tela

Um divisor de águas no mundo dos dispositivos móveis foi a popularização
do touchscreen. As telas sensíveis ao toque permitem adicionar recursos
interessantíssimos aos aplicativos com o uso de gestos. Neste capítulo será
demonstrado como detectar e realizar uma ação quando gestos forem
realizados sobre a tela do aparelho.

Detectando toques na tela
Um toque na tela acontece quando o usuário coloca um ou mais dedos sobre
ela. Esse evento pode ser capturado em uma activity como um todo
sobrescrevendo o método onTouchEvent(MotionEvent) ou em uma view,
individualmente definindo um listener com o método
setOnTouchListener(OnTouchListener). Crie um novo projeto para entender melhor
esses eventos.

Application Name Toques
Package Name dominando.android.toques
Activity Name TouchActivity

Deixe a activity como a seguir:
import android.os.Bundle
import android.view.MotionEvent
import android.widget.TextView
 
class TouchActivity : AppCompatActivity() {
    private lateinit var txtTouchEvent: TextView
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        txtTouchEvent = TextView(this)
        setContentView(txtTouchEvent)
    }



    override fun onTouchEvent(event: MotionEvent): Boolean {
        super.onTouchEvent(event)
        var log = "onTouch\n"
        val consumed = when (event.action) {
            MotionEvent.ACTION_DOWN -> {
                log += "ACTION_DOWN\n"
                true
            }
            MotionEvent.ACTION_MOVE -> {
                log += "ACTION_MOVE\n"
                true
            }
            MotionEvent.ACTION_UP -> {
                log += "ACTION_UP\n"
                true
            }
            MotionEvent.ACTION_CANCEL -> {
                log += "ACTION_CANCEL\n"
                true
            }
            MotionEvent.ACTION_OUTSIDE -> {
                log += "ACTION_OUTSIDE\n"
                true
            }
            else -> false
        }
        val fingerOnScreen = event.pointerCount
        log += "Dedos na tela: $fingerOnScreen\n"
        for (i in 0 until fingerOnScreen) {
            log += "$i x=${event.getX(i)}, y=${ event.getY(i)}\n"
        }
        txtTouchEvent.text = log
        return consumed
    }
}

Foi utilizado o método onTouchEvent(MotionEvent) que deve obrigatoriamente
retornar um booleano indicando se o evento foi consumido ou não. Se
qualquer view consumir o evento, a activity não o fará. A propriedade action
do objeto MotionEvent retorna a ação de toque que foi disparada. Essas ações
estão definidas em constantes na classe MotionEvent e as principais estão
listadas na Tabela 27.1.

Tabela 27.1 – Principais eventos de toque na tela



Ação Descrição
ACTION_DOWN Um toque foi efetuado na tela. Essa é a primeira ação que ocorre em um evento de toque.
ACTION_MOVE O usuário está movendo o dedo sobre a tela.
ACTION_UP Um ponto da tela que estava sendo tocado e foi liberado. Isso acontece quando o usuário retira

o dedo da tela.
ACTION_CANCEL O toque foi cancelado, pois outra janela está consumindo o evento.
ACTION_OUTSIDE O toque aconteceu fora dos limites da view.

Perceba que toques na tela não necessariamente querem dizer com o dedo.
Existem dispositivos Android que utilizam canetas ou até mesmo mouse para
efetuar toques na tela. A partir do Android 4.0 (API Level 14) é possível
obter essa informação com o método getToolType(int) da classe MotionEvent.
Passando o índice do toque na tela, esse método pode retornar:
TOOL_TYPE_UNKNOWN (desconhecido), TOOL_TYPE_FINGER (dedo),
TOOL_TYPE_STYLUS (caneta) ou TOOL_TYPE_MOUSE (mouse).

A propriedade pointerCount informa quantos toques estão sendo feitos
simultaneamente na tela. Para cada um desses toques é possível obter as
posições x e y relativas à view usando getX(int) e getY(int) ou à tela como um
todo utilizando os métodos getRawX(int) e getRawY(int). O número máximo de
toques detectados é dez, ou seja, podemos utilizar todos os dedos das mãos ao
mesmo tempo.

A Figura 27.1 mostra nosso aplicativo em execução ao mover cinco dedos
sobre a tela.



Figura 27.1 – Capturando múltiplos toques na tela.
A mesma abordagem pode ser aplicada a uma única view:

txtTouchEvent.setOnTouchListener { view, motionEvent ->
    // Tratar evento aqui
    true
}

Essa é a forma mais simples de tratar eventos de toque. Na próxima seção
será demonstrado como detectar gestos em views.

Detectando gestos
Com a classe GestureDetector é possível detectar gestos mais comuns como tap,
double-tap, scroll e fling. Para isso, é necessário passar para essa classe uma
implementação da interface GestureDetector.OnGestureListener que contém os
métodos listados na Tabela 27.2.

Tabela 27.2 – Gestos capturados pela interface OnGestureListener
Método Descrição

onDown(MotionEvent) Detecta quando o usuário tocou a tela.
onShowPress(MotionEvent) O usuário continua realizando o toque na tela, mas ainda não moveu ou liberou

o dedo da tela. Ele é chamado depois do onDown(MotionEvent) e antes do
onLongPress(MotionEvent).



onSingleTapUp(MotionEvent) Disparado quando o evento de tap ocorre. Ele é bem similar ao clique, mas se o
usuário passar algum tempo pressionando, o onLongPress(MotionEvent) será
chamado.

onScroll(MotionEvent,MotionEvent, Notifica um gesto de scroll tanto horizontal quanto vertical. O primeiro
          float,float) parâmetro é o MotionEvent que disparou o evento, o segundo é o evento de

movimento e os dois últimos são a distância x e y percorrida desde a última
chamada a esse método.

onLongPress(MotionEvent) Detecta um toque longo. Sempre é chamado após o onDown(MotionEvent) e
antes do onShowPress(MotionEvent).

onFling(MotionEvent,MotionEvent, Disparado após liberar o toque depois de um evento de scroll. O primeiro
        float,float) parâmetro é o MotionEvent, que disparou o evento; o segundo é o evento de

movimento; e os dois últimos são a velocidade nos eixos x e y mensurada em
pixels por segundo.

A interface OnDoubleTapListener contém os métodos necessários para detectar o
gesto de toque duas vezes consecutivas, ou simplesmente double tap. Ela
contém os seguintes métodos listados na Tabela 27.3.

Tabela 27.3 – Métodos da interface OnDoubleTapListener
Método Descrição

onSingleTapConfirmed(MotionEvent) Chamado quando um tap simples é realizado e o segundo tap não foi feito.
onDoubleTap(MotionEvent) Notifica que o evento de double tap ocorreu.
onDoubleTapEvent(MotionEvent) Chamado quando um evento ocorre dentro do evento de double tap.

Para usar essas duas interfaces, crie uma nova activity chamada GestureActivity
e deixe-a conforme a seguir:
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.util.Log
import android.view.GestureDetector
import android.view.MotionEvent
import androidx.core.view.GestureDetectorCompat
 
class GestureActivity : AppCompatActivity() {
    private lateinit var gestureDetector: GestureDetectorCompat
 
    private val doubleTapListener: GestureDetector.OnDoubleTapListener =
            object : GestureDetector.OnDoubleTapListener {
                override fun onSingleTapConfirmed(motionEvent: MotionEvent): Boolean {
                    Log.d(TAG, "onSingleTapConfirmed")
                    return true
                }
                override fun onDoubleTap(motionEvent: MotionEvent): Boolean {
                    Log.d(TAG, "onDoubleTap")
                    return true



                }
                override fun onDoubleTapEvent(motionEvent: MotionEvent): Boolean {
                    Log.d(TAG, "onDoubleTapEvent")
                    return true
                }
            }
 
    private val gestureListener: GestureDetector.OnGestureListener =
            object : GestureDetector.OnGestureListener {
                override fun onDown(motionEvent: MotionEvent): Boolean {
                    Log.d(TAG, "onDown")
                    return true
                }
                override fun onShowPress(motionEvent: MotionEvent) {
                    Log.d(TAG, "onShowPress")
                }
                override fun onSingleTapUp(motionEvent: MotionEvent): Boolean {
                    Log.d(TAG, "onSingleTapUp")
                    return true
                }
                override fun onScroll(motionEvent: MotionEvent, motionEvent2: MotionEvent,
                                      v: Float, v2: Float): Boolean {
                    Log.d(TAG, "onScroll")
                    return true
                }
                override fun onLongPress(motionEvent: MotionEvent) {
                    Log.d(TAG, "onLongPress")
                }
                override fun onFling(motionEvent: MotionEvent, motionEvent2: MotionEvent,
                                     v: Float, v2: Float): Boolean {
                    Log.d(TAG, "onFling")
                    return true
                }
            }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_gesture)
        gestureDetector = GestureDetectorCompat(this, gestureListener)
        gestureDetector.setOnDoubleTapListener(doubleTapListener)
    }
    override fun onTouchEvent(event: MotionEvent): Boolean {
        return gestureDetector.onTouchEvent(event)
    }
    companion object {
        private val TAG = "DominandoAndroid"



    }
}

Foi utilizada a classe GestureDetectorCompat, que permite detectar alguns
eventos que só foram introduzidos a partir do Jelly Bean. Uma instância
desse objeto foi criada passando o contexto e uma instância de OnGestureListener.
Logo em seguida foi definido um listener para o evento de double tap
chamando o método setOnDoubleTapListener(OnDoubleTapListener). Execute a
aplicação e teste os eventos de tap, double tap, scroll e long press. Você
obterá resultados similares aos da Tabela 27.4.

Tabela 27.4 – Eventos disparados durante a detecção dos gestos
Tap Double tap Scroll Long press

onDown onDown onDown onDown
onSingleTapUp onSingleTapUp onScroll onShowPress
onSingleTapConfirmed onDoubleTap onScroll onLongPress

onDoubleTapEvent onScroll
onDown onScroll
onDoubleTapEvent onScroll

onScroll
onFling

Perceba que durante a detecção dos gestos vários métodos podem ser
chamados. Se não quiser implementar todos eles, é possível criar um objeto
da classe SimpleOnGestureListener e sobrescrever apenas os métodos desejados.
Por exemplo, podem-se implementar apenas os métodos
onDoubleTap(MotionEvent) e onLongPress (MotionEvent), conforme a seguir:
val simpleListener = object: GestureDetector.SimpleOnGestureListener() {
    override fun onDoubleTap(e: MotionEvent?): Boolean {
        Log.d(TAG, "onDoubleTap")
        return super.onDoubleTap(e)
    }
    override fun onLongPress(e: MotionEvent?) {
        super.onLongPress(e)
        Log.d(TAG, "onLongPress")
    }
}

E inicializar o GestureDetector com este objeto:
gestureDetector = GestureDetectorCompat(this, simpleListener)

A classe SimpleOnGestureListener contém implementações vazias de todos os
métodos de ambas as interfaces, assim, é preciso apenas sobrescrever os
métodos desejados.



Gesto de escala
Para detectar o gesto conhecido como pinch (ou pinça) pode-se utilizar a
classe ScaleGestureDetector. Normalmente esse gesto é utilizado para efetuar
zoom em determinada área da tela. Para exemplificar o uso desse gesto, será
visto como fazer zoom em uma imagem. Crie uma nova activity chamada
PinchActivity e adicione uma ImageView ao arquivo de layout conforme a seguir:
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ImageView
        android:layout_width="144dp"
        android:layout_height="144dp"
        android:src="@mipmap/ic_launcher"
        android:layout_centerInParent="true"
        android:id="@+id/imageView" />
</RelativeLayout>

Vamos fazer os seguintes ajustes na PinchActivity:
import android.os.Bundle
import android.view.ScaleGestureDetector
import android.view.View
import android.view.ViewTreeObserver
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_pinch.*
 
class PinchActivity : AppCompatActivity() {
    private lateinit var scaleDetector: ScaleGestureDetector
    private var scaleValue: Float = 0.toFloat()
    private var origWidth: Int = 0
    private var origHeight: Int = 0
    private val scaleListener =
            object : ScaleGestureDetector.SimpleOnScaleGestureListener() {
                override fun onScale(detector: ScaleGestureDetector): Boolean {
                    scaleValue *= detector.scaleFactor
                    scaleValue = Math.max(1.0f, Math.min(scaleValue, 7.0f))
                    val lp = imageView.layoutParams
                    lp.width = (origWidth * scaleValue).toInt()
                    lp.height = (origHeight * scaleValue).toInt()
                    imageView.layoutParams = lp
                    return true
                }
            }



    private val imageViewGlobalLayoutListener =
            object : ViewTreeObserver.OnGlobalLayoutListener {
                override fun onGlobalLayout() {
                    origWidth = imageView.width
                    origHeight = imageView.height
                    imageView.viewTreeObserver.removeOnGlobalLayoutListener(this)
                }
            }
    private val imageViewTouchListener =
            View.OnTouchListener { view, motionEvent ->
                scaleDetector.onTouchEvent(motionEvent)
            }
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_pinch)
        scaleDetector = ScaleGestureDetector(this, scaleListener)
        imageView.setOnTouchListener(imageViewTouchListener)
        imageView.viewTreeObserver.addOnGlobalLayoutListener(
                imageViewGlobalLayoutListener
        )
    }
}

A classe possui um atributo do tipo ScaleDetector, que é inicializado com um
objeto que ouvirá o gesto de escala, que nesse exemplo é o atributo
scaleListener. Esse objeto é uma instância de OnScaleGestureListener que contém a
implementação do método onScale(ScaleGestureDetector), que será disparado
quando o gesto de escala for detectado. Com o parâmetro ScaleGestureDetector
desse método, a escala que foi capturada é obtida por meio da propriedade
scaleFactor. E para evitar que a imagem fique grande ou pequena demais, foi
estabelecida uma escala mínima de 1 e máxima de 7 vezes o tamanho da
imagem.

Conhecida a escala, os parâmetros de layout da ImageView são obtidos usando
layoutParams; em seguida, a largura e a altura da view são alteradas, e, por fim,
os parâmetros são reatribuídos à ImageView.

Perceba que, para realizar o cálculo, é preciso saber o tamanho original da
ImageView, então foi utilizado o mesmo artifício do capítulo de animações: o
ViewTreeObserver.OnGlobalLayoutListener. Lembrando que no onCreate(Bundle) a
ImageView ainda não foi desenhada na tela, então não é possível saber o seu
tamanho real nesse momento. Utilizando esse listener, o tamanho da view é



obtido e o objeto é desregistrado, pois esse evento só é preciso uma única
vez.

Execute a aplicação e teste o gesto de pinch para aumentar e diminuir o
tamanho da ImageView.

Drag and Drop
No Android 3 (API Level 11) foi adicionada a Drag and Drop API, que
facilita a implementação da ação de “arrastar e soltar”. O processo inicia,
basicamente, ao invocar o método startDrag(ClipData,DragShadowBuilder,Object,int), e,
em seguida, cada view que desejar tratar a ação de “soltar” deve ter um
objeto que implemente da interface View.OnDragListener e que contenha apenas o
método onDrag(View, DragEvent).

Para entender melhor como funciona esse tipo de ação, adicione uma nova
activity chamada DragDropActivity ao projeto1 no qual o seu arquivo de layout
terá quatro LinearLayout com uma ImageView em cada um deles. A ideia é que
seja possível arrastar a ImageView de um LinearLayout para outro. O arquivo de
layout da res/layout/activity_drag_drop.xml deve ficar assim:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/llRoot"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">
        <LinearLayout
            android:id="@+id/llTopLeft"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:background="@drawable/bg" >
            <ImageView
                android:id="@+id/img1"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:src="@mipmap/ic_launcher" />



        </LinearLayout>
        <LinearLayout
            android:id="@+id/llTopRight"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:background="@drawable/bg" >
            <ImageView
                android:id="@+id/img2"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:src="@mipmap/ic_launcher" />
        </LinearLayout>
    </LinearLayout>
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">
        <LinearLayout
            android:id="@+id/llBottomLeft"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:background="@drawable/bg" >
            <ImageView
                android:id="@+id/img3"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:src="@mipmap/ic_launcher" />
        </LinearLayout>
        <LinearLayout
            android:id="@+id/llBottomRight"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:background="@drawable/bg" >
            <ImageView
                android:id="@+id/img4"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:src="@mipmap/ic_launcher" />



        </LinearLayout>
    </LinearLayout>
</LinearLayout>

O layout não tem nada de especial; cada LinearLayout (llTopLeft, llTopRight,
llBottomLeft e llBottomRight) servirá de contêiner, onde pode soltar cada ImageView
(img1, img2, img3 e img4). Perceba que foi definido o background do LinearLayout
que não é uma imagem, mas sim um XML que define um shape. Crie o
arquivo res/drawable/bg.xml e deixe-o como a seguir:
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <shape android:shape="rectangle">
            <stroke
                android:width="2dp"
                android:color="#FFFFFFFF" />
            <gradient
                android:angle="225"
                android:endColor="#DD2ECCFA"
                android:startColor="#DD000000" />
            <corners
                android:bottomLeftRadius="7dp"
                android:bottomRightRadius="7dp"
                android:topLeftRadius="7dp"
                android:topRightRadius="7dp" />
        </shape>
    </item>
</selector>

Ao arrastar o ImageView sobre um LinearLayout, o background será alterado.
Para isso, crie o arquivo res/drawable/bg_hover.xml, que é idêntico ao
res/drawable/bg.xml, tendo como única diferença a propriedade android:color da
tag stroke. Ela fará com que a cor da borda fique vermelha:
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <shape android:shape="rectangle">
            <stroke
                android:width="2dp"
                android:color="#FF0000" />
            <gradient
                android:angle="225"
                android:endColor="#DD2ECCFA"
                android:startColor="#DD000000" />
            <corners
                android:bottomLeftRadius="7dp"



                android:bottomRightRadius="7dp"
                android:topLeftRadius="7dp"
                android:topRightRadius="7dp" />
        </shape>
    </item>
</selector>

Finalmente, faça a seguinte implementação na classe DragDropActivity:
import android.content.ClipData
import android.os.Build
import android.os.Bundle
import android.view.DragEvent
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.LinearLayout
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_drag_drop.*
 
class DragDropActivity : AppCompatActivity(), View.OnTouchListener, View.OnDragListener {
    public override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_drag_drop)
        img1.setOnTouchListener(this)
        img2.setOnTouchListener(this)
        img3.setOnTouchListener(this)
        img4.setOnTouchListener(this)
        llTopLeft.setOnDragListener(this)
        llTopRight.setOnDragListener(this)
        llBottomLeft.setOnDragListener(this)
        llBottomRight.setOnDragListener(this)
    }
    override fun onTouch(view: View, me: MotionEvent): Boolean {
        val action = me.action
        if (action == MotionEvent.ACTION_DOWN) {
            val data = ClipData.newPlainText("", "")
            val shadowBuilder = View.DragShadowBuilder(view)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                view.startDragAndDrop(data, shadowBuilder, view, 0)
            } else {
                view.startDrag(data, shadowBuilder, view, 0)
            }
            view.visibility = View.INVISIBLE
            return true
        }



        return false
    }
    override fun onDrag(v: View, event: DragEvent): Boolean {
        when (event.action) {
            DragEvent.ACTION_DRAG_ENTERED -> v.setBackgroundResource(R.drawable.bg_hover)
            DragEvent.ACTION_DRAG_EXITED -> v.setBackgroundResource(R.drawable.bg)
            DragEvent.ACTION_DROP -> {
                val view = event.localState as View
                val owner = view.parent as ViewGroup
                owner.removeView(view)
                val container = v as LinearLayout
                container.addView(view)
                view.visibility = View.VISIBLE
            }
            DragEvent.ACTION_DRAG_ENDED -> {
                v.setBackgroundResource(R.drawable.bg)
                val view2 = event.localState as View
                view2.visibility = View.VISIBLE
            }
        }
        return true
    }
}

A activity implementa a interface OnTouchListener, e no método onTouch(View,
MotionEvent) um objeto do tipo ClipData é criado, pois ele permite transportar
alguma informação junto ao objeto que está sendo arrastado. Já o objeto
DragShadowBuilder serve para criar uma cópia da view que será arrastada com o
efeito de transparência. Para iniciar o processo de arrastar, deve ser chamado
o método startDrag(ClipData, DragShadowBuilder,Object,int), ou
startDragAndDrop(ClipData,DragShadowBuilder,Object,int) no Android Nougat (API Level
24) ou superior. Passando os objetos citados anteriormente juntamente com a
view que disparou o evento, que no nosso caso é uma ImageView.

A outra interface que a activity implementa é a OnDragListener, que contém o
método onDrag(View,DragEvent), por meio do qual é checado qual ação de drag
está sendo realizada (arrastar ou soltar). Ao entrar na área onde é possível
soltar a view, esse método é chamado com a ação ACTION_DRAG_ENTERED;
nesse caso, apenas o background do LinearLayout é alterado. A operação inversa
é feita ao sair da área onde não se pode mais soltar a view; nesse caso, a ação
será ACTION_DRAG_EXITED. Já a ação de soltar propriamente dita é feita
quando a ação é igual a ACTION_DROP; nesse momento, são realizadas as



seguintes tarefas:
• a view real que está sendo arrastada é obtida por meio da propriedade

localState;
• o LinearLayout onde a view está contida é obtido utilizando a propriedade

parent;
• a view é removida do LinearLayout anterior;
• a ImageView é adicionada ao LinearLayout onde foi “solta” (o parâmetro v

indica o LinearLayout onde estamos soltando a view);
• e finalmente deixamos a view visível.
A ação ACTION_DRAG_ENDED acontece quando todo o processo de drag and

drop termina. Nesse momento, o background é redefinido e a view torna-se
visível novamente. Execute a aplicação, e o resultado deve ficar similar ao da
Figura 27.2.

Figura 27.2 – Drag and drop em execução.
Neste capítulo foi demonstrado o uso de eventos de toque e gestos. No

próximo, falaremos sobre sensores.

1 Esse projeto foi baseado em um post do blog Lars Vogel disponível em:



http://www.vogella.com/tutorials/AndroidDragAndDrop/article.html.



CAPÍTULO 28
Sensores

Os dispositivos Android vêm com diversos sensores que trazem dados
precisos sobre a movimentação, a posição e o ambiente em que o aparelho se
encontra. Neste capítulo serão abordados os sensores disponíveis no Android
e como capturar seus dados dentro dos aplicativos.

Trabalhando com sensores
O Android dá suporte a uma grande variedade de sensores, alguns baseados
em hardware e outros em software. Os baseados em hardware têm
componentes físicos no aparelho, enquanto os baseados em software simulam
esses componentes utilizando outros elementos de hardware.

A seguir, estão listados os principais sensores:
• TYPE_ACCELEROMETER – traz a informação da aceleração em m/s2 nos três

eixos (x, y e z) incluindo a gravidade. Esse sensor pode ser usado para
detecção de movimento e está disponível desde o Android 1.5;

• TYPE_AMBIENT_TEMPERATURE – informa a temperatura do ambiente em
graus Celsius. Esse sensor está disponível a partir do Android 4.0 (API
Level 14) e substitui o sensor TYPE_TEMPERATURE;

• TYPE_GRAVITY – mensura o valor da força da gravidade em m/s2 que é
aplicado ao dispositivo nos eixos x, y e z. Disponível a partir do Android
2.3 (API Level 9);

• TYPE_GYROSCOPE – traz a taxa de rotação do aparelho em rad/s ao redor
dos eixos x, y e z. Disponível a partir do Android 2.3 (API Level 9);

• TYPE_LIGHT – informa o nível de luminosidade do ambiente em lux.
Disponível desde o Android 1.5;

• TYPE_LINEAR_ACCELERATION – retorna o valor da aceleração em m/s2 nos
três eixos, desconsiderando a força da gravidade. Disponível a partir do



Android 2.3 (API Level 9);
• TYPE_MAGNETIC_FIELD – mede a intensidade do campo magnético nos

eixos x, y e z. É medido em microteslas (μT). Disponível a partir do
Android 2.3 (API Level 9);

• TYPE_PRESSURE – mede a pressão do ar em hPa ou mbar. Disponível a
partir do Android 2.3 (API Level 9);

• TYPE_PROXIMITY – mensura a proximidade de um objeto em centímetros
(cm) em relação à tela do aparelho. Usado novamente para saber se o
usuário está segurando o aparelho próximo ao ouvido. Disponível a partir
do Android 1.5;

• TYPE_RELATIVE_HUMIDITY – informa a umidade relativa do ar em
percentual. Disponível a partir do Android 4 (API Level 14);

• TYPE_ROTATION_VECTOR – mensura a orientação do dispositivo provendo
os três vetores de rotação. Disponível a partir do Android 2.3 (API Level
9);

• TYPE_STEP_COUNTER – retorna a quantidade de passos dados pelo usuário
desde que ligou o aparelho pela última vez. E TYPE_STEP_DETECTOR detecta
quando o usuário deu um passo retornando o valor 1. Disponível a partir
do Android 2.3 (API Level 19);

• TYPE_HEART_RATE – reporta o valor de batimentos cardíacos por minuto.
Devemos adicionar a permissão android.permission.BODY_SENSORS. Disponível
a partir do Lollipop (API Level 21).

O acesso aos sensores do aparelho é feito por meio da classe SensorManager.
Para obter uma instância dessa classe deve ser chamado o método
getSystemService(String) da classe Context, passando como parâmetro
Context.SENSOR_SERVICE. Com ela, é possível obter o sensor desejado por meio
do método getDefaultSensor(int) passando como parâmetro o tipo do sensor
desejado utilizando uma das constantes listadas anteriormente
(TYPE_ACCELEROMETER, por exemplo). Esse método retornará uma instância
da classe Sensor. Obviamente, nem todos os sensores estão disponíveis em
todos os aparelhos; sendo assim, esse objeto pode vir nulo.

Para ouvir os eventos do sensor é preciso invocar o método
registerListener(SensorEventListener,Sensor,int) da classe SensorManager passando como
parâmetros um objeto que implemente a interface SensorEventListener; o sensor; e



o intervalo que esses valores serão enviados. Essa interface contém dois
métodos:

• onAccuracyChanged(Sensor,int) – indica que a precisão que o sensor está
enviando os dados mudou. O segundo parâmetro indica a nova acurácia e
os possíveis valores estão listados na Tabela 28.1 que são constantes da
classe SensorManager;

• onSensorChanged(SensorEvent) – informa que o valor do sensor mudou. O objeto
SensorEvent traz os valores do sensor na propriedade values, que é um array
de float cujo tamanho pode variar de acordo com o sensor.

Tabela 28.1 – Valores possíveis para a precisão de um sensor
Constante Descrição

SENSOR_STATUS_ACCURACY_HIGH O sensor está reportando informação com o máximo de precisão.
SENSOR_STATUS_ACCURACY_LOW O sensor está reportando informação com baixa precisão, sendo

necessária calibração com o ambiente em que o sensor está sendo
usado.

SENSOR_STATUS_ACCURACY_MEDIUM O sensor está reportando informação com uma precisão razoável, mas
a calibração com o ambiente em que o sensor está sendo usado pode
melhorar a precisão.

SENSOR_STATUS_UNRELIABLE A informação reportada pelo sensor não é confiável e é necessária
calibração com o ambiente em que o sensor será usado.

Ainda falando do método registerListener(SensorEventListener,Sensor,int), ele recebe
como último parâmetro a frequência desejada com que o sensor enviará seus
dados. Os possíveis valores estão listados na Tabela 28.2.

Tabela 28.2 – Valores possíveis para o intervalo do sensor
Constante Descrição

SENSOR_DELAY_FASTEST Recupera a informação do sensor da forma mais rápida possível.
SENSOR_DELAY_GAME Recupera a informação do sensor em uma taxa adequada para jogos.
SENSOR_DELAY_NORMAL Essa constante é a padrão, caso não seja informada nenhuma.
SENSOR_DELAY_UI Recupera a informação do sensor em uma taxa adequada para o uso de interface

gráfica.

Conhecidos os principais conceitos, observe o exemplo a seguir:
val sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager
val sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
if (sensor != null) {
    sensorManager.registerListener(object : SensorEventListener {
        override fun onSensorChanged(event: SensorEvent?) {
            event?.let {



                val x = event.values[0]
                val y = event.values[1]
                val z = event.values[2]
                Log.d("DominandoAndroid", "x: $x | y:$y | z: $z")
            }
        }
        override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {
            Log.d("DominandoAndroid", "Precisão mudou")
        }
    }, sensor, SensorManager.SENSOR_DELAY_NORMAL)
}

Nesse trecho de código é obtido os valores do acelerômetro do aparelho que
retorna a aceleração nos eixos x, y e z em um intervalo-padrão de atualização.

Se a utilização de sensores for essencial para a aplicação, é necessário
adicionar a linha a seguir no AndroidManifest.xml:
<manifest ...>
    <uses-feature
        android:name="android.hardware.sensor.accelerometer"
        android:required="true" />

Com isso, apenas aparelhos que possuam o sensor de acelerômetro poderão
instalar o aplicativo.

Listando os sensores do aparelho
Para entender melhor o uso dos sensores, crie um novo projeto que listará
todos os sensores do aparelho e, ao selecionar um, seus valores poderão ser
visualizados.

Application Name Sensores
Package Name dominando.android.sensores
Activity Name MainActivity

Deixe o arquivo de layout res/layout/activity_main.xml como a seguir:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:padding="16dp"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"



        android:text="Selecione um sensor" />
    <Spinner
        android:id="@+id/spnSensors"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
    <TextView
        android:id="@+id/txtValues"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Valor do sensor..."/>
</LinearLayout>

O Spinner listará os sensores disponíveis no aparelho enquanto o TextView
exibirá os valores do sensor. Modifique a MainActivity para que fique como a
seguir:
import android.content.Context
import android.content.pm.ActivityInfo
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.os.Bundle
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    private val sensorManager: SensorManager by lazy {
        getSystemService(Context.SENSOR_SERVICE) as SensorManager
    }
    private val sensorsList: List<Sensor> by lazy {
        sensorManager.getSensorList(Sensor.TYPE_ALL)
    }
    private val sensorListener = object: SensorEventListener {
        override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {
            Toast.makeText(this@MainActivity,
                    "Precisão mudou: $accuracy", Toast.LENGTH_SHORT).show()
        }
        override fun onSensorChanged(event: SensorEvent) {
            var values = "Valores do Sensor:\n"
            event.values.indices.forEach { i ->
                values += "values[$i] = ${event.values[i]}\n"



            }
            txtValues.text = values
        }
    }
    private var selectedSensor: Int = 0
 
    public override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
        val sensorNamesList = sensorsList.map { it.name }
        val adapter = ArrayAdapter(
                this, android.R.layout.simple_spinner_item, sensorNamesList)
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        spnSensors.adapter = adapter
        spnSensors.onItemSelectedListener = object: AdapterView.OnItemSelectedListener {
            override fun onNothingSelected(parent: AdapterView<*>?) {
            }
            override fun onItemSelected(parent: AdapterView<*>?, view: View?,
                                        position: Int, id: Long) {
                selectedSensor = position
                unregisterSensor()
                registerSensor()
            }
        }
    }
    override fun onResume() {
        super.onResume()
        registerSensor()
    }
    override fun onPause() {
        super.onPause()
        unregisterSensor()
    }
    private fun registerSensor() {
        sensorManager.registerListener(
                sensorListener,
                sensorsList[selectedSensor],
                SensorManager.SENSOR_DELAY_NORMAL
        )
    }
    private fun unregisterSensor() {
        sensorManager.unregisterListener(sensorListener)
    }
}



No atributo sensorsList é armazenada a lista dos sensores obtida utilizando o
método getSensorList(int) passando como parâmetro TYPE_ALL, que fará com que
todos os tipos de sensores sejam retornados. No onCreate(Bundle), por meio da
propriedade requestedOrientation, é definida uma orientação fixa para a activity
para facilitar a demonstração de alguns sensores como o de aceleração. Em
seguida, foi criada a constante sensorNamesList com o nome de cada um dos
sensores que é usada para criar o adapter do Spinner. Perceba que ao selecionar
um sensor, o método unregisterSensor() é chamado para não receber mais dados
do sensor atual e logo após o método registerSensor() iniciar o recebimento dos
dados do novo sensor.

No onResume() o objeto sensorListener é registrado para obter os valores do
sensor e no onPause() é desregistrado invocando o método
unregisterListener(SensorEventListener).

É possível testar a aplicação tanto no aparelho real quanto no emulador. Ao
testar no emulador deve-se utilizar a opção “Virtual sensors”, como mostra a
Figura 28.1.

Figura 28.1 – Opção “Virtual sensors” do emulador do Android.
A aba Accelerometer nos permite testar o acelerômetro do aparelho. Na



aba Additional sensors mostrada na Figura 28.2 podemos testar outros
sensores como: temperatura ambiente, campo magnético, proximidade,
luminosidade, pressão e umidade relativa.

A Figura 28.3 mostra a aplicação em execução no emulador. 

Figura 28.2 – Sensores adicionais do emulador do Android.



Figura 28.3 – Aplicação de sensores no emulador do Android.

Utilizando o acelerômetro
O sensor de acelerômetro se baseia em um sistema de coordenadas de três
eixos (x, y, z) como mostra a Figura 28.4, em que cada eixo representa uma
orientação. O eixo x representa deslocamentos em torno do horizontal, o eixo
y indica movimentos no eixo vertical e o eixo z representa profundidade. Este
último é usado apenas em ambientes 3D.

Os valores dos eixos são retornados em metros por segundo ao quadrado
(m/s2), que é uma unidade derivada do sistema internacional de medidas (SI)
usada para medir a aceleração de um objeto móvel. Essa aceleração varia
entre -9,81 a 9,81, valor que representa a gravidade do planeta Terra.
Portanto, se deixar o aparelho sobre uma superfície plana, a sua aceleração
será zero para os eixos X e Y, mas será de 9,8m/s² no eixo Z.



Figura 28.4 – Eixos dos sensores. Fonte: http://developer.android.com.
Com o intuito de demonstrar o uso do acelerômetro do aparelho, será criada

uma activity que deslocará uma bolinha na tela de acordo com a posição do
aparelho. A movimentação da bolinha será feita baseada no sensor de
aceleração.

Serão criadas três novas classes: GameActivity, ThreadGame e Ball. A activity será
ouvinte de eventos do sensor de acelerômetro e exibirá uma View que
desenhará a bola na tela. A classe ThreadGame será uma subclasse de Thread que
ficará em loop requisitando o desenho da tela. A última classe, Ball, realizará
o cálculo da posição da bola utilizando a aceleração dada pelo sensor.

Crie uma nova classe chamada Ball e deixe-a conforme a seguir:
import android.content.Context
import android.graphics.BitmapFactory
 
class Ball(context: Context) {
    var xPos: Float = 0f
        private set
    var yPos: Float = 0f
        private set
    private var xSpeed: Float = 0f
    private var ySpeed: Float = 0f



    private var xAcceleration: Float = 0f
    private var yAcceleration: Float = 0f
    private var screenWidth: Float = 0f
    private var screenHeight: Float = 0f
    private var lastUpdateTime: Long = -1
    val ballImage = BitmapFactory.decodeResource(
            context.resources, R.drawable.ball)
 
    fun setAcceleration(x: Float, y: Float) {
        xAcceleration = -x
        yAcceleration = y
        applyPhysics()
    }
    fun setScreenDimension(w: Int, h: Int) {
        screenWidth = w.toFloat()
        screenHeight = h.toFloat()
    }
    fun applyPhysics() {
        if (screenWidth <= 0 || screenHeight <= 0) return
        val timestamp = System.currentTimeMillis()
        if (lastUpdateTime < 0) {
            lastUpdateTime = timestamp
            return
        }
        val elapsedTime = timestamp - lastUpdateTime
        lastUpdateTime = timestamp
        xSpeed += xAcceleration * elapsedTime / 1000 * PIXELS_PER_METER
        ySpeed += yAcceleration * elapsedTime / 1000 * PIXELS_PER_METER
        xPos += xSpeed * elapsedTime / 1000 * PIXELS_PER_METER
        yPos += ySpeed * elapsedTime / 1000 * PIXELS_PER_METER
        var reboundInX = false
        var reboundInY = false
        if (yPos < 0) {
            yPos = 0f
            ySpeed = -ySpeed * REBOUND
            reboundInY = true
        } else if (yPos + ballImage.height > screenHeight) {
            yPos = screenHeight - ballImage.height
            ySpeed = -ySpeed * REBOUND
            reboundInY = true
        }
        if (reboundInY && Math.abs(ySpeed) < MIN_SPEED) {
            ySpeed = 0f
        }
        if (xPos < 0) {



            xPos = 0f
            xSpeed = -xSpeed * REBOUND
            reboundInX = true
        } else if (xPos + ballImage.width > screenWidth) {
            xPos = screenWidth - ballImage.width
            xSpeed = -xSpeed * REBOUND
            reboundInX = true
        }
        if (reboundInX && Math.abs(xSpeed) < MIN_SPEED) {
            xSpeed = 0f
        }
    }
    companion object {
        private const val REBOUND = 0.6f
        private const val MIN_SPEED = 5f
        private const val PIXELS_PER_METER = 25f
    }
}

A constante REBOUND define o percentual que será reduzido da velocidade
quando a bolinha atingir os limites da tela. Foi definido que a velocidade será
reduzida em 60% (0,6). Caso seja necessário que a bolinha pule mais,
aumente esse valor, ou diminua, caso contrário. Já na constante MIN_SPEED é
definida a velocidade mínima da bola. Caso atinja esse valor, a bolinha
parará. Em PIXELS_PER_METER foi estipulado um valor para a proporção de
pixels para metros. Isso é necessário, uma vez que tanto os valores do
acelerômetro como as fórmulas físicas (vistas mais adiante) utilizam a
unidade de medida de m/s2 (metros por segundo ao quadrado).

Foram definidos alguns atributos da bolinha e da tela, que são,
respectivamente, a posição X e Y da bolinha na tela (xPos e yPos); a velocidade
e aceleração nos eixos X e Y (xSpeed e ySpeed); e a largura e altura da tela
(screenWidth e screenHeight). O atributo lastUpdateTime armazenará o tempo
decorrido desde a última utilização. Esse atributo será utilizado para realizar
o cálculo da distância percorrida. O atributo ballImage define a imagem da bola.

No construtor é recebido um objeto da classe Context para inicializar a
imagem da bolinha. O método setAcceleration(Float,Float) será chamado pela
activity e receberá a aceleração informada pelo acelerômetro. O método
setScreenDimension(Float,Float) definirá o tamanho da tela para determinar os
limites onde a bolinha poderá se deslocar. Com ele, é possível detectar a
colisão da bolinha com as extremidades da tela.



O método applyPhysics() é o mais importante do projeto. É nele que serão
aplicados os conceitos de física para estabelecer a posição e a movimentação
da bolinha. Para isso, é importante salientar as unidades de medida utilizadas
nessas fórmulas: a distância é definida em metros; a velocidade, em metros
por segundo; e o tempo é definido em segundos. Por isso, serão necessárias
algumas conversões durante esse cálculo.

No início do cálculo é necessário saber o tempo decorrido desde a última
atualização da posição. Essa informação é armazenada na variável elapsedTime.
Em seguida, é calculada a velocidade baseada na fórmula:
velocidade = velocidade inicial + aceleração * tempo

Como é preciso fazer isso nos eixos x e y, esse cálculo é feito e o resultado
é armazenado nos atributos xSpeed e ySpeed. Observe que é feita uma divisão
por 1.000, uma vez que a unidade de medida deve estar em segundos (1
segundo = 1.000 milissegundos). Depois, o valor multiplicado pela constante
PIXELS_PER_METER para obter a unidade de medida a ser usada na tela, que é
em pixels. Nos atributos xPos e yPos é armazenado o resultado do cálculo da
posição x e y utilizando a fórmula:
distância = velocidade * tempo

Feitos esses cálculos, começa a checagem de colisão com as bordas da tela,
iniciando pela verificação com a parte superior. Caso yPos seja menor que
zero, a velocidade é invertida e é descontado o percentual do rebote, que foi
estipulado em 60% da velocidade atual. Também é definido reboundInY para
verdadeiro. Essa informação é útil para saber que a bola deve parar após
atingir uma velocidade inferior à mínima. É verificada também a colisão com
a parte inferior da tela; caso isso aconteça, é feito algo similar ao que foi feito
quando a colisão acontece na parte superior. Em seguida, temos uma lógica
similar para checar a colisão com as laterais.

Crie agora uma classe ThreadGame e deixe-a como a seguir:
import java.util.concurrent.TimeUnit
import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Canvas
import android.graphics.Rect
import android.view.SurfaceHolder
 
class ThreadGame(context: Context,



                 private val ball: Ball,
                 private val surfaceHolder: SurfaceHolder) : Thread() {
    private var isRunning: Boolean = false
    private val backgroundImage: Bitmap = BitmapFactory.decodeResource(
            context.resources, R.drawable.grass)
 
    override fun run() {
        isRunning = true
        while (isRunning) {
            try {
                ball.applyPhysics()
                drawGame()
                TimeUnit.MILLISECONDS.sleep(16)
            } catch (ie: InterruptedException) {
                isRunning = false
            }
        }
    }
    fun stopGame() {
        isRunning = false
        interrupt()
    }
    private fun drawGame() {
        var canvas: Canvas? = null
        try {
            canvas = surfaceHolder.lockCanvas()
            if (canvas != null) {
                val rect = Rect(0, 0, canvas.width, canvas.height)
                canvas.drawBitmap(backgroundImage, null, rect, null)
                canvas.drawBitmap(ball.ballImage,
                        ball.xPos, ball.yPos, null)
            }
        } finally {
            if (canvas != null) {
                surfaceHolder.unlockCanvasAndPost(canvas)
            }
        }
    }
}

A classe ThreadGame herda de Thread e permite realizar a lógica do que será
exibido na tela. O atributo isRunning determinará se a Thread continuará sua
execução ou não.

Essa classe possui mais três atributos: ball, backgroundImage e surfaceHolder. O
primeiro atributo é uma instância da classe Ball, que foi explicada



anteriormente, o segundo é a imagem de background que será usada, e o
último é uma instância da classe SurfaceHolder, que trabalha em conjunto com a
classe SurfaceView. O SurfaceHolder obtém o objeto Canvas para desenhar o
conteúdo da SurfaceView. Isso deve ser feito, obrigatoriamente, a partir de outra
Thread, que nesse exemplo é representada pela ThreadGame.

No método run() existe um loop controlado pelo atributo isRunning, em que
dentro dele a posição da bolinha é calculada ao chamar o método applyPhysics().
Em seguida, é requisitado que a tela seja desenhada por meio do método
drawGame(). Por fim, a Thread é posta para dormir por um tempo para que essa
tela possa ser desenhada. O método stopGame() atribuirá o valor false ao atributo
isRunning e chamará o método interrupt() para interromper a execução da Thread.

O método drawGame() obtém a instância do Canvas por meio do método
lockCanvas() da instância do SurfaceHolder. Depois de pintar o background da tela
a bolinha é desenhada. O processo de renderização termina quando o que foi
pintado no canvas é enviado para o SurfaceView por meio do método
unlockCanvasAndPost().

Crie agora a classe GameActivity e deixe-a como a seguir:
import android.app.Activity
import android.content.Context
import android.content.pm.ActivityInfo
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.os.Bundle
import android.view.SurfaceHolder
import android.view.SurfaceHolder.Callback
import android.view.SurfaceView
 
class GameActivity : Activity(), SensorEventListener, Callback {
    private val surfaceView: SurfaceView by lazy {
        SurfaceView(this).apply {
            keepScreenOn = true
        }
    }
    private val surfaceHolder: SurfaceHolder by lazy {
        surfaceView.holder
    }
    private val ball: Ball by lazy {
        Ball(this)



    }
    private val sensorManager: SensorManager by lazy {
        getSystemService(Context.SENSOR_SERVICE) as SensorManager
    }
    private var threadGame: ThreadGame? = null
 
    public override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
        surfaceHolder.addCallback(this)
        setContentView(surfaceView)
    }
    override fun onResume() {
        super.onResume()
        val accelerometer = sensorManager.getDefaultSensor(
                Sensor.TYPE_ACCELEROMETER)
        sensorManager.registerListener(this, accelerometer,
                SensorManager.SENSOR_DELAY_GAME)
    }
    override fun onPause() {
        super.onPause()
        sensorManager.unregisterListener(this)
    }
    override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int,
                                height: Int) {
        ball.setScreenDimension(width, height)
    }
    override fun surfaceCreated(holder: SurfaceHolder) {
        threadGame = ThreadGame(this, ball, holder)
        threadGame?.start()
    }
    override fun surfaceDestroyed(holder: SurfaceHolder) {
        try {
            ball.setScreenDimension(0, 0)
            threadGame?.stopGame()
        } finally {
            threadGame = null
        }
    }
    override fun onAccuracyChanged(sensor: Sensor, accuracy: Int) {}
    override fun onSensorChanged(event: SensorEvent) {
        ball.setAcceleration(event.values[0], event.values[1])
    }
}

A GameActivity implementa duas interfaces: android.hardware.SensorEventListener e



android.graphics.drawable.Drawable.Callback. A primeira serve para notificar quando há
mudança dos valores do sensor de aceleração, enquanto a segunda se refere a
mudanças na instância da classe android.view.SurfaceView, usada para desenhar a
tela.

O atributo surfaceView é utilizado para desenhar o conteúdo na tela. Perceba
que ao instanciar esse objeto a propriedade keepScreenOn é definida como true
para que a tela do aparelho não se apague enquanto o jogo estiver em
execução. Logo depois, é obtida a instância de android.view.SurfaceHolder por meio
da propriedade holder da surfaceView.

No onCreate(Bundle) foi definida uma orientação fixa para nossa activity por
meio da propriedade requestedOrientation; em seguida, o atributo surfaceView é
inicializado e definido como a view da activity. Com o objeto surfaceHolder a
Activity é registrada para ser notificada sobre eventos da surfaceView com o
método addCallbacks(Callback).

No método onResume(), a instância do sensor de aceleração é obtida por meio
do método getDefaultSensor(int) do objeto sensorManager, em seguida, a Activity é
registrada para ouvir mudanças nos valores do sensor invocando o método
registerListener(SensorEventListener,Sensor,int). No onPause(), esse registro é desfeito com
unregisterListener(SensorEventListener). Isso é importante para evitar que essa activity
fique recebendo dados do sensor mesmo não estando em foreground.

Os próximos três métodos são da interface SurfaceHolder.Callback, a qual nossa
activity implementa. O método surfaceChanged(SurfaceHolder,int,int,int) é chamado
quando o tamanho da view muda. Inicialmente, a view tem um tamanho
(largura e altura) igual a zero. Quando esse valor muda, essa informação é
repassada para o atributo ball. Após a criação da SurfaceView o método
surfaceCreated(SurfaceHolder) é chamado; nesse momento, a threadGame é instanciada
e inicializada. Por último, quando a view é destruída (o que ocorre
normalmente quando a tela é fechada), a threadGame é parada. No método
onSensorChanged(SensorEvent) da interface SensorEventListener a aceleração da bolinha
é atualizada.

Altere a activity principal do projeto para GameActivity no
AndroidManifest.xml e execute a aplicação. O resultado deve ficar similar à
Figura 28.5.



Figura 28.5 – Aplicativo que utiliza acelerômetro em execução.
Os sensores, sem sombra de dúvidas, podem agregar valor à sua aplicação,

principalmente em jogos, e como vimos neste capítulo sua utilização é bem
simples. Seu uso, no entanto, vai depender muito do propósito do seu
aplicativo.



CAPÍTULO 29
Gradle

O Gradle (http://www.gradle.org) é um sistema de automação de tarefas
utilizado pelo Android Studio para executar todo o processo de build, desde a
compilação até a geração do APK (Android Package). Com o Gradle, é
possível definir configurações customizadas de build de forma simples e
flexível. Neste capítulo será abordada a utilização do Gradle no Android
Studio, seus principais recursos e a personalização do processo de build de
um aplicativo.

Visão geral
O Gradle é um sistema open-source de automação de build que segue os
mesmos conceitos de ferramentas como Ant (https://ant.apache.org/) e
Maven (https://maven.apache.org/), ambos da Apache Foundation.
Entretanto, em vez de utilizar arquivos XML para definir o processo de build,
o Gradle utiliza uma DSL (Domain Specific Language) baseada na
linguagem Groovy (http://groovy-lang.org/) e com um gráfico acíclico
dirigido (DAG – Directed Acyclic Graph) para determinar a ordem em que as
tarefas devem ser executadas.

Por ser baseado em plugins, o Gradle pode ser utilizado para compilar
diversos tipos de projetos. Os primeiros plugins foram criados para projetos
Java, Groovy e Scala. Em projetos Android, o Gradle é utilizado desde a
primeira versão do Android Studio.

Uma vez que o Gradle é uma ferramenta independente, é possível compilar
aplicações Android sem a necessidade de ter o Android Studio instalado na
máquina. Isso dá a liberdade de executar todo o processo de build via
terminal. Isso é uma grande vantagem, pois fornece compatibilidade e
integração com ferramentas externas, tais como os sistemas de CI
(Continuous Integration – Integração Contínua) e CD (Continuous Delivery –



Entrega Contínua).
O processo de build envolve muitas ferramentas e processos, mas

tipicamente segue as seguintes etapas:
• os recursos são compilados em um arquivo *.arsc (Android Resources) e a

classe R é gerada;
• o compilador converte o código fonte (*.kt do Kotlin ou *.java do Java)

em bytecodes com a extensão *.class;
• esses arquivos são transformados em um ou mais arquivos *.dex (Dalvik

Executable);
• em seguida, o *.apk é gerado contendo os arquivos *.dex o *.arsc demais

recursos;
• finalmente, o *.apk é assinado e pode ser instalado no aparelho.
Obviamente que durante essas etapas alguns plugins podem executar

tarefas, como, por exemplo, o kapt, que processa anotações em código
Kotlin.

O Gradle permite personalizar cada etapa desse processo. Existem livros
focados apenas em Gradle, o que quer dizer que há muito a ser falado sobre
essa ferramenta. Entretanto, o objetivo aqui será mostrar sua utilização em
projetos com o Android Studio.

Projeto e módulos
Um projeto Android representa uma aplicação completa, que é composta por
um ou mais módulos que podem ser compilados juntos ou separadamente.
Um módulo pode ser:

• Java Library – contém apenas código-fonte (Java ou Kotlin), por meio do
qual é gerado um arquivo JAR. Para esse tipo de módulo, deve-se utilizar
o plugin java-library:
apply plugin: 'java-library'

• Android Library – é uma biblioteca reutilizável que, além de código-
fonte, pode possuir recursos específicos do Android como layouts,
drawables, estilos etc. Ao ser compilado, será gerado um arquivo com
extensão AAR (Android ARchive). E para esse tipo de módulo deve-se
aplicar o plugin com.android.library:
apply plugin: 'com.android.library'



• Android Application – é a aplicação que será executada em dispositivo
Android e que pode depender de outros módulos ou de bibliotecas locais
ou externas. A maioria dos projetos possui apenas um módulo dessa
categoria, mas nada impede de ter uma aplicação para telefones e tablets
juntamente com a versão do aplicativo para Android TV ou Android
Auto, por exemplo. Ao final é gerado um APK por módulo dessa
categoria:
apply plugin: 'com.android.application'

Como foi visto em capítulos anteriores, é possível aplicar mais de um
plugin em cada módulo, como foi feito ao aplicar o plugin do Kotlin e do
Google Play Services. Entretanto, não é comum (nem recomendado) utilizar
no mesmo módulo mais de um dos plugins listados acima.

Dependências
Um projeto Android pode utilizar classes ou recursos que não estejam
necessariamente no código do seu aplicativo. Quando isso ocorre, seu projeto
possui dependências que podem ser:

• dependências de módulos – um módulo pode incluir em seu build.gradle
uma dependência de outro módulo. Dessa forma, quando o módulo for
compilado, sua dependência será compilada e incluída no arquivo final;

• dependências locais – se o projeto possui arquivos binários (como
arquivos JAR) no seu computador que devem ser adicionados ao projeto,
eles devem ser declarados no build.gradle;

• dependências remotas – a grande maioria das bibliotecas está disponível
em repositórios remotos na web, e os repositórios mais populares são o
JCenter e Maven, que são suportados pelo Android Studio. Dessa forma,
não é necessário baixar o JAR e copiá-lo para o projeto; basta informar as
coordenadas da biblioteca no repositório. Normalmente a coordenada
segue o padrão grupo:nome:versão, assim, para utilizar a biblioteca de
compatibilidade do Android, por exemplo, é utilizada a coordenada
androidx.appcompat:appcompat:1.0.0.

Veja a seguir um exemplo da declaração de cada tipo de dependência:
dependencies {
    // Dependência de módulo
    implementation project(":myLibrary")



    // Dependência externa
    implementation 'androidx.appcompat:appcompat:1.0.0'
    // Dependência de lista de arquivos
    implementation files('libs/foo.jar', 'libs/bar.jar')
    // Dependência de diretório libs
    implementation fileTree(dir: 'libs', include: '*.jar')
}

É possível visualizar a árvore de dependências de cada biblioteca, ou seja,
as dependências das dependências. Para isso, basta selecionar a opção View
> Tool Windows > Gradle, em seguida, expanda a opção app > Tasks >
android e dê um duplo-clique em androidDependencies. Após o Gradle
executar a task, a janela Run exibe a árvore de dependências.

Tembém é possível visualizar as dependências clicando com o botão direito
sobre o projeto e selecionando a opção Open Module Settings. Na parte
superior, selecione a aba Dependencies e será exibida a tela da Figura 29.1.

Figura 29.1 – Dependências do projeto no Android Studio.
Como é possível observar, a listagem das dependências traz as respectivas

versões e escopo. Além do escopo implementation, temos o escopo
testImplementation e androidTestImplementation que são utilizados para escrever testes
do aplicativo. Esse tópico será abordado no Capítulo 31.



Trabalhando com módulos
Todos os projetos criados até aqui tinham apenas um módulo chamado app.
Nesta seção será apresentado como criar projetos com um módulo além do
app.

Application Name Gradle
Package Name dominando.android.gradle
Activity Name MainActivity

Uma vez criado o projeto, o módulo app será criado como de costume. Crie
novo módulo selecionando o menu File > New module... e será exibida a
tela da Figura 29.2.

Figura 29.2 – Criando um novo módulo no Android Studio.
Selecione a opção Android Library e, em seguida, clique no botão Next,

então será exibida a tela da Figura 29.3. Coloque o nome do módulo como
MyLib e o nome do pacote ficará dominando.android.mylib. Clique em Finish para
concluir a criação do módulo.



Figura 29.3 – Configurando um novo módulo no Android Studio.
O novo módulo deve possuir um arquivo build.gradle similar ao listado a

seguir:
apply plugin: 'com.android.library'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
 
android {
    compileSdkVersion 28
    defaultConfig {
        minSdkVersion 21
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}



dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'androidx.appcompat:appcompat:1.0.2'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.0'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.1'
}

Ele é praticamente idêntico ao que foi utilizado até agora no módulo app de
todos os exemplos que foram feitos até aqui. A única diferença é que está
sendo utilizado o plugin com.android.library em vez de com.android.application.

Clique com o botão direito sobre o módulo myLib e selecione a opção New >
Activity > Empty Activity. Nomeie essa nova activity como LibActivity e
clique em Finish para concluir o assistente.

Abra o arquivo res/layout/activity_lib.xml e deixe-o como a seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".LibActivity">
    <TextView
        android:id="@+id/textView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="LibActivity"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

Um botão será adicionado para chamar a LibActivity a partir da MainActivity,
abra o arquivo de layout res/layout/activity_main.xml e deixe-o como a
seguir:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">



    <Button
        android:id="@+id/button"
        style="@style/Widget.AppCompat.Button.Colored"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="LibActivity"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

Agora adicione o evento de clique do botão na MainActivity conforme a
seguir:
import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import dominando.android.mylib.LibActivity
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        button.setOnClickListener {
            startActivity(Intent(this, LibActivity::class.java))
        }
    }
}

Para que a MainActivity (que está no módulo app) reconheça a LibActivity (que
está no módulo myLib), é preciso adicionar a dependência da mylib no arquivo
build.gradle do módulo app:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
 
android { ... }
dependencies {
    implementation project(":mylib")
    ...
}

No bloco dependencies, foi adicionada a instrução implementation project, que fará
com que quando o módulo app for compilado, a mylib seja compilada e



empacotada junto. É importante ressaltar que mylib pode também ser
compilada individualmente, gerando um arquivo com a extensão aar.

Caso haja algum problema durante a compilação verifique se não há
conflito de versão entre as dependências declaradas no módulo app e no
módulo mylib.

O nome do pacote também deve estar correto no AndroidManifest.xml do
módulo mylib:
<manifest ...
    package="dominando.android.mylib" >

Para compilar o projeto no Android Studio, basta acessar o menu Build e,
em seguida, a opção Make Project. O resultado pode ser observado na janela
Build, normalmente localizada na parte inferior ou acessível pelo menu View
> Tool Windows. Essa janela é mostrada na Figura 29.4.

Nessa janela, é possível observar as tarefas do Gradle que estão sendo
executadas. Caso algo dê errado, você poderá visualizar a mensagem de erro.
Perceba que é possível alternar para o modo de visualização do terminal,
clicando no segundo botão da barra de ferramentas.

Figura 29.4 – Janela Build do Android Studio.
Para visualizar as tarefas disponíveis no projeto, clique na janela Gradle,

selecionando a opção de menu View > Tool Windows > Gradle, e será
exibida a tela da Figura 29.5.



Figura 29.5 – Janela Gradle do Android Studio.
Para executar qualquer uma dessas tarefas basta dar um duplo clique sobre

ela. Execute a aplicação e, ao clicar no botão, a activity da biblioteca será
exibida.

Source sets
Projetos Android que utilizam o Gradle possuem uma estrutura bem definida
como se observa na Figura 29.6.



Figura 29.6 – Estrutura do projeto Android.
Fonte: https://developer.android.com

Dentro da pasta src geralmente existem três subpastas: main, androidTest e
test. E dentro de cada uma delas, por padrão, pode-se ter o seguinte conteúdo:
java/
res/
assets/
aidl/
jni/
AndroidManifest.xml

Ao longo do livro foi visto que o diretório java contém o código-fonte do
aplicativo, res possui os recursos da aplicação, no assets ficam arquivos de
recursos que não apresentam variações de acordo com as configurações do
aparelho.

No diretório jni deve ficar o código-fonte escrito em C/C++ que acessa
funções nativas do aparelho e que pode ser acessado no código Java/Kotlin
via JNI (Java Native Interface). Para usar essa funcionalidade é necessário
instalar e configurar o Android NDK (Native Development Kit) e adicionar o
caminho em que está instalado no arquivo local.properties do seu projeto.

O diretório aidl é usado para adicionar arquivos que descrevem uma
interface para conectar a serviços de outros aplicativos. No Capítulo 15 foi



visto como uma activity pode se conectar a um serviço utilizando o método
bindService(Intent) e a interface ServiceConnection. É possível fazer o mesmo por
meio de um serviço de outro aplicativo utilizando arquivos *.aidl (Android
Interface Definition Language).

Nas pastas src/androidTest e src/test fica o código-fonte dos testes unitários
e testes de automação do aplicativo que será abordado no Capítulo 31.

Apesar de existir essa estrutura-padrão, ela é perfeitamente configurável,
utilizando o bloco sourceSets, como mostrado a seguir:
apply plugin: 'com.android.application'
android {
    ...
    sourceSets {
        main {
            java.srcDirs = ['src/main/kotlin']
            res.srcDirs = [
                            'src/main/res-app/products',
                            'src/main/res-app/users',
                            'src/main/res-app/suggestions',
                            'src/main/res'
                    ]
            // Se precisar mudar o local do AndroidManifest.xml
            manifest.srcFile 'src/main/manifest/AndroidManifest.xml'
        }
    }
    ...
}

No exemplo anterior, o diretório de código-fonte é renomeado de java para
kotlin. Também foram definidos vários diretórios de recursos (src/main/res-
app/*), um para cada funcionalidade do aplicativo e uma pasta comum para
recursos genéricos (como o ícone da aplicação) ou utilizados por mais de
uma funcionalidade (src/main/res/*). Isso nos ajuda a organizar melhor os
arquivos de recursos (imagens, layouts, strings etc.) à medida que o projeto
cresce. Dentro destas pastas é possível criar subdiretórios estabelecidos pelo
Android, como: drawable, layout, values etc. Por exemplo: res-
app/products/layout, res-app/products/drawable, res-app/users/values etc.

Arquivos do Gradle
A estrutura de diretórios de um projeto Android já foi analisada algumas



vezes ao longo do livro. Nesta seção o foco são os arquivos utilizados pelo
Gradle no processo de build.

settings.gradle
Este arquivo fica localizado na raiz do projeto e tende a ter um conteúdo bem
sucinto, já que ele apenas contém a relação dos módulos que o projeto possui.
Nos exemplos criados até aqui, o projeto tinha apenas um módulo, então o
arquivo ficava como a seguir:
include ':app'

Um projeto que é composto por mais de um módulo, ficaria da seguinte
forma:
include ':app', ':shared', ':persistence', ':companion'

Nesse caso, além do módulo app, o projeto abrange mais três módulos: para
classes compartilhadas (shared), persistência de dados (persistence) e uma
aplicação “companheira” (companion).

A grande motivação de utilizar vários módulos é reutilizar e organizar o
código.

build.gradle
Os projetos do Android Studio possuem ao menos dois arquivos chamados
build.gradle: um localizado na raiz do projeto e outro para cada módulo.

O arquivo localizado na raiz do projeto estabelece configurações que são
aplicadas a todos os módulos. Sua estrutura é basicamente a seguinte:
buildscript {
    ext.kotlin_version = '1.3.20'
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.3.1'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}
allprojects {
    repositories {
        google()
        jcenter()



    }
}

Os repositórios remotos e as dependências utilizadas pelo Gradle ficam no
bloco buildscript. Por exemplo, em todos os projetos feitos até aqui existe a
dependência do plugin do Android e do Kotlin para Gradle declarado no
bloco dependencies. No bloco allprojects ficam os repositórios e dependências
utilizadas por todos os módulos do projeto. Entretanto, é mais comum
adicionar apenas os repositórios.

Nesse arquivo, é comum definir propriedades que podem ser utilizadas por
todos os módulos do projeto, como mostra o exemplo a seguir:
buildscript {
    ext {
        appcompat_version = '1.0.2'
        compile_sdk_version = 28
        constraintlayout_version = '1.1.3'
        espresso_version = '3.1.1'
        gradle_version = '3.3.1'
        junit_version = '4.12'
        kotlin_version = '1.3.20'
        testrunner_version = '1.1.0'
    }
    repositories { ... }
    dependencies {
        classpath "com.android.tools.build:gradle:$gradle_version"
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
         ...
    }
}

Foi utilizado o bloco ext para definir as propriedades que podem ser
utilizadas tanto nesse arquivo quanto no build.gradle de cada módulo, como
está sendo feito com as variáveis compile_sdk_version, appcompat_version, gradle_version
e kotlin_version. Conforme se observa no arquivo build.gradle do módulo
mostrado a seguir:
android {
  compileSdkVersion compile_sdk_version
  ...
}
...
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation project(":mylib")



    implementation"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
    implementation "androidx.appcompat:appcompat:$appcompat_version"
    implementation "androidx.constraintlayout:constraintlayout:$constraintlayout_version"
    testImplementation "junit:junit:$junit_version"
    androidTestImplementation "androidx.test.ext:junit:$testrunner_version"
    androidTestImplementation "androidx.test.espresso:espresso-core:$espresso_version"
}

Utilizamos diretamente o nome da propriedade para acessá-la (em strings,
utilizamos $propriedade), mas, por questão de clareza, poderíamos utilizar a
sintaxe mais completa que seria, por exemplo, rootProject.ext.appcompat_version.

O arquivo build.gradle localizado no diretório-raiz de cada módulo é onde
se declaram as dependências do módulo e onde são realizadas as
configurações de build.

gradle.properties
Neste arquivo adicionamos configurações gerais do Gradle, tais como:
tamanho de memória heap, nível de log a ser exibido, número de threads
utilizadas durante o processo de build etc.

local.properties
É neste arquivo que ficam armazenadas as configurações locais da máquina
como o caminho do SDK e do NDK do Android:
ndk.dir=/Users/nglauber/Library/Android/sdk/ndk-bundle
sdk.dir=/Users/nglauber/Library/Android/sdk

O conteúdo desse arquivo é gerado automaticamente pelo Android Studio e
não deve ser modificado.

gradle-wrapper
Na raiz do projeto há um diretório gradle que possui o subdiretório wrapper
contendo os seguintes arquivos:

gradle-wrapper.jar é um script que invoca uma versão específica do gradle,
baixando-o se necessário. Com isso, é possível compilar um projeto que
utiliza o Gradle sem ter a necessidade de instalá-lo manualmente.

gradle-wrapper.properties armazena informações sobre sobre a distribuição
do Gradle.

É importante enfatizar que é preciso sempre sincronizar o projeto quando



alguma mudança for feita em algum arquivo de configuração de build. Isso
pode ser feito por meio do menu Tools > Android > Sync Project with
Gradle files.

Build Types, Flavors e Build Variants
Com o Gradle é possível criar diferentes versões do mesmo aplicativo a partir
de um único projeto. Isso é particularmente útil quando é preciso distribuir
APKs para diferentes configurações de aparelho no Google Play. Para
alcançar esse objetivo, definem-se diversas variações do aplicativo com base
no build type e no product flavor, compondo assim uma build variant:

• Build Type – define algumas propriedades utilizadas pelo Gradle ao
compilar e empacotar a aplicação e tipicamente é utilizado para diferentes
estágios do ciclo de desenvolvimento. Por padrão, o plugin do Android
cria dois build types: debug e release. O build type debug é utilizado
durante o desenvolvimento do aplicativo, onde são ativados símbolos para
depuração do código. Já o release deve ser utilizado para publicação do
aplicativo, onde ele é assinado com uma chave diferente e a depuração é
desabilitada;

• Product Flavor – representa diferentes versões da mesma aplicação e que
serão liberadas para os usuários, como, por exemplo, “gratuita” e “paga”.
Flavors são opcionais e devem ser criados explicitamente pelo
desenvolvedor. Por padrão, todo projeto possui apenas o flavor main, mas
é possível definir flavors que possuem código e recursos específicos;

• Build variant – é a junção de um build type com um flavor, permitindo
assim gerar múltiplos APKs com diferentes configurações para o mesmo
projeto. Isso é particularmente útil para criar diferentes versões da mesma
aplicação sem ter que criar projetos separados. Por exemplo, ao definir os
flavors “free” e “paid” para o aplicativo, teríamos ao menos os build
variants: debugFree, releaseFree, debugPaid e releasePaid.

Para compilar a aplicação, o Gradle utilizará uma combinação do código
disponível em diretórios diferentes:

• src/main – contém o código comum a todas as build variants;
• src/debug ou src/release – contém o código específico para cada build

type;



• src/paid ou src/free – contém o código específico de cada product flavor;
• src/paidDebug, src/paidRelease, src/freeDebug ou src/freeRelease –

contém o código específico da build variant.
Lembrando que o conteúdo que se encontra nos diretórios diferentes do

src/main não deve existir nele, pois se isso acontecer aparecerá um erro
informando que a classe ou recurso foi redeclarado.

Para ver como esse recurso funciona na prática, defina os flavors no
build.gradle:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
android {
    ...
    flavorDimensions "dominando"
    productFlavors {
        paid {
            dimension "dominando"
        }
        free {
            dimension "dominando"
        }
    }
}

Em seguida, defina as classes e recursos específicos para cada flavor. Por
exemplo:
package dominando.android.gradle
class Helper {
    companion object {
        const val message: String = "free"
    }
}

Essa classe deve estar localizada em
src/free/java/dominando/android/gradle. Note que o diretório é java, o
source set que definimos anteriormente usando a pasta kotlin era apenas para
o main. Se quiser substituir o diretório java por kotlin nesse flavor, basta
adicionar o source set no build.gradle:
sourceSets {
    ...
    free {



            java.srcDirs = ['src/free/kotlin']
    }
}

Como foi mencionado, podem-se definir recursos específicos do flavor.
Adicione o arquivo strings.xml a seguir no diretório src/free/res/values:
<resources>
    <string name="msg_text">Free</string>
</resources>

Crie os mesmos arquivos para o flavor paid mudando os respectivos valores
da constante message na classe Helper e da string msg_text no strings.xml.

Agora utilize a classe e esse recurso na MainActivity:
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        button.text = "${Helper.message} ${getString(R.string.msg_text)}"
        ...
    }
}

Para selecionar qual Build Variant deve ser executada acesse View > Tool
Windows > Build Variants e será exibida a tela da Figura 29.7.

Figura 29.7 – Selecionando a Build Variant no Android Studio.
Selecione a build variant desejada e execute a aplicação. Para as build

variants freeDebug e freeRelease o botão ficará com o texto “Free Free”, enquanto
as build variants paidDebug e paidRelease exibirão o texto “Paid Paid”.

Os flavors podem ajudar bastante na organização de versões diferentes do
mesmo aplicativo, permitindo a definição de classes e recursos específicos de
cada versão. Observe mais algumas modificações que podem ser feitas:
apply plugin: 'com.android.application'
android {
    ...
    flavorDimensions "dominando"



    productFlavors {
        paid {
            dimension "dominando"
            applicationIdSuffix ".paid"
            versionNameSuffix "-paid"
            minSdkVersion 14 // para a versão paga, suportamos a versão 4.0
        }
        free {
            dimension "dominando"
            applicationIdSuffix ".free"
            versionNameSuffix "-free"
        }
    }
}
dependencies { ... }

Pode ser definido um sufixo para o id da aplicação com o atributo
applicationIdSuffix, e com isso será possível ter instalado no aparelho os dois
flavors ao mesmo tempo. Também é permitido adicionar um sufixo para o
nome da versão utilizando o versionNameSuffix. Lembrando que essa informação
fica visível para o usuário nas configurações do aparelho. Por fim, para a
versão paga, é dado suporte ao Android 4.0 (API Level 14) enquanto para a
versão gratuita, conforme definido no bloco defaultConfig, o aparelho deve rodar
Android 5.0 ou superior.

Outra curiosidade é a declaração dependências para build variants
específicas. Por exemplo, apenas na versão gratuita teria propagandas, então
é possível declarar dependências exclusivas do flavor free da seguinte forma:
dependencies {
    freeImplementation 'com.google.firebase:firebase-ads:+'
}

É preciso apenas utilizar a sintaxe <buildVariant>Implementation para declarar as
dependências específicas do flavor.

Assinatura do aplicativo
Uma das únicas diferenças entre os build types de debug e release é o tipo de
assinatura do aplicativo. Ao compilar um aplicativo no modo debug, é
utilizada a chave debug.keystore que se encontra no subdiretório .android do
diretório do usuário do seu computador. Isso foi mencionado rapidamente nos
capítulos 1 e 18.



Para publicar a aplicação no Google Play é preciso assiná-la com uma
chave única, e cada nova versão do seu aplicativo deve sempre ser assinada
com essa mesma chave. Essa chave é um arquivo *.jks (ou *.keystore) que
deve ser armazenado em um lugar seguro, pois, caso você o perca, não será
possível atualizar o aplicativo na loja.

Para gerar esse arquivo dentro do Android Studio, clique em Build >
Generate Signed APK. Na janela que for exibida, selecione a opção APK e
clique em Next e será exibida a tela da Figura 29.8.

Figura 29.8 – Criação da chave no Android Studio.
Clique no botão Create New e será exibida a tela da Figura 29.9.



Figura 29.9 – Geração de um keystore para meus aplicativos.
Preencha todas as informações requeridas e clique em OK. Essa chave será

válida por 25 anos, e como sua aplicação precisa ser validada por essa chave,
armazene-a em um local seguro (inclusive com o usuário e a senha).
Continuando o processo, será gerado um APK com a assinatura de release,
mas esse processo será detalhado no Capítulo 32. Por agora, feche esta janela.

Para configurar a assinatura do aplicativo, é preciso colocar uma cópia da
chave que acabamos de criar na raiz do projeto e, em seguida, utilize o bloco
signingConfigs como a seguir:
android {
    ...
    signingConfigs {
        signRelease {
            storeFile rootProject.file("release.keystore")
            storePassword "senha"
            keyAlias "AliasDaChave"
            keyPassword "senha"
        }
    }
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'),



                'proguard-rules.pro'
            signingConfig signingConfigs.signRelease
        }
    }
}

No bloco signConfigs ficam todos os tipos de assinatura utilizados pelo
módulo. Aqui, foi nomeada a configuração para o build type de release como
signRelease. Na propriedade storeFile deve-se indicar o arquivo que assinará a
aplicação, o storePassword, o keyAlias e o keyPassword.

Para atribuir o tipo de assinatura ao build type deve-se utilizar a
propriedade signingConfig do bloco release. Com essa configuração, ao executar a
aplicação em modo release o APK será assinado com a configuração
especificada.

Entretanto, não é uma boa prática colocar as senhas explicitamente no
arquivo de compilação. Uma alternativa é colocar essas informações em
variáveis de ambiente do sistema operacional:
signingConfigs {
    signRelease {
        storeFile rootProject.file("sua_chave.jks")
        storePassword System.getenv("KSTOREPWD")
        keyAlias "AliasDaChave"
        keyPassword System.getenv("KEYPWD")
    }
}

Para que esse exemplo funcione, é necessário definir as variáveis de
ambiente KSTOREPWD e KEYPWD no sistema operacional.

Outra alternativa é utilizar um arquivo com a senhas. O arquivo
keystore.properties deveria ser adicionado na raiz do projeto e ficar como a
seguir:
storePassword=senha
keyPassword=senha
keyAlias=AliasDaChave
storeFile=sua_chave.jks

Como foi mencionado no início do capítulo, o gradle suporta Groovy.
Então é permitido ter código Groovy dentro do build.gradle. O código a
seguir lerá o arquivo keystore.properties:
def keystorePropertiesFile = rootProject.file("keystore.properties")
def keystoreProperties = new Properties()
keystoreProperties.load(new FileInputStream(keystorePropertiesFile))



 
android {
    ...
    signingConfigs {
        signRelease {
            storeFile rootProject.file(keystoreProperties['storeFile'])
            storePassword keystoreProperties['storePassword']
            keyAlias keystoreProperties['keyAlias']
            keyPassword keystoreProperties['keyPassword']
        }
    }
    ...

A palavra reservada def é a sintaxe para criar variáveis em Groovy. Foi
declarada a variável keyStorePropertiesFile que está armazenando o conteúdo do
arquivo keystore.properties. A variável keyStoreProperties fará o mapeamento do
conteúdo do arquivo em propriedades. Por fim, essa variável é utilizada no
bloco signRelease.

ProGuard
O ProGuard (http://proguard.sourceforge.net) é uma ferramenta para
diminuição, otimização, obfuscação e pré-verificação de código. Ela detecta e
remove classes, atributos e métodos não utilizados e renomeia os demais
usando o menor nome possível. Isso dificulta o entendimento do código-fonte
caso alguém descompile seu aplicativo. No Android, ele ainda tem o recurso
de encriptação de classes.

Por padrão, no bloco release, o uso do ProGuard é desabilitado. Para
habilitar, é preciso definir o valor da propriedade minifyEnabled para true:
android {
    ...
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            ...
        }
    }

Na propriedade proguardFiles, é indicado o arquivo proguard-android-
optimize.txt que armazena as configurações-padrão do ProGuard e está
localizado no diretório ANDROID_SDK/tools/proguard. Também é



adicionado automaticamente o arquivo proguard-rules.pro, que é um arquivo
em texto plano no qual é preciso adicionar regras específicas para o módulo.

Após o proguard ser executado, alguns arquivos importantes são gerados no
diretório <módulo>/build/outputs/mapping/release: o arquivo dump.txt
descreve a estrutura interna de todas as classes contidas no APK; no
mapping.txt encontramos o mapeamento entre os nomes originais de classes,
métodos e atributos, e seus novos nomes obfuscados; em seeds.txt fica a lista
de todas as classes, métodos e atributos que não foram obfuscados; e, por
fim, em usage.txt encontra-se a lista de todo o código que foi removido pelo
proguard.

Outra opção importante do Proguard que deve ser utilizada em conjunto
com o minifyEnabled é o shrinkResources. Com essa opção habilitada, o proguard
verifica os recursos que não estão sendo utilizados e os remove:
android {
    ...
    buildTypes {
        release {
            shrinkResources true
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'),
                    'proguard-rules.pro'
        }
    }
}

É importante ressaltar que apenas os recursos da pasta res/values não são
removidos devido a uma limitação da ferramenta AAPT (Android Asset
Packaging Tool).

Proguard e bibliotecas
Durante todo o livro foram utilizadas diversas bibliotecas simplesmente
adicionando-as na seção dependencies do build.gradle. Entretanto, muitas dessas
bibliotecas requerem que suas classes não sejam obfuscadas pelo Proguard.
Então, sempre que adicionar uma biblioteca, verifique se ela possui alguma
regra nesse sentido e a adicione ao arquivo proguard-rules.pro. Vejamos
alguns exemplos:

Gson (https://github.com/google/gson)
-keepattributes Signature



-keepattributes *Annotation*
-keep class sun.misc.Unsafe { *; }
-keep class dominando.android.gradle.model.** { *; }
-keep class * implements com.google.gson.TypeAdapterFactory
-keep class * implements com.google.gson.JsonSerializer
-keep class * implements com.google.gson.JsonDeserializer

As regras são estipuladas por cada biblioteca que sabe das motivações de
cada uma delas. É importante saber um pouco sobre cada uma das diretivas.
Neste exemplo, a instrução -keepattributes serve para manter os atributos da
classe. Já a opção -dontwarn especifica que o Proguard não deve gerar um aviso
de referências não resolvidas, e isso, segundo a documentação, só deve ser
feito se você souber o que está fazendo. Porém, provavelmente a opção mais
utilizada é a -keep, que define que a classe e seus métodos e atributos não
devem ser obfuscados. No exemplo anterior é informado que as (supostas)
classes do pacote dominando.android.gradle.model não devem ser obfuscadas, pois o
Gson utiliza o nome das classes e das propriedades para transformar o JSON
em objetos. Então essas classes deveriam ser mantidas inalteradas.

Parceler (https://github.com/johncarl81/parceler):
-keep interface org.parceler.Parcel
-keep @org.parceler.Parcel class * { *; }
-keep class **$$Parcelable { *; }

Aqui é mantida a interface Parcel, as classes anotadas com @Parcel e as classes
que terminam com Parcelable que são geradas pela biblioteca em tempo de
compilação.

Foram apresentados apenas dois exemplos aqui, mas é importante verificar
cada biblioteca que for adicionada ao projeto possui alguma regra de
proguard, e, em caso positivo, adicionar essa regra ao arquivo proguard-
rules.pro.

Proguard D8 e R8
Durante o processo de compilação de uma aplicação Android em modo
debug, cada classe se torna um arquivo *.dex que são aglutinados em alguns
poucos arquivos por meio da ferramenta D8. Ao gerar o APK de release, o
Proguard executa seu trabalho para obfuscar as classes e minimizar os
recursos para que o D8 gere os arquivos *.dex e gerar o APK.

Durante a escrita deste livro, o Google está trabalhando em uma ferramenta
chamada R8 que visa a substituir o Proguard. O R8 unirá o trabalho do



Proguard e do D8 em um único processo deixando a geração do APK mais
rápida e com um arquivo levemente menor que o Proguard. O R8 é
compatível com os arquivos de regras do Proguard, portanto a migração para
essa nova ferramenta tende a ser simples. Para habilitá-lo e testá-lo no
Android Studio 3.2 basta adicionar a seguinte linha no gradle.properties:
android.enableR8=true

Multidex
Se durante o desenvolvimento da aplicação o código-fonte, juntamente com
as bibliotecas das quais ele depende, exceder o limite de 65.536 (64 x 1024 =
64K) métodos, será exibida uma mensagem de erro durante a compilação:
trouble writing output:
Too many field references: 131000; max is 65536.
You may try using --multi-dex option.

E em versões mais antigas, a mensagem pode ser algo como:
Conversion to Dalvik format failed:
Unable to execute dex: method ID not in [0, 0xffff]: 65536

Até a versão 5.0, o Android utilizava a Dalvik, que por padrão só utiliza um
arquivo classes.dex. Para rodar múltiplos arquivos *.dex na Dalvik é preciso
adicionar a biblioteca multidex. Para o Lollipop e superior o Android utilizar
o ART (Android Runtime), que já suporta nativamente a execução de
múltiplos arquivos *.dex que são compilados em um único arquivo *.oat.

Sendo assim, para dar suporte ao multidex no Android Lollipop (API 21)
ou superior, basta habilitar a opção multiDexEnabled no build.gradle:
android {
    defaultConfig {
        ...
        minSdkVersion 21
        targetSdkVersion 28
        multiDexEnabled true
    }
    ...

Já para dar suporte ao Android KitKat (API 19) ou inferior é preciso
adicionar a biblioteca MultiDex e fazer mais algumas configurações:
android {
    defaultConfig {
        ...



        minSdkVersion 19
        targetSdkVersion 28
        multiDexEnabled true
    }
    ...
}
dependencies {
    implementation 'androidx.multidex:multidex:2.0.0'
}

Se o aplicativo possui uma classe que herda de Application, deve-se fazer com
que ela herde de MultiDexApplication:
class MyApplication: MultiDexApplication { ... }

E declarar essa classe no AndroidManifest.xml:
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapp">
    <application
            android:name=".MyApplication" >
        ...
    </application>
</manifest>

Caso o projeto não possua uma classe que herde de Application, basta declarar
a classe androidx.multidex.MultiDexApplication no AndroidManifest.xml.

Entretanto, se você já possui uma classe que herda de alguma subclasse de
Application, pode utilizar a chamada MultiDex.install(Context):
class MyApplication: SomeOtherApplication {
  override protected fun attachBaseContext(base: Context) {
     super.attachBaseContext(base)
     MultiDex.install(this)
  }
}

Feitas essas configurações, seu aplicativo já estará apto a exceder, caso seja
necessário, o limite de 64K.

Otimizando o processo de build
Existem algumas opções que podem deixar o processo de build um pouco
mais rápido e podem ser úteis em projetos maiores.

É possível criar uma build variant de desenvolvimento e compilar apenas o
mínimo de recursos necessários:
flavorDimensions "stage"



productFlavors {
    dev {
        dimension "stage"
        minSdkVersion 21
        versionNameSuffix "-dev"
        applicationIdSuffix '.dev'
        resConfigs "en", "xxhdpi"
        ...
    }
}

Com isso, apenas as pastas com o sufixo en e xxhdpi serão compiladas (além
dos diretórios-padrão, claro).

Outra opção que pode ser útil é habilitar o modo offline se você estiver com
uma conexão de internet lenta ou instável. Desta forma, o gradle não tentará
baixar as dependências e utilizará as dependências que ele possuir em cache.
Para habilitar o modo offline selecione a opção File > Settings (no Windows)
ou Android Studio > Preferences no Mac.

No painel esquerdo, selecione a opção Build, Execution, Deployment >
Gradle. Em seguida, marque a opção Offline work e clique em OK como
mostra a Figura 29.10.

Figura 29.10 – Opção para habilitar o Gradle no modo offline.
Se estiver utilizando o terminal de linha de comando, basta passar o

parâmetro --offline.
Criar módulos, build types, flavors, entre outros recursos do Gradle, ajudam



a organizar o projeto e promover a reutilização de código. Eles também
podem diminuir o tempo de build, já que o Gradle só compilará os módulos
que sofreram mudanças.

Neste capítulo foram abordados os principais tópicos do uso do Gradle no
Android Studio, se precisar de mais informações, consulte a documentação
disponível no endereço https://developer.android.com/studio/build.



CAPÍTULO 30
Material Design e bibliotecas

Android

No decorrer do livro foram utilizados alguns componentes e conceitos do
Material Design, o padrão de design adotado pelo Google e indicado para a
plataforma Android desde o lançamento da versão 5.0 Lollipop. Neste
capítulo serão abordados mais alguns conceitos e componentes para aplicar
esse padrão de design e serão demonstradas algumas bibliotecas de terceiros
bastante úteis no dia a dia do desenvolvedor Android.

Aplicativo de discos
Para demonstrar a utilização de alguns conceitos do Material Design, será
desenvolvido neste capítulo um aplicativo que acessará um JSON na web e
terá as informações dos discos da banda Engenheiros do Hawaii e de seu
vocalista Humberto Gessinger. Ao final, o aplicativo ficará como a Figura
30.1 e, ao clicar em um dos álbuns da lista, a tela de detalhe será exibida
conforme a Figura 30.2.

Application Name EngHaw
Package Name dominando.android.enghaw
Activity Name MainActivity



Figura 30.1 – Tela principal do aplicativo de discos.

Figura 30.2 – Tela de detalhes do aplicativo de discos.



Definindo as cores e o tema da aplicação
Para iniciar o desenvolvimento do exemplo, defina as cores e os temas do
aplicativo. No guia do Material Design existem algumas paletas de cores que
podem ser adotadas. As cores definidas para o aplicativo devem ser
adicionadas ao arquivo res/values/colors.xml:
<resources>
    <color name="text_primary">#ECEFF1</color>
    <color name="primary">#607D8B</color>
    <color name="primary_dark">#455A64</color>
    <color name="primary_selection">#CFD8DC</color>
    <color name="accent">#FF4081</color>
    <color name="accent_dark">#F50057</color>
    <color name="accent_selection">#FF80AB</color>
</resources>

Feito isso, implemente os temas da aplicação que utilizarão essas cores.
Abra o arquivo res/styles.xml e deixe-o como a seguir:
<resources>
    <style name="BaseTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <item name="android:textColorPrimary">@color/text_primary</item>
        <item name="colorPrimary">@color/primary</item>
        <item name="colorPrimaryDark">@color/primary_dark</item>
        <item name="colorAccent">@color/accent</item>
    </style>
    <style name="AppTheme" parent="BaseTheme">
        <item name="android:statusBarColor">@color/primary_dark</item>
        <item name="android:navigationBarColor">@color/primary_dark</item>
        <item name="android:colorActivatedHighlight">@color/primary_selection</item>
    </style>
    <style name="AppTheme.Translucent" parent="AppTheme">
        <item name="android:windowIsTranslucent">true</item>
        <item name="android:windowTranslucentStatus">true</item>
    </style>
    <style name="TextTitle">
        <item name="android:textSize">16sp</item>
        <item name="android:textColor">@android:color/black</item>
    </style>
    <style name="TextRegular">
        <item name="android:textSize">14sp</item>
        <item name="android:textColor">@android:color/darker_gray</item>
    </style>
</resources>

Foi definido o tema BaseTheme que conterá as configurações básicas do tema



da aplicação. O tema AppTheme herda do BaseTheme e é utilizado diretamente
pela aplicação, como se observa no AndroidManifest.xml.

A partir do Android Lollipop (API Level 21), é possível definir a cor das
barras de status e de navegação do aparelho. No tema AppTheme foi definida a
cor da barra de navegação na propriedade android:navigationBarColor. E para
definir a cor da barra de status foi utilizada a propriedade android:statusBarColor.
Foi definido o tema translúcido (AppTheme.Translucent) que será utilizado na tela
de detalhes.

Agora faça os seguintes ajustes no build.gradle do projeto como a seguir:
buildscript {
    ext {
        appcompat_version = '1.0.2'
        constraint_layout_version = '1.1.3'
        coroutines_version = '1.1.0'
        gson_version = '2.8.5'
        gradle_version = '3.3.1'
        kotlin_version = '1.3.20'
        material_design_version = '1.0.0'
        okhttp_version = '3.11.0'
    }
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath "com.android.tools.build:gradle:$gradle_version"
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}
...

Foram definidas algumas variáveis com as versões das bibliotecas que serão
utilizadas na aplicação. O arquivo build.gradle do módulo deve ficar como a
seguir:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
 
android {
    compileSdkVersion 28
    defaultConfig {
        applicationId "dominando.android.enghaw"



        minSdkVersion 21
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    androidExtensions {
        experimental = true
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
    implementation "androidx.appcompat:appcompat:$appcompat_version"
    implementation "com.google.android.material:material:$material_design_version"
    implementation "com.google.code.gson:gson:$gson_version"
    implementation "com.squareup.okhttp3:okhttp:$okhttp_version"
    implementation "androidx.constraintlayout:constraintlayout:$constraint_layout_version"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutines_version"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutines_version"
}

Note que o compileSdkVersion e o targetSdkVersion estão definidos para o API 28,
mas o minSdkVersion está definido como 21. Será utilizada a biblioteca com
diversos componentes do Material Design, por isso, foi adicionada a
dependência com.google.android.material:material que nos permitirá criar um visual
consistente. Também foram adicionadas as dependências das bibliotecas
Gson, OkHttp e Coroutines, que já foram utilizadas em capítulos anteriores.

No bloco androidExtensions foram habilitados os recursos experimentais do
Kotlin, pois será utilizada a anotação @Parcelize para facilitar a implementação
de objetos que implementem Parcelable. Se preferir, utilize a biblioteca
AutoParcel.

Lendo informações do web com GSON e OkHttp
Foi visto que com a biblioteca OkHttp é possível obter mais facilmente uma
String que representa um arquivo JSON retornado pelo servidor. Para ler o



arquivo e transformá-lo em objetos Kotlin podem-se utilizar as classes
JSONObject e JSONArray, mas a biblioteca GSON, do próprio Google, simplifica
esse trabalho. Para isso, basta ter uma estrutura de objetos igual à estrutura do
JSON que será lido. Por exemplo, o arquivo JSON tem a seguinte estrutura:
[
  {
    "titulo": "Longe Demais das Capitais",
    "capa": "capa_longe.jpg",
    "capa_big": "capa_longe_big.jpg",
    "ano": 1986,
    "gravadora": "BMG",
    "formacao": [ "Humberto Gessinger", "Marcelo Pitz", "Carlos Maltz" ],
    "faixas": [ "Toda Forma De Poder", "Segurança", ... ]
  }, ...
]

Esse arquivo contém um array de discos (pois inicia com colchete “[“), e
cada disco tem título, imagem da capa pequena e grande, ano de lançamento
do álbum, gravadora, formação da banda (representada por um array com o
nome dos integrantes) e título das faixas do disco.

Em seguida, adicione ao projeto a classe Album no pacote model que deve
ficar como a seguir:
import android.os.Parcelable
import com.google.gson.annotations.SerializedName
import kotlinx.android.parcel.Parcelize
 
@Parcelize
class Album (
        @SerializedName("titulo")
        val title: String,
        @SerializedName("capa")
        val cover: String,
        @SerializedName("capa_big")
        val coverBig: String,
        @SerializedName("ano")
        val year: Int,
        @SerializedName("gravadora")
        val recordingCompany: String,
        @SerializedName("formacao")
        val formation: List<String>,
        @SerializedName("faixas")
        val tracks: List<String>
) : Parcelable



Observe que a classe representa a mesma estrutura do arquivo JSON.
Entretanto, no arquivo JSON o nome dos campos estão em português e os
atributos da classe estão em inglês. Para que a leitura seja feita corretamente,
utiliza-se a anotação @SerializedName(String) para fazer essa adaptação.

Para juntar o OkHttp e o GSON crie a classe AlbumHttp (também no pacote
model), que deve ficar como a seguir:
import com.google.gson.Gson
import okhttp3.OkHttpClient
import okhttp3.Request
import java.util.concurrent.TimeUnit
 
object AlbumHttp {
    const val BASE_URL =
        "https://raw.githubusercontent.com/nglauber/dominando_android3/master/enghaw/"
 
    fun loadAlbums(): Array<Album>? {
        val client = OkHttpClient.Builder()
                .readTimeout(5, TimeUnit.SECONDS)
                .connectTimeout(10, TimeUnit.SECONDS)
                .build()
        val request = Request.Builder()
                .url("${BASE_URL}enghaw.json")
                .build()
        return try {
            val response = client.newCall(request).execute()
            val json = response.body()?.string()
            Gson().fromJson(json, Array<Album>::class.java)
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }
}

A utilização do GSON se resume a uma única linha marcada em negrito.
Todo o arquivo JSON foi convertido para um array de objetos Album.
Lembrando que isso só foi possível porque as estruturas do JSON e da classe
Album são iguais.

Como o aplicativo acessará a internet, adicione a permissão ao
AndroidManifest.xml:
<uses-permission android:name="android.permission.INTERNET" />



Listagem de álbuns da web
Na tela de listagem serão exibidos todos os álbuns com a respectiva miniatura
da imagem da capa do disco. Para exibir a listagem será utilizada a
RecyclerView, e para carregar as imagens a biblioteca Picasso. Sendo assim,
adicione a dependência no build.gradle:
dependencies {
    ...
    implementation "com.squareup.picasso:picasso:$picasso_version"
}

Adicione a propriedade picasso_version no build.gradle do projeto:
buildscript {
    ext { ...
        picasso_version = '2.71828'
    }

Adicione o arquivo de layout res/layout/item_album.xml que representará
cada item da lista:
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="?android:attr/selectableItemBackground"
    android:clickable="true"
    android:focusable="true"
    android:padding="16dp">
    <ImageView
        android:id="@+id/imgCover"
        android:layout_width="72dp"
        android:layout_height="72dp"
        android:layout_marginEnd="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toStartOf="@+id/txtTitle"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <TextView
        android:id="@+id/txtTitle"
        style="@style/TextTitle"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toEndOf="@+id/imgCover"



        app:layout_constraintTop_toTopOf="@id/imgCover" />
    <TextView
        android:id="@+id/txtYear"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:textSize="14sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="@+id/txtTitle"
        app:layout_constraintTop_toBottomOf="@+id/txtTitle" />
</androidx.constraintlayout.widget.ConstraintLayout>

O único ponto a ressaltar nesse arquivo é que foi definido o background do
elemento-raiz do layout para dar um feedback visual ao ser clicado. Isso não
é necessário ao utilizarmos a ListView, mas deve ser feito ao utilizar a
RecyclerView.

Agora implemente o adapter da tela listagem. Adicione a classe AlbumAdapter
e deixe-a como a seguir:
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import com.squareup.picasso.Picasso
import dominando.android.enghaw.model.Album
import dominando.android.enghaw.model.AlbumHttp
import kotlinx.android.synthetic.main.item_album.view.*
 
class AlbumAdapter(
        private val albums: List<Album>,
        private val onItemClick: (View, Album, Int) -> Unit
) : RecyclerView.Adapter<AlbumAdapter.AlbumViewHolder>() {
    override fun getItemCount(): Int {
        return albums.size
    }
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): AlbumViewHolder {
        val v = LayoutInflater.from(parent.context)
                .inflate(R.layout.item_album, parent, false)
        val vh = AlbumViewHolder(v)
        v.setOnClickListener { view ->
            val position = vh.adapterPosition
            val album = albums[position]
            onItemClick(view, album, position)



        }
        return vh
    }
    override fun onBindViewHolder(holder: AlbumViewHolder, position: Int) {
        val album = albums[position]
        holder.run {
            Picasso.get()
                    .load(AlbumHttp.BASE_URL + album.cover)
                    .into(imgCover)
            txtTitle?.text = album.title
            txtYear?.text = album.year.toString()
        }
    }
    class AlbumViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        var imgCover: ImageView? = view.imgCover
        var txtTitle: TextView? = view.txtTitle
        var txtYear: TextView? = view.txtYear
    }
}

Foi criada uma subclasse de RecyclerView.Adapter que tem como atributos uma
lista de objetos Album chamada albums e uma função de callback chamada
onItemClick. Essa função espera como parâmetro a view que foi clicada, o
objeto Album e a posição do item na lista. Esse callback é necessário porque a
RecyclerView não contém o evento de clique em um item da lista (como a
ListView). Então foi criado um mecanismo próprio, associando o evento de
clique em cada view da lista, que invoca esse callback passando os
parâmetros necessários.

Por herdar RecyclerView.Adapter, implementam-se os seguintes métodos:
• getItemCount() – retorna a quantidade de elementos que serão exibidos na

lista;
• onCreateViewHolder(ViewGroup,int) – é onde o arquivo de layout que representará

o item da lista é carregado e o objeto ViewHolder é criado. Nesse método
não é preenchida nenhuma informação da view, apenas as configurações
necessárias para o uso;

• onBindViewHolder(ViewHolder,int) – é aqui onde preenchemos a view, que será
exibida pela RecyclerView.

A classe AlbumViewHolder segue a mesma linha do que fizemos com o adapter
que usamos na ListView, a única diferença é que este herda de
RecyclerView.ViewHolder. Perceba que estamos acessando diretamente os



componentes declarados no arquivo de layout (baseado no id) graças ao
Kotlin Extensions. No onCreateViewHolder(ViewGroup, int) estamos criando um
objeto AlbumViewHolder e configurando o evento de clique, no qual basicamente
estamos chamando o callback onItemClick.

Crie o arquivo de layout res/layout/album_list.xml que será utilizado para a
listagem de álbuns e deixe-o como a seguir:
<androidx.swiperefreshlayout.widget.SwipeRefreshLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/swpRefresh"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/rvAlbums"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:scrollbars="vertical" />
</androidx.swiperefreshlayout.widget.SwipeRefreshLayout>

A RecyclerView foi colocada dentro de um SwipeRefreshLayout para dar um
feedback visual para o usuário enquanto os dados estão sendo carregados, e
também para permitir atualizar a lista caso haja algum problema. Também foi
habilitada a exibição da barra de rolagem (que não é exibida por padrão).

Nesse aplicativo teremos duas telas de listagem de álbuns que
compartilham algumas coisas em comum. Por isso, crie a classe
AlbumListBaseFragment listada a seguir:
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlin.coroutines.CoroutineContext
 
abstract class AlbumListBaseFragment : Fragment(), CoroutineScope {
    private lateinit var job: Job
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)



        retainInstance = true
        job = Job()
    }
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View {
        return inflater.inflate(R.layout.album_list, container, false)
    }
    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
    }
}

Para simplificar esse exemplo, não foi utilizada nenhuma arquitetura como
MVP ou MVVM, por isso os fragments acessarão diretamente as fontes de
dados (web ou local) para obter a listagem dos álbuns. Entretanto, em ambos
os casos é necessário fazê-lo fora da UI thread, por isso foram utilizadas as
coroutines mais uma vez.

A classe implementa a interface CoroutineScope onde a propriedade
coroutineContext deve ser implementada. Por padrão, o contexto da coroutine é
Dispatchers.Main (a main thread) e as demais ações serão filhas do atributo job.
No método onCreate(Bundle) o atributo job é inicializado e, em seguida, é
definido que a instância do fragment deve ser retida ao girar a tela do
aparelho. Todas as coroutines-filhas de job são canceladas no método
onDestroy(). No onCreateView(LayoutInflater,ViewGroup,Bundle) o arquivo de layout do
fragment é carregado.

Agora será implementada a primeira subclasse de AlbumListBaseFragment. Crie
a classe AlbumListWebFragment e deixe-a como a seguir:
import android.content.res.Configuration
import android.os.Bundle
import android.view.View
import androidx.recyclerview.widget.DefaultItemAnimator
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import dominando.android.enghaw.model.Album
import dominando.android.enghaw.model.AlbumHttp
import kotlinx.android.synthetic.main.album_list.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext



class AlbumListWebFragment : AlbumListBaseFragment() {
    private var albums: List<Album>? = null
    private var downloadJob: Job? = null
 
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        swpRefresh.setOnRefreshListener {
            loadAlbumsAsync()
        }
        rvAlbums.run {
            tag = "web" // será utilizado no capítulo de testes
            setHasFixedSize(true)
            val orientation = resources.configuration.orientation
            layoutManager = if (orientation == Configuration.ORIENTATION_PORTRAIT) {
                LinearLayoutManager(activity)
            } else {
                GridLayoutManager(activity, 2)
            }
            addItemDecoration(
                    DividerItemDecoration(context, LinearLayoutManager.VERTICAL)
            )
            itemAnimator = DefaultItemAnimator()
        }
    }
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        if (albums == null) {
            if (downloadJob?.isActive == true) {
                showProgress(true)
            } else {
                loadAlbumsAsync()
            }
        } else {
            updateList()
        }
    }
    private fun loadAlbumsAsync() {
        downloadJob = launch {
            showProgress(true)
            albums = withContext(Dispatchers.IO) {
                AlbumHttp.loadAlbums()?.toList()
            }
            showProgress(false)
            updateList()
            downloadJob = null



        }
    }
    private fun onItemClick(v: View, album: Album, position: Int) {
        // Implementaremos mais adiante
    }
    private fun updateList() {
        val list = albums ?: emptyList()
        rvAlbums.adapter = AlbumAdapter(list, this::onItemClick)
    }
    private fun showProgress(show: Boolean) {
        swpRefresh.post { swpRefresh.isRefreshing = show }
    }
}

O atributo downloadJob será utilizado para armazenar a operação que faz o
download do arquivo JSON. No método loadAlbumsAsync() foram utilizadas
coroutines para carregar os dados em background. Perceba que nele é
inicializado o atributo downloadJob com bloco launch. Nesse momento, o
indicador de progresso do SwipeRefreshLayout é exibido por meio do método
showProgress(Boolean). Em seguida, o atributo albums é inicializado com o retorno
do método loadAlbums() da classe AlbumHttp. Perceba que isso está sendo feito
com a chamada withContext(Dispatchers.IO) para que a operação seja feita na thread
de IO (input/output). Quando o download for concluído, o indicador de
progresso é ocultado e a RecyclerView é atualizada. O método onDestroy() da
superclasse cancelará todas as coroutines-filhas de job, inclusive a downloadJob.

O método onViewCreated(Bundle) é chamado quando a view do fragment está
carregada em memória, então foram definidas algumas características da
RecyclerView. Por meio do método setHasFixedSize(boolean) é definido que os itens
terão tamanho fixo, pois isso ajuda a renderizá-los mais rapidamente. Em
seguida, é definido o gerenciador de layout, que será responsável por
posicionar os itens da RecyclerView. Quando o aparelho estiver em portrait, é
utilizado o LinearLayoutManager, que fará com que os itens fiquem um abaixo do
outro; quando o aparelho estiver em landscape, é utilizado um
GridLayoutManager que dividirá a lista em duas colunas. Esse é um recurso muito
interessante da RecyclerView, pois permite aproveitar melhor o espaço da tela do
aparelho. Outro gerenciador interessante é o StaggeredGridLayoutManager, que é
semelhante ao GridLayoutManager, mas os itens são exibidos em formato de tiles
em tamanhos alternados. Também é possível criar seus próprios
gerenciadores de layout definindo uma subclasse de RecycleView.LayoutManager.



Foi definido também um separador entre as linhas da lista por meio do
método addItemDecoration(ItemDecoration) passando como parâmetro um
DividerItemDecoration. Por fim, uma animação foi atribuída para quando itens
forem inseridos ou removidos da lista, utilizando a propriedade itemAnimator.
Utilizando a DefaultItemAnimator fará a animação-padrão. Caso queira criar a sua
própria, basta definir uma subclasse de RecyclerView.ItemAnimator.

No onActivityCreated(Bundle) é verificado se as informações dos discos devem
ser baixadas. Se a lista de discos é nula, é preciso verificar se o download já
foi iniciado utilizando a propriedade isActive do objeto downloadJob. Caso seja
true, é preciso apenas aguardar que o download seja concluído. Quando o
download for concluído, o método updateList() é chamado e criará uma
instância de AlbumAdapter que é atribuída à RecyclerView.

Adicione esse fragment ao arquivo de layout da MainActivity
(res/layout/activity_main.xml):
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity">
    <androidx.appcompat.widget.Toolbar
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        android:background="?attr/colorPrimary" />
    <fragment
        android:id="@+id/listWeb"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:name="dominando.android.enghaw.AlbumListWebFragment" />
</LinearLayout>

Observe no tema da aplicação (BaseTheme) não possui barra de título uma vez
que herda de Theme.AppCompat.Light.NoActionBar, por isso, o componente Toolbar foi
adicionado. Como foi visto no Capítulo 8, é preciso utilizá-lo nesses casos.

Agora faça as seguintes mudanças na classe MainActivity:
import android.graphics.Color
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle



import kotlinx.android.synthetic.main.activity_main.*
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        setSupportActionBar(toolbar)
        toolbar.setTitleTextColor(Color.WHITE)
    }
}

O resultado ficará similar ao da Figura 30.3.

Figura 30.3 – Tela de lista de discos.

Elevação da View
O ambiente do Material Design é um espaço 3D. Isso significa que todos os
objetos têm as coordenadas x, y e z. O eixo z determina a distância da
superfície, e ao definir esse valor uma sombra é aplicada ao componente.
Esse conceito envolve duas propriedades que podem ser aplicadas a uma
View: elevation e translation. A elevação é estática e representa a coordenada z
aplicada ao componente. Já a translação é usada em animações para enfatizar
a elevação e, consequentemente, a sombra do componente.



Alguns componentes têm uma recomendação para o valor da elevação,
como mostra a Tabela 30.1.

Tabela 30.1 – Valores recomendados para elevação das views
Componente Valor

NavigationView / DrawerLayout 16 dp
FloatingActionButton 6 dp
AppBar 4 dp
CardView 2 dp
Conteúdo 0 dp

O recurso de profundidade adicionado no Lollipop pode ser aplicado a
qualquer view, e o Android se encarregará de exibir uma sombra
automaticamente. Essa sombra será exibida de acordo com a propriedade
android:elevation. O componente com valor maior fará sombra para o que tem o
menor valor. Também podemos utilizar a propriedade android:translationZ para
criar animações em que o componente é elevado durante alguma ação. Essas
propriedades podem ser modificadas programaticamente por meio das
propriedades elevation e translationZ e estão disponíveis a partir do Lollipop (API
Level 21).

CardView
O componente CardView foi abordado brevemente no Capítulo 4 será utilizado
na tela de detalhes. Crie o arquivo res/layout/content_details.xml e deixe-o
como a seguir:
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">
    <com.google.android.material.card.MaterialCardView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:cardBackgroundColor="@android:color/white"
        app:cardCornerRadius="3dp"
        app:cardElevation="2dp">
        <LinearLayout



            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">
            <TextView
                android:id="@+id/txtTitle"
                style="@style/TextTitle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />
            <TextView
                android:id="@+id/txtYear"
                style="@style/TextRegular"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />
            <TextView
                android:id="@+id/txtRecordingCompany"
                style="@style/TextRegular"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />
            <TextView
                style="@style/TextTitle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/formation" />
            <TextView
                android:id="@+id/txtFormation"
                style="@style/TextRegular"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />
        </LinearLayout>
    </com.google.android.material.card.MaterialCardView>
 
    <com.google.android.material.card.MaterialCardView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_marginTop="16dp"
        android:layout_marginBottom="16dp"
        android:padding="16dp"
        app:cardBackgroundColor="@android:color/white"
        app:cardCornerRadius="3dp"
        app:cardElevation="2dp">
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"



            android:padding="16dp">
            <TextView
                style="@style/TextTitle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/songs" />
            <TextView
                android:id="@+id/txtSongs"
                style="@style/TextRegular"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />
        </LinearLayout>
    </com.google.android.material.card.MaterialCardView>
</LinearLayout>

Os únicos comentários sobre esse arquivo são: a elevação que foi definida
segundo a recomendação do Material Design; e a curva definida para o
CardView.

Adicione o texto que utilizamos neste layout ao arquivo
res/values/strings.xml:
<string name="app_name">Engenheiros do Hawaii</string>
<string name="formation">Formação</string>
<string name="songs">Músicas</string>

CoordinatorLayout
Um efeito muito bacana adicionado ao Material Design foi a habilidade de
ocultar ou reposicionar componentes ao realizar uma ação em outro
componente. Entretanto, codificar esse comportamento manualmente requer
certo trabalho e, apesar de ser possível, pode fugir um pouco das guidelines
do Material Design.

Nesse contexto, existe o CoordinatorLayout que é descrito na documentação
como “um FrameLayout com super-poderes”. Como o nome sugere, ele
coordena a iteração entre componentes que definem determinado
comportamento por meio de objetos do tipo Behavior. Assim, ele determina
como cada um deles deve agir baseado no estado de cada componente. Vimos
um exemplo simples do uso do CoordinatorLayout no exemplo de hotéis, onde o
FloatingActionButton subia quando a SnackBar era exibida. Na próxima seção será
mostrado como este componente trabalha em conjunto com a barra de título
da aplicação.



Para utilizar o CoordinatorLayout é preciso adicionar a dependência da
biblioteca de design que já foi adicionada no build.gradle.

CoordinatorLayout e AppBar
O CoordinatorLayout será utilizado primeiramente na tela principal. A ideia é que,
ao iniciar o scroll para cima, a barra de título desapareça, e, ao fazê-lo para
baixo, ela reapareça automaticamente. Altere o arquivo
res/layout/activity_main.xml e deixe-o como a seguir:
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <com.google.android.material.appbar.AppBarLayout
        android:id="@+id/appBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:elevation="4dp">
        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            app:layout_scrollFlags="scroll|enterAlways|snap" />
    </com.google.android.material.appbar.AppBarLayout>
    <fragment
        android:id="@+id/listWeb"
        android:name="dominando.android.enghaw.AlbumListWebFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior"/>
</androidx.coordinatorlayout.widget.CoordinatorLayout>

Esse arquivo tem bastante coisa nova. O elemento-raiz é o CoordinatorLayout,
dentro dele está uma AppBar, que nada mais é que um LinearLayout que possui
vários recursos do Material Design, como a elevação e o comportamento de
scroll que está sendo implementado. Dentro da AppBar, tem a Toolbar com a
propriedade app:layout_scrollFlags. A Tabela 30.2 apresenta os valores possíveis
para essa propriedade; perceba que eles podem ser combinados.

Tabela 30.2 – Valores para a propriedade layout_scrollFlags
Valor Descrição



scroll Todas as views que saírem da tela ao ser feito o scroll devem ter esse valor; as que não
tiverem permanecerão na tela.

enterAlways Garante que qualquer scroll para baixo exibirá a view.
enterAlwaysCollapsed Quando a view declarar uma altura mínima (android:minHeight), ela somente será exibida

quando alcançar esse valor mínimo.
exitUntilCollapsed Fará com que a view diminua até alcançar o seu valor mínimo.
snap Ao terminar o scroll, se a view estiver apenas parcialmente visível, ela será exibida ou

ocultada, dependendo de quão visível ela estiver.

Voltando ao arquivo de layout, temos o fragment de listagem de discos, que
possui a RecyclerView. Perceba que na declaração do fragment definimos a
propriedade app:layout_behavior que realizará o comportamento de scroll
desejado.

Execute a aplicação e veja o comportamento do scroll. O resultado ficará
conforme a Figura 30.4.

Figura 30.4 – Tela de lista de discos com CoordinatorLayout.

CoordinatorLayout e CollapsingToolbarLayout
A tela de detalhes exibirá a capa do disco na barra de título e, ao fazer scroll
na tela, a barra de título diminuirá até ficar em seu tamanho mínimo. Crie a
DetailsActivity e deixe o arquivo de layout (res/layout/activity_details.xml) como
a seguir:



<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/coordinatorLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true" >
    <com.google.android.material.appbar.AppBarLayout
        android:id="@+id/appBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:fitsSystemWindows="true"
        app:elevation="4dp">
        <com.google.android.material.appbar.CollapsingToolbarLayout
            android:id="@+id/collapseToolbar"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:fitsSystemWindows="true"
            app:contentScrim="?attr/colorPrimary"
            app:layout_scrollFlags="scroll|exitUntilCollapsed">
            <ImageView
                android:id="@+id/imgCover"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:fitsSystemWindows="true"
                android:scaleType="centerCrop"
                app:layout_collapseMode="parallax"
                app:layout_collapseParallaxMultiplier="0.7" />
            <androidx.appcompat.widget.Toolbar
                android:id="@+id/toolbar"
                android:layout_width="match_parent"
                android:layout_height="?attr/actionBarSize"
                app:layout_collapseMode="pin" />
        </com.google.android.material.appbar.CollapsingToolbarLayout>
    </com.google.android.material.appbar.AppBarLayout>
    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false"
        android:scrollbars="vertical"
        app:layout_behavior="@string/appbar_scrolling_view_behavior">
        <include layout="@layout/content_details" />
    </androidx.core.widget.NestedScrollView>
    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/fabFavorite"



        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        app:elevation="6dp"
        android:tint="@android:color/white"
        app:fabSize="normal"
        app:layout_anchor="@+id/appBar"
        app:layout_anchorGravity="bottom|end" />
</androidx.coordinatorlayout.widget.CoordinatorLayout>

A ScrollView padrão do Android não permite realizar o efeito desejado, por
isso está sendo utilizada a NestedScrollView. Dentro dela foi incluído o arquivo
res/layout/content_details.xml que foi criado anteriormente. A AppBarLayout
possui uma CollapsingToolbarLayout que fará o efeito de expandir e diminuir a
altura da Toolbar durante o scroll. Perceba que foi definida a propriedade
app:layout_scrollFlags, explicada na seção anterior. Outra propriedade interessante
é a app:contentScrim, que é a cor a ser utilizada quando a barra atingir o tamanho
mínimo.

Outro detalhe importantíssimo é a propriedade fitsSystemWindows. Uma vez
que o layout é desenhado por trás da barra de status, é preciso utilizar esse
flag para que seja atribuído automaticamente um espaçamento (padding) na
parte superior dos componentes, que corresponde a altura da barra de status
do aparelho.

Implemente agora para a DetailsActivity:
import android.content.Context
import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.coordinatorlayout.widget.CoordinatorLayout
import com.squareup.picasso.Picasso
import dominando.android.enghaw.model.Album
import dominando.android.enghaw.model.AlbumHttp
import kotlinx.android.synthetic.main.activity_details.*
import kotlinx.android.synthetic.main.content_details.*
 
class DetailsActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_details)
        val album = intent.getParcelableExtra<Album>(EXTRA_ALBUM)
        if (album != null) {
            loadCover(album)



            initTitleBar(album.title)
            fillFields(album)
        }
    }
    private fun loadCover(album: Album) {
        Picasso.get()
                .load(AlbumHttp.BASE_URL + album.coverBig)
                .into(imgCover)
    }
    private fun initTitleBar(title: String) {
        setSupportActionBar(toolbar)
        if (appBar != null) {
            if (appBar?.layoutParams is CoordinatorLayout.LayoutParams) {
                val lp = appBar?.layoutParams as CoordinatorLayout.LayoutParams
                lp.height = resources.displayMetrics.widthPixels
            }
        }
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        if (collapseToolbar != null) {
            supportActionBar?.setDisplayShowTitleEnabled(true)
            collapseToolbar?.title = title
        } else {
            supportActionBar?.setDisplayShowTitleEnabled(false)
        }
    }
    private fun fillFields(album: Album) {
        txtTitle.text = album.title
        txtYear.text = album.year.toString()
        txtRecordingCompany.text = album.recordingCompany
        var sb = StringBuilder()
        for (member in album.formation){
            if (sb.isNotEmpty()) sb.append('\n')
            sb.append(member)
        }
        txtFormation.text = sb.toString()
        sb = StringBuilder()
        album.tracks.forEachIndexed { index, track ->
            if (sb.isNotEmpty()) sb.append('\n')
            sb.append(index+1).append(". ").append(track)
        }
        txtSongs.text = sb.toString()
    }
    companion object {
        const val EXTRA_ALBUM = "album"
        fun start(context: Context, album: Album) {



            context.startActivity(Intent(context, DetailsActivity::class.java).apply {
                putExtra(EXTRA_ALBUM, album)
            })
        }
    }
}

Essa classe não possui muitas coisas que já não tenham sido abordadas. Os
métodos fillFields(Album) e loadCover(Album) apenas preenchem os componentes
visuais com o conteúdo do objeto Album recebido como parâmetro da Intent que
chamou a activity. No método initTitleBar(String) a Toolbar é definida como barra
de título da activity; em seguida, é configurada a altura do CoordinatorLayout para
que seja igual à sua largura. Isso é feito para que a capa do disco não fique
distorcida, visto que ela é quadrada. Depois, é configurado o botão up da
barra de título e, por fim, o texto da barra de título é definido. Note que é
checado se o collapseToolbar e appBar são diferentes de null, pois eles podem não
estar presentes no arquivo de layout. Isso acontecerá quando for
implementada uma versão desse layout para landscape, como será visto
adiante.

Agora altere o tema da DetailsActivity para utilizar o tema translúcido no
AndroidManifest.xml:
<activity
    android:name=".DetailsActivity"
    android:theme="@style/AppTheme.Translucent" />

Para chamar a DetailsActivity, altere o método onItemClick(View,position,Album) da
classe AlbumListWebFragment:
private fun onItemClick(v: View, album: Album, position: Int) {
    context?.run {
        DetailsActivity.start(this, album)
    }
}

Execute a aplicação e verifique o comportamento do scroll na tela de
detalhes. Ela deve ficar como a Figura 30.5.



Figura 30.5 – Tela de detalhe do disco com CoordinatorLayout.
O aplicativo já está tomando forma, mas ao girar o aparelho na tela de

detalhe não é possível sequer fazer o scroll. Isso porque foi feito o ajuste no
CoordinatorLayout para que ele tivesse a mesma medida para altura e largura de
modo a não distorcer a imagem da capa. Para resolver esse problema, crie um
layout alternativo res/layout-land/activity_details.xml para quando o aparelho
estiver em landscape:
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/coordinator"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true">
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="horizontal">
        <FrameLayout
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:orientation="vertical"



            android:padding="16dp">
            <ImageView
                android:id="@+id/imgCover"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:layout_gravity="center"
                android:scaleType="fitStart" />
            <androidx.appcompat.widget.Toolbar
                android:id="@+id/toolbar"
                android:layout_width="match_parent"
                android:layout_height="?android:attr/actionBarSize"/>
            <com.google.android.material.floatingactionbutton.FloatingActionButton
                android:id="@+id/fabFavorite"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="end|bottom"
                android:layout_margin="16dp"
                android:tint="@android:color/white"
                app:backgroundTint="@color/accent"
                app:fabSize="normal"
                app:layout_anchor="@+id/imgCover" />
        </FrameLayout>
        <androidx.core.widget.NestedScrollView
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:clipToPadding="false"
            android:scrollbars="vertical">
            <include layout="@layout/content_details" />
        </androidx.core.widget.NestedScrollView>
    </LinearLayout>
</androidx.coordinatorlayout.widget.CoordinatorLayout>

Nessa versão do layout não existe a AppBar nem a CollapsingToolbarLayout.
Execute a aplicação, abra a tela de detalhe e ela ficará similar à Figura 30.6.



Figura 30.6 – Tela de detalhe do disco em landscape.

Transições de tela
No capítulo sobre animações foi demonstrado como implementar animações
personalizadas para transições de tela. Com o Material Design esse conceito
ganhou ainda mais importância com a adição de novos recursos. É possível
definir animações para a transição de abrir e fechar a activity e para animar
elementos compartilhados entre as telas.

Para utilizar a transição de telas, é preciso definir alguns atributos de estilo.
Então, faça os seguintes ajustes no arquivo res/values/styles.xml:
<resources>
    ...
    <style name="AppTheme" parent="BaseTheme">
        <item name="android:windowContentTransitions">true</item>
        <item name="android:windowEnterTransition">@android:transition/explode</item>
        <item name="android:windowExitTransition">@android:transition/explode</item>
        <item name="android:statusBarColor">@color/primary_dark</item>
        <item name="android:navigationBarColor">@color/primary_dark</item>
        <item name="android:colorActivatedHighlight">@color/primary_selection</item>
    </style>
    ...
</resources>



A propriedade android:windowContentTransitions habilita a transição entre
activities. Já nas propriedades android:windowEnterTransition e
android:windowExitTransition foram especificadas as animações entrada e saída das
activities. Além das que foram utilizadas, pode-se usar: fade, move, slide_top,
slide_bottom, slide_left, slide_right.

Na AlbumListWebFragment, altere o método onItemClick(View, Album, Int) deixando-o
conforme a seguir:
private fun onItemClick(v: View, album: Album, position: Int) {
    activity?.run {
        val options = ActivityOptionsCompat.makeSceneTransitionAnimation(this)
        val intent = Intent(this, DetailsActivity::class.java).apply {
            putExtra(DetailsActivity.EXTRA_ALBUM, album)
        }
        ActivityCompat.startActivity(this, intent, options.toBundle())
    }
}

Com a classe ActivityOptionsCompat, a animação de transição é gerada ao
invocar o método makeSceneTransitionAnimation(Activity). Em seguida, o método
ActivityCompat.startActivity(Activity, Intent, Bundle) é chamado passando a activity
atual, o objeto Intent para a DetailsActivity e o objeto options.

Execute a aplicação e uma animação será executada ao abrir a tela de
detalhes.

É possível especificar as animações de saída e entrada da activity utilizando
o código a seguir:
override fun onCreate(savedInstanceState: Bundle?) {
    window.requestFeature(Window.FEATURE_CONTENT_TRANSITIONS)
    window.exitTransition = Explode()
    window.enterTransition = Explode()
    super.onCreate(savedInstanceState)
    ...
}

Perceba que este código é executado antes no onCreate(Bundle), antes mesmo
da chamada ao método da superclasse.

Transição com itens compartilhados
Neste exemplo será implementada uma transição entre a tela de listagem e de
detalhes utilizando a imagem da capa, o título e o ano, já que ambos
aparecem nas duas telas.



Essa animação de views compartilhadas entre duas activities trará um efeito
muito interessante ao aplicativo. A primeira coisa que deve ser feita é
habilitar esse recurso no arquivo res/values/styles.xml:
<resources>
    ...
    <style name="AppTheme" parent="BaseTheme">
        <item name="android:windowContentTransitions">true</item>
        <item name="android:windowSharedElementEnterTransition">
            @android:transition/move
        </item>
        <item name="android:windowSharedElementExitTransition">
            @android:transition/move
        </item>
        <item name="android:statusBarColor">@color/primary_dark</item>
        <item name="android:navigationBarColor">@color/primary_dark</item>
        <item name="android:colorActivatedHighlight">@color/primary_selection</item>
    </style>
     ...
</resources>

A transição do conteúdo da janela foi habilitada com a propriedade
android:windowContentTransitions onde foi definido o comportamento dos elementos
compartilhados entre as telas nas propriedades
android:windowSharedElementEnterTransition e android:windowSharedElementExitTransition
indicando que eles se movimentarão.

O próximo passo é definir a propriedade android:transitionName das views que
são comuns às duas telas. Por exemplo, a ImageView da capa, que aparece no
item da lista e na tela de detalhe devem ter o mesmo valor atribuído para essa
propriedade em ambos os arquivos de layout. Abra a classe AlbumAdapter e
altere o método a seguir:
override fun onBindViewHolder(holder: AlbumViewHolder, position: Int) {
    val album = albums[position]
    holder.run {
        Picasso.get()
                .load(AlbumHttp.BASE_URL + album.cover)
                .into(imgCover)
        txtTitle?.text = album.title
        txtYear?.text = album.year.toString()
        imgCover?.transitionName = "cover${album.title}"
        txtTitle?.transitionName = "title${album.title}"
        txtYear?.transitionName = "year${album.title}"
    }



}
O nome de transição deve ser único único para cada view de modo que a

transição de retorno da activity de detalhes para a principal possa ser feita
para as views de origem corretas.

Faça o mesmo na DetailsActivity:
class DetailsActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_details)
        val album = intent.getParcelableExtra<Album>(EXTRA_ALBUM)
        if (album != null) {
            loadCover(album)
            initTitleBar(album.title)
            fillFields(album)
            initEnterAnimation(album)
        }
    }
    private fun initEnterAnimation(album: Album) {
        imgCover.transitionName = "cover${album.title}"
        txtTitle.transitionName = "title${album.title}"
        txtYear.transitionName = "year${album.title}"
    }
    ...

Agora altere o método onItemClick(View,Album,Int) da AlbumListWebFragment para
ficar como a seguir:
import androidx.core.util.Pair // certifique-se de usar esse import
import kotlinx.android.synthetic.main.item_album.view.*
...
private fun onItemClick(v: View, album: Album, position: Int) {
    activity?.run {
        val options = ActivityOptionsCompat.makeSceneTransitionAnimation(this,
                Pair.create(v.imgCover, "cover${album.title}"),
                Pair.create(v.txtTitle, "title${album.title}"),
                Pair.create(v.txtYear, "year${album.title}")
        )
        val intent = Intent(this, DetailsActivity::class.java).apply {
            putExtra(DetailsActivity.EXTRA_ALBUM, album)
        }
        ActivityCompat.startActivity(this, intent, options.toBundle())
    }
}



O método makeSceneTransitionAnimation() requer a utilização da classe
androidx.core.util.Pair para mapear a view no seu respectivo nome de transição.

Ao abrir a activity de detalhe, as views do item da lista farão uma animação
até as respectivas posições na activity de detalhe, e a operação reversa será
realizada quando ela for fechada. Porém, se você observar atentamente, a
animação não é feita da forma correta; isso está acontecendo porque a barra
de título é redimensionada em tempo de execução, atrapalhando o
comportamento desejado. Outro problema é que a animação é feita com a
imagem que está na tela de listagem e que vai sendo ampliada até ser exibida
completamente na tela de detalhe. Entretanto, essa imagem da tela de detalhe
é diferente da imagem que está sendo carregada na tela de listagem. Por isso,
é preciso esperar que ela seja carregada para que a animação flua
normalmente.

Para contornar esses problemas, a transição de tela será adiada até que tudo
esteja pronto, ou seja, até que o download da imagem seja concluído:
import com.squareup.picasso.Target
 
class DetailsActivity : AppCompatActivity() {
    private var coverTarget: Target? = null
    // Os demais métodos não foram modificados
    private fun initEnterAnimation(album: Album) {
        imgCover.transitionName = "cover${album.title}"
        txtTitle.transitionName = "title${album.title}"
        txtYear.transitionName = "year${album.title}"
        postponeEnterTransition()
    }
    private fun loadCover(album: Album) {
        coverTarget = object: Target {
            override fun onBitmapLoaded(bitmap: Bitmap?, from: Picasso.LoadedFrom?) {
                imgCover.setImageBitmap(bitmap)
                startEnterAnimation()
            }
            override fun onBitmapFailed(e: Exception?, errorDrawable: Drawable?) {
                startEnterAnimation()
            }
            override fun onPrepareLoad(placeHolderDrawable: Drawable?) {
            }
        }.apply {
            Picasso.get()
                    .load(AlbumHttp.BASE_URL + album.coverBig)
                    .into(this)



        }
    }
    private fun startEnterAnimation() {
        imgCover.viewTreeObserver.addOnPreDrawListener(object:

ViewTreeObserver.OnPreDrawListener {
            override fun onPreDraw(): Boolean {
                imgCover.viewTreeObserver.removeOnPreDrawListener(this)
                startPostponedEnterTransition()
                return true
            }
        })
    }
    ...

Primeiramente foi declarado um atributo do tipo Target (do Picasso) que
permite detectar quando a imagem foi carregada. No método initEnterAnimation()
invocamos o método postponeEnterTransition() que impedirá que a animação de
entrada seja realizada até que o método startPostponedEnterTransition() seja
chamado. Com isso, ao terminar de carregar a imagem (ou se ocorrer algum
erro), a transição de entrada é iniciada. Execute a aplicação, e a transição
deve estar bem melhor.

Porém, você deve ter percebido um detalhe inconveniente: o FAB ficou
com um comportamento estranho, mas isso será corrigido com os seguintes
ajustes na DetailsActivity:
import android.transition.Transition
...
override fun onBackPressed() {
    fabFavorite.animate()
            .scaleX(0f)
            .scaleY(0f)
            .setDuration(100L)
            .withEndAction {
                val params = fabFavorite.layoutParams as? CoordinatorLayout.LayoutParams
                if (params != null) {
                    params.behavior = null
                    fabFavorite.requestLayout()
                }
                super.onBackPressed()
            }
}
private fun startEnterAnimation() {
    imgCover.viewTreeObserver.addOnPreDrawListener(object:

ViewTreeObserver.OnPreDrawListener {



        override fun onPreDraw(): Boolean {
            imgCover.viewTreeObserver.removeOnPreDrawListener(this)
            startPostponedEnterTransition()
            window.enterTransition.addListener(object: Transition.TransitionListener {
                override fun onTransitionStart(transition: Transition?) {
                    fabFavorite.scaleX = 0f
                    fabFavorite.scaleY = 0f
                }
                override fun onTransitionEnd(transition: Transition?) {
                    fabFavorite.animate()
                            .scaleX(1f)
                            .scaleY(1f)
                            .duration = 100L
                }
                override fun onTransitionCancel(transition: Transition?) { }
                override fun onTransitionPause(transition: Transition?) { }
                override fun onTransitionResume(transition: Transition?) { }
            })
            return true
        }
    })
}

Quando a tela de detalhes é exibida, após a transição de entrada ser
executada, uma animação de escala é feita para exibir o botão. Para detectar
quando a transição foi iniciada, foi utilizada a interface TransitionListener, e no
onTransitionStart(Transition) a escala do botão é definida como zero, e, ao terminar,
no onTransitionEnd(Transition) a animação é realizada. Ao pressionar o botão de
voltar, a animação inversa é executada. Execute a aplicação novamente e veja
como ficou a animação.

Biblioteca Palette
O Google disponibilizou uma biblioteca que permite extrair uma paleta de
cores a partir de uma imagem. Dada determinada imagem, é possível obter as
cores Vibrant, Vibrant Dark, Vibrant Light, Muted, Muted Dark e Muted
Light. Para demonstrar o uso dessa biblioteca, será utilizada a foto de capa do
disco para extrair a paleta de cores e elas serão utilizadas para mudar as cores
de diversos elementos da tela.

Adicione primeiramente a dependência da biblioteca no build.gradle:
dependencies {
    ...



    implementation "androidx.palette:palette:$palette_version"
}

Adicione a constante palette_version = '1.0.0' no build.gradle do projeto. Em
seguida, faça alguns pequenos ajustes na DetailsActivity:
private fun loadCover(album: Album) {
    coverTarget = object: Target {
        override fun onBitmapLoaded(bitmap: Bitmap?, from: Picasso.LoadedFrom?) {
            imgCover.setImageBitmap(bitmap)
            setUiColors(bitmap)
            // startEnterAnimation()
        }
        // O restante do método não mudou
}
private fun setUiColors(bitmap: Bitmap?) {
    if (bitmap == null) {
        startEnterAnimation()
        return
    }
    Palette.from(bitmap).generate { palette ->
        palette?.let {
            val vibrantColor = palette.getVibrantColor(Color.BLACK)
            val darkVibrantColor = palette.getDarkVibrantColor(Color.BLACK)
            val darkMutedColor = palette.getDarkMutedColor (Color.BLACK)
            val lightMutedColor = palette.getLightMutedColor(Color.WHITE)
            txtTitle.setTextColor(vibrantColor)
            if (appBar != null) {
                appBar?.setBackgroundColor(vibrantColor)
            } else {
                toolbar.setBackgroundColor(Color.TRANSPARENT)
            }
            window.navigationBarColor = darkMutedColor
            if (collapseToolbar != null) {
                collapseToolbar?.setStatusBarScrimColor(darkMutedColor)
                collapseToolbar?.setContentScrimColor(darkVibrantColor)
            }
            coordinatorLayout?.setBackgroundColor(lightMutedColor)
        }
        startEnterAnimation()
    }
}

Após fazer o download da imagem, o método setUiColors(Bitmap) é invocado, e
nele foi utilizada a classe Palette para extrair as cores da imagem com o
método generate(PaletteAsyncListener). Esse listener é utilizado porque extrair as



cores pode demorar alguns milissegundos e, quando o processo for
concluído, o método onGenerated(Palette) (omitido pelo lambda) será invocado.

Nesse momento são alteradas as cores do texto do título do disco, do
background da barra de título, da barra de navegação, da CollapsingToolBar
quando estiver no tamanho mínimo e do background do CoordinatorLayout.
Execute a aplicação, clique em cada disco e verifique que cada tela terá um
conjunto diferente de cores.

Persistindo os álbuns favoritos
Serão adicionadas algumas classes para implementar a persistência dos discos
favoritos no banco de dados SQLite utilizando o Room (abordado no
Capítulo 10). Será utilizado o Live Data para que, quando um novo álbum
seja adicionado ou removido aos favoritos, a tela seja atualizada
automaticamente.

Adicione a versão da biblioteca dos Architecture Components no
build.gradle do projeto:
buildscript {
    ext {
        livedata_version = '2.0.0'
        room_version = '2.0.0'
        ...

Agora adicione as dependências no build.gradle ao projeto:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'
...
dependencies {
    ...
    implementation "androidx.lifecycle:lifecycle-livedata:$livedata_version"
    implementation "androidx.room:room-runtime:$room_version"
    kapt "androidx.room:room-compiler:$room_version"
}

Como de costume, é preciso aplicar o plugin do kapt para processar as
anotações do Room. Adicionadas as dependências, será feita a
implementação da persistência começando pela classe Album:
import androidx.room.Entity
import androidx.room.PrimaryKey



import android.os.Parcelable
import com.google.gson.annotations.SerializedName
import kotlinx.android.parcel.Parcelize
 
@Parcelize
@Entity
class Album (
        @PrimaryKey (autoGenerate = true)
        var id: Long = 0L,
        //... demais campos não mudam
) : Parcelable

A anotação @Entity foi adicionada para poder persistir o objeto Album, e o
atributo id servirá de chave primária da tabela.

Temos um pequeno problema com a classe Album. Os campos formation e tracks
são do tipo List<String>, que não é possível de salvar diretamente no SQLite.
Uma alternativa seria criar duas novas classes chamadas Member e Song e fazer
o relacionamento entre elas e a tabela de Album, mas para deixar o exemplo
mais simples, essas informações serão salvas no banco de dados no formato
de strings separadas por vírgula.

Para que isso seja possível, é preciso utilizar o recurso de TypeConverter do
Room. Crie a classe Converters no pacote db como apresentado a seguir:
import androidx.room.TypeConverter
 
class Converters {
    @TypeConverter
    fun stringToList(value: String): List<String> {
        return value.split(',')
    }
    @TypeConverter
    fun listToString(list: List<String>): String {
        val sb = StringBuffer()
        list.forEachIndexed { i, s ->
            if (i > 0) sb.append(',')
            sb.append(s)
        }
        return sb.toString()
    }
}

Ambos os métodos estão anotados com @TypeConverter que é o suficiente para
o Room identificar que se trata de um método de conversão de tipos. O
método stringToList(String) converte uma String em uma List<String> enquanto o



método listToString(List<String>) realiza a operação inversa. O primeiro será
utilizado pelo Room ao ler informações do banco, enquanto o segundo será
chamado ao salvar um registro.

Adicione a interface AlbumDao também no pacote db e deixe-a como a seguir:
import androidx.lifecycle.LiveData
import dominando.android.enghaw.model.Album
import androidx.room.*
 
@Dao
interface AlbumDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun save(album: Album): Long
    @Delete
    fun delete(album: Album)
    @Query("SELECT * FROM Album ORDER BY year")
    fun allAlbums(): LiveData<List<Album>>
    @Query("SELECT * FROM Album WHERE title LIKE :title")
    fun albumByTitle(title: String): List<Album>
}

Essa classe não possui nada que não tenhamos visto quando falamos sobre
Room. O método save(Album) para inserir ou atualizar (caso já exista) o Album
no banco de dados e que retorna o id do registro salvo (que é gerado
automaticamente). Também foi declarado o método delete(Album) para remover
um Album da tabela. O método allAlbums() retorna todos os registros da tabela.
Perceba que é utilizado um LiveData para que os dados sejam atualizados
automaticamente. Por fim, o método albumByTitle(String) faz a busca do álbum
por título que será utilizado para saber se o favorito já foi incluído. Como os
ábuns vindos da web não possuem um identificador único, foi utilizado o
título para esse propósito.

Finalmente, para definir o banco de dados, crie a classe AppDb e deixe-a da
seguinte forma:
import android.content.Context
import androidx.room.*
import dominando.android.enghaw.model.Album
 
@Database(entities = [Album::class], version = 1)
@TypeConverters(Converters::class)
abstract class AppDb: RoomDatabase() {
    abstract fun albumDao(): AlbumDao
 



    companion object {
        private val DB_NAME = "engHawDb"
        private var INSTANCE: AppDb? = null
 
        fun getInstance(context: Context): AppDb? {
            if (INSTANCE == null) {
                INSTANCE = Room.databaseBuilder(
                        context.applicationContext,
                        AppDb::class.java,
                        DB_NAME)
                        .build()
            }
            return INSTANCE
        }
        fun destroyInstance() {
            INSTANCE = null
        }
    }
}

O banco de dados da aplicação é bem simples, uma vez que possui apenas
uma entidade definida na anotação @Database. Perceba que utilizando a
anotação @TypeConverters é informada a classe responsável pela conversão de
tipos (entre String e List<String>) que foi criada anteriormente. O método
getInstance(Context) servirá para centralizar a obtenção da instância única dessa
classe.

Para facilitar a comunicação entre a UI e o banco de dados, no pacote db
adicione a classe AlbumRepository listada a seguir:
import androidx.lifecycle.LiveData
import android.content.Context
import dominando.android.enghaw.model.Album
 
class AlbumRepository(context: Context) {
    private val db: AppDb by lazy {
        AppDb.getInstance(context) as AppDb
    }
    private val dao: AlbumDao by lazy {
        db.albumDao()
    }
    fun save(album: Album) {
        val id = dao.save(album)
        album.id = id
    }



    fun delete(album: Album) {
        dao.delete(album)
    }
    fun loadFavorites(): LiveData<List<Album>> {
        return dao.allAlbums()
    }
    fun isFavorite(album: Album): Boolean {
        return dao.albumByTitle(album.title).isNotEmpty()
    }
}

Esta é uma classe simples com o propósito apenas para centralizar a criação
e acesso ao banco de dados.

TabLayout e a tela de favoritos
Será adicionado um fragment à tela principal que listará os discos favoritos
cadastrados no banco de dados. Crie a classe AlbumListDbFragment e deixe-a
como a seguir:
import android.content.Intent
import android.content.res.Configuration
import android.os.Bundle
import android.view.View
import androidx.core.app.ActivityCompat
import androidx.core.app.ActivityOptionsCompat
import androidx.core.util.Pair
import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
import androidx.recyclerview.widget.DefaultItemAnimator
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import dominando.android.enghaw.db.AlbumRepository
import dominando.android.enghaw.model.Album
import kotlinx.android.synthetic.main.album_list.*
import kotlinx.android.synthetic.main.item_album.view.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
 
class AlbumListDbFragment : AlbumListBaseFragment() {
    private val repo: AlbumRepository by lazy {
        AlbumRepository(requireContext())
    }



    private var albumList: LiveData<List<Album>>? = null
 
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        swpRefresh.isEnabled = false
        rvAlbums.setHasFixedSize(true)
        rvAlbums.tag = "fav" // será utilizado no capítulo de testes
 
        rvAlbums.layoutManager =
            if (resources.configuration.orientation == Configuration.ORIENTATION_PORTRAIT) {
                    LinearLayoutManager(requireActivity())
            } else {
                    GridLayoutManager(requireActivity(), 2)
            }
        rvAlbums.addItemDecoration(
                DividerItemDecoration(context, LinearLayoutManager.VERTICAL)
        )
        rvAlbums.itemAnimator = DefaultItemAnimator()
    }
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState);
        launch {
            albumList = withContext(Dispatchers.IO) { repo.loadFavorites() }
            albumList?.observe(this@AlbumListDbFragment, Observer { albums ->
                if (albums != null) {
                    updateList(albums)
                }
            })
        }
    }
    private fun updateList(albums: List<Album>) {
        rvAlbums.adapter = AlbumAdapter(albums, this::onItemClick)
    }
    private fun onItemClick(v: View, album: Album, position: Int) {
        activity?.run {
            val options = ActivityOptionsCompat.makeSceneTransitionAnimation(this,
                    Pair.create(v.imgCover, "cover${album.title}"),
                    Pair.create(v.txtTitle, "title${album.title}"),
                    Pair.create(v.txtYear, "year${album.title}")
            )
            val intent = Intent(this, DetailsActivity::class.java).apply {
                putExtra(DetailsActivity.EXTRA_ALBUM, album)
            }
            ActivityCompat.startActivity(this, intent, options.toBundle())
        }



    }
}

Essa classe é basicamente uma cópia da classe ListaDiscosWebFragment. A
diferença básica é que, em vez de obter os dados da web, eles estão vindo do
banco de dados, e que no caso dessa classe é obtido um LiveData<List<Album>>
em vez de uma List<Album>. Um detalhe é que o SwipeRefreshLayout foi
desabilitado, já que não faz muito sentido ter um recurso de “refresh” em um
banco de dados local porque a resposta tende a ser praticamente instantânea.

Abra o arquivo de layout res/layout/activity_main.xml e faça as seguintes
mudanças:
<androidx.coordinatorlayout.widget.CoordinatorLayout ...>
    <com.google.android.material.appbar.AppBarLayout ...>
        <androidx.appcompat.widget.Toolbar ... />
        <com.google.android.material.tabs.TabLayout
            android:id="@+id/tabs"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:tabGravity="fill" />
    </com.google.android.material.appbar.AppBarLayout>
    <androidx.viewpager.widget.ViewPager
        android:id="@+id/viewPager"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior" />
</androidx.coordinatorlayout.widget.CoordinatorLayout>

O fragment foi substituído por um ViewPager e um TabLayout foi adicionado à
AppBar. Agora configure o ViewPager na MainActivity como a seguir:
import android.graphics.Color
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager
import androidx.fragment.app.FragmentPagerAdapter
import kotlinx.android.synthetic.main.activity_main.*
 
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        setSupportActionBar(toolbar)
        toolbar.setTitleTextColor(Color.WHITE)
        viewPager.adapter = AlbumPagerAdapter(supportFragmentManager)



        tabs.setupWithViewPager(viewPager)
    }
    inner class AlbumPagerAdapter(fm: FragmentManager): FragmentPagerAdapter(fm) {
        override fun getItem(position: Int): Fragment {
            return if (position == 0) {
                AlbumListWebFragment()
            } else {
                AlbumListDbFragment()
            }
        }
        override fun getCount() = 2
 
        override fun getPageTitle(position: Int): CharSequence? {
            return if (position == 0) {
                getString(R.string.tab_all)
            } else {
                getString(R.string.tab_favorites)
            }
        }
    }
}

Os componentes TabLayout e o ViewPager foram abordados no Capítulo 9.
Esses dois componentes podem ser interligados para que, ao mudar a página
deslizando para o lado, a aba seja atualizada, e, ao mudar de aba, a página
seja atualizada. Para isso, basta invocar o método setUpWithViewPager(ViewPager)
do TabLayout. Para configurar as páginas do ViewPager, é necessário criar uma
subclasse de FragmentPagerAdapter. No método getCount() da classe DiscoPagerAdapter
foi informado que serão exibidas duas abas, onde a primeira será o
AlbumListWebFragment e a segunda, AlbumListDbFragment, conforme descrito no
método getItem(int). Por fim, o título de cada aba é definido no método
getPageTitle(int). Adicione estes textos ao arquivo res/values/strings.xml:
<string name="tab_all">Todos os Álbuns</string>
<string name="tab_favorites">Favoritos</string>

Execute a aplicação e ela deverá possuir duas abas, como mostra a Figura
30.7. Entretanto, a parte da interface gráfica que salva um disco no banco
ainda não foi implementada. Isso será feito na próxima seção.



Figura 30.7 – Tela principal da aplicação com duas abas.

Vector Drawable
A partir do Android 5.0 (API Level 21) surgiu a possibilidade de utilizar
imagens vetoriais por meio de “Vector Drawables”. Com elas, as imagens se
adéquam às diversas densidades de tela sem que haja perda de qualidade.
Com isso não há a necessidade de criar imagens para cada densidade de tela.
A imagem vetorial é representada por um conjunto de instruções de traçado.

Para criar uma imagem vetorial, é preciso criar um arquivo na pasta
res/drawable que comece com a tag <vector>. Vejamos o exemplo a seguir
disponível no site do Android:
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="256dp"
    android:height="256dp"
    android:viewportHeight="32"
    android:viewportWidth="32">
    <group
        android:name="meuGrupo"
        android:pivotX="128"
        android:pivotY="128"
        android:rotation="0">



        <path
            android:name="coracao"
            android:fillColor="#8fff"
            android:pathData="M20.5,9.5
                        c-1.955,0,-3.83,1.268,-4.5,3
                        c-0.67,-1.732,-2.547,-3,-4.5,-3
                        C8.957,9.5,7,11.432,7,14
                        c0,3.53,3.793,6.257,9,11.5
                        c5.207,-5.242,9,-7.97,9,-11.5
                        C25,11.432,23.043,9.5,20.5,9.5z" />
    </group>
</vector>

Esse arquivo desenhará um ícone de coração; embora seja bem estranho à
primeira vista, se analisarmos com calma é possível ter uma ideia de como
isso é feito. Assim, primeiro observe as propriedades da tag <vector> listadas
na Tabela 30.3.

Dentro da tag <vector> está a tag <group>, que é opcional e usada para agrupar
traçados (que será explicado em seguida), mas é necessária quando é preciso
realizar animações de rotação, escala ou movimentação dos vetores. Suas
principais propriedades estão listadas na Tabela 30.4.

Tabela 30.3 – Valores para a tag <vector>
Propriedade Propósito

width / height Representam o tamanho intrínseco da imagem, ou seja, o tamanho que ela terá visualmente.
viewportHeight Tamanho do canvas no qual a imagem vetorial será desenhada.
viewportWidth
tint Cor a ser aplicada na imagem.
autoMirrored Indica se a imagem deve ser espelhada quando utilizada em idiomas RTL (right-to-left).
alpha Opacidade da imagem.

Tabela 30.4 – Valores para a tag <group>
Propriedade Propósito

name Um nome que pode ser dado ao grupo.
rotation Rotação do grupo (de 0 a 360°).
pivotX / pivotY Coordenada x/y do pivô usada para escala e rotação.
scaleX / scaleY Escala a ser aplicada nas coordenadas x/y.
translateX / translateY Translação aplicada nas coordenadas x/y.

Na tag <path> é definido o caminho a ser percorrido para desenhar a imagem,
e a Tabela 30.5 lista suas principais propriedades.



Tabela 30.5 – Valores para a tag <path>
Propriedade Propósito

name Um nome que pode ser dado ao path.
pathData Define as instruções para desenhar o traçado.
fillColor Define a cor para preencher o traçado que será desenhado.
strokeColor Define a cor da linha do traçado que será desenhado.
strokeWidth Largura da linha do traçado.
strokeAlpha Opacidade da linha do traçado.
strokeLineJoin Define o tipo de ligação entre as linhas do traçado. Pode ser miter (linha reta), round (arredondado)

ou bevel (chanfrado).

Sem sombra de dúvidas a propriedade mais confusa é a android:pathData. Ela
segue um padrão estabelecido pela W3C (World Wide Web Consortium) e
cada letra representa uma ação a ser realizada; normalmente é seguida por
dois valores que representam as coordenadas x e y. A Tabela 30.6 lista as
principais ações que podem ser efetuadas para criar uma imagem vetorial. A
lista completa pode ser encontrada no seguinte endereço:
http://www.w3.org/TR/SVG11/paths.html.

Tabela 30.6 – Principais comandos da propriedade pathData definidos
pelo W3C

Comando Parâmetros Descrição
M x y Move a caneta para uma posição x,y.
(absoluto)
m
(relativo)
Z ou z Nenhum Fecha o caminho desenhando uma linha reta até a primeira coordenada do path.
L x y Traça uma linha da posição atual (definida pelo comando M ou m) até uma coordenada x,y.
(absoluto)
l
(relativo)
C x1 y1 x2 Desenha uma curva da coordenada x,y usando a posição x1,y1 para controlar o início da
(absoluto) y2 x y curva e a posição x2,y2 para controlar o final da curva.
c
(relativo)

Nesse momento você pode estar pensando que nunca vai conseguir
desenhar nada utilizando esses comandos. Essa é realmente uma tarefa
complicada para fazer manualmente. Por isso, deve-se utilizar uma
ferramenta visual (como o Sketch, por exemplo) para desenhar imagens
vetoriais e salvá-las como arquivos SVG. Em seguida, pode-se utilizar o
Android Studio para transformar o arquivo SVG em um arquivo no padrão



Vector Drawable. Isso pode ser feito selecionando a opção File > New >
Vector Asset e clicando na opção Local file (SVG, PSD). Ao selecionar o
arquivo *.svg, é exibida uma pré-visualização de como ele ficará ao ser
convertido para um Vector Drawable. É importante ressaltar que nem todos
os comandos de arquivo SVG são compatíveis, mas o Android Studio avisará
quando o arquivo não puder ser convertido.

FloatingActionButton da tela de favoritos
Nesta seção será implementada a lógica do FloatingActionButton da tela de
detalhes. Ele terá dois aspectos visuais: um quando o disco não estiver na
lista de favoritos e outro quando estiver. Cada estado terá um ícone e uma cor
diferente.

Acesse o menu File > New > Vector Asset e preencha os campos
conforme a Figura 30.8 para criar a imagem ic_check.xml. Repita o processo
para a imagem ic_clear.xml. Ambas as imagens devem ficar na pasta
res/drawable.

Figura 30.8 – Criando imagem SVG para o FloatingActionButton.
Criadas as imagens, elas serão utilizadas no código da DetailsActivity:



import kotlinx.coroutines.CoroutineScope
import kotlin.coroutines.CoroutineContext
 
class DetailsActivity : AppCompatActivity(), CoroutineScope {
    private var coverTarget: Target? = null
    private var album: Album? = null
    private val repo: AlbumRepository by lazy {
        AlbumRepository(this)
    }
    private lateinit var job: Job
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_details)
        job = Job()
        val album = intent.getParcelableExtra<Album>(EXTRA_ALBUM)
        if (album != null) {
            this.album = album
            initTitleBar(album.title)
            fillFields(album)
            initEnterAnimation(album)
            loadCover(album)
        } else {
            finish()
        }
    }
    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
    }
    // Os métodos initEnterAnimation, loadCover, setUiColors e initTitleBar não mudaram
    private fun fillFields(album: Album) {
        // Restante do método não mudou...
        updateFab()
        fabFavorite.setOnClickListener {
            toggleFavorite()
        }
    }
    private fun toggleFavorite() {
        album?.let {
            launch {
                withContext(Dispatchers.IO) {
                    val isFavorite = repo.isFavorite(it)



                    if (isFavorite) {
                        repo.delete(it)
                    } else {
                        repo.save(it)
                    }
                }
                updateFab()
            }
        }
    }
    private fun updateFab() {
        album?.let {
            launch {
                val isFavorite = withContext(Dispatchers.IO) { repo.isFavorite(it) }
                fabFavorite.setImageDrawable(getFabIcon(isFavorite))
                fabFavorite.backgroundTintList = getFabBackground(isFavorite)
            }
        }
    }
    private fun getFabIcon(favorite: Boolean): Drawable? {
        return ContextCompat.getDrawable(this,
                if (favorite)
                    R.drawable.ic_clear
                else
                    R.drawable.ic_check
        )
    }
    private fun getFabBackground(favorite: Boolean): ColorStateList? {
        return ContextCompat.getColorStateList(this,
                if (favorite)
                    R.color.bg_fab_clear
                else
                    R.color.bg_fab_favorite
        )
    }
   ...

Definimos o atributo repo do tipo AlbumRepository que é utilizado para inserir e
remover o disco favoritos. Ao preencher as informações do álbum na tela, o
método updateFab() é chamado para exibir o ícone correto do FAB. Logo em
seguida o evento de clique do botão é definido, e simplesmente chama o
método toggleFavorite(), onde é verificado se o álbum já se encontra na lista de
favoritos; em caso positivo, o álbum é removido do banco, caso contrário, é
inserido. O método updateFab() atualizará o ícone e o background do FAB



dependendo se o álbum for um favorito ou não, isso é feito invocando
respectivamente setImageDrawable(Drawable) e backgroundTintList. Para a cor de
background, é preciso definir os arquivos a seguir na pasta res/color.

Primeiro, bg_fab_favorite.xml:
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true"
        android:color="@color/primary_dark"/>
    <item android:color="@color/primary"/>
</selector>

Em seguida, bg_fab_clear.xml:
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true"
        android:color="@color/accent_dark"/>
    <item android:color="@color/accent"/>
</selector>

Esses arquivos estão definindo dois selectors que serão utilizados no FAB.
Execute a aplicação e o botão de favoritos deve funcionar parcialmente. Note
que, ao adicionar o disco aos favoritos e voltar para a tela anterior, ele já
estará aparecendo na listagem de favoritos.

AnimatorVectorDrawable
Uma das recomendações do Material Design é que as mudanças de estado
dos componentes não sejam bruscas, ou seja, deve haver uma transição
suave. Ao adicionar ou remover um item dos favoritos, a imagem do botão é
simplesmente modificada. Nesse cenário é possível utilizar a classe
AnimatorVectorDrawable para animar um VectorDrawable de modo a ter uma transição
mais suave.

Para exemplificar o uso dessa classe, o ícone do FAB de favoritos será
animado. Será feita uma animação onde o ícone de check se transforme no
ícone de cancelar e vice-versa. Porém, uma das restrições para realizar esse
tipo de animação com vetores é que eles tenham a mesma quantidade de
comandos, e ao observar os dois arquivos que foram criados (ic_check.xml e
ic_cancel.xml da pasta res/drawable), eles têm quantidades diferentes de
comandos (que é definido no atributo android:pathData), por isso ele será
implementado manualmente.

Adicione os seguintes textos ao arquivo res/values/strings.xml. Eles



representam os comandos utilizados para desenhar cada um dos ícones:
<string name="vector_check" translatable="false">M3,13 L7,17 7,17 9,19 9,19 9,19 10,18 10,18 21,7

19,5 9,15 5,11 Z</string>
<string name="vector_clear" translatable="false">M4,6 L10,12 4,18 6,20 12,14 18,20 20,18 14,12,

20,6 18,4 12,10 6,4 Z</string>
Perceba que foram adicionados intencionalmente alguns comandos

repetidos no vector_check, pois é preciso que haja a compatibilidade na
quantidade de comandos entre os dois ícones. No ícone de check, o primeiro
comando move (M) a posição “da caneta” para a posição 3,13. Em seguida, a
linha (comando L) começa a ser traçada nas posições especificadas (x,y)
separadas por espaço. Por fim, o comando Z encerra o traçado. A Figura 30.9
mostra as coordenadas dos dois vetores para melhor entendimento.

 

Figura 30.9 – Coordenadas das imagens vetoriais.
Faça as seguintes mudanças no arquivo res/drawable/ic_check.xml

deixando-o como a seguir:
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportHeight="24"
    android:viewportWidth="24">
    <group
        android:name="rotation"
        android:pivotX="12"
        android:pivotY="12"
        android:rotation="0">
        <path
            android:name="v"



            android:fillColor="#FFFFFF"
            android:pathData="@string/vector_check" />
    </group>
</vector>

Nesse arquivo foi definido um grupo que será utilizado para criar uma
animação de rotação. Para que a rotação seja feita tendo como referência o
meio da imagem, foram utilizadas as propriedades android:pivotX e android:pivotY.
Na tag <path> foi utilizada a string com as instruções para desenhar a imagem.

Agora modifique o arquivo res/drawable/ic_clear.xml e deixe-o da seguinte
forma:
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:name="x"
        android:fillColor="#FFFFFF"
        android:pathData="@string/vector_clear" />
</vector>

Nesse arquivo apenas foi alterada a propriedade android:pathData.
A primeira animação fará a mutação do vetor check para o cancel, ao

mesmo tempo que fará a rotação. Para isso, adicione o arquivo
res/drawable/avd_check.xml e deixe-o da seguinte forma:
<animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:drawable="@drawable/ic_check" >
    <target
        android:name="rotation"
        android:animation="@animator/rotation" />
    <target
        android:name="v"
        android:animation="@animator/check_clear" />
</animated-vector>

Observe que no arquivo res/drawable/ic_check.xml, a tag <path> foi
nomeada com o valor “v” e a tag <group> como “rotation”. Para animar esses
itens adicione o arquivo res/animator/check_clear.xml:
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <objectAnimator
        android:duration="300"
        android:propertyName="pathData"



        android:valueFrom="@string/vector_check"
        android:valueTo="@string/vector_clear"
        android:valueType="pathType"/>
</set>

Nesse arquivo foi definido um objectAnimator (abordado no Capítulo 26) que
animará a mudança da propriedade (android:propertyName) “pathData” do vetor
check (@string/vector_check) para o vetor cancel (@string/vector_clear).

Agora crie o arquivo res/animator/rotation.xml que fará a animação de
rotação:
<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="300"
    android:propertyName="rotation"
    android:valueFrom="0"
    android:valueTo="180" />

Para implementar a animação inversa que transforma o ícone de cancel para
o de check. Adicione o arquivo res/drawable/avd_clear.xml:
<animated-vector
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/ic_clear" >
    <target
        android:name="x"
        android:animation="@animator/clear_check" />
</animated-vector>

Aqui está sendo animado o path “x” (definido no arquivo
res/values/drawable/ic_clear.xml) utilizando o arquivo
res/animator/clear_check.xml apresentado a seguir:
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <objectAnimator
        android:duration="200"
        android:propertyName="pathData"
        android:valueFrom="@string/vector_clear"
        android:valueTo="@string/vector_check"
        android:valueType="pathType"/>
</set>

Definidos os arquivos de animação, faça os seguintes ajustes na DetailActivity:
class DetailsActivity : AppCompatActivity(), CoroutineScope {
    // Os demais atributos e métodos permanecem iguais
    private fun updateFab() {
        album?.let {
            launch {



                val isFavorite = withContext(Dispatchers.IO) { repo.isFavorite(it) }
                val icon = getFabIcon(isFavorite)
                fabFavorite.setImageDrawable(icon)
                fabFavorite.backgroundTintList = getFabBackground(isFavorite)
                if (icon is AnimatedVectorDrawable) {
                    icon.start()
                }
            }
        }
    }
    private fun getFabIcon(favorite: Boolean): Drawable? {
        return ContextCompat.getDrawable(this,
                if (favorite)
                    R.drawable.avd_check
                else
                    R.drawable.avd_clear
        )
    }
}

Execute a aplicação e teste a animação adicionando e removendo discos da
lista de favoritos.

Animated Vector Drawable com Shape Shifter
Uma ferramenta muito útil na criação de Animated Vector Drawables é o
Shape Shifter (https://shapeshifter.design). Com ela é possível testar as
animações, inclusive em slow motion, antes de utilizar nos projetos. A
ferramenta permite exportar a animação como um arquivo XML que pode ser
utilizado diretamente no Android Studio. A Figura 30.10 mostra o Shape
Shifter em execução.



Figura 30.10 – Ferramenta Shape Shifter em execução.
A título de curiosidade, é listado a seguir o arquivo

res/drawable/avd_check.xml gerado pelo Shape Shifter:
<animated-vector
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt">
    <aapt:attr name="android:drawable">
        <vector
            android:name="vector"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24">
            <group
                android:name="rotation"
                android:pivotX="12"
                android:pivotY="12">
                <path
                    android:name="v"
                    android:pathData="M 3 13 L 7 17 L 7 17 L 9 19 L 9 19 L 9 19 L 10 18 L 10 18 L 21 7 L

19 5 L 9 15 L 5 11 Z"
                    android:fillColor="#ffffff"/>
            </group>



        </vector>
    </aapt:attr>
    <target android:name="rotation">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:propertyName="rotation"
                android:duration="300"
                android:valueFrom="0"
                android:valueTo="180"
                android:valueType="floatType"
                android:interpolator="@android:interpolator/fast_out_slow_in"/>
        </aapt:attr>
    </target>
    <target android:name="v">
        <aapt:attr name="android:animation">
            <objectAnimator
                android:propertyName="pathData"
                android:duration="300"
                android:valueFrom="M 3 13 L 7 17 L 7 17 L 9 19 L 9 19 L 9 19 L 10 18 L 10 18 L 21 7 L 19

5 L 9 15 L 5 11 Z"
                android:valueTo="M 4 6 L 10 12 L 4 18 L 6 20 L 12 14 L 18 20 L 20 18 L 14 12 L 20 6 L 18

4 L 12 10 L 6 4 Z"
                android:valueType="pathType"
                android:interpolator="@android:interpolator/fast_out_slow_in"/>
        </aapt:attr>
    </target>
</animated-vector>

A ferramenta simplesmente coloca em um único arquivo o que foi feito
aqui em arquivos distintos. O <vector> seria o arquivo
res/drawable/ic_check.xml, o primeiro <objectAnimator> seria o
res/animator/rotation.xml e o segundo <objectAnimator> seria o
res/drawable/check_clear.xml.

Com isso concluímos mais um exemplo de projeto simples, mas que
englobou vários conceitos do Material Design e algumas bibliotecas úteis no
dia a dia do desenvolvedor Android.



CAPÍTULO 31
Ferramentas de teste

Por: Nelson Glauber & Ubiratan Soares
Os testes do aplicativo devem ocorrer em paralelo durante todo o ciclo de
desenvolvimento. Isso permite identificar falhas o mais breve possível e, com
isso, conseguir um software mais estável e confiável. Para efetuar esses testes
existem diversas técnicas, como seguir um projeto de testes com os cenários a
serem testados, ou, ainda, realizando testes exploratórios em que o testador
investiga cada funcionalidade da aplicação.

Neste capítulo será explorada a automatização de testes unitários e de
interface gráfica por meio da Android Testing Support Library (ATSL) e
demais ferramentas disponíveis no SDK do Android.

Introdução
O ATSL provê um framework com um conjunto de APIs para criar e
executar testes automatizados nos aplicativos sob diferentes níveis. É
possível criar testes unitários baseados em JUnit para validar classes que não
dependam da API do Android ou utilizar as funcionalidades de
instrumentação disponíveis no SDK para testar componentes do Android,
como activities, services e content providers.

A instrumentação é uma parte do framework de testes que disponibiliza
uma API que ajuda a controlar o ciclo de vida desses componentes e
possibilita criar mock objects, que permitem simular objetos reais do sistema
de forma controlada.

As suítes de teste estão organizadas em uma estrutura de pacote similar à do
código principal da aplicação. Dessa forma, ao compilar o projeto, as
informações da aplicação que será testada serão obtidas e utilizadas para criar
o pacote de testes a ser executado no aparelho.

O SDK também provê uma ferramenta de linha de comando chamada



monkey, que ajuda a executar testes de estresse na aplicação.

Estrutura do projeto de testes
Os testes automatizados no Android podem ser divididos basicamente em
dois tipos:

• Unit tests (testes unitários) – Rodam na JVM (Java Virtual Machine)
local da máquina do desenvolvedor e geralmente focam componentes
independentes do framework do Android. Estes testes são salvos no
diretório app/src/test/java.

• Instrumentation tests (testes instrumentados) – Têm grande dependência
de componentes específicos do Android, portanto precisam ser executados
em um dispositivo real ou em um emulador. Estes testes são armazenados
no diretório app/src/androidTest/java.

O Android Studio permite a criação e execução de ambos os tipos de teste,
como será visto nas seções seguintes.

Testes unitários com JUnit
Ao iniciar um novo projeto no Android Studio, automaticamente é criada a
pasta src/test. As classes definidas nessa pasta servem para testar partes do
seu código que não dependam da API do Android ou do aparelho, pois elas
são executadas na JVM local do computador e não em um dispositivo
Android.

Abra o projeto de hotéis do Capítulo 18 para escrever alguns testes unitários
para ele. Porém, antes, adicione as seguintes dependências no build.gradle do
módulo app:
dependencies {
    ...
    testImplementation "junit:junit:$junit_version"
    testImplementation "com.squareup.okhttp3:mockwebserver:$okhttp_version"
    testImplementation "com.nhaarman.mockitokotlin2:mockito-kotlin:$mockito_kotlin_version"
    testImplementation "org.assertj:assertj-core:$assertj_version"
    testImplementation "androidx.arch.core:core-testing:$android_arch_test"
}

Em seguida, adicione as respectivas versões no arquivo build.gradle do
projeto:
buildscript {



    ext { ...
        android_arch_test = '2.0.0'
        assertj_version = '3.11.1'
        junit_version = '4.2'
        mockito_kotlin_version = '2.0.0'
        

Perceba que a dependência foi adicionada com a instrução testImplementation,
que indica que essa biblioteca só será utilizada pelo framework de testes.
Além do JUnit que contém os recursos básicos de teste, foram adicionadas as
seguintes dependências:

• MockWebServer
(https://github.com/square/okhttp/tree/master/mockwebserver) é uma
biblioteca que permite simular requisições e respostas a chamadas HTTP.
Neste exemplo, ele será usado para servir de dublê da API de hotéis;

• AssertJ (http://joel-costigliola.github.io/assertj/) permite efetuar asserções
de forma mais simples e clara;

• Mockito (https://site.mockito.org) para criar mocks de interfaces e
configurar comportamentos;

• Android Architecture Components Core Testing para ter acesso à classe
InstantExecutorTaskRule que troca a thread de background utilizada pelo
Architecture Componentes para executar de forma síncrona. Nesse
exemplo, será utilizado para testar objetos LiveData.

O primeiro teste automatizado do aplicativo de hotéis será com uma classe
bem simples: a HotelValidator. Adicione a classe HotelValidatorTests ao diretório
src/test:
import dominando.android.hotel.form.HotelValidator
import dominando.android.hotel.model.Hotel
import org.assertj.core.api.Java6Assertions.assertThat
import org.junit.Assert.assertTrue
import org.junit.Test
 
class HotelValidatorTests {
    private val validator by lazy {
        HotelValidator()
    }
    private val validInfo = Hotel(
            name = "Ritz Lagoa da Anta",
            address = "Av. Brigadeiro Eduardo Gomes de Brito, 546, Maceió/AL",
            rating = 4.9f



    )
    @Test fun should_validate_info_for_a_valid_hotel() {
        // Junit4 Style
        assertTrue(validator.validate(validInfo))
        // AssertJ Style
        assertThat(validator.validate(validInfo)).isTrue()
    }
    @Test fun should_not_validate_info_without_a_hotel_name() {
        val missingName = validInfo.copy(name = "")
        assertThat(validator.validate(missingName)).isFalse()
    }
    @Test fun should_not_validate_info_without_a_hotel_address() {
        val missingAddress = validInfo.copy(address = "")
        assertThat(validator.validate(missingAddress)).isFalse()
    }
    @Test fun should_not_validate_info_when_name_is_outside_accepted_size() {
        val nameTooShort = validInfo.copy(name = "I")
        assertThat(validator.validate(nameTooShort)).isFalse()
    }
    @Test fun should_not_validate_info_when_address_is_outside_accepted_size() {
        val bigAddress =
                "Av. Brigadeiro Eduardo Gomes de Brito, 546 - " +
                        "Lagoa da Anta, Maceió - AL, 57038-230"
        val addressTooLong = validInfo.copy(address = bigAddress)
        assertThat(validator.validate(addressTooLong)).isFalse()
    }
}

Primeiramente foi definido o validator, que será o objeto que será testado. Em
seguida, foi criado o atributo validInfo, que é considerado um hotel válido.
Todos os testes devem estar anotados com o @Test. O primeiro primeiro teste
valida se validInfo é realmente um hotel válido. Nesse método foi utilizado
tanto o estilo JUnit de asserção quando o do AssertJ. O método
assertTrue(boolean) espera que a expressão passada como parâmetro seja igual a
true. O mesmo comportamento é obtido utilizando a chamada
assertThat(boolean).isTrue() do AssertJ.

Perceba que foram utilizados nomes de métodos grandes para deixar bem
claro o propósito do teste. Os demais testes basicamente fazem uma cópia do
objeto validInfo e checam, respectivamente, se o nome vazio retorna falso, se o
endereço vazio retorna falso, se um nome muito curto retorna falso, e se um
endereço muito longo retorna falso. Esses foram apenas alguns exemplos de
testes que poderiam ser realizados numa simples classe de validação, mas



outros ainda poderiam ser adicionados.
Para executar o teste, existem algumas opções. A mais simples é clicando

sobre a seta verde na própria classe como mostra a Figura 31.1.

Figura 31.1 – Executando testes JUnit no Android Studio.
O resultado será exibido conforme a Figura 31.2.

Figura 31.2 – Resultado dos testes JUnit no Android Studio.
Os testes também podem ser executados via terminal utilizando o seguinte

comando na raiz do projeto:
./gradlew test

Ao executar esse comando um relatório de execução é gerado em
app/build/reports/tests/testDebugUnitTest/index.html similar ao mostrado na
Figura 31.3.



Figura 31.3 – Relatório dos testes instrumentados.
O próximo teste unitário será criado para a classe HotelHttp, por isso adicione

a classe HotelHttpTests:
import com.nhaarman.mockitokotlin2.mock
import com.nhaarman.mockitokotlin2.verify
import com.nhaarman.mockitokotlin2.whenever
import dominando.android.hotel.auth.Auth
import dominando.android.hotel.model.Hotel
import dominando.android.hotel.repository.HotelRepository
import dominando.android.hotel.repository.http.HotelHttp
import dominando.android.hotel.repository.http.HotelHttpApi
import dominando.android.hotel.repository.http.Status
import dominando.android.hotel.repository.imagefiles.FindHotelPicture
import okhttp3.OkHttpClient
import okhttp3.mockwebserver.MockResponse
import okhttp3.mockwebserver.MockWebServer
import org.assertj.core.api.Java6Assertions.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Test
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.util.*
 
class HotelHttpTests {
 
    private val photoGallery = mock<FindHotelPicture>()



    private val hotelRepository = mock<HotelRepository>()
    private val auth = mock<Auth>()
    private lateinit var hotelHttp: HotelHttp
    private lateinit var mockWebServer: MockWebServer
 
    @Before fun before_each_test() {
        mockWebServer = MockWebServer()
        val remote = Retrofit.Builder()
                .baseUrl(mockWebServer.url("/").toString())
                .client(OkHttpClient())
                .addConverterFactory(GsonConverterFactory.create())
                .build()
                .create(HotelHttpApi::class.java)
        hotelHttp = HotelHttp(remote, hotelRepository, photoGallery, auth)
    }
    @After fun after_each_test() {
        mockWebServer.shutdown()
    }
    @Test fun should_synchronize_local_hotel_with_remote_server() {
        // Given
        val hotel = Hotel(
                name = "Ritz Recife",
                rating = 5.0f
        )
        authmanager_must_return_a_valid_user()
        local_hotel_storage_have_one_item(hotel)
        server_should_receive_data_from_hotel()
        // When
        hotelHttp.synchronizeWithServer()
        // Then
        local_storage_should_have_hotel_status_as_updated(hotel)
    }
    private fun local_storage_should_have_hotel_status_as_updated(hotel: Hotel) {
        assertThat(hotel.status).isEqualTo(Status.OK)
        assertThat(hotel.serverId).isEqualTo(HOTEL_SERVER_ID)
        verify(hotelRepository).update(hotel)
    }
    private fun server_should_receive_data_from_hotel() {
        mockWebServer.enqueue(
                MockResponse().apply {
                    setResponseCode(200)
                    setBody("{\"id\":$HOTEL_SERVER_ID}")
                }
        )
        mockWebServer.enqueue(



                MockResponse().apply {
                    setResponseCode(200)
                    setBody(
                            """
                            [
                                {
                                    "id":$HOTEL_SERVER_ID,
                                    "name":"Ritz Recife"
                                }
                            ]
                            """
                    )
                }
        )
    }
    private fun local_hotel_storage_have_one_item(hotel: Hotel) {
        whenever(hotelRepository.pending())
                .thenReturn(listOf(hotel))
    }
    private fun authmanager_must_return_a_valid_user() {
        whenever(auth.getUserId())
                .thenReturn("nglauber")
    }
 
    companion object {
        val HOTEL_SERVER_ID = Random().nextLong()
    }
}

Essa classe contém apenas um teste, mas possui diversos conceitos
interessantes e muito úteis para escrita de testes. O primeiro atributo,
photoGallery, é necessário para criar uma instância do HotelHttp, mas lembre-se de
que FindHotelPicture é uma interface, a implementação real dessa interface é a
ImageGalleryPicture. Entretanto, nesse teste, em vez da implementação real, foi
utilizado um “dublê” ou um mock como é mais comumente chamado. O
Mockito é o responsável por criar uma implementação dessa interface, que,
por padrão, não faz nada.

O outro mock dessa classe é o hotelRepository, que é uma implementação da
interface HotelRepository. Ele é um ótimo exemplo de como funcionam os
mocks. No método local_hotel_storage_have_one_item(Hotel) é definido o
comportamento do dublê do repositório informando que sempre (whenever(T))
que a chamada hotelRepository.pending() for realizada, então será retornada



(thenResult(T)) uma lista específica de hotéis. Desta forma, quando a classe
HotelHttp requisitar os itens pendentes a serem enviados para o servidor (que
acontece no método sendPendingData()), essa lista fixa será retornada.

Esta é a grande motivação do uso dos mocks, simular a implementação de
uma interface provendo retornos ou comportamentos específicos para realizar
os testes.

Um outro mock que é necessário para esse teste é o da interface Auth. A
HotelHttp utiliza esse objeto para obter o usuário corrente da aplicação e só
realizará a sincronização se esse usuário não for vazio. Por essa razão foi
criado o atributo auth, sendo o seu comportamento definido no método
authmanager_must_return_a_valid_user(). Sempre que o método getUserId() for chamado,
o usuário “nglauber” será retornado.

O atributo hotelHttp é o objeto a ser testado e logo abaixo dele está o
mockWebServer, que é um mock do servidor. Isso mesmo! Essa classe pode
simular as requisições feitas ao servidor bem como as respostas recebidas.
Esses dois atributos são inicializados no método before_each_test() que está
anotado com @Before para indicar que ele será chamado antes de cada teste ser
executado (aqui só foi declarado um teste). Perceba que neste método o
MockWebServer foi instanciado e passado como parâmetro para a instância da
HotelHttpApi criada por meio da classe Retrofit.Builder. Por fim, o objeto hotelHttp é
instanciado passando os parâmetros necessários, sendo que todos são mocks
para testarem vários cenários.

O método after_each_test() está anotado com @After para indicar que ele será
executado após cada teste. E nele o mockWebServer é encerrado.

O teste em si é executado no método
should_synchronize_local_hotel_with_remote_server() e foi utilizado um padrão bem
interessante: Given (Dado), When (Quando), Then (Então). Esse padrão
sempre parte de um dado estado que a aplicação se encontra, quando algum
evento acontece, então algo muda e é verificado se o resultado foi o esperado.

Nosso teste pode ser lido como: dado que existe um hotel, um usuário
autenticado e que existe um hotel no repositório local; quando for feita a
sincronização com o servidor, então o status do hotel deve ter sido alterado e o
método update(Hotel) do repositório deve ter sido chamado.

O método server_should_receive_data_from_hotel() está simulando as requisições
feitas ao servidor. Durante a sincronização, primeiramente são enviados os



dados locais, por isso é esperado o retorno do id do hotel que foi inserido no
servidor. Em seguida, o servidor retorna os dados armazenados. O método
enqueue(MockResponse) do MockServer é que enfileira essas requisições e a classe
MockResponse simula a resposta do servidor.

Após a sincronização, no método
local_storage_should_have_hotel_status_as_updated(Hotel) é verificado se o status do hotel
e o seu respectivo id no servidor foram atualizados localmente. Por fim, é
verificado se o método update(Hotel) do repositório foi chamado, pois isso
acontece no processo de sincronização.

Esse teste só foi possível graças à arquitetura que foi criada ao longo do
livro. Criar interfaces facilita bastante a escrita de testes, pois é possível criar
os mocks para testar os mais diversos cenários. Aqui poderiam ser
adicionados testes para quando o servidor não estiver disponível ou quando
enviar uma resposta errada, e, assim, ir ajustando o código para que esses
testes passem, deixando o código mais robusto e menos propenso a erros.

O último teste unitário criado aqui será para o cadastro de hotéis, mais
especificamente para o HotelFormViewModel. Crie a classe HotelFormViewModelTests
e deixe-a como a seguir:
import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.lifecycle.MutableLiveData
import com.nhaarman.mockitokotlin2.*
import dominando.android.hotel.form.HotelFormViewModel
import dominando.android.hotel.model.Hotel
import dominando.android.hotel.repository.HotelRepository
import org.assertj.core.api.Java6Assertions.assertThat
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import java.util.*
 
class HotelFormViewModelTests {
    @get:Rule
    val taskExecutorRule = InstantTaskExecutorRule()
    private lateinit var viewModel: HotelFormViewModel
    private val mockedRepo = mock<HotelRepository>()
    private val anHotelID = Random().nextLong()
    private val anHotel = Hotel(
            id = anHotelID,
            name = "Ritz Recife",
            address = "Praia de Boa Viagem, SN",



            rating = 5.0f
    )
 
    @Before fun before_each_test() {
        viewModel = HotelFormViewModel(mockedRepo)
    }
    @Test fun given_an_existing_ID_should_load_the_hotel() {
        // Given
        val liveData = MutableLiveData<Hotel>().apply {
            value = anHotel
        }
        // When
        whenever(mockedRepo.hotelById(any()))
                .thenReturn(liveData)
        // Then
        viewModel.loadHotel(anHotelID).observeForever {
            assertThat(it).isEqualTo(anHotel)
        }
    }
    @Test fun given_valid_hotel_info_should_save_a_hotel() {
        // Given
        val info = Hotel(
                name = "Ritz Recife",
                address = "Praia de Boa Viagem, Recipe/PE",
                rating = 4.8f
        )
        // When
        val saved = viewModel.saveHotel(info)
        whenever(mockedRepo.save(any())).thenAnswer { Unit }
        // Then
        assertThat(saved).isTrue()
        verify(mockedRepo, times(1)).save(any())
        verifyNoMoreInteractions(mockedRepo)
    }
    @Test fun given_invalid_hotel_info_should_fail_at_save_the_hotel() {
        // Given
        val invalidInfo = Hotel(
                name = "Y",
                address = "WWW",
                rating = 4.8f
        )
        // When
        val saved = viewModel.saveHotel(invalidInfo)
        // Then
        assertThat(saved).isFalse()



        verifyZeroInteractions(mockedRepo)
    }
}

O atributo viewModel armazena a instância de HotelFormViewModel que será
testada. Em seguida, foi declarado um mock para o HotelRepository e um objeto
Hotel que será utilizado nos testes. Note que todos os testes utilizam o padrão
Given/When/Then.

O primeiro teste valida se quando for feita a busca do hotel pelo id, então
deve ser retornado o mesmo do hotel do objeto LiveData. Perceba que foi
utilizado o método observeForever para aguardar o retorno do repositório.

O próximo teste verifica se dado um hotel válido, quando o método saveHotel
(Hotel) for chamado então o hotel será salvo. Perceba que foi utilizado o
método verify (Mock,VerificationMode) para garantir que o método foi chamado
apenas uma vez, e que não houve mais nenhuma interação com o repositório
utilizando o método verifyNoMoreInteractions(Mock).

O último teste checa se dado um hotel inválido, quando o método
saveHotel(Hotel) for chamado então ele deve retornar falso.

Nesta seção foram demonstrados os testes unitários de classes simples, que
acessam servidor e que são utilizados pela interface gráfica. Entretanto, existe
a oportunidade de criar muitos outros testes para todas as classes desse
projeto que não foram listados aqui para não estendermos demais este
conteúdo.

Testes instrumentados com AndroidJUnitRunner
Os testes unitários puros utilizando JUnit podem ser úteis para verificar
classes auxiliares da aplicação, mas na grande maioria dos casos o código
terá alguma dependência da API do Android. Para desenvolver testes
automatizados para essas situações, deve-se recorrer aos testes
instrumentados.

Ao iniciar um novo projeto no Android Studio, ele já se encarrega de criar
automaticamente o diretório src/androidTest, no qual serão armazenados
testes desse tipo. Para executá-los, é preciso da classe AndroidJUnitRunner, pois é
ela que trata do carregamento do pacote de testes junto à aplicação que será
testada, executa os testes e reporta os resultados.

Para demonstrar o desenvolvimento desse tipo de teste, vamos utilizar mais



uma vez o projeto de hotéis. Será criada uma classe para testar a RoomRepository
que verificará a inclusão, alteração, listagem e exclusão no banco de dados.
Porém, antes verifique se as seguintes configurações estão presentes no
arquivo build.gradle:
android { ...
    defaultConfig {
        ...
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
dependencies {
    ...
    androidTestImplementation "androidx.test.ext:junit:$testrunner_version"
    androidTestImplementation "androidx.arch.core:core-testing:$android_arch_test"
}

Na seção dafaultConfig é informado que será utilizada a classe AndroidJUnitRunner
para executar os testes por meio da propriedade testInstrumentationRunner. Na
seção dependencies foram declaradas as dependências utilizando a instrução
androidTestImplementation, pois ela será utilizada exclusivamente no pacote de
testes.

Verifique se a constante testrunner_version = '1.0.0' está declarada no arquivo
build.gradle do projeto.

Antes de implementar o teste, adicione o objeto LiveDataTestUtil como a
seguir:
import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
 
object LiveDataTestUtil {
    @Throws(InterruptedException::class)
    fun <T> getValue(liveData: LiveData<T>): T {
        val data = arrayOfNulls<Any>(1)
        val latch = CountDownLatch(1)
        val observer = object : Observer<T> {
            override fun onChanged(o: T?) {
                data[0] = o
                latch.countDown()
                liveData.removeObserver(this)
            }
        }
        liveData.observeForever(observer)



        latch.await(2, TimeUnit.SECONDS)
        return data[0] as T
    }
}

Esse objeto possui apenas um método que aguarda pelo retorno do LiveData
por dois segundos. Caso nenhuma informação seja retornada nesse intervalo,
é retornado null.

Crie a classe RoomRepositoryTests no diretório androidTests e deixe-a como a
seguir:
import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.room.Room
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.platform.app.InstrumentationRegistry
import dominando.android.hotel.model.Hotel
import dominando.android.hotel.repository.http.Status
import dominando.android.hotel.repository.room.HotelDatabase
import dominando.android.hotel.repository.room.RoomRepository
import org.junit.Assert.*
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import java.util.*
 
@RunWith(AndroidJUnit4::class)
class RoomRepositoryTests {
 
    @Rule
    @JvmField
    var instantTaskExecutorRule = InstantTaskExecutorRule()
    private lateinit var repo: RoomRepository
    private lateinit var dummyHotel: Hotel
 
    @Before fun before_each_test() {
        val db = Room.inMemoryDatabaseBuilder(
                InstrumentationRegistry.getInstrumentation().context,
                HotelDatabase::class.java).build()
        repo = RoomRepository(db)
        dummyHotel = Hotel(
                id = 0,
                name = "Hotel Recife",
                address = "Av. Boa Viagem",
                rating = 4.5F



        )
    }
    @Test fun insert_hotel_must_change_id_and_status() {
        repo.save(dummyHotel)
        assertNotEquals(dummyHotel.id, 0)
        assertEquals(dummyHotel.status, Status.INSERT)
    }
    @Test fun insert_the_same_hotel_must_update_the_record() {
        repo.save(dummyHotel)
        val id = dummyHotel.id
        assertNotEquals(id, 0)
        val hotel1 = LiveDataTestUtil.getValue(repo.hotelById(id))
        repo.save(dummyHotel)
        val hotel2 = LiveDataTestUtil.getValue(repo.hotelById(id))
        assertEquals(hotel2.status, Status.UPDATE)
        assertEquals(hotel1.id, hotel2.id)
        assertEquals(hotel1.name, hotel2.name)
        assertEquals(hotel1.address, hotel2.address)
        assertEquals(hotel1.rating, hotel2.rating)
    }
    @Test fun update_all_hotel_fields() {
        repo.save(dummyHotel)
        val hotelId = dummyHotel.id
        val updatedHotel = newHotel()
        updatedHotel.id = hotelId
        repo.save(updatedHotel)
        val loadedHotel = LiveDataTestUtil.getValue(repo.hotelById(hotelId))
        assertEquals(updatedHotel, loadedHotel)
    }
    @Test fun load_all_inserted_hotels() {
        val allHotels = listOf(
                newHotel(),
                newHotel(),
                newHotel()
        )
        allHotels.forEach {
            repo.save(it)
        }
        val returnedList = LiveDataTestUtil.getValue(repo.search("%"))
        assertEquals(allHotels.size, returnedList.size)
        assert(returnedList.containsAll(allHotels))
    }
    @Test fun remove_hotel() {
        repo.save(dummyHotel)
        repo.remove(dummyHotel)



        val returnedHotel = LiveDataTestUtil.getValue(repo.hotelById(dummyHotel.id))
        assertNull(returnedHotel)
    }
    private fun newHotel() = Hotel(
            name = UUID.randomUUID().toString(),
            address = UUID.randomUUID().toString(),
            rating = (Math.random() * 5.0).toFloat()
    )
}

Essa classe inicia com a anotação @RunWith para indicar que ela será
executada pela AndroidJUnit4. Em seguida, foi declarado o atributo repo, que
representa o RoomRepository que será testado, e o objeto dummyHotel que será
utilizado em alguns testes.

Antes de executar cada teste, uma instância do HotelDatabase em memória é
criada utilizando a Room.inMemoryDatabaseBuilder(Context,RoomDatabase) em que o
contexto que está sendo utilizado é o de testes instrumentados, por isso foi
utilizada a classe InstrumentationRegistry. Com a instância de HotelDatabase, o objeto
RoomRepository é criado.

O teste insert_hotel_must_change_id_and_status() verifica apenas se o hotel foi
inserido com sucesso checando se o id é diferente de zero e se o status é igual
a INSERT.

Em insert_the_same_hotel_must_update_the_record() o objeto dummyHotel é salvo no
banco de dados e, em seguida, é verificado se ele foi inserido com sucesso.
Logo após, um hotel1 é obtido do banco de dados utilizando o id do registro
recém-inserido. Depois, o dummyHotel (que deve estar com um id associado) é
inserido novamente, o que deve fazer com que ele seja atualizado. O hotel2 é
carregado baseado no id, e, por fim, é checado se os objetos hotel1 e hotel2
possuem as propriedades iguais, exceto pelo status.

No teste update_all_hotel_fields() é verificado se ao fazer uma atualização no
hotel todos os atributos são modificados corretamente. Em
load_all_inserted_hotels() são inseridos três objetos hotel, e, em seguida, são
carregados todos os hotéis do banco de dados utilizando o método search(String).
Então é checado se a lista possui o mesmo tamanho e se todos os objetos
inseridos estão na lista retornada do banco. O último teste remove_hotel() checa
se um hotel foi removido do banco.

Para executar o teste, basta clicar na seta verde ao lado do nome da classe,
ou executar o seguinte comando no terminal:



./gradlew connectedAndroidTest
Ao executar esse comando um relatório de execução é gerado em

app/build/reports/androidTests/connected/index.html como mostra a Figura
31.4.

Figura 31.4 – Relatório dos testes instrumentados.

Validando os eventos de uma activity
Até agora foi demonstrado apenas como testar classes simples, mas é
possível testar uma activity utilizando testes instrumentados, inclusive
validando comportamentos internos e suas respostas aos eventos do ciclo
gerados pelo sistema. Na próxima seção será demonstrado como testar a
interação com a interface gráfica, mas por ora o foco será a validação dos
comportamentos internos de uma activity.

Para exemplificar esse conceito, crie um teste para a aplicação Orientacao que
criamos no Capítulo 3. Abra esse projeto e adicione as seguintes
dependências ao build.gradle:
android {
    defaultConfig { ...
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"



    }
}
dependencies {
    ...
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.0'
    androidTestImplementation 'androidx.test:rules:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.1'
    androidTestImplementation 'org.hamcrest:hamcrest-integration:1.3'
}

Adicione a classe MainActivityTest ao diretório app/src/androidTest e deixe-a
como a seguir:
import android.content.Context
import android.widget.ListView
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.rule.ActivityTestRule
import kotlinx.android.synthetic.main.activity_main.*
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.MatcherAssert.assertThat
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
 
@RunWith(AndroidJUnit4::class)
class MainActivityTest {
    @get:Rule
    val activityRule = ActivityTestRule(MainActivity::class.java)
    lateinit var mainActivity: MainActivity
    lateinit var context: Context
 
    @Before fun setUp() {
        context = InstrumentationRegistry.getInstrumentation().targetContext
        mainActivity = activityRule.activity
    }
    @Test fun add_text_test() {
        mainActivity.runOnUiThread {
            mainActivity.edtName.setText("Texto 1")
            mainActivity.btnAddClick(mainActivity.btnAdd)
        }
        InstrumentationRegistry.getInstrumentation().waitForIdleSync()
        val listView = mainActivity.findViewById<ListView>(R.id.lstNames)
        assertThat(listView.count, `is`(1))



    }
}

O primeiro ponto a ser observado é a utilização de uma ActivityTestRule, que
se encarregará de criar uma instância da Activity para execução dos testes. No
método setup() a instância da activity é obtida e o teste é realizado no método
add_text_test(). Nele é definido o texto do EditText e, em seguida, simulado o
clique no botão que adicionará o texto “Texto 1” à lista. Perceba que isso é
feito na thread de UI por meio do método runOnUiThread(Runnable), e para
aguardar essa operação ser concluída é invocado o método waitForIdleSync().
Para finalizar, é verificado se a ListView na qual o texto foi adicionado contém
1 elemento.

KOTLINxJAVA: Como is é uma palavra reservada no Kotlin, para utilizar o
método is() foi necessário colocá-lo entre apóstrofos `is`.

A forma de executar o teste é idêntica aos demais exemplos. Basta clicar no
botão “play” próximo ao nome da classe.

Espresso
Nas últimas duas seções foi visto como criar testes para classes que envolvem
objetos de modelo, comunicação, persistência de dados e até mesmo
interfaces gráficas da aplicação. Percebe-se que neste último caso, ao criar
testes para componentes que lidam com interfaces gráficas, existe uma
complexidade maior por ter de lidar com comportamentos e eventos em
Threads diferentes, sincronização entre o código de teste e o que está sendo
excecutado na Thread de UI, além da própria localização dos componentes
gráficos e geração de eventos.

O Espresso é parte integrante do ATSL e permite testar a interface gráfica
de maneira mais rápida e produtiva. Ele simula eventos disparados pelo
usuário sem precisar se preocupar diretamente com a manipulação das Threads.
Sua API possibilita criar fluxos de ações dentro da sua aplicação em
dispositivos com Android 2.2 (API Level 8) ou superior. Com isso, é possível
escrever testes caixa-branca (aqueles em que temos acesso ao código-fonte)
para UI da aplicação.

Para criar testes com o Espresso, é preciso seguir basicamente três passos:
encontrar a view, executar uma ação e verificar o estado da view.



A classe ViewMatchers é a responsável por definir critérios a serem utilizados
para encontrar uma view dentro da activity em execução. Os principais
métodos dessa classe estão listados na Tabela 30.1.

Tabela 30.1 – Métodos da classe ViewMatchers
Método Propósito

withId(int) Procura a view pelo id.
withText(String) Procura uma view que contenha determinado texto.
withTagValue(Object) Procura uma view que tenha determinada tag.
withHint(String) Procura uma view com determinado hint (usado normalmente em itens de menu).
hasDescendant(Matcher) Procura uma view que tenha determinada view-filha.
withContentDescriptor(String) Procura uma view com determinada String usada para acessibilidade de deficientes

visuais.

Essa tabela é realmente bem resumida; para a listagem completa, consulte a
documentação do Espresso.

É importante destacar que, se a view não for encontrada, o teste falhará,
mas se a view com a qual se deseja interagir for encontrada, é possível
efetuar uma ação sobre ela. A classe responsável por essas ações é a
ViewActions, e alguns dos seus métodos estão na Tabela 30.2.

Tabela 30.2 – Métodos da classe ViewActions
Método Propósito

click() Dispara o evento de clique na view.
doubleClick() Dispara o evento de clique duplo na view.
longClick() Dispara o evento de clique longo.
pressBack() Simula o pressionamento da tecla física de voltar.
pressImeActionButton() Pressiona a ação do teclado virtual (enter, next, go etc.).
closeSoftKeyboard() Fecha o teclado virtual.
scrollTo() Faz scroll na tela.
swipeLeft() Realiza o gesto de swipe para esquerda, direita, cima ou baixo.
swipeRight()
swipeUp()
swipeDown()
typeText(String) Digita determinado texto.
clearText() Limpa o texto da view.

Encontrada a view e realizada a ação, é possível checar seu estado e
verificar se o teste passou. Para isso, devem-se utilizar os métodos da classe
ViewAssertions, mais comumente o método matches(Matcher).



Configurando o Espresso
Vamos escrever alguns testes para o aplicativo de hotéis. Verifique as
seguintes configurações no build.gradle:
android { ...
    defaultConfig { ...
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    ...
}
dependencies {
    ...
    androidTestImplementation "androidx.test.ext:junit:$testrunner_version"
    androidTestImplementation "androidx.arch.core:core-testing:$android_arch_test"
    androidTestImplementation "androidx.test:rules:$testrules_version"
    androidTestImplementation "androidx.test.espresso:espresso-core:$espresso_version"
    androidTestImplementation "org.hamcrest:hamcrest-integration:$hamcrest_version"
}

Estamos adicionando as dependências do JUnitTestRunner, Espresso,
Hamcrest e Rules do JUnit 4. Lembre-se de adicionar as versões do Android
Test Rules e do Hamcrest no build.gradle do projeto:
buildscript {
    ext { ...
        testrules_version = '1.1.1'
        hamcrest_version = '1.3'

Criando um teste simples
Será criada uma classe de teste para o aplicativo que verificará se a
funcionalidade de inserir um novo registro está funcionando corretamente.
Adicione a classe HotelCrudTest à pasta src/androidTest e deixe-a como a
seguir:
import androidx.room.Room
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.*
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.rule.ActivityTestRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import dominando.android.hotel.common.HotelActivity
import dominando.android.hotel.repository.HotelRepository
import dominando.android.hotel.repository.room.HotelDatabase



import dominando.android.hotel.repository.room.RoomRepository
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.koin.dsl.module.module
import org.koin.standalone.StandAloneContext.loadKoinModules
 
@RunWith(AndroidJUnit4::class)
class HotelCrudTest {
    @get:Rule
    val activityRule = ActivityTestRule(HotelActivity::class.java)
 
    init {
        loadKoinModules(module {
            single(override = true) {
                val db = Room.inMemoryDatabaseBuilder(
                        InstrumentationRegistry.getInstrumentation().context,
                        HotelDatabase::class.java)
                        .allowMainThreadQueries()
                        .build()
                RoomRepository(db) as HotelRepository
            }
        })
    }
    @Test
    fun crudTest() {
        add()
    }
    private fun add() {
        onView(withId(R.id.fabAdd)).perform(click())
        onView(withId(R.id.edtName)).perform(typeText(NEW_HOTEL_NAME))
        onView(withId(R.id.edtName)).perform(pressImeActionButton())
        onView(withId(R.id.edtAddress)).perform(typeText(NEW_HOTEL_ADDRESS))
        onView(withId(R.id.edtAddress)).perform(pressImeActionButton())
        closeSoftKeyboard()
    }
 
    companion object {
        private const val NEW_HOTEL_NAME = "Hotel de Teste"
        private const val NEW_HOTEL_ADDRESS = "Rua tal"
    }
}

Essa classe de teste começa com as anotações informando que ela será
executada com o AndroidJUnit4. Foi utilizada a classe ActivityTestRule para que



a activity principal seja executada.
No bloco init, o banco de dados real está sendo substituído por uma

implementação em memória, como foi feito na classe RoomRepositoryTests. Foi
utilizado o método loadKoinModules de modo a substituir a implementação, que
é provida pelo arquivo AndroidModules.kt do projeto, e isso é feito ao passar
o parâmetro override para a função single, que retorna o repositório.

O método crudTest() está invocando o método addHotel(), que realizará as
etapas para inserir um hotel.

A primeira instrução desse método pode ser lida da seguinte forma: na view
(onView) com o id (withId) fabAdd realize a ação (perform) de clique (click); em
seguida, um texto é digitado nas caixas de texto edtName e edtAddress com o
método typeText(String); para concluir a inserção, o Enter do teclado é
pressionado com o método pressImeActionButton(). Por fim, o teclado virtual é
fechado usando o método closeSoftKeyboard().

O Espresso tem uma limitação em relação ao uso de animações, portanto
elas devem ser desabilitadas nas Opções do desenvolvedor nas
configurações do aparelho, como mostra a Figura 31.5.

Figura 31.5 – Desabilitando as animações do aparelho.
Desabilite as três primeiras opções exibidas na figura. Caso não tenha feito



o login na aplicação, execute-a separadamente e faça o login, em seguida,
execute o teste com o emulador em execução ou um aparelho conectado à
máquina.

Trabalhando com listas
Será criado o teste para a alteração de um hotel existente que será executado
após o método que testa a inserção de um hotel. Altere a classe HotelCrudTest
para adicionar os métodos edit() e delete():
import androidx.room.Room
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.espresso.Espresso.onData
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.action.ViewActions.*
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.rule.ActivityTestRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import dominando.android.hotel.common.HotelActivity
import dominando.android.hotel.repository.HotelRepository
import dominando.android.hotel.repository.room.HotelDatabase
import dominando.android.hotel.repository.room.RoomRepository
import org.hamcrest.Matchers.containsString
import org.hamcrest.Matchers.hasToString
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.koin.dsl.module.module
import org.koin.standalone.StandAloneContext.loadKoinModules
 
@RunWith(AndroidJUnit4::class)
class HotelCrudTest {
    // Atributo e o bloco init não mudaram
    @Test
    fun crudTest() {
        add()
        edit()
        delete()
    }
    private fun add() {
        onView(withId(R.id.fabAdd)).perform(click())



        fillHotelForm(NEW_HOTEL_NAME, NEW_HOTEL_ADDRESS)
        listViewHasHotelWithName(NEW_HOTEL_NAME)
    }
    private fun edit() {
        clickOnHotelName(NEW_HOTEL_NAME)
        onView(withId(R.id.action_edit)).perform(click())
        fillHotelForm(CHANGED_HOTEL_NAME, CHANGED_HOTEL_ADDRESS)
        onView(withId(R.id.txtName)).check(matches(withText(CHANGED_HOTEL_NAME)))
        onView(withId(R.id.txtAddress)).check(matches(withText(CHANGED_HOTEL_ADDRESS)))
        pressBack()
        listViewHasHotelWithName(CHANGED_HOTEL_NAME)
    }
    private fun delete() {
        onData(hasToString(containsString(CHANGED_HOTEL_NAME)))
                .inAdapterView(withId(android.R.id.list)).atPosition(0)
                .perform(longClick())
        onView(withId(R.id.action_delete)).perform(click())
    }
    private fun fillHotelForm(name: String, address: String) {
        onView(withId(R.id.edtName)).perform(replaceText(name))
        onView(withId(R.id.edtAddress)).perform(replaceText(address))
        onView(withId(R.id.edtAddress)).perform(pressImeActionButton())
        closeSoftKeyboard()
    }
    private fun listViewHasHotelWithName(name: String) {
        onData(hasToString(containsString(name)))
                .inAdapterView(withId(android.R.id.list))
                .atPosition(0)
                .onChildView(withId(R.id.txtName))
                .check(matches(withText(containsString(name))))
    }
    private fun clickOnHotelName(name: String) {
        onData(hasToString(containsString(name)))
                .inAdapterView(withId(android.R.id.list))
                .atPosition(0)
                .perform(click())
    }
 
    companion object {
        private const val NEW_HOTEL_NAME = "Hotel de Teste"
        private const val NEW_HOTEL_ADDRESS = "Rua tal"
        private const val CHANGED_HOTEL_NAME = "Hotel Modificado"
        private const val CHANGED_HOTEL_ADDRESS = "Rua modificada"
    }
}



Ao realizar os testes em uma View e esta for uma AdapterView, como uma
ListView ou um Spinner, o método onView() não consegue verificar se os dados já
foram carregados nesses componentes, ele apenas se encarrega de saber se o
componente está presente na hierarquia de views. Por isso, deve-se utilizar o
método Espresso.onData() que retorna uma view específica da lista. Para buscar
essa view, nesse exemplo foi utilizado o método hasToString(Matcher) com o
containsString(String), que verifica o toString() do objeto que alimenta o item da
lista.

Essa abordagem está sendo utilizada em dois métodos utilitários. Em
listViewHasHotelWithName(String) é checado se a ListView contém um hotel com
determinado nome utilizando o método check(ViewAssertion). Já em
clickOnHotelName(String) é efetuado o clique no item da lista utilizando o método
perform(ViewAction).

O formulário de cadastro de hotéis será preenchido tanto para testar a
inclusão quanto a alteração. Por essa razão foi criado o método
fillHotelForm(String,String). Note que foi utilizado o método replaceText(String), pois na
alteração o texto deverá ser substituído e na inclusão esse método funcionará
também.

Agora o método add() está completo, pois está inserindo um novo hotel e
verificando se ele foi adicionado corretamente à lista.

No método edit() o hotel é selecionado na lista (clickOnHotelName(String)), depois
o botão de edição da action bar é clicado. Então o nome e do endereço do
hotel são modificados e a operação de salvar é realizada clicando no botão do
teclado (no método fillHotelForm()). A tecla back é pressionada para voltar para
a tela principal e, por fim, é verificado se a lista foi atualizada
(listViewHasHotelWithName(String)).

O método delete() procurará na lista o registro recém-editado. Ao encontrá-lo,
um clique longo é realizado sobre ele, ativando assim a opção de excluir. Por
fim, o botão de excluir é clicado.

Actions e Matchers customizados
No teste anterior não foi possível interagir com o componente RatingBar, pois
não existe uma ação predefinida para determinar a quantidade de estrelas do
componente como existe para digitar um texto no EditText. Para isso, é preciso
criar uma ação personalizada. Adicione a classe a seguir ao pacote de testes



da aplicação:
import android.view.View
import android.widget.RatingBar
import org.hamcrest.Matcher
import androidx.test.espresso.UiController
import androidx.test.espresso.ViewAction
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
 
class RatingBarAction : ViewAction {
    private var rating: Float = 0f
    override fun getConstraints(): Matcher<View> {
        return isAssignableFrom(RatingBar::class.java)
    }
    override fun getDescription(): String {
        return "RatingBar with rating $rating"
    }
    override fun perform(uiController: UiController, view: View) {
        val ratingBar = view as RatingBar
        ratingBar.rating = rating.toFloat()
    }
 
    companion object {
        fun setRating(value: Float): RatingBarAction {
            val ratingBarAction = RatingBarAction()
            ratingBarAction.rating = value
            return ratingBarAction
        }
    }
}

Foi criada uma subclasse de ViewAction em que o principal método é o perform
(UiController,View), no qual é indicada a ação que é realizada com o componente.
Nesse caso, o método setRating(Float) do RatingBar é invocado para mudar a
quantidade de estrelas que são exibidas. Já o método estático setRating(Float) da
classe RatingBarAction é apenas um atalho para facilitar o uso dessa classe.

Entretanto, não adianta criar uma ação se não for possível checar se o
resultado foi efetuado. Por essa razão é importante criar um Matcher. Adicione
a classe RatingBarMatcher e deixe-a como a seguir:
import android.view.View
import android.widget.RatingBar
import androidx.test.espresso.matcher.BoundedMatcher
import org.hamcrest.Description
 



class RatingBarMatcher(private val rating: Float)
    : BoundedMatcher<View, RatingBar>(RatingBar::class.java) {
    override fun describeTo(description: Description?) {
        description
                ?.appendText("with hint rating value:")
                ?.appendValue(rating)
    }
    override fun matchesSafely(item: RatingBar): Boolean {
        return item.rating == rating
    }
    companion object {
        fun withRatingValue(rating: Float): RatingBarMatcher {
            return RatingBarMatcher(rating)
        }
    }
}

A classe herda de BoundedMatcher onde é preciso apenas implementar os
métodos matchesSafely(T) e describeTo(Description). Ela recebe como parâmetro o
valor de rating a ser testado. O método withRatingValue(Float) é apenas um
utilitário para instanciar o matcher.

Essas duas classes serão utilizadas no HotelCrudTest como a seguir.
No método add() da classe HotelCrudTest agora será possível modificar o

RatingBar da seguinte forma:
import dominando.android.hotel.RatingBarAction.Companion.setRating
import dominando.android.hotel.RatingBarMatcher.Companion.withRatingValue
...
 
@RunWith(AndroidJUnit4::class)
class HotelCrudTest {
    // Apenas os métodos modificados estão sendo listados
    private fun add() {
        onView(withId(R.id.fabAdd)).perform(click())
        fillHotelForm(NEW_HOTEL_NAME, NEW_HOTEL_ADDRESS, NEW_HOTEL_RATING)
        listViewHasHotelWithName(NEW_HOTEL_NAME)
    }
    private fun edit() {
        clickOnHotelName(NEW_HOTEL_NAME)
        onView(withId(R.id.action_edit)).perform(click())
        fillHotelForm(CHANGED_HOTEL_NAME, CHANGED_HOTEL_ADDRESS,

CHANGED_HOTEL_RATING)
        onView(withId(R.id.txtName)).check(matches(withText(CHANGED_HOTEL_NAME)))
        onView(withId(R.id.txtAddress)).check(matches(withText(CHANGED_HOTEL_ADDRESS)))
        onView(withId(R.id.rtbRating)).check(matches(withRatingValue(CHANGED_HOTEL_RATING)))



        pressBack()
        listViewHasHotelWithName(CHANGED_HOTEL_NAME)
    }
    private fun fillHotelForm(name: String, address: String, rating: Float) {
        onView(withId(R.id.edtName)).perform(replaceText(name))
        onView(withId(R.id.edtAddress)).perform(replaceText(address))
        onView(withId(R.id.rtbRating)).perform(setRating(rating))
        onView(withId(R.id.edtAddress)).perform(pressImeActionButton())
        closeSoftKeyboard()
    }
    companion object {
        ...
        private const val NEW_HOTEL_RATING = 3.5f
        private const val CHANGED_HOTEL_RATING = 4.5f
    }
}

Execute os testes novamente e agora as estrelas do hotel estão sendo
atribuídas e devidamente testadas.

Espresso e RecyclerView
No exemplo de hotéis foi utilizada a ListView, mas no exemplo de discos a
listagem é exibida em uma RecyclerView. Para fins de teste, esses dois
componentes também são tratados de forma diferente. Abra o projeto EngHaw
do Capítulo 30 para escrever um teste para ele utilizando o Espresso.

Para acessar elementos de uma RecyclerView, é preciso colocar mais uma
dependência no build.gradle:
android { ...
    defaultConfig { ...
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    ...
}
dependencies {
    ...
    implementation 'androidx.test.espresso:espresso-idling-resource:3.1.1'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.0'
    androidTestImplementation "androidx.test:rules:1.1.1"
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-contrib:3.1.1'
}



Note que, além das configurações do Espresso que já foram mencionadas,
foi adicionada a dependência do espresso-contrib, que contém classes específicas
para trabalhar com RecyclerView. Também foi adicionado a dependência de
“idling resource” para que seja possível aguardar o download das
informações dos discos.

Antes de implementar os testes, teremos que fazer uma pequena
modificação no projeto para que o teste só inicie após o carregamento das
informações dos álbuns. Crie o objeto IdleResource no pacote do projeto (não no
de teste).
import androidx.test.espresso.idling.CountingIdlingResource
object IdleResource {
    val instance = CountingIdlingResource("ALBUMS")
}

Com esse objeto, os testes poderão verificar se a tela está pronta para ser
testada. Agora faça as seguintes mudanças na classe AlbumListWebFragment.
private fun loadAlbumsAsync() {
    downloadJob = launch {
        IdleResource.instance.increment()
        showProgress(true)
        albums = withContext(Dispatchers.IO) {
            AlbumHttp.loadAlbums()?.toList()
        }
        IdleResource.instance.decrement()
        showProgress(false)
        updateList()
        downloadJob = null
    }
}

Ao incrementar o IdleResource informamos que a classe está ocupada. Ao
decrementar e ficar com o valor zero, a tela está disponível para o teste.
Agora faça uma mudança similar na classe AlbumListDbFragment.
override fun onActivityCreated(savedInstanceState: Bundle?) {
    super.onActivityCreated(savedInstanceState);
    launch {
        IdleResource.instance.increment()
        albumList = withContext(Dispatchers.IO) { repo.loadFavorites() }
        albumList?.observe(this@AlbumListDbFragment, Observer { albums ->
            if (albums != null) {
                updateList(albums)
            }



        })
        IdleResource.instance.decrement()
    }
}

Será criado um teste que realizará um fluxo simples da nossa aplicação. Um
item da lista de discos vindos da web será clicado, e, quando a tela de
detalhes for exibida, o botão de favoritos será clicado. Em seguida, voltará
para a tela principal, mudará para a aba de favoritos e verificará se o disco
recém-adicionado encontra-se nessa lista. Crie a classe AlbumUITest na pasta
src/androidTest e deixe-a como a seguir:
import androidx.recyclerview.widget.RecyclerView
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.swipeLeft
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.RecyclerViewActions.actionOnItem
import androidx.test.espresso.contrib.RecyclerViewActions.scrollTo
import androidx.test.espresso.matcher.ViewMatchers.*
import androidx.test.rule.ActivityTestRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import org.hamcrest.Matchers.`is`
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
 
@RunWith(AndroidJUnit4::class)
class AlbumUITest {
    @get:Rule
    var activityRule: ActivityTestRule<MainActivity> = ActivityTestRule(MainActivity::class.java)
 
    @Before fun setUp() {
        activityRule.activity.deleteDatabase("engHawDb")
    }
    @Test fun test_add_favorite() {
        val tagRecyclerWeb = "web"
        val tagRecyclerFavorite = "fav"
        val albumTitleToBeClicked = "Minuano"
        IdlingRegistry.getInstance().register(IdleResource.instance)
        onView(withTagValue(`is`(tagRecyclerWeb as Any)))
                .perform(scrollTo<RecyclerView.ViewHolder>(



                        hasDescendant(withText(albumTitleToBeClicked))
                ))
        onView(withTagValue(`is`(tagRecyclerWeb as Any)))
                .perform(actionOnItem<RecyclerView.ViewHolder>(
                        hasDescendant(withText(albumTitleToBeClicked)),
                        click()
                ))
        onView(withId(R.id.txtTitle))
                .check(matches(withText(albumTitleToBeClicked)))
        onView(withId(R.id.fabFavorite))
                .perform(click())
        pressBack()
        onView(withId(R.id.viewPager))
                .perform(swipeLeft())
        onView(withTagValue(`is`(tagRecyclerFavorite as Any)))
                .check(matches(hasDescendant(withText(albumTitleToBeClicked))))
    }
}

Um detalhe curioso da nossa aplicação é que os dois fragmentos exibidos
nas abas utilizam o mesmo arquivo de layout para exibir o seu conteúdo,
então foi utilizada a tag para obter a referência do componente.

Perceba que por meio da classe IdlingRegistry foi registrado o IdleResource para
que o teste fique ciente que a classe a ser testada está pronta.

Para achar um elemento dentro da lista, foi utilizado o método hasDescendant
(withText(String)). Como o disco “Minuano” não se encontra visível assim que a
aplicação é executada, é feito um scroll na lista utilizando o método
scrollTo(Matcher). Ao encontrar o item, a ação de clique é executada por meio do
método actionOnItem (Matcher,ViewAction). Perceba que a primeira coisa que a ser
feita nesse teste foi apagar o banco para garantir que ele estivesse vazio ao
executar o teste.

Teste de estresse com o Monkey
O Monkey é uma ferramenta de linha de comando que pode ser executada
para enviar um fluxo de eventos aleatórios para sua aplicação. Ele é útil para
efetuar um teste de estresse no aplicativo. Para executar o Monkey, basta
executar o comando a seguir dentro do diretório ANDROID_SDK/platform-
tools:
adb shell monkey -p dominando.android.enghaw -v 500

Esse comando executa os testes do Monkey em uma aplicação, cujo pacote



é especificado pelo parâmetro -p e envia 500 eventos. A Tabela 30.3
apresenta as principais opções para o uso do Monkey.

Tabela 30.3 – Parâmetros do Monkey
Opção Propósito

-v Exibe o log durante a execução do Monkey.
-s <valor> Número “semente” para ser usado pelo Monkey. Ao usar o mesmo valor em uma execução

futura, os mesmos eventos serão gerados.
--throttle Determina um intervalo entre os eventos.
<milisegundos>
--pct-touch Percentual de eventos de toque.
<percentual>
--pct-motion Percentual de eventos de movimento.
<percentual>
--pct-nav Percentual de eventos básicos de navegação.
<percentual>
--pct-majornav Percentual de eventos de navegação.
<percentual>
--pct-syskeys Percentual de eventos do sistema (home, back, chamada telefônica, controle de volume etc.).
<percentual>
--pct-appswitch Percentual de troca de aplicação (invocando startActivity(Intent)).
<percentual>
-p <nome do Pacote da aplicação a ser testada.
pacote>
--ignore-crashes Ao especificar essa opção, o Monkey continuará a enviar eventos para o sistema se alguma

exceção ocorrer.
--ignore-timeouts Ao especificar essa opção, o Monkey continuará a enviar eventos para o sistema mesmo se a

aplicação não estiver respondendo.

Para mais opções, consulte a documentação do Android.

Mais ferramentas
Existem diversas outras ferramentas de teste que valem muito a pena serem
exploradas, mas que não mostramos aqui. Eu o aconselho a pesquisar sobre:

• Appium (http://appium.io) – é uma ferramenta construída sobre o UI
Automator e facilita os testes de UI caixa-preta;

• Robolectric (http://robolectric.org) – permite executar testes que
necessitam do emulador ou aparelho na sua máquina local;

• Spoon (http://square.github.io/spoon) – permite executar testes em
diversos aparelhos ao mesmo tempo, gerando relatórios em HTML e
ainda permitindo tirar screenshots do aparelho durante a execução dos
testes;



• Bitbar (https://bitbar.com/testing/) – serviço de teste na nuvem no qual é
possível “alugar” diversos aparelhos para efetuar seus testes;

• Firebase Test Lab (https://firebase.google.com/docs/test-lab) – serviço de
teste da nuvem do Firebase.

Cada uma dessas ferramentas pode auxiliar na construção de testes para o
aplicativo e, com isso, melhorar a sua qualidade. Existem muitas outras, mas
essas são algumas das mais populares.



CAPÍTULO 32
Google Play

Por Marcelo R. Quinta e Nelson Glauber
Ao terminar a primeira versão do aplicativo e realizados os devidos testes,
chega a hora de mostrar a todos o resultado do trabalho realizado. Isso
poderia ser feito enviando ou disponibilizando o APK (Android Package)
diretamente para os interessados, mas, sem dúvida, esta não é uma forma de
distribuição eficiente, pois o usuário teria que saber o local correto para
encontrar o aplicativo, mudar configurações de segurança para que seja
possível a instalação fora da loja, a atualização do software seria praticamente
manual, entre outras desvantagens.

Para disponibilizar o aplicativo de maneira global e mais gerenciável, o
esperado é publicá-lo em alguma loja de aplicativos Android. A loja oficial e
mais visitada do mundo é a Google Play, que está presente em mais de 90%
dos dispositivos Android. As exceções são aparelhos da Amazon e
fabricantes da China.

Neste capítulo será demonstrada a preparação do aplicativo para ser
publicado na Google Play, a geração do APK, registro do desenvolvedor e
finalmente a publicação do aplicativo.

Preparação do código-fonte
Para publicar o aplicativo na Google Play, é necessário o envio de um APK
devidamente configurado e assinado com uma chave. É necessário ficar
atento a algumas configurações importantes durante a preparação do
aplicativo. Isso inclui itens obrigatórios e outros opcionais que podem ser
determinantes para que a aplicação possa ser mais facilmente encontrada pelo
usuário.

As configurações obrigatórias são aquelas feitas no projeto dentro dos
arquivos AndroidManifest.xml e no build.gradle. O Android Studio já alerta



sobre alguns erros durante o processo de desenvolvimento, entretanto, é
importante entender para que servem cada um dos campos nos arquivos.

AndroidManifest.xml
No AndroidManifest.xml, além dos componentes da aplicação (activities,
services, broadcast receivers, content providers etc.) são descritas várias
informações importantes que foram mencionadas ao longo do livro, mas que
serão reforçadas aqui.

O atributo package da tag <manifest> é definido sempre quando o projeto é
criado. Ele é o identificador único do aplicativo na loja e não poderá ser
alterado após a publicação. Um padrão para definir o nome do pacote é
inverter o domínio da empresa e adicionar o nome do projeto. Por exemplo,
se a empresa MyCompany, cujo domínio é mycompany.com, for desenvolver
o aplicativo chamado “My App”, um bom nome de pacote seria
“com.mycompany.myapp”. Este valor não deve ser modificado manualmente no
AndroidManifest.xml, pois está presente em diferentes arquivos do projeto. O
procedimento mais adequado e recomendado para a troca do identificador do
aplicativo é utilizar a opção Refactor > Rename do Android.

Outra informação importante localizada na tag <manifest> é a lista de
permissões que o aplicativo necessita. Elas são definidas com a tag <uses-
permission> e é importante verificar se todas as permissões necessárias estão
declaradas, bem como remover as que não estão sendo usadas.

Com a tag <uses-feature> é possível declarar a necessidade de algum recurso
específico de hardware (como a câmera ou sensores) ou software (como o
OpenGL). Assim, caso um dispositivo não possua a funcionalidade citada, o
aplicativo nem aparecerá para o usuário na loja.

Ainda na tag <manifest>, por meio da propriedade android:installLocation é
definido o local-padrão para instalação do APK, podendo ser: apenas na
memória interna (internalOnly) que é a opção-padrão; caso não seja informada
essa propriedade pode-se optar por instalar preferencialmente em memória
externa (preferExternal), ou automático (auto). No modo automático, a aplicação
será instalada na memória interna, mas caso não haja espaço suficiente, será
instalada na memória externa (cartão de memória). É importante destacar que
os dados do aplicativo, como banco de dados, serão sempre salvos na
memória interna. Outro detalhe relevante é que nem todos os tipos de



aplicativos podem ser instalados na memória externa, como serviços de
alarme, teclados, widgets, entre outros. Consulte a documentação para mais
detalhes.

Na tag <application> são definidas informações mais básicas do aplicativo. O
ícone é definido na propriedade android:icon, no qual se deve utilizar uma
imagem *.png localizada na pasta res/mipmap devendo sempre definir uma
imagem para cada densidade de tela. A partir do Android 7.1 (API Level 25)
os aplicativos podem usar ícones redondos por meio da propriedade
android:roundIcon. No Android 8.0 (API Level 26) e superior é possível definir
“ícones adaptativos”. Perceba que o ic_launcher_round.xml localizado na
pasta res/mipmap-anydpi-v26 utiliza a tag <adaptive-icon> em que são
declarados o <background> e o <foreground> do ícone apontando para recursos na
pasta drawable que são (geralmente) Vector Drawables. A vantagem dos
Adaptive Icons é que o fabricante pode deixar os ícones no formato que
preferir, então o background será usado para preencher essa área e o
foreground será o ícone em si, que ficará centralizado.

Na propriedade android:label é definido o nome visível do aplicativo, e esse
texto deve preferencialmente estar declarado no arquivo
res/values/strings.xml.

A propriedade android:debuggable é utilizada para indicar que a aplicação está
sendo executada em modo de debug. Ela não é adicionada por padrão, mas
caso esteja presente, defina-a como false ou a remova antes da publicação.

build.gradle
O arquivo build.gradle do módulo do aplicativo tem o objetivo de
complementar ou até abstrair informações do AndroidManifest.xml, mas que
ficam mais configuráveis neste local. Por ser um script escrito na linguagem
Groovy, seu objetivo principal é descrever todas as dependências internas e
externas, além de configurações de construção e até exportação do APK
como foi visto no Capítulo 29.

As versões mínima, máxima e alvo (target) do Android são definidas no
bloco defaultConfig. A propriedade minSdkVersion define a versão mínima da API
do Android suportada pelo aplicativo, ou seja, dispositivos com versão
anterior da estipulada não serão suportados. A targetSdkVersion estipula a versão
máxima da API do Android que o aplicativo foi testado e homologado, ou



seja, dispositivos com versão posterior da API do Android podem instalar a
aplicação, mas o funcionamento não é garantido. Em maxSdkVersion é a versão
máxima da API do Android suportada pelo aplicativo, ou seja, dispositivos
com versão posterior da estipulada não serão suportados. A adição deste
atributo não é recomendada, visto que, segundo a documentação oficial, seu
aplicativo deve estar preparado e atualizado para novas versões.

Ainda no bloco defaultConfig ficam os atributos versionCode e versionName. O
versionCode define um número de versionamento interno do aplicativo e não é
visível ao usuário, servindo somente para a realização de atualizações na
Google Play. O versionCode deve ser incrementado toda vez que uma nova
versão do APK for enviada para a loja. O versionName, por sua vez, é a versão
pública que é visível ao usuário. Apesar de obrigatório, não há nenhuma
regra para a sua declaração e não precisa obrigatoriamente ser modificada no
envio de uma nova versão do APK para a loja.

Como foi demonstrado no Capítulo 29, os build types são declarados nesse
arquivo. O tipo debug diz respeito às configurações utilizadas durante o
desenvolvimento da aplicação que a executa em modo de debugging. O build
type de release desabilita toda a parte de debug do projeto e é utilizado para
realizar a publicação do aplicativo na loja.

Para dificultar a engenharia reversa do projeto, a opção é utilizar o
ProGuard, que obfusca o código fonte reduzindo o nome de classes, atributos,
métodos, variáveis etc.; trocando-os para identificadores de difícil
entendimento. O Proguard também remove o código e recursos não
utilizados, deixando o APK de release menor:
buildTypes {
    release {
        shrinkResources true
        minifyEnabled true
        proguardFiles getDefaultProguardFile('proguard-android.txt'),
            'proguard-rules.pro'
        }
    }

Para obfuscar o código basta habilitar a propriedade minifyEnabled e para
remover os recursos desnecessários utiliza-se shrinkResources. Lembre-se de
adicionar todas as regras do Proguard para as bibliotecas de terceiros
utilizadas no projeto.



Geração do APK
Após a devida preparação do projeto, é necessário gerar um APK que será
enviado para a Google Play. Para isso, é necessário criar uma chave
(normalmente chamada de keystore), que é um arquivo binário que armazena
uma chave privada utilizada para identificar o aplicativo bem como a pessoa
ou a empresa que o desenvolveu.

Para gerar a chave no Android Studio, clique em Build > Generate Signed
Bundle/APK.... Na tela que for exibida selecione a opção APK e, em
seguida, clique em Next para exibir a tela da Figura 32.1.

Figura 32.1 – Tela de criação do APK assinado.
Na parte superior, o módulo app deve estar selecionado. Caso já possua uma

keystore, selecione-a clicando em Choose existing.... Para criar uma nova
chave, clique em Create new... e será exibida a tela da Figura 32.2.



Figura 32.2 – Tela de criação da chave para assinatura do aplicativo.
Preencha todas as informações requeridas similar ao apresentado na figura e

gere um arquivo de chave. A aplicação precisa ser validada por uma chave
que dure até depois de 22 de outubro de 2033, mas a chave que será gerada é
válida por 25 anos. Guarde este arquivo em um local seguro, e de preferência
faça cópias na nuvem, pois a aplicação só poderá ser atualizada na loja com
ela. Lembre-se também de memorizar as duas senhas necessárias. A primeira
servirá para abrir o arquivo. A segunda refere-se à assinatura para o alias
escolhido.

Escolha o keystore, insira a senha, o nome do alias e a senha do alias. Em
seguida, clique em Next e será exibida a tela da Figura 32.3.



Figura 32.3 – Assinatura do APK com a chave gerada.
Escolha o local onde APK assinado será salvo e no campo Build type

selecione release. Em Signature Versions, marque os dois tipos de assinatura
v1 e v2 (introduzida no Android 7). Após aguardar a geração do APK, seu
aplicativo está pronto para ser mandado para a loja no local especificado.

Se o seu aplicativo ficar muito grande (ex.: maior que 30 MB), retire os
recursos que o façam exceder este espaço e faça com que, ao ser aberto pela
primeira vez, a aplicação faça o download deste material. Consulte a
documentação sobre App Bundles para mais detalhes.

Antes de publicar a aplicação, é importante verificar se o APK gerado está
funcionando corretamente no aparelho, pois após a obsfuscação alguma
classe pode ter sido modificada acidentalmente. Para instalar o APK no
aparelho, basta utilizar o comando:
adb install -r seu_app.apk

Um último detalhe em relação ao uso das chaves é que, caso o aplicativo
use uma chave de API gerada a partir da debug.keystore para acessar algum
serviço (como os serviços do Google, por exemplo), muito provavelmente
será necessário gerar uma nova API key com a chave utilizada para
publicação.

APK Analyzer
A Google Play pode receber APKs com tamanho maior que 100MB,
entretanto não é interessante disponibilizar para o usuário arquivos enormes
para download. Uma etapa que pode ser bastante útil após a geração do APK



é a sua verificação utilizando o APK Analyzer, que pode ser acessado pelo
menu Build > Analyze APK, ou simplesmente abrindo o APK resultante
dentro do Android Studio.

É possível observar o tamanho relativo e absoluto de cada arquivo, os
detalhes dos arquivos que compõem o aplicativo e até comparar com versões
anteriores conforme mostra a Figura 32.4.

Figura 32.4 – Visão de um APK no APK Analyzer.
Como é possível perceber, a maior parte deste projeto é composta por

código-fonte. Em geral, os componentes que mais ocupam espaço dentro de
um APK são imagens, fontes ou arquivos extras. A sugestão para diminuir o
APK é abrir a árvore de artefatos do aplicativo, procurar os maiores arquivos
e tentar substituí-los por versões menores.

Registro de desenvolvedor na Google Play
Para publicar um aplicativo na Google Play, é necessário um cadastro na loja
e pagamento de taxa inicial. Para realizar o registro, acesse o site
https://play.google.com/apps/publish e faça login com sua conta do Google.
Em seguida, leia cuidadosamente o contrato de distribuição de desenvolvedor
do Google Play, que inclusive está disponível em português. Caso concorde
com os termos, clique em “Aceitar”.

A próxima etapa é pagar a taxa de registro que atualmente custa 25 dólares.
É necessário um cartão de crédito internacional e será a única que vez que
você pagará para ser um desenvolvedor Android. Não há pagamento anual.

Preencha os detalhes da sua conta como mostra a Figura 32.5. O “Nome de



desenvolvedor” refere-se àquele que será mostrado na loja.

Figura 32.5 – Preenchendo as informações de desenvolvedor na Google
Play.

Espere até 48 horas para o processamento da requisição de pagamento seja
concluído, e uma vez confirmada, uma mensagem chegará por email.

Com a conta confirmada, já será possível publicar a aplicação. E se alguma
aplicação a ser publicada seja paga ou tenha compras dentro do aplicativo, é
preciso configurar uma conta de comerciante dentro do Google Wallet.

Publicação do aplicativo
Com sua conta de desenvolvedor devidamente confirmada e com o APK
gerado e testado, é chegado o grande momento: o registro e publicação do
aplicativo na Google Play.

Acesse o Google Play Console (https://play.google.com/apps/publish) e
faça login com a conta Google utilizada no registro do desenvolvedor e será
exibida a tela da Figura 32.6.



Figura 32.6 – Tela principal do Google Play Console.
Clique no botão Create Application e será exibida a tela da Figura 32.7.
Selecione o idioma-padrão, digite o título do aplicativo e, em seguida,

clique em Create. Embora recomendado, não é necessário ser exatamente o
nome que aparece no AndroidManifest.xml.

Após criar a aplicação, uma nova janela será exibida com diversas opções à
esquerda como mostra a Figura 32.8. Fique atento às opções com um ícone
de “check” em cinza. Assim que o aplicativo estiver pronto para ser
publicado, essas opções estarão na cor verde.



Figura 32.7 – Adicionando título do seu novo aplicativo e escolhendo o
idioma-padrão.

Figura 32.8 – Tela de rascunho do aplicativo no Google Play Console.

Versões de apps



Chegou a hora de submeter o APK. Escolha a opção App releases (Versões
de apps) no menu lateral e serão exibidas várias opções de publicação, sendo:

• Production Track (Faixa de Produção) libera o aplicativo para todos os
usuários;

• Open Track (Faixa Aberta) qualquer um pode se registrar para fazer
download da aplicação e testá-la;

• Closed Track (Faixa Fechada) você especifica os usuários ou grupo de
usuários que terão acesso à aplicação;

• Internal Test Track (Faixa de Teste Interno) para testes internos rápidos.
Muitas empresas realizam a publicação do aplicativo de forma gradual. De

início publicam internamente para que o próprio time possa testá-lo. Em
seguida, criam grupos de usuários ou até mesmo contratam uma empresa
terceirizada para efetuar esses testes em busca de erros ou até mesmo para
sugerir melhorias ou novas funcionalidades. Depois liberam uma versão de
testes pública para que os usuários selecionados registrem-se para baixar e
testar o aplicativo. Enfim, a última etapa é publicar para o público em geral.

Aqui será demonstrada apenas a opção de “Produção”. Por isso, clique em
Manage dentro de Production Track. Na tela que for exibida, clique em
Create Release e será mostrada a tela da Figura 32.9.



Figura 32.9 – Selecionando a chave para o APK.
Clique em Continue para inscrever o aplicativo no Google Play. Leia

atentamente o contrato e clique em Accept. Finalmente, selecione o APK
gerado no Android Studio e o upload do arquivo iniciará automaticamente.
Após o envio, um resumo de compatibilidade da aplicação será exibido
conforme a Figura 32.10.



Figura 32.10 – Informações do APK enviado para o Google Play.
No campo What’s new in this release? (O que há de novo nessa versão)

insira um texto explicativo básico sobre o aplicativo de no máximo 500
caracteres.

O portal de desenvolvedor da Google Play oferece serviços de tradução a
preços variáveis. Pode ser interessante consultar o preço desses serviços para
ter uma tradução profissional para o aplicativo.

Clique no botão Save para salvar o APK sua respectiva descrição.

Detalhes do app
Selecione a opção Store Listing (Detalhes do app) no lado esquerdo como
mostra a Figura 32.11.



Figura 32.11 – Informações do aplicativo Google Play.
Preencha todas as informações requisitadas, levando em conta a

obrigatoriedade e a importância de algumas delas. Para cada idioma
suportado pode e deve haver uma tradução dos detalhes do aplicativo.
Observe as informações de cada seção.

Product Details
• Title – título do aplicativo na loja. É o mesmo entrado anteriormente no

cadastro e ele pode ser atualizado quando quiser;
• Short Description – um texto que descreve rapidamente o aplicativo.

Funciona como um slogan ou chamada rápida para o usuário;
• Full Description – um detalhamento sobre o que é o aplicativo e o que ele

oferece. Assim como os dois anteriores, este item é obrigatório e permite
a digitação de até 4.000 caracteres. Prefira tópicos ao texto corrido e tome
cuidado para não infringir as regras das diretrizes e práticas de políticas
da Google Play.

Graphic Assets
• Screenshots – é preciso fornecer ao menos duas capturas de tela, mas o

ideal é oferecer prints do aplicativo em vários tipos de dispositivos, como,
por exemplo, telefones, tablets de 7” e tablets de 10”. Para que seu app
apareça na lista “Projetado para tablets” da Play Store, é necessário o



upload de pelo menos uma captura de tela de 7” e uma captura de tela de
10”. As imagens devem estar no formato JPEG ou PNG (sem
transparência), com dimensão mínima de 320 pixels e dimensão máxima
de 3.840 pixels. Priorize as imagens que resumam o conceito do seu
aplicativo;

• Hi-res icon – é o ícone do aplicativo em alta resolução. É uma imagem
PNG de 32 bits (com alfa) e de tamanho 512x512 pixels que ficará ao
lado do aplicativo na loja. Este não substitui o ícone de inicialização do
app, mas deve ser a versão com a mais alta fidelidade e resolução
possível;

• Feature Graphic – é uma imagem JPG ou PNG de 32 bits (sem
transparência), de tamanho 1024x500 pixels que cobrirá o cabeçalho da
página do aplicativo na Google Play, com o objetivo de tornar mais
atraente a página da aplicação;

• Promo Graphic – é um item opcional usado para promoções em
dispositivos Android com versões anteriores ao 4.0. Sendo uma imagem
JPG ou PNG de 24 bits e tamanho 180x120 pixels, é recomendado que
você não utilize palavras, pois a imagem é pequena;

• Promo Video – é um item opcional, caso haja um vídeo no YouTube que
promova o aplicativo, é possível adicioná-lo na descrição do aplicativo,
deixando sua página mais envolvente. Ele aparecerá juntamente com as
screenshots do aplicativo (na primeira posição). Ao usar o aplicativo da
Google Play Store, o vídeo será fixado também no topo, sobrepondo o
gráfico de recursos.

Categorização
• Application type – aqui é possível optar por “Applications” ou “Games”;
• Category – é um item obrigatório no qual deve-se optar por uma entre as

mais diversas categorias. Selecione a que mais se encaixa no perfil do seu
aplicativo.

Contact details
• Website – é uma informação opcional na qual pode ser informada a URL

que será disponibilizada para que os usuários tenham mais detalhes sobre
o aplicativo. Lembre-se de que a maioria dos acessos a este site virá de
dispositivos móveis, por isso é importante ter um site acessível por



telefones e tablets;
• Email – é obrigatório e deve ser preenchido com o email de contato do

aplicativo para o Google e os usuários;
• Phone – item opcional e pode ser preenchido com o telefone de contato do

aplicativo para o Google, caso exista algum problema a ser resolvido.
Privacy Policy
• A URL da política de privacidade é obrigatório, pois informa aos usuários

se e como serão utilizados os dados de sua interação com o aplicativo. Ela
é pública e também fica disponível na página da aplicação.

Após entrar com todos os metadados a serem exibidos na página do
aplicativo, clique no botão Save Draft. Espere que apareça um ícone de
confirmação ao lado de Store Listing. Caso ele ainda não esteja sendo
exibido, é muito provável que alguma das informações anteriores não tenha
sido preenchida corretamente.

Conteúdo e classificação
Selecione a opção Content Rating (Conteúdo e classificação) no lado
esquerdo. O sistema de classificação de conteúdo do Google Play para apps e
jogos foi projetado para fornecer classificações respeitáveis e relevantes para
usuários em todo o mundo. O sistema de classificação inclui classificações
oficiais da International Age Rating Coalition (IARC) e de seus órgãos
participantes. Insira o endereço de email para que o IARC possa usar para
comunicações relacionadas à classificação. Em seguida, deve-se escolher a
categoria do aplicativo entre as opções:

• Referência, Notícias ou Educacional;
• Redes sociais, Fóruns, Blogs ou Compartilhamento;
• Agregadores de conteúdo, Lojas de Consumo ou Serviços comerciais de

streaming;
• Jogos;
• Entretenimento;
• Utilitários, Produtividade, Comunicação ou Outros.
Escolha a categoria mais adequada e, em seguida, será exibido um

questionário sobre o conteúdo do aplicativo relativo a: violência, sexualidade,
linguajar, substâncias controladas (drogas), uso da localização do usuário, se



faz vendas ou realiza comunicação por voz, texto ou imagens. Após
responder a essas questões, clique em Save questionnaire. Em seguida,
clique em Calculate Rating para que sua aplicação receba um certificado de
classificação. Por fim, clique em Apply Rating e isso restringirá o download
da aplicação somente àquelas pessoas que tiverem idade mínima
especificada. Por isso, leia bastante as diretrizes de classificação de conteúdo
para não ter seu aplicativo retirado da loja. Leia o documento “Políticas do
Programa para Desenvolvedores do Google Play” para se informar melhor
sobre este assunto.

Preço e distribuição
Neste ponto o APK foi enviado, a página de detalhes do app está pronta e a
classificação do aplicativo já foi devidamente configurada. A última etapa
obrigatória é estipular preço e tipo de distribuição.

Selecione a opção Princing & Distribution no lado esquerdo. Escolha
primeiramente se o aplicativo será pago ou gratuito. Caso seja pago,
selecione o valor (em dólares). Entretanto, ao selecioná-lo como gratuito não
será possível torná-lo pago após a publicação.

Selecione os países e (em alguns casos) operadoras onde seu aplicativo
estará disponível. Em aplicativos pagos, não é possível definir valores
diferentes para cada país.

Em seguida, selecione no campo Primarily Child-Directed se o aplicativo
é direcionado ao público infantil (abaixo dos 13 anos). Também informe se o
aplicativo exibirá propagandas no campo Contains Ads.

Na seção User Programs selecione alguma categoria especial de aplicações
se julgar que o aplicativo se encaixa em alguma delas.

Na seção Consent, marque a opção Marketing Opt-out caso não queira que
o Google faça marketing do seu aplicativo. Leia novamente as diretrizes de
conteúdo Android e verifique se seu aplicativo está de acordo. Em caso
positivo, marque a opção Content guidelines. Em caso negativo, reveja o
projeto ou viabilidade de seu aplicativo. Por fim, esteja certo de que seu
aplicativo está de acordo com as Leis de Importação dos Estados Unidos e
marque a opção US export laws no formulário.

Tome bastante cuidado com as questões de propriedade intelectual, como
imagens, vídeos, sons e qualquer outro tipo de mídia que não seja de sua



autoria, pois isso pode causar a retirada do aplicativo da loja.
Clique na opção Save Draft para salvar as informações de preço e

distribuição do aplicativo.
Caso exista alguma compra dentro do aplicativo (In-app Billing), cadastre-a

na opção In-app products.

Finalizando a publicação
Volte à opção App releases, clique em Edit Release e, em seguida, selecione
Review. Por fim, clique no botão Start Rollout to production (Iniciar
lançamento para produção). Confirme a operação e seu aplicativo será
publicado e estará disponível na Google Play em cerca de horas (às vezes,
minutos).

No dia seguinte da publicação do aplicativo, um novo grupo de opções é
disponibilizado dentro do Google Play Console. Lembre-se de visitá-lo
frequentemente para visualizar as estatísticas de download e vendas,
visualizar e responder às avaliações dos usuários, gerenciar falhas e ANRs
(Android Not Responding) e ler dicas de otimização que o analisador do
Google fez do seu APK.

Atualize a descrição sempre que novas funcionalidades forem adicionadas,
removidas ou atualizadas e mantenha os usuários engajados no seu aplicativo
Android, a plataforma móvel mais popular do mundo.






Python para análise de dados
McKinney, Wes
9788575227510
616 páginas

Compre agora e leia

Obtenha instruções completas para manipular, processar, limpar e
extrair informações de conjuntos de dados em Python. Atualizada
para Python 3.6, este guia prático está repleto de casos de estudo
práticos que mostram como resolver um amplo conjunto de
problemas de análise de dados de forma eficiente. Você conhecerá
as versões mais recentes do pandas, da NumPy, do IPython e do
Jupyter no processo. Escrito por Wes McKinney, criador do projeto
Python pandas, este livro contém uma introdução prática e
moderna às ferramentas de ciência de dados em Python. É ideal
para analistas, para quem Python é uma novidade, e para
programadores Python iniciantes nas áreas de ciência de dados e
processamento científico. Os arquivos de dados e os materiais
relacionados ao livro estão disponíveis no GitHub. • utilize o shell
IPython e o Jupyter Notebook para processamentos exploratórios; •
conheça os recursos básicos e avançados da NumPy (Numerical
Python); • comece a trabalhar com ferramentas de análise de dados



da biblioteca pandas; • utilize ferramentas flexíveis para carregar,
limpar, transformar, combinar e reformatar dados; • crie
visualizações informativas com a matplotlib; • aplique o recurso
groupby do pandas para processar e sintetizar conjuntos de dados; •
analise e manipule dados de séries temporais regulares e
irregulares; • aprenda a resolver problemas de análise de dados do
mundo real com exemplos completos e detalhados.

Compre agora e leia






Padrões para Kubernetes
Ibryam, Bilgin
9788575228159
272 páginas

Compre agora e leia

O modo como os desenvolvedores projetam, desenvolvem e
executam software mudou significativamente com a evolução dos
microsserviços e dos contêineres. Essas arquiteturas modernas
oferecem novas primitivas distribuídas que exigem um conjunto
diferente de práticas, distinto daquele com o qual muitos
desenvolvedores, líderes técnicos e arquitetos estão acostumados.
Este guia apresenta padrões comuns e reutilizáveis, além de
princípios para o design e a implementação de aplicações nativas
de nuvem no Kubernetes. Cada padrão inclui uma descrição do
problema e uma solução específica no Kubernetes. Todos os
padrões acompanham e são demonstrados por exemplos concretos
de código. Este livro é ideal para desenvolvedores e arquitetos que
já tenham familiaridade com os conceitos básicos do Kubernetes, e
que queiram aprender a solucionar desafios comuns no ambiente
nativo de nuvem, usando padrões de projeto de uso comprovado.
Você conhecerá as seguintes classes de padrões: • Padrões básicos,



que incluem princípios e práticas essenciais para desenvolver
aplicações nativas de nuvem com base em contêineres. • Padrões
comportamentais, que exploram conceitos mais específicos para
administrar contêineres e interações com a plataforma. • Padrões
estruturais, que ajudam você a organizar contêineres em um Pod
para tratar casos de uso específicos. • Padrões de configuração, que
oferecem insights sobre como tratar as configurações das
aplicações no Kubernetes. • Padrões avançados, que incluem
assuntos mais complexos, como operadores e escalabilidade
automática (autoscaling).

Compre agora e leia






Candlestick
Debastiani, Carlos Alberto
9788575225943
200 páginas

Compre agora e leia

A análise dos gráficos de Candlestick é uma técnica amplamente
utilizada pelos operadores de bolsas de valores no mundo inteiro.
De origem japonesa, este refinado método avalia o comportamento
do mercado, sendo muito eficaz na previsão de mudanças em
tendências, o que permite desvendar fatores psicológicos por trás
dos gráficos, incrementando a lucratividade dos investimentos.
Candlestick – Um método para ampliar lucros na Bolsa de Valores
é uma obra bem estruturada e totalmente ilustrada. A preocupação
do autor em utilizar uma linguagem clara e acessível a torna leve e
de fácil assimilação, mesmo para leigos. Cada padrão de análise
abordado possui um modelo com sua figura clássica, facilitando a
identificação. Depois das características, das peculiaridades e dos
fatores psicológicos do padrão, é apresentado o gráfico de um caso
real aplicado a uma ação negociada na Bovespa. Este livro possui,
ainda, um índice resumido dos padrões para pesquisa rápida na
utilização cotidiana.



Compre agora e leia






Avaliando Empresas, Investindo em
Ações
Debastiani, Carlos Alberto
9788575225974
224 páginas

Compre agora e leia

Avaliando Empresas, Investindo em Ações é um livro destinado a
investidores que desejam conhecer, em detalhes, os métodos de
análise que integram a linha de trabalho da escola fundamentalista,
trazendo ao leitor, em linguagem clara e acessível, o conhecimento
profundo dos elementos necessários a uma análise criteriosa da
saúde financeira das empresas, envolvendo indicadores de balanço
e de mercado, análise de liquidez e dos riscos pertinentes a fatores
setoriais e conjunturas econômicas nacional e internacional. Por
meio de exemplos práticos e ilustrações, os autores exercitam os
conceitos teóricos abordados, desde os fundamentos básicos da
economia até a formulação de estratégias para investimentos de
longo prazo.

Compre agora e leia






Manual de Análise Técnica
Abe, Marcos
9788575227022
256 páginas

Compre agora e leia

Este livro aborda o tema Investimento em Ações de maneira inédita
e tem o objetivo de ensinar os investidores a lucrarem nas mais
diversas condições do mercado, inclusive em tempos de crise.
Ensinará ao leitor que, para ganhar dinheiro, não importa se o
mercado está em alta ou em baixa, mas sim saber como operar em
cada situação. Com o Manual de Análise Técnica o leitor
aprenderá: - os conceitos clássicos da Análise Técnica de forma
diferenciada, de maneira que assimile não só os princípios, mas que
desenvolva o raciocínio necessário para utilizar os gráficos como
meio de interpretar os movimentos da massa de investidores do
mercado; - identificar oportunidades para lucrar na bolsa de
valores, a longo e curto prazo, até mesmo em mercados baixistas;
um sistema de investimentos completo com estratégias para abrir,
conduzir e fechar operações, de forma que seja possível maximizar
lucros e minimizar prejuízos; - estruturar e proteger operações por
meio do gerenciamento de capital. Destina-se a iniciantes na bolsa



de valores e investidores que ainda não desenvolveram uma
metodologia própria para operar lucrativamente.

Compre agora e leia